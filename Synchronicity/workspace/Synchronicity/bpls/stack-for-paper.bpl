                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/stack-for-paper.anchor:                 
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int item,Node next) {                                                               
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.item := item;                                                                        
          this.next := next;                                                                        
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Stack {                                                                                   
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures this.head.item == item && this.head.next == old(this.head);                         
      }                                                                                             
      public int push(int item) {                                                                   
        acquire(this);                                                                              
        Node node;                                                                                  
        node = new Node();                                                                          
        Node tmp1;                                                                                  
        tmp1 := this.head;                                                                          
        node.init(item,tmp1)                                                                        
        this.head := node;                                                                          
        release(this);                                                                              
        // return -1;                                                                               
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head) != Node.null && $result == old(this.head.item) && this.head == old(this.head.next);
      }                                                                                             
      public int pop() {                                                                            
        acquire(this);                                                                              
        while (true)                                                                                
          invariant holds(this, tid);                                                               
          invariant NextSpecStep(0);                                                                
          {                                                                                         
          boolean tmp2;                                                                             
          Node tmp3;                                                                                
          tmp3 := this.head;                                                                        
          tmp2 = tmp3 == Node.null;                                                                 
          if (!tmp2) break; else {                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            release(this);                                                                          
            yield;                                                                                  
            acquire(this);                                                                          
          }                                                                                         
        }                                                                                           
        int value;                                                                                  
        Node tmp4;                                                                                  
        tmp4 := this.head;                                                                          
        value := tmp4.item;                                                                         
        Node tmp5;                                                                                  
        Node tmp6;                                                                                  
        tmp6 := this.head;                                                                          
        tmp5 := tmp6.next;                                                                          
        this.head := tmp5;                                                                          
        release(this);                                                                              
         return value;                                                                              
        // return -1;                                                                               
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head) != Node.null && $result == old(this.head.item) && this.head == old(this.head.next);
      }                                                                                             
      public int pop2() {                                                                           
        while (true)                                                                                
          invariant NextSpecStep(0);                                                                
          {                                                                                         
          boolean tmp7;                                                                             
          tmp7 = true;                                                                              
          if (!tmp7) break; else {                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            acquire(this);                                                                          
            boolean tmp8;                                                                           
            Node tmp9;                                                                              
            tmp9 := this.head;                                                                      
            tmp8 = tmp9 == Node.null;                                                               
            if (tmp8 /* == this.head == Node.null */) {                                             
              break;                                                                                
            } else {                                                                                
                                                                                                    
            }                                                                                       
            release(this);                                                                          
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        int value;                                                                                  
        Node tmp10;                                                                                 
        tmp10 := this.head;                                                                         
        value := tmp10.item;                                                                        
        Node tmp11;                                                                                 
        Node tmp12;                                                                                 
        tmp12 := this.head;                                                                         
        tmp11 := tmp12.next;                                                                        
        this.head := tmp11;                                                                         
        release(this);                                                                              
         return value;                                                                              
        // return -1;                                                                               
      }                                                                                             
                                                                                                    
    }                                                                                               
    class StackWithCAS {                                                                            
      volatile Node head isLocal(this, tid)                                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void push(int v) {                                                                     
        while (true)   {                                                                            
          boolean tmp13;                                                                            
          tmp13 = true;                                                                             
          if (!tmp13) break; else {                                                                 
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node next;                                                                              
            next := this.head;                                                                      
            Node nu;                                                                                
            nu = new Node();                                                                        
            nu.init(v,next)                                                                         
            yield;                                                                                  
            boolean tmp14;                                                                          
            tmp14 = this.head@next :~ nu;                                                           
            if (tmp14) {                                                                            
              break;                                                                                
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head) != Node.null && $result == old(this.head.item) && this.head == old(this.head.next);
      }                                                                                             
      public int pop() {                                                                            
        while (true)   {                                                                            
          boolean tmp15;                                                                            
          tmp15 = true;                                                                             
          if (!tmp15) break; else {                                                                 
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node top;                                                                               
            top := this.head;                                                                       
            yield;                                                                                  
            boolean tmp16;                                                                          
            tmp16 = top != Node.null;                                                               
            if (tmp16 /* == top != Node.null */) {                                                  
              Node next;                                                                            
              next := top.next;                                                                     
              boolean tmp17;                                                                        
              tmp17 = this.head@top :~ next;                                                        
              if (tmp17) {                                                                          
                int tmp18;                                                                          
                tmp18 := top.item;                                                                  
                 return tmp18;                                                                      
              } else {                                                                              
                                                                                                    
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        // return -1;                                                                               
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int item,Node next) {                                                               
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.item := item;                                                                        
          this.next := next;                                                                        
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Stack {                                                                                   
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures this.head.item == item && this.head.next == old(this.head);                         
      }                                                                                             
      public int push(int item) {                                                                   
        acquire(this);                                                                              
        Node node;                                                                                  
        node = new Node();                                                                          
        Node tmp1;                                                                                  
        tmp1 := this.head;                                                                          
        node.init(item,tmp1)                                                                        
        this.head := node;                                                                          
        release(this);                                                                              
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head) != Node.null && $result == old(this.head.item) && this.head == old(this.head.next);
      }                                                                                             
      public int pop() {                                                                            
        acquire(this);                                                                              
        while (true)                                                                                
          invariant holds(this, tid);                                                               
          invariant NextSpecStep(0);                                                                
          {                                                                                         
          boolean tmp2;                                                                             
          Node tmp3;                                                                                
          tmp3 := this.head;                                                                        
          tmp2 = tmp3 == Node.null;                                                                 
          if (!tmp2) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            release(this);                                                                          
            yield;                                                                                  
            acquire(this);                                                                          
          }                                                                                         
        }                                                                                           
        int value;                                                                                  
        Node tmp4;                                                                                  
        tmp4 := this.head;                                                                          
        value := tmp4.item;                                                                         
        Node tmp5;                                                                                  
        Node tmp6;                                                                                  
        tmp6 := this.head;                                                                          
        tmp5 := tmp6.next;                                                                          
        this.head := tmp5;                                                                          
        release(this);                                                                              
        {                                                                                           
           return value;                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head) != Node.null && $result == old(this.head.item) && this.head == old(this.head.next);
      }                                                                                             
      public int pop2() {                                                                           
        while (true)                                                                                
          invariant NextSpecStep(0);                                                                
          {                                                                                         
          boolean tmp7;                                                                             
          tmp7 = true;                                                                              
          if (!tmp7) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            acquire(this);                                                                          
            boolean tmp8;                                                                           
            Node tmp9;                                                                              
            tmp9 := this.head;                                                                      
            tmp8 = tmp9 == Node.null;                                                               
            if (tmp8 /* == this.head == Node.null */) {                                             
              {                                                                                     
                break;                                                                              
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
            release(this);                                                                          
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        int value;                                                                                  
        Node tmp10;                                                                                 
        tmp10 := this.head;                                                                         
        value := tmp10.item;                                                                        
        Node tmp11;                                                                                 
        Node tmp12;                                                                                 
        tmp12 := this.head;                                                                         
        tmp11 := tmp12.next;                                                                        
        this.head := tmp11;                                                                         
        release(this);                                                                              
        {                                                                                           
           return value;                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class StackWithCAS {                                                                            
      hasCASOperation volatile Node head isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid head_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node head_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == this.head_nextValue;                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void push(int v) {                                                                     
        while (true)   {                                                                            
          boolean tmp13;                                                                            
          tmp13 = true;                                                                             
          if (!tmp13) {                                                                             
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node next;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                next := this.head  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                next := this.head;                                                                  
              }                                                                                     
            }                                                                                       
            Node nu;                                                                                
            nu = new Node();                                                                        
            nu.init(v,next)                                                                         
            yield;                                                                                  
            boolean tmp14;                                                                          
            {                                                                                       
              noop(TraceOff);                                                                       
              boolean ctmp4313459;                                                                  
              ctmp4313459 = *;                                                                      
              if (ctmp4313459) {                                                                    
                noop(TraceOn);                                                                      
                tmp14 = false;                                                                      
              } else {                                                                              
                ctmp4313459 = *;                                                                    
                if (ctmp4313459) {                                                                  
                  Tid tmpTid;                                                                       
                  Node tmpValue;                                                                    
                  Mover _m;                                                                         
                  _m = writePermission(this.head, nu);                                              
                  assume this.head == next;                                                         
                  assume !goesWrong(_m);                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == next;                                               
                  this.head_nextThread := tmpTid as B;                                              
                  this.head_nextValue := tmpValue as B;                                             
                  noop(TraceOn);                                                                    
                  this.head := nu;                                                                  
                  tmp14 = true;                                                                     
                } else {                                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == next;                                               
                  Node _currentValue;                                                               
                  _currentValue := this.head  as B;                                                 
                  this.head := next as B;                                                           
                  Mover _m;                                                                         
                  _m = writePermission(this.head, nu);                                              
                  this.head := _currentValue as B;                                                  
                  assume goesWrong(_m);                                                             
                  noop(TraceOn);                                                                    
                  this.head := nu;                                                                  
                  tmp14 = false;                                                                    
                }                                                                                   
              }                                                                                     
            }                                                                                       
            if (tmp14) {                                                                            
              {                                                                                     
                break;                                                                              
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head) != Node.null && $result == old(this.head.item) && this.head == old(this.head.next);
      }                                                                                             
      public int pop() {                                                                            
        while (true)   {                                                                            
          boolean tmp15;                                                                            
          tmp15 = true;                                                                             
          if (!tmp15) {                                                                             
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node top;                                                                               
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                top := this.head  as R;                                                             
              } else {                                                                              
                noop(TraceOn);                                                                      
                top := this.head;                                                                   
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            boolean tmp16;                                                                          
            tmp16 = top != Node.null;                                                               
            if (tmp16 /* == top != Node.null */) {                                                  
              Node next;                                                                            
              next := top.next;                                                                     
              boolean tmp17;                                                                        
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp4313551;                                                                
                ctmp4313551 = *;                                                                    
                if (ctmp4313551) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp17 = false;                                                                    
                } else {                                                                            
                  ctmp4313551 = *;                                                                  
                  if (ctmp4313551) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(this.head, next);                                          
                    assume this.head == top;                                                        
                    assume !goesWrong(_m);                                                          
                    assume this.head_nextThread == tid;                                             
                    assume this.head_nextValue == top;                                              
                    this.head_nextThread := tmpTid as B;                                            
                    this.head_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    this.head := next;                                                              
                    tmp17 = true;                                                                   
                  } else {                                                                          
                    assume this.head_nextThread == tid;                                             
                    assume this.head_nextValue == top;                                              
                    Node _currentValue;                                                             
                    _currentValue := this.head  as B;                                               
                    this.head := top as B;                                                          
                    Mover _m;                                                                       
                    _m = writePermission(this.head, next);                                          
                    this.head := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    this.head := next;                                                              
                    tmp17 = false;                                                                  
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              if (tmp17) {                                                                          
                int tmp18;                                                                          
                tmp18 := top.item;                                                                  
                {                                                                                   
                   return tmp18;                                                                    
                }                                                                                   
              } else {                                                                              
                                                                                                    
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int item,Node next) {                                                               
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.item := item;                                                                        
          this.next := next;                                                                        
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Stack {                                                                                   
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures this.head.item == item && this.head.next == old(this.head);                         
      }                                                                                             
      public int push(int item) {                                                                   
        acquire(this);                                                                              
        Node node;                                                                                  
        node = new Node();                                                                          
        Node tmp1;                                                                                  
        tmp1 := this.head;                                                                          
        {                                                                                           
          inlined node.init(item,tmp1);                                                             
          exit$253: {                                                                               
            int item$253;                                                                           
            Node next$253;                                                                          
            Node this$253;                                                                          
            item$253 = item;                                                                        
            next$253 = tmp1;                                                                        
            this$253 = node;                                                                        
            {                                                                                       
              assume this$253.item == 0;                                                            
              assume this$253.next == Node.null;                                                    
              {                                                                                     
                this$253.item := item$253;                                                          
                this$253.next := next$253;                                                          
                {                                                                                   
                  break exit$253;                                                                   
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        this.head := node;                                                                          
        release(this);                                                                              
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head) != Node.null && $result == old(this.head.item) && this.head == old(this.head.next);
      }                                                                                             
      public int pop() {                                                                            
        acquire(this);                                                                              
        while (true)                                                                                
          invariant holds(this, tid);                                                               
          invariant NextSpecStep(0);                                                                
          {                                                                                         
          boolean tmp2;                                                                             
          Node tmp3;                                                                                
          tmp3 := this.head;                                                                        
          tmp2 = tmp3 == Node.null;                                                                 
          if (!tmp2) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            release(this);                                                                          
            yield;                                                                                  
            acquire(this);                                                                          
          }                                                                                         
        }                                                                                           
        int value;                                                                                  
        Node tmp4;                                                                                  
        tmp4 := this.head;                                                                          
        value := tmp4.item;                                                                         
        Node tmp5;                                                                                  
        Node tmp6;                                                                                  
        tmp6 := this.head;                                                                          
        tmp5 := tmp6.next;                                                                          
        this.head := tmp5;                                                                          
        release(this);                                                                              
        {                                                                                           
           return value;                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head) != Node.null && $result == old(this.head.item) && this.head == old(this.head.next);
      }                                                                                             
      public int pop2() {                                                                           
        while (true)                                                                                
          invariant NextSpecStep(0);                                                                
          {                                                                                         
          boolean tmp7;                                                                             
          tmp7 = true;                                                                              
          if (!tmp7) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            acquire(this);                                                                          
            boolean tmp8;                                                                           
            Node tmp9;                                                                              
            tmp9 := this.head;                                                                      
            tmp8 = tmp9 == Node.null;                                                               
            if (tmp8 /* == this.head == Node.null */) {                                             
              {                                                                                     
                break;                                                                              
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
            release(this);                                                                          
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        int value;                                                                                  
        Node tmp10;                                                                                 
        tmp10 := this.head;                                                                         
        value := tmp10.item;                                                                        
        Node tmp11;                                                                                 
        Node tmp12;                                                                                 
        tmp12 := this.head;                                                                         
        tmp11 := tmp12.next;                                                                        
        this.head := tmp11;                                                                         
        release(this);                                                                              
        {                                                                                           
           return value;                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class StackWithCAS {                                                                            
      hasCASOperation volatile Node head isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid head_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node head_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == this.head_nextValue;                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void push(int v) {                                                                     
        while (true)   {                                                                            
          boolean tmp13;                                                                            
          tmp13 = true;                                                                             
          if (!tmp13) {                                                                             
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node next;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                next := this.head  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                next := this.head;                                                                  
              }                                                                                     
            }                                                                                       
            Node nu;                                                                                
            nu = new Node();                                                                        
            {                                                                                       
              inlined nu.init(v,next);                                                              
              exit$254: {                                                                           
                int item$254;                                                                       
                Node next$254;                                                                      
                Node this$254;                                                                      
                item$254 = v;                                                                       
                next$254 = next;                                                                    
                this$254 = nu;                                                                      
                {                                                                                   
                  assume this$254.item == 0;                                                        
                  assume this$254.next == Node.null;                                                
                  {                                                                                 
                    this$254.item := item$254;                                                      
                    this$254.next := next$254;                                                      
                    {                                                                               
                      break exit$254;                                                               
                    }                                                                               
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              inlined return;                                                                       
            }                                                                                       
            yield;                                                                                  
            boolean tmp14;                                                                          
            {                                                                                       
              noop(TraceOff);                                                                       
              boolean ctmp4313459;                                                                  
              ctmp4313459 = *;                                                                      
              if (ctmp4313459) {                                                                    
                noop(TraceOn);                                                                      
                tmp14 = false;                                                                      
              } else {                                                                              
                ctmp4313459 = *;                                                                    
                if (ctmp4313459) {                                                                  
                  Tid tmpTid;                                                                       
                  Node tmpValue;                                                                    
                  Mover _m;                                                                         
                  _m = writePermission(this.head, nu);                                              
                  assume this.head == next;                                                         
                  assume !goesWrong(_m);                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == next;                                               
                  this.head_nextThread := tmpTid as B;                                              
                  this.head_nextValue := tmpValue as B;                                             
                  noop(TraceOn);                                                                    
                  this.head := nu;                                                                  
                  tmp14 = true;                                                                     
                } else {                                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == next;                                               
                  Node _currentValue;                                                               
                  _currentValue := this.head  as B;                                                 
                  this.head := next as B;                                                           
                  Mover _m;                                                                         
                  _m = writePermission(this.head, nu);                                              
                  this.head := _currentValue as B;                                                  
                  assume goesWrong(_m);                                                             
                  noop(TraceOn);                                                                    
                  this.head := nu;                                                                  
                  tmp14 = false;                                                                    
                }                                                                                   
              }                                                                                     
            }                                                                                       
            if (tmp14) {                                                                            
              {                                                                                     
                break;                                                                              
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head) != Node.null && $result == old(this.head.item) && this.head == old(this.head.next);
      }                                                                                             
      public int pop() {                                                                            
        while (true)   {                                                                            
          boolean tmp15;                                                                            
          tmp15 = true;                                                                             
          if (!tmp15) {                                                                             
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node top;                                                                               
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                top := this.head  as R;                                                             
              } else {                                                                              
                noop(TraceOn);                                                                      
                top := this.head;                                                                   
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            boolean tmp16;                                                                          
            tmp16 = top != Node.null;                                                               
            if (tmp16 /* == top != Node.null */) {                                                  
              Node next;                                                                            
              next := top.next;                                                                     
              boolean tmp17;                                                                        
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp4313551;                                                                
                ctmp4313551 = *;                                                                    
                if (ctmp4313551) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp17 = false;                                                                    
                } else {                                                                            
                  ctmp4313551 = *;                                                                  
                  if (ctmp4313551) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(this.head, next);                                          
                    assume this.head == top;                                                        
                    assume !goesWrong(_m);                                                          
                    assume this.head_nextThread == tid;                                             
                    assume this.head_nextValue == top;                                              
                    this.head_nextThread := tmpTid as B;                                            
                    this.head_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    this.head := next;                                                              
                    tmp17 = true;                                                                   
                  } else {                                                                          
                    assume this.head_nextThread == tid;                                             
                    assume this.head_nextValue == top;                                              
                    Node _currentValue;                                                             
                    _currentValue := this.head  as B;                                               
                    this.head := top as B;                                                          
                    Mover _m;                                                                       
                    _m = writePermission(this.head, next);                                          
                    this.head := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    this.head := next;                                                              
                    tmp17 = false;                                                                  
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              if (tmp17) {                                                                          
                int tmp18;                                                                          
                tmp18 := top.item;                                                                  
                {                                                                                   
                   return tmp18;                                                                    
                }                                                                                   
              } else {                                                                              
                                                                                                    
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int item,Node next) {                                                               
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.item := item;                                                                        
          this.next := next;                                                                        
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Stack {                                                                                   
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures this.head.item == item && this.head.next == old(this.head);                         
      }                                                                                             
      public int push(int item) {                                                                   
        acquire(this);                                                                              
        Node node;                                                                                  
        node = new Node();                                                                          
        Node tmp1;                                                                                  
        tmp1 := this.head;                                                                          
        {                                                                                           
          inlined node.init(item,tmp1);                                                             
          exit$253: {                                                                               
            int item$253;                                                                           
            Node next$253;                                                                          
            Node this$253;                                                                          
            item$253 = item;                                                                        
            next$253 = tmp1;                                                                        
            this$253 = node;                                                                        
            {                                                                                       
              assume this$253.item == 0;                                                            
              assume this$253.next == Node.null;                                                    
              {                                                                                     
                this$253.item := item$253;                                                          
                this$253.next := next$253;                                                          
                {                                                                                   
                  break exit$253;                                                                   
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        this.head := node;                                                                          
        release(this);                                                                              
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head) != Node.null && $result == old(this.head.item) && this.head == old(this.head.next);
      }                                                                                             
      public int pop() {                                                                            
        acquire(this);                                                                              
        while (true)                                                                                
          invariant holds(this, tid);                                                               
          invariant NextSpecStep(0);                                                                
          {                                                                                         
          boolean tmp2;                                                                             
          Node tmp3;                                                                                
          tmp3 := this.head;                                                                        
          tmp2 = tmp3 == Node.null;                                                                 
          if (!tmp2) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            release(this);                                                                          
            yield;                                                                                  
            acquire(this);                                                                          
          }                                                                                         
        }                                                                                           
        int value;                                                                                  
        Node tmp4;                                                                                  
        tmp4 := this.head;                                                                          
        value := tmp4.item;                                                                         
        Node tmp5;                                                                                  
        Node tmp6;                                                                                  
        tmp6 := this.head;                                                                          
        tmp5 := tmp6.next;                                                                          
        this.head := tmp5;                                                                          
        release(this);                                                                              
        {                                                                                           
           return value;                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head) != Node.null && $result == old(this.head.item) && this.head == old(this.head.next);
      }                                                                                             
      public int pop2() {                                                                           
        while (true)                                                                                
          invariant NextSpecStep(0);                                                                
          {                                                                                         
          boolean tmp7;                                                                             
          tmp7 = true;                                                                              
          if (!tmp7) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            acquire(this);                                                                          
            boolean tmp8;                                                                           
            Node tmp9;                                                                              
            tmp9 := this.head;                                                                      
            tmp8 = tmp9 == Node.null;                                                               
            if (tmp8 /* == this.head == Node.null */) {                                             
              {                                                                                     
                break;                                                                              
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
            release(this);                                                                          
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        int value;                                                                                  
        Node tmp10;                                                                                 
        tmp10 := this.head;                                                                         
        value := tmp10.item;                                                                        
        Node tmp11;                                                                                 
        Node tmp12;                                                                                 
        tmp12 := this.head;                                                                         
        tmp11 := tmp12.next;                                                                        
        this.head := tmp11;                                                                         
        release(this);                                                                              
        {                                                                                           
           return value;                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class StackWithCAS {                                                                            
      hasCASOperation volatile Node head isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid head_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node head_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == this.head_nextValue;                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void push(int v) {                                                                     
        while (true)   {                                                                            
          boolean tmp13;                                                                            
          tmp13 = true;                                                                             
          if (!tmp13) {                                                                             
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node next;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                next := this.head  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                next := this.head;                                                                  
              }                                                                                     
            }                                                                                       
            Node nu;                                                                                
            nu = new Node();                                                                        
            {                                                                                       
              inlined nu.init(v,next);                                                              
              exit$254: {                                                                           
                int item$254;                                                                       
                Node next$254;                                                                      
                Node this$254;                                                                      
                item$254 = v;                                                                       
                next$254 = next;                                                                    
                this$254 = nu;                                                                      
                {                                                                                   
                  assume this$254.item == 0;                                                        
                  assume this$254.next == Node.null;                                                
                  {                                                                                 
                    this$254.item := item$254;                                                      
                    this$254.next := next$254;                                                      
                    {                                                                               
                      break exit$254;                                                               
                    }                                                                               
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              inlined return;                                                                       
            }                                                                                       
            yield;                                                                                  
            boolean tmp14;                                                                          
            {                                                                                       
              noop(TraceOff);                                                                       
              boolean ctmp4313459;                                                                  
              ctmp4313459 = *;                                                                      
              if (ctmp4313459) {                                                                    
                noop(TraceOn);                                                                      
                tmp14 = false;                                                                      
              } else {                                                                              
                ctmp4313459 = *;                                                                    
                if (ctmp4313459) {                                                                  
                  Tid tmpTid;                                                                       
                  Node tmpValue;                                                                    
                  Mover _m;                                                                         
                  _m = writePermission(this.head, nu);                                              
                  assume this.head == next;                                                         
                  assume !goesWrong(_m);                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == next;                                               
                  this.head_nextThread := tmpTid as B;                                              
                  this.head_nextValue := tmpValue as B;                                             
                  noop(TraceOn);                                                                    
                  this.head := nu;                                                                  
                  tmp14 = true;                                                                     
                } else {                                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == next;                                               
                  Node _currentValue;                                                               
                  _currentValue := this.head  as B;                                                 
                  this.head := next as B;                                                           
                  Mover _m;                                                                         
                  _m = writePermission(this.head, nu);                                              
                  this.head := _currentValue as B;                                                  
                  assume goesWrong(_m);                                                             
                  noop(TraceOn);                                                                    
                  this.head := nu;                                                                  
                  tmp14 = false;                                                                    
                }                                                                                   
              }                                                                                     
            }                                                                                       
            if (tmp14) {                                                                            
              {                                                                                     
                break;                                                                              
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head) != Node.null && $result == old(this.head.item) && this.head == old(this.head.next);
      }                                                                                             
      public int pop() {                                                                            
        while (true)   {                                                                            
          boolean tmp15;                                                                            
          tmp15 = true;                                                                             
          if (!tmp15) {                                                                             
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node top;                                                                               
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                top := this.head  as R;                                                             
              } else {                                                                              
                noop(TraceOn);                                                                      
                top := this.head;                                                                   
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            boolean tmp16;                                                                          
            tmp16 = top != Node.null;                                                               
            if (tmp16 /* == top != Node.null */) {                                                  
              Node next;                                                                            
              next := top.next;                                                                     
              boolean tmp17;                                                                        
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp4313551;                                                                
                ctmp4313551 = *;                                                                    
                if (ctmp4313551) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp17 = false;                                                                    
                } else {                                                                            
                  ctmp4313551 = *;                                                                  
                  if (ctmp4313551) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(this.head, next);                                          
                    assume this.head == top;                                                        
                    assume !goesWrong(_m);                                                          
                    assume this.head_nextThread == tid;                                             
                    assume this.head_nextValue == top;                                              
                    this.head_nextThread := tmpTid as B;                                            
                    this.head_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    this.head := next;                                                              
                    tmp17 = true;                                                                   
                  } else {                                                                          
                    assume this.head_nextThread == tid;                                             
                    assume this.head_nextValue == top;                                              
                    Node _currentValue;                                                             
                    _currentValue := this.head  as B;                                               
                    this.head := top as B;                                                          
                    Mover _m;                                                                       
                    _m = writePermission(this.head, next);                                          
                    this.head := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    this.head := next;                                                              
                    tmp17 = false;                                                                  
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              if (tmp17) {                                                                          
                int tmp18;                                                                          
                tmp18 := top.item;                                                                  
                {                                                                                   
                   return tmp18;                                                                    
                }                                                                                   
              } else {                                                                              
                                                                                                    
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Node ***/                                                                           
                                                                                                    
type Node;                                                                                          
const unique Node.null: Node;                                                                       
var Node._state: [Node]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.item: [Node]int;                                                                           
                                                                                                    
function {:inline} ReadEval.Node.item(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.item(tid: Tid,this : Node,newValue: int,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.next: [Node]Node;                                                                          
                                                                                                    
function {:inline} ReadEval.Node.next(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.next(tid: Tid,this : Node,newValue: Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node._lock: [Node]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Node._lock(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node._lock(tid: Tid,this : Node,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Stack ***/                                                                          
                                                                                                    
type Stack;                                                                                         
const unique Stack.null: Stack;                                                                     
var Stack._state: [Stack]State;                                                                     
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Stack.head: [Stack]Node;                                                                        
                                                                                                    
function {:inline} ReadEval.Stack.head(tid: Tid,this : Stack,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Stack._state[this], tid)) then                                                         
  if (isLocal(Stack._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Stack._state[this], tid) && Stack._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Stack.head(tid: Tid,this : Stack,newValue: Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Stack._state[this], tid)) then                                                         
  if (isLocal(Stack._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Stack._state[this], tid) && Stack._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Stack._lock: [Stack]Tid;                                                                        
                                                                                                    
function {:inline} ReadEval.Stack._lock(tid: Tid,this : Stack,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Stack._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Stack._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Stack._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Stack._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Stack._lock(tid: Tid,this : Stack,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Stack._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Stack._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Stack._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Stack._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Stack.push(tid:Tid, this : Stack, item : int)                                            
returns ($result : int)                                                                             
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Stack._state;                                                                              
modifies Stack.head;                                                                                
modifies Stack._lock;                                                                               
modifies StackWithCAS._state;                                                                       
modifies StackWithCAS.head;                                                                         
modifies StackWithCAS._lock;                                                                        
modifies StackWithCAS.head_nextThread;                                                              
modifies StackWithCAS.head_nextValue;                                                               
                                                                                                    
requires ValidTid(tid);                                                                                    // (18.3): Bad tid
requires isShared(Stack._state[this]);                                                                     // (18.3): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
{                                                                                                   
 var tmp14334598: Node;                                                                             
 var path4334583: int;                                                                              
 var Node.next4334545: [Node]Node;                                                                  
 var $result4334580: int;                                                                           
 var path4334545: int;                                                                              
 var Stack._lock4334603: [Stack]Tid;                                                                
 var Stack.head4334603: [Stack]Node;                                                                
 var StackWithCAS.head4334603: [StackWithCAS]Node;                                                  
 var item4334603: int;                                                                              
 var Node._lock4334583: [Node]Tid;                                                                  
 var Stack._state4334545: [Stack]State;                                                             
 var StackWithCAS._lock4334545: [StackWithCAS]Tid;                                                  
 var Stack._state4334583: [Stack]State;                                                             
 var Node._lock4334545: [Node]Tid;                                                                  
 var this4334545: Stack;                                                                            
 var $result4334603: int;                                                                           
 var StackWithCAS._state4334545: [StackWithCAS]State;                                               
 var $result4334545: int;                                                                           
 var this$253: Node;                                                                                
 var tmp14334580: Node;                                                                             
 var StackWithCAS.head4334583: [StackWithCAS]Node;                                                  
 var tid4334580: Tid;                                                                               
 var Node.item4334603: [Node]int;                                                                   
 var Stack.head4334580: [Stack]Node;                                                                
 var node: Node;                                                                                    
 var item$2534334583: int;                                                                          
 var Node._state4334598: [Node]State;                                                               
 var StackWithCAS._state4334580: [StackWithCAS]State;                                               
 var Stack._state4334598: [Stack]State;                                                             
 var Node.item4334580: [Node]int;                                                                   
 var Stack.head4334583: [Stack]Node;                                                                
 var Node.item4334598: [Node]int;                                                                   
 var $pc4334603: Phase;                                                                             
 var tmp14334583: Node;                                                                             
 var Node.next4334603: [Node]Node;                                                                  
 var $result4334583: int;                                                                           
 var Stack._lock4334580: [Stack]Tid;                                                                
 var node4334580: Node;                                                                             
 var StackWithCAS._state4334583: [StackWithCAS]State;                                               
 var Node.item4334583: [Node]int;                                                                   
 var node4334598: Node;                                                                             
 var Node._lock4334580: [Node]Tid;                                                                  
 var next$253: Node;                                                                                
 var node4334545: Node;                                                                             
 var moverPath4334583: MoverPath;                                                                   
 var StackWithCAS._lock4334603: [StackWithCAS]Tid;                                                  
 var next$2534334583: Node;                                                                         
 var $recorded.state4334598: int;                                                                   
 var this4334580: Stack;                                                                            
 var tmp1: Node;                                                                                    
 var item$2534334580: int;                                                                          
 var StackWithCAS.head4334598: [StackWithCAS]Node;                                                  
 var next$2534334580: Node;                                                                         
 var Node.item4334545: [Node]int;                                                                   
 var Stack._lock4334598: [Stack]Tid;                                                                
 var Stack._lock4334583: [Stack]Tid;                                                                
 var Stack._state4334603: [Stack]State;                                                             
 var this$2534334580: Node;                                                                         
 var this4334598: Stack;                                                                            
 var Node.next4334583: [Node]Node;                                                                  
 var item4334583: int;                                                                              
 var tid4334598: Tid;                                                                               
 var StackWithCAS.head4334580: [StackWithCAS]Node;                                                  
 var StackWithCAS.head_nextValue4334603: [StackWithCAS]Node;                                        
 var $pc4334545: Phase;                                                                             
 var StackWithCAS._lock4334598: [StackWithCAS]Tid;                                                  
 var this$2534334583: Node;                                                                         
 var StackWithCAS._state4334598: [StackWithCAS]State;                                               
 var mover4334583: Mover;                                                                           
 var Node._state4334583: [Node]State;                                                               
 var mover4334545: Mover;                                                                           
 var StackWithCAS._state4334603: [StackWithCAS]State;                                               
 var StackWithCAS.head_nextThread4334545: [StackWithCAS]Tid;                                        
 var $recorded.state4334580: int;                                                                   
 var $recorded.state4334583: int;                                                                   
 var $pc4334580: Phase;                                                                             
 var path4334580: int;                                                                              
 var StackWithCAS.head_nextValue4334583: [StackWithCAS]Node;                                        
 var StackWithCAS.head_nextThread4334603: [StackWithCAS]Tid;                                        
 var $recorded.state4334545: int;                                                                   
 var Stack.head4334545: [Stack]Node;                                                                
 var item4334545: int;                                                                              
 var tmp14334603: Node;                                                                             
 var StackWithCAS._lock4334583: [StackWithCAS]Tid;                                                  
 var Stack._state4334580: [Stack]State;                                                             
 var $recorded.state4334603: int;                                                                   
 var mover4334598: Mover;                                                                           
 var item4334598: int;                                                                              
 var Node._lock4334598: [Node]Tid;                                                                  
 var node4334603: Node;                                                                             
 var StackWithCAS.head4334545: [StackWithCAS]Node;                                                  
 var StackWithCAS.head_nextThread4334583: [StackWithCAS]Tid;                                        
 var $pc4334598: Phase;                                                                             
 var item$253: int;                                                                                 
 var StackWithCAS.head_nextValue4334545: [StackWithCAS]Node;                                        
 var StackWithCAS.head_nextValue4334598: [StackWithCAS]Node;                                        
 var $pc4334583: Phase;                                                                             
 var $result4334598: int;                                                                           
 var mover4334580: Mover;                                                                           
 var this4334583: Stack;                                                                            
 var tid4334603: Tid;                                                                               
 var StackWithCAS._lock4334580: [StackWithCAS]Tid;                                                  
 var path4334598: int;                                                                              
 var Stack.head4334598: [Stack]Node;                                                                
 var Node._state4334603: [Node]State;                                                               
 var moverPath4334598: MoverPath;                                                                   
 var Stack._lock4334545: [Stack]Tid;                                                                
 var Node._state4334580: [Node]State;                                                               
 var Node.next4334580: [Node]Node;                                                                  
 var StackWithCAS.head_nextThread4334580: [StackWithCAS]Tid;                                        
 var node4334583: Node;                                                                             
 var StackWithCAS.head_nextValue4334580: [StackWithCAS]Node;                                        
 var moverPath4334545: MoverPath;                                                                   
 var this4334603: Stack;                                                                            
 var Node.next4334598: [Node]Node;                                                                  
 var Node._state4334545: [Node]State;                                                               
 var moverPath4334580: MoverPath;                                                                   
 var tid4334583: Tid;                                                                               
 var StackWithCAS.head_nextThread4334598: [StackWithCAS]Tid;                                        
 var item4334580: int;                                                                              
 var tmp14334545: Node;                                                                             
 var Node._lock4334603: [Node]Tid;                                                                  
 var tid4334545: Tid;                                                                               
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
 if ($pc == PreCommit) {                                                                            
  assume this != Stack.null;                                                                        
 } else {                                                                                           
  assert this != Stack.null;                                                                               // (21.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume Stack._lock[this] == Tid.null;                                                              
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (21.5): Reduction failure
 Stack._lock[this] := tid;                                                                          
                                                                                                    
 // 22.5: Node node;                                                                                
                                                                                                    
                                                                                                    
 // 22.5: node = new Node();                                                                        
                                                                                                    
 havoc node;                                                                                        
 assume node != Node.null && isFresh(Node._state[node]);                                            
 Node._state[node] := LOCAL(tid);                                                                   
 assume Node.item[node]  == 0;                                                                      
 assume Node.next[node]  == Node.null;                                                              
 assume Node._lock[node]  == Tid.null;                                                              
                                                                                                    
 // 22.5: Node tmp1;                                                                                
                                                                                                    
                                                                                                    
 // 22.5: tmp1 := this.head;                                                                        
                                                                                                    
                                                                                                    
 moverPath4334545 := ReadEval.Stack.head(tid: Tid,this: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334545 := m#moverPath(moverPath4334545);                                                     
 path4334545 := p#moverPath(moverPath4334545);                                                      
 assume Node._state4334545 == Node._state && Node.item4334545 == Node.item && Node.next4334545 == Node.next && Node._lock4334545 == Node._lock && Stack._state4334545 == Stack._state && Stack.head4334545 == Stack.head && Stack._lock4334545 == Stack._lock && StackWithCAS._state4334545 == StackWithCAS._state && StackWithCAS.head4334545 == StackWithCAS.head && StackWithCAS._lock4334545 == StackWithCAS._lock && StackWithCAS.head_nextThread4334545 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334545 == StackWithCAS.head_nextValue && tmp14334545 == tmp1 && node4334545 == node && $result4334545 == $result && item4334545 == item && this4334545 == this && tid4334545 == tid && $pc4334545 == $pc;
 assume $recorded.state4334545 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Stack.null;                                                                        
 } else {                                                                                           
  assert this != Stack.null;                                                                               // (22.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4334545);                                                              
 assert $pc != PhaseError;                                                                                 // (22.5): Reduction failure
 tmp1 := Stack.head[this];                                                                          
 // inlined: node.init(item,tmp1)}                                                                  
 exit$253_top:                                                                                      
                                                                                                    
 // 22.5: int item$253;                                                                             
                                                                                                    
                                                                                                    
 // 22.5: Node next$253;                                                                            
                                                                                                    
                                                                                                    
 // 22.5: Node this$253;                                                                            
                                                                                                    
                                                                                                    
 // 22.5: item$253 = item;                                                                          
                                                                                                    
 item$253 := item;                                                                                  
                                                                                                    
 // 22.5: next$253 = tmp1;                                                                          
                                                                                                    
 next$253 := tmp1;                                                                                  
                                                                                                    
 // 22.5: this$253 = node;                                                                          
                                                                                                    
 this$253 := node;                                                                                  
                                                                                                    
 // 7.3: assume this$253.item == 0;                                                                 
                                                                                                    
 assume (Node.item[this$253]==0);                                                                   
                                                                                                    
 // 7.3: assume this$253.next == Node.null;                                                         
                                                                                                    
 assume (Node.next[this$253]==Node.null);                                                           
                                                                                                    
                                                                                                    
 // 8.5: this$253.item := item$253;                                                                 
                                                                                                    
                                                                                                    
 moverPath4334580 := WriteEval.Node.item(tid: Tid,this$253: Node,item$253: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334580 := m#moverPath(moverPath4334580);                                                     
 path4334580 := p#moverPath(moverPath4334580);                                                      
 assume Node._state4334580 == Node._state && Node.item4334580 == Node.item && Node.next4334580 == Node.next && Node._lock4334580 == Node._lock && Stack._state4334580 == Stack._state && Stack.head4334580 == Stack.head && Stack._lock4334580 == Stack._lock && StackWithCAS._state4334580 == StackWithCAS._state && StackWithCAS.head4334580 == StackWithCAS.head && StackWithCAS._lock4334580 == StackWithCAS._lock && StackWithCAS.head_nextThread4334580 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334580 == StackWithCAS.head_nextValue && this$2534334580 == this$253 && next$2534334580 == next$253 && item$2534334580 == item$253 && tmp14334580 == tmp1 && node4334580 == node && $result4334580 == $result && item4334580 == item && this4334580 == this && tid4334580 == tid && $pc4334580 == $pc;
 assume $recorded.state4334580 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$253 != Node.null;                                                                     
 } else {                                                                                           
  assert this$253 != Node.null;                                                                            // (8.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover4334580);                                                              
 assert $pc != PhaseError;                                                                                 // (8.5): Reduction failure
 Node.item[this$253] := item$253;                                                                   
                                                                                                    
                                                                                                    
 // 9.5: this$253.next := next$253;                                                                 
                                                                                                    
                                                                                                    
 moverPath4334583 := WriteEval.Node.next(tid: Tid,this$253: Node,next$253: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334583 := m#moverPath(moverPath4334583);                                                     
 path4334583 := p#moverPath(moverPath4334583);                                                      
 assume Node._state4334583 == Node._state && Node.item4334583 == Node.item && Node.next4334583 == Node.next && Node._lock4334583 == Node._lock && Stack._state4334583 == Stack._state && Stack.head4334583 == Stack.head && Stack._lock4334583 == Stack._lock && StackWithCAS._state4334583 == StackWithCAS._state && StackWithCAS.head4334583 == StackWithCAS.head && StackWithCAS._lock4334583 == StackWithCAS._lock && StackWithCAS.head_nextThread4334583 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334583 == StackWithCAS.head_nextValue && this$2534334583 == this$253 && next$2534334583 == next$253 && item$2534334583 == item$253 && tmp14334583 == tmp1 && node4334583 == node && $result4334583 == $result && item4334583 == item && this4334583 == this && tid4334583 == tid && $pc4334583 == $pc;
 assume $recorded.state4334583 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$253 != Node.null;                                                                     
 } else {                                                                                           
  assert this$253 != Node.null;                                                                            // (9.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover4334583);                                                              
 assert $pc != PhaseError;                                                                                 // (9.5): Reduction failure
 Node.next[this$253] := next$253;                                                                   
 if (isLocal(Node._state[next$253], tid)) {                                                         
  Node._state[next$253] := SHARED();                                                                
  assert isSharedAssignable(Node._state[Node.next[next$253]]);                                             // (9.5): next$253 became shared, but next$253.next may not be shared.
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 7.29: break exit$253;                                                                           
                                                                                                    
 goto exit$253_bottom;                                                                              
 exit$253_bottom:                                                                                   
                                                                                                    
                                                                                                    
 // 23.5: this.head := node;                                                                        
                                                                                                    
                                                                                                    
 moverPath4334598 := WriteEval.Stack.head(tid: Tid,this: Stack,node: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334598 := m#moverPath(moverPath4334598);                                                     
 path4334598 := p#moverPath(moverPath4334598);                                                      
 assume Node._state4334598 == Node._state && Node.item4334598 == Node.item && Node.next4334598 == Node.next && Node._lock4334598 == Node._lock && Stack._state4334598 == Stack._state && Stack.head4334598 == Stack.head && Stack._lock4334598 == Stack._lock && StackWithCAS._state4334598 == StackWithCAS._state && StackWithCAS.head4334598 == StackWithCAS.head && StackWithCAS._lock4334598 == StackWithCAS._lock && StackWithCAS.head_nextThread4334598 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334598 == StackWithCAS.head_nextValue && tmp14334598 == tmp1 && node4334598 == node && $result4334598 == $result && item4334598 == item && this4334598 == this && tid4334598 == tid && $pc4334598 == $pc;
 assume $recorded.state4334598 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Stack.null;                                                                        
 } else {                                                                                           
  assert this != Stack.null;                                                                               // (23.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover4334598);                                                              
 assert $pc != PhaseError;                                                                                 // (23.5): Reduction failure
 Stack.head[this] := node;                                                                          
 if (isLocal(Node._state[node], tid)) {                                                             
  Node._state[node] := SHARED();                                                                    
  assert isSharedAssignable(Node._state[Node.next[node]]);                                                 // (23.5): node became shared, but node.next may not be shared.
 }                                                                                                  
                                                                                                    
 if ($pc == PreCommit) {                                                                            
  assume this != Stack.null;                                                                        
 } else {                                                                                           
  assert this != Stack.null;                                                                               // (24.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Stack._lock[this] == tid;                                                                          // (24.5): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (24.5): Reduction failure
 Stack._lock[this] := Tid.null;                                                                     
                                                                                                    
 // 20.29: // return -1;                                                                            
                                                                                                    
 assume Node._state4334603 == Node._state && Node.item4334603 == Node.item && Node.next4334603 == Node.next && Node._lock4334603 == Node._lock && Stack._state4334603 == Stack._state && Stack.head4334603 == Stack.head && Stack._lock4334603 == Stack._lock && StackWithCAS._state4334603 == StackWithCAS._state && StackWithCAS.head4334603 == StackWithCAS.head && StackWithCAS._lock4334603 == StackWithCAS._lock && StackWithCAS.head_nextThread4334603 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334603 == StackWithCAS.head_nextValue && tmp14334603 == tmp1 && node4334603 == node && $result4334603 == $result && item4334603 == item && this4334603 == this && tid4334603 == tid;
 assume $recorded.state4334603 == 1;                                                                
 $result := -1;                                                                                     
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  Stack.pop(tid:Tid, this : Stack)                                                         
returns ($result : int)                                                                             
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Stack._state;                                                                              
modifies Stack.head;                                                                                
modifies Stack._lock;                                                                               
modifies StackWithCAS._state;                                                                       
modifies StackWithCAS.head;                                                                         
modifies StackWithCAS._lock;                                                                        
modifies StackWithCAS.head_nextThread;                                                              
modifies StackWithCAS.head_nextValue;                                                               
                                                                                                    
requires ValidTid(tid);                                                                                    // (27.5): Bad tid
requires isShared(Stack._state[this]);                                                                     // (27.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
{                                                                                                   
 var $pc4334637_bottom: Phase;                                                                      
 var tmp3: Node;                                                                                    
 var StackWithCAS._lock4334637: [StackWithCAS]Tid;                                                  
 var Node.next4334632_post: [Node]Node;                                                             
 var moverPath4334646: MoverPath;                                                                   
 var value4334646: int;                                                                             
 var this4334646: Stack;                                                                            
 var StackWithCAS._lock4334646: [StackWithCAS]Tid;                                                  
 var StackWithCAS.head4334617: [StackWithCAS]Node;                                                  
 var tmp44334661: Node;                                                                             
 var tmp54334658: Node;                                                                             
 var tmp34334632_post: Node;                                                                        
 var StackWithCAS.head_nextThread4334632: [StackWithCAS]Tid;                                        
 var $result4334646: int;                                                                           
 var mover4334661: Mover;                                                                           
 var Node.item4334637: [Node]int;                                                                   
 var $recorded.state4334649: int;                                                                   
 var Node.next4334632: [Node]Node;                                                                  
 var Stack.head4334664: [Stack]Node;                                                                
 var $result4334672: int;                                                                           
 var StackWithCAS.head_nextValue4334632: [StackWithCAS]Node;                                        
 var StackWithCAS.head_nextValue4334632_post: [StackWithCAS]Node;                                   
 var tmp64334668: Node;                                                                             
 var $pc4334672: Phase;                                                                             
 var StackWithCAS.head_nextThread4334617: [StackWithCAS]Tid;                                        
 var StackWithCAS._lock4334649: [StackWithCAS]Tid;                                                  
 var Stack.head4334632: [Stack]Node;                                                                
 var $pc4334632_post: Phase;                                                                        
 var tmp4: Node;                                                                                    
 var StackWithCAS._lock4334617: [StackWithCAS]Tid;                                                  
 var this4334672: Stack;                                                                            
 var StackWithCAS.head4334664: [StackWithCAS]Node;                                                  
 var $recorded.state4334661: int;                                                                   
 var mover4334617: Mover;                                                                           
 var StackWithCAS.head4334646: [StackWithCAS]Node;                                                  
 var $recorded.state4334658: int;                                                                   
 var Stack.head4334672: [Stack]Node;                                                                
 var Node._lock4334637: [Node]Tid;                                                                  
 var tmp44334658: Node;                                                                             
 var StackWithCAS.head_nextThread4334661: [StackWithCAS]Tid;                                        
 var Stack.head4334646: [Stack]Node;                                                                
 var StackWithCAS.head_nextValue4334617: [StackWithCAS]Node;                                        
 var Node.next4334637: [Node]Node;                                                                  
 var StackWithCAS._state4334668: [StackWithCAS]State;                                               
 var StackWithCAS.head_nextThread4334649: [StackWithCAS]Tid;                                        
 var $recorded.state4334668: int;                                                                   
 var $result4334668: int;                                                                           
 var moverPath4334649: MoverPath;                                                                   
 var Node.item4334632: [Node]int;                                                                   
 var this4334632: Stack;                                                                            
 var Node._state4334637: [Node]State;                                                               
 var tid4334632_post: Tid;                                                                          
 var StackWithCAS.head4334649: [StackWithCAS]Node;                                                  
 var $result4334637: int;                                                                           
 var path4334649: int;                                                                              
 var StackWithCAS.head4334668: [StackWithCAS]Node;                                                  
 var tmp54334668: Node;                                                                             
 var StackWithCAS.head4334637: [StackWithCAS]Node;                                                  
 var tid4334664: Tid;                                                                               
 var $pc4334664: Phase;                                                                             
 var StackWithCAS.head4334661: [StackWithCAS]Node;                                                  
 var $recorded.state4334632: int;                                                                   
 var StackWithCAS.head_nextValue4334668: [StackWithCAS]Node;                                        
 var StackWithCAS._lock4334672: [StackWithCAS]Tid;                                                  
 var Stack.head4334649: [Stack]Node;                                                                
 var $result4334658: int;                                                                           
 var Node._lock4334658: [Node]Tid;                                                                  
 var StackWithCAS.head_nextValue4334658: [StackWithCAS]Node;                                        
 var moverPath4334661: MoverPath;                                                                   
 var tmp2: bool;                                                                                    
 var StackWithCAS._lock4334658: [StackWithCAS]Tid;                                                  
 var Node._state4334637_bottom: [Node]State;                                                        
 var this4334637: Stack;                                                                            
 var value4334661: int;                                                                             
 var StackWithCAS.head4334637_bottom: [StackWithCAS]Node;                                           
 var tid4334617: Tid;                                                                               
 var Node.item4334637_bottom: [Node]int;                                                            
 var Stack._lock4334661: [Stack]Tid;                                                                
 var $result4334649: int;                                                                           
 var Node._lock4334668: [Node]Tid;                                                                  
 var Node._state4334664: [Node]State;                                                               
 var Node.next4334646: [Node]Node;                                                                  
 var StackWithCAS._state4334632: [StackWithCAS]State;                                               
 var Node.item4334672: [Node]int;                                                                   
 var StackWithCAS._lock4334668: [StackWithCAS]Tid;                                                  
 var tmp64334664: Node;                                                                             
 var StackWithCAS._state4334646: [StackWithCAS]State;                                               
 var Node._state4334646: [Node]State;                                                               
 var StackWithCAS.head_nextThread4334637: [StackWithCAS]Tid;                                        
 var Node.next4334661: [Node]Node;                                                                  
 var tmp34334632: Node;                                                                             
 var tmp44334649: Node;                                                                             
 var value: int;                                                                                    
 var Node._state4334649: [Node]State;                                                               
 var Node._state4334668: [Node]State;                                                               
 var tid4334646: Tid;                                                                               
 var Stack.head4334668: [Stack]Node;                                                                
 var Stack._lock4334658: [Stack]Tid;                                                                
 var Node._lock4334632: [Node]Tid;                                                                  
 var Stack._state4334637: [Stack]State;                                                             
 var StackWithCAS.head_nextValue4334672: [StackWithCAS]Node;                                        
 var Node._lock4334617: [Node]Tid;                                                                  
 var $pc4334661: Phase;                                                                             
 var moverPath4334617: MoverPath;                                                                   
 var value4334658: int;                                                                             
 var Node._lock4334672: [Node]Tid;                                                                  
 var Node.next4334658: [Node]Node;                                                                  
 var $recorded.state4334637_bottom: int;                                                            
 var Stack.head4334617: [Stack]Node;                                                                
 var Stack._state4334658: [Stack]State;                                                             
 var StackWithCAS._state4334658: [StackWithCAS]State;                                               
 var StackWithCAS._state4334637_bottom: [StackWithCAS]State;                                        
 var tmp64334672: Node;                                                                             
 var StackWithCAS._state4334637: [StackWithCAS]State;                                               
 var Stack._state4334646: [Stack]State;                                                             
 var Node.item4334664: [Node]int;                                                                   
 var StackWithCAS._state4334672: [StackWithCAS]State;                                               
 var StackWithCAS.head_nextThread4334658: [StackWithCAS]Tid;                                        
 var Stack.head4334632_post: [Stack]Node;                                                           
 var StackWithCAS.head_nextThread4334664: [StackWithCAS]Tid;                                        
 var StackWithCAS.head4334632: [StackWithCAS]Node;                                                  
 var $result4334632: int;                                                                           
 var Stack._lock4334637_bottom: [Stack]Tid;                                                         
 var tmp44334672: Node;                                                                             
 var Stack._state4334649: [Stack]State;                                                             
 var this4334637_bottom: Stack;                                                                     
 var mover4334658: Mover;                                                                           
 var Stack._lock4334668: [Stack]Tid;                                                                
 var tmp64334658: Node;                                                                             
 var tid4334649: Tid;                                                                               
 var StackWithCAS.head_nextThread4334632_post: [StackWithCAS]Tid;                                   
 var Node.next4334637_bottom: [Node]Node;                                                           
 var Stack.head4334637_bottom: [Stack]Node;                                                         
 var tmp34334617: Node;                                                                             
 var $pc4334632: Phase;                                                                             
 var Stack._state4334632_post: [Stack]State;                                                        
 var Node.next4334672: [Node]Node;                                                                  
 var $recorded.state4334646: int;                                                                   
 var $result4334617: int;                                                                           
 var tmp44334646: Node;                                                                             
 var StackWithCAS.head_nextThread4334672: [StackWithCAS]Tid;                                        
 var Node.item4334617: [Node]int;                                                                   
 var StackWithCAS.head_nextThread4334646: [StackWithCAS]Tid;                                        
 var Node._lock4334637_bottom: [Node]Tid;                                                           
 var phase4334637: Phase;                                                                           
 var value4334649: int;                                                                             
 var Node.item4334632_post: [Node]int;                                                              
 var value4334664: int;                                                                             
 var Node.next4334664: [Node]Node;                                                                  
 var StackWithCAS._state4334661: [StackWithCAS]State;                                               
 var moverPath4334658: MoverPath;                                                                   
 var this4334617: Stack;                                                                            
 var value4334668: int;                                                                             
 var tmp44334664: Node;                                                                             
 var Stack._state4334632: [Stack]State;                                                             
 var tmp54334672: Node;                                                                             
 var Node._state4334661: [Node]State;                                                               
 var StackWithCAS._lock4334661: [StackWithCAS]Tid;                                                  
 var this4334658: Stack;                                                                            
 var $recorded.state4334617: int;                                                                   
 var Stack._lock4334617: [Stack]Tid;                                                                
 var StackWithCAS.head_nextValue4334664: [StackWithCAS]Node;                                        
 var Node.next4334668: [Node]Node;                                                                  
 var Stack._lock4334632_post: [Stack]Tid;                                                           
 var tmp5: Node;                                                                                    
 var this4334632_post: Stack;                                                                       
 var Stack._state4334661: [Stack]State;                                                             
 var $pc4334649: Phase;                                                                             
 var $recorded.state4334664: int;                                                                   
 var tmp6: Node;                                                                                    
 var tid4334661: Tid;                                                                               
 var path4334664: int;                                                                              
 var Stack._state4334617: [Stack]State;                                                             
 var Stack._state4334637_bottom: [Stack]State;                                                      
 var $pc4334646: Phase;                                                                             
 var path4334617: int;                                                                              
 var mover4334664: Mover;                                                                           
 var tid4334632: Tid;                                                                               
 var StackWithCAS.head_nextValue4334661: [StackWithCAS]Node;                                        
 var mover4334646: Mover;                                                                           
 var Node._state4334658: [Node]State;                                                               
 var Node._lock4334664: [Node]Tid;                                                                  
 var StackWithCAS.head_nextValue4334637_bottom: [StackWithCAS]Node;                                 
 var Stack._lock4334649: [Stack]Tid;                                                                
 var Stack.head4334661: [Stack]Node;                                                                
 var StackWithCAS._lock4334632: [StackWithCAS]Tid;                                                  
 var Node._lock4334661: [Node]Tid;                                                                  
 var this4334664: Stack;                                                                            
 var $pc4334668: Phase;                                                                             
 var this4334649: Stack;                                                                            
 var tmp24334617: bool;                                                                             
 var path4334661: int;                                                                              
 var path4334646: int;                                                                              
 var $result4334632_post: int;                                                                      
 var $result4334637_bottom: int;                                                                    
 var mover4334649: Mover;                                                                           
 var $result4334664: int;                                                                           
 var $pc4334658: Phase;                                                                             
 var StackWithCAS._lock4334632_post: [StackWithCAS]Tid;                                             
 var tid4334637: Tid;                                                                               
 var StackWithCAS._state4334617: [StackWithCAS]State;                                               
 var StackWithCAS._state4334632_post: [StackWithCAS]State;                                          
 var tid4334658: Tid;                                                                               
 var Node.next4334649: [Node]Node;                                                                  
 var Node.item4334649: [Node]int;                                                                   
 var moverPath4334664: MoverPath;                                                                   
 var tmp54334664: Node;                                                                             
 var StackWithCAS._lock4334664: [StackWithCAS]Tid;                                                  
 var StackWithCAS.head4334672: [StackWithCAS]Node;                                                  
 var StackWithCAS.head4334632_post: [StackWithCAS]Node;                                             
 var tid4334672: Tid;                                                                               
 var Node._lock4334632_post: [Node]Tid;                                                             
 var StackWithCAS.head_nextValue4334637: [StackWithCAS]Node;                                        
 var StackWithCAS._state4334649: [StackWithCAS]State;                                               
 var $result4334661: int;                                                                           
 var Node._state4334617: [Node]State;                                                               
 var Stack._lock4334646: [Stack]Tid;                                                                
 var Node.item4334668: [Node]int;                                                                   
 var tmp24334632_post: bool;                                                                        
 var tmp44334668: Node;                                                                             
 var Node.item4334658: [Node]int;                                                                   
 var $pc4334637: Phase;                                                                             
 var Stack.head4334637: [Stack]Node;                                                                
 var tid4334668: Tid;                                                                               
 var Node._lock4334646: [Node]Tid;                                                                  
 var Node._lock4334649: [Node]Tid;                                                                  
 var tid4334637_bottom: Tid;                                                                        
 var Node.next4334617: [Node]Node;                                                                  
 var StackWithCAS.head_nextThread4334637_bottom: [StackWithCAS]Tid;                                 
 var StackWithCAS.head_nextValue4334649: [StackWithCAS]Node;                                        
 var path4334658: int;                                                                              
 var Stack._state4334672: [Stack]State;                                                             
 var StackWithCAS.head4334658: [StackWithCAS]Node;                                                  
 var Stack._state4334668: [Stack]State;                                                             
 var $recorded.state4334672: int;                                                                   
 var Stack._lock4334664: [Stack]Tid;                                                                
 var $recorded.state4334637: int;                                                                   
 var Stack._lock4334672: [Stack]Tid;                                                                
 var Node._state4334672: [Node]State;                                                               
 var $recorded.state4334632_post: int;                                                              
 var Node._state4334632_post: [Node]State;                                                          
 var Node.item4334661: [Node]int;                                                                   
 var Stack.head4334658: [Stack]Node;                                                                
 var $pc4334617: Phase;                                                                             
 var StackWithCAS.head_nextThread4334668: [StackWithCAS]Tid;                                        
 var Stack._state4334664: [Stack]State;                                                             
 var tmp24334632: bool;                                                                             
 var Stack._lock4334632: [Stack]Tid;                                                                
 var this4334668: Stack;                                                                            
 var this4334661: Stack;                                                                            
 var StackWithCAS._state4334664: [StackWithCAS]State;                                               
 var tmp64334661: Node;                                                                             
 var StackWithCAS.head_nextValue4334646: [StackWithCAS]Node;                                        
 var Node.item4334646: [Node]int;                                                                   
 var StackWithCAS._lock4334637_bottom: [StackWithCAS]Tid;                                           
 var Node._state4334632: [Node]State;                                                               
 var tmp54334661: Node;                                                                             
 var Stack._lock4334637: [Stack]Tid;                                                                
 var value4334672: int;                                                                             
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
 if ($pc == PreCommit) {                                                                            
  assume this != Stack.null;                                                                        
 } else {                                                                                           
  assert this != Stack.null;                                                                               // (30.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume Stack._lock[this] == Tid.null;                                                              
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (30.9): Reduction failure
 Stack._lock[this] := tid;                                                                          
 assume Node._state4334637 == Node._state && Node.item4334637 == Node.item && Node.next4334637 == Node.next && Node._lock4334637 == Node._lock && Stack._state4334637 == Stack._state && Stack.head4334637 == Stack.head && Stack._lock4334637 == Stack._lock && StackWithCAS._state4334637 == StackWithCAS._state && StackWithCAS.head4334637 == StackWithCAS.head && StackWithCAS._lock4334637 == StackWithCAS._lock && StackWithCAS.head_nextThread4334637 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334637 == StackWithCAS.head_nextValue && $result4334637 == $result && this4334637 == this && tid4334637 == tid;
 assume $recorded.state4334637 == 1;                                                                
                                                                                                    
 // 31.9: while (true)                                                                              
                                                                                                    
 phase4334637 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (27.5): Bad tid
  invariant isShared(Stack._state[this]);                                                                  // (27.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
  invariant (isAccessible(Stack._state[this], tid) && Stack._lock[this] == tid);                    
  invariant true;                                                                                   
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state4334637,Node.item4334637,Node.next4334637,Node._lock4334637,Stack._state4334637,Stack.head4334637,Stack._lock4334637,StackWithCAS._state4334637,StackWithCAS.head4334637,StackWithCAS._lock4334637,StackWithCAS.head_nextThread4334637,StackWithCAS.head_nextValue4334637));       // (31.9): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state4334637,Node.item4334637,Node.next4334637,Node._lock4334637,Stack._state4334637,Stack.head4334637,Stack._lock4334637,StackWithCAS._state4334637,StackWithCAS.head4334637,StackWithCAS._lock4334637,StackWithCAS.head_nextThread4334637,StackWithCAS.head_nextValue4334637));       // (31.9): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Stack :: Invariant.Y_Stack.head(tid : Tid, _this, Stack.head[_this] ,Node._state4334637,Node.item4334637,Node.next4334637,Node._lock4334637,Stack._state4334637,Stack.head4334637,Stack._lock4334637,StackWithCAS._state4334637,StackWithCAS.head4334637,StackWithCAS._lock4334637,StackWithCAS.head_nextThread4334637,StackWithCAS.head_nextValue4334637));       // (31.9): Loop does not preserve yields_as annotation for field head
  invariant (forall _this : StackWithCAS :: Invariant.Y_StackWithCAS.head(tid : Tid, _this, StackWithCAS.head[_this] ,Node._state4334637,Node.item4334637,Node.next4334637,Node._lock4334637,Stack._state4334637,Stack.head4334637,Stack._lock4334637,StackWithCAS._state4334637,StackWithCAS.head4334637,StackWithCAS._lock4334637,StackWithCAS.head_nextThread4334637,StackWithCAS.head_nextValue4334637));       // (31.9): Loop does not preserve yields_as annotation for field head
  invariant phase4334637 == $pc;                                                                           // (31.9): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (31.9): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 31.26: boolean tmp2;                                                                           
                                                                                                    
                                                                                                    
  // 31.16: Node tmp3;                                                                              
                                                                                                    
                                                                                                    
  // 31.16: tmp3 := this.head;                                                                      
                                                                                                    
                                                                                                    
  moverPath4334617 := ReadEval.Stack.head(tid: Tid,this: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
  mover4334617 := m#moverPath(moverPath4334617);                                                    
  path4334617 := p#moverPath(moverPath4334617);                                                     
  assume Node._state4334617 == Node._state && Node.item4334617 == Node.item && Node.next4334617 == Node.next && Node._lock4334617 == Node._lock && Stack._state4334617 == Stack._state && Stack.head4334617 == Stack.head && Stack._lock4334617 == Stack._lock && StackWithCAS._state4334617 == StackWithCAS._state && StackWithCAS.head4334617 == StackWithCAS.head && StackWithCAS._lock4334617 == StackWithCAS._lock && StackWithCAS.head_nextThread4334617 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334617 == StackWithCAS.head_nextValue && tmp34334617 == tmp3 && tmp24334617 == tmp2 && $result4334617 == $result && this4334617 == this && tid4334617 == tid && $pc4334617 == $pc;
  assume $recorded.state4334617 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (31.16): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4334617);                                                             
  assert $pc != PhaseError;                                                                                // (31.16): Reduction failure
  tmp3 := Stack.head[this];                                                                         
                                                                                                    
  // 31.26: tmp2 = tmp3 == Node.null;                                                               
                                                                                                    
  tmp2 := (tmp3==Node.null);                                                                        
  if (!(tmp2)) {                                                                                    
                                                                                                    
   // 31.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (35.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert Stack._lock[this] == tid;                                                                         // (35.13): lock not held
  $pc := transition($pc, _L);                                                                       
  assert $pc != PhaseError;                                                                                // (35.13): Reduction failure
  Stack._lock[this] := Tid.null;                                                                    
                                                                                                    
  // 36.13: yield;                                                                                  
                                                                                                    
  assume Node._state4334632 == Node._state && Node.item4334632 == Node.item && Node.next4334632 == Node.next && Node._lock4334632 == Node._lock && Stack._state4334632 == Stack._state && Stack.head4334632 == Stack.head && Stack._lock4334632 == Stack._lock && StackWithCAS._state4334632 == StackWithCAS._state && StackWithCAS.head4334632 == StackWithCAS.head && StackWithCAS._lock4334632 == StackWithCAS._lock && StackWithCAS.head_nextThread4334632 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334632 == StackWithCAS.head_nextValue && tmp34334632 == tmp3 && tmp24334632 == tmp2 && $result4334632 == $result && this4334632 == this && tid4334632 == tid;
  assume $recorded.state4334632 == 1;                                                               
  call Yield(tid);                                                                                  
  $pc := PreCommit;                                                                                 
  assume Node._state4334632_post == Node._state && Node.item4334632_post == Node.item && Node.next4334632_post == Node.next && Node._lock4334632_post == Node._lock && Stack._state4334632_post == Stack._state && Stack.head4334632_post == Stack.head && Stack._lock4334632_post == Stack._lock && StackWithCAS._state4334632_post == StackWithCAS._state && StackWithCAS.head4334632_post == StackWithCAS.head && StackWithCAS._lock4334632_post == StackWithCAS._lock && StackWithCAS.head_nextThread4334632_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334632_post == StackWithCAS.head_nextValue && tmp34334632_post == tmp3 && tmp24334632_post == tmp2 && $result4334632_post == $result && this4334632_post == this && tid4334632_post == tid;
  assume $recorded.state4334632_post == 1;                                                          
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (37.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assume Stack._lock[this] == Tid.null;                                                             
  $pc := transition($pc, _R);                                                                       
  assert $pc != PhaseError;                                                                                // (37.13): Reduction failure
  Stack._lock[this] := tid;                                                                         
  assume Node._state4334637_bottom == Node._state && Node.item4334637_bottom == Node.item && Node.next4334637_bottom == Node.next && Node._lock4334637_bottom == Node._lock && Stack._state4334637_bottom == Stack._state && Stack.head4334637_bottom == Stack.head && Stack._lock4334637_bottom == Stack._lock && StackWithCAS._state4334637_bottom == StackWithCAS._state && StackWithCAS.head4334637_bottom == StackWithCAS.head && StackWithCAS._lock4334637_bottom == StackWithCAS._lock && StackWithCAS.head_nextThread4334637_bottom == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334637_bottom == StackWithCAS.head_nextValue && $result4334637_bottom == $result && this4334637_bottom == this && tid4334637_bottom == tid;
  assume $recorded.state4334637_bottom == 1;                                                        
  assert phase4334637 == $pc;                                                                              // (31.9): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 39.9: int value;                                                                                
                                                                                                    
                                                                                                    
 // 39.9: Node tmp4;                                                                                
                                                                                                    
                                                                                                    
 // 39.9: tmp4 := this.head;                                                                        
                                                                                                    
                                                                                                    
 moverPath4334646 := ReadEval.Stack.head(tid: Tid,this: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334646 := m#moverPath(moverPath4334646);                                                     
 path4334646 := p#moverPath(moverPath4334646);                                                      
 assume Node._state4334646 == Node._state && Node.item4334646 == Node.item && Node.next4334646 == Node.next && Node._lock4334646 == Node._lock && Stack._state4334646 == Stack._state && Stack.head4334646 == Stack.head && Stack._lock4334646 == Stack._lock && StackWithCAS._state4334646 == StackWithCAS._state && StackWithCAS.head4334646 == StackWithCAS.head && StackWithCAS._lock4334646 == StackWithCAS._lock && StackWithCAS.head_nextThread4334646 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334646 == StackWithCAS.head_nextValue && tmp44334646 == tmp4 && value4334646 == value && $result4334646 == $result && this4334646 == this && tid4334646 == tid && $pc4334646 == $pc;
 assume $recorded.state4334646 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Stack.null;                                                                        
 } else {                                                                                           
  assert this != Stack.null;                                                                               // (39.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4334646);                                                              
 assert $pc != PhaseError;                                                                                 // (39.9): Reduction failure
 tmp4 := Stack.head[this];                                                                          
                                                                                                    
 // 39.9: value := tmp4.item;                                                                       
                                                                                                    
                                                                                                    
 moverPath4334649 := ReadEval.Node.item(tid: Tid,tmp4: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334649 := m#moverPath(moverPath4334649);                                                     
 path4334649 := p#moverPath(moverPath4334649);                                                      
 assume Node._state4334649 == Node._state && Node.item4334649 == Node.item && Node.next4334649 == Node.next && Node._lock4334649 == Node._lock && Stack._state4334649 == Stack._state && Stack.head4334649 == Stack.head && Stack._lock4334649 == Stack._lock && StackWithCAS._state4334649 == StackWithCAS._state && StackWithCAS.head4334649 == StackWithCAS.head && StackWithCAS._lock4334649 == StackWithCAS._lock && StackWithCAS.head_nextThread4334649 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334649 == StackWithCAS.head_nextValue && tmp44334649 == tmp4 && value4334649 == value && $result4334649 == $result && this4334649 == this && tid4334649 == tid && $pc4334649 == $pc;
 assume $recorded.state4334649 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume tmp4 != Node.null;                                                                         
 } else {                                                                                           
  assert tmp4 != Node.null;                                                                                // (39.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4334649);                                                              
 assert $pc != PhaseError;                                                                                 // (39.9): Reduction failure
 value := Node.item[tmp4];                                                                          
                                                                                                    
 // 40.9: Node tmp5;                                                                                
                                                                                                    
                                                                                                    
 // 40.9: Node tmp6;                                                                                
                                                                                                    
                                                                                                    
 // 40.9: tmp6 := this.head;                                                                        
                                                                                                    
                                                                                                    
 moverPath4334658 := ReadEval.Stack.head(tid: Tid,this: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334658 := m#moverPath(moverPath4334658);                                                     
 path4334658 := p#moverPath(moverPath4334658);                                                      
 assume Node._state4334658 == Node._state && Node.item4334658 == Node.item && Node.next4334658 == Node.next && Node._lock4334658 == Node._lock && Stack._state4334658 == Stack._state && Stack.head4334658 == Stack.head && Stack._lock4334658 == Stack._lock && StackWithCAS._state4334658 == StackWithCAS._state && StackWithCAS.head4334658 == StackWithCAS.head && StackWithCAS._lock4334658 == StackWithCAS._lock && StackWithCAS.head_nextThread4334658 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334658 == StackWithCAS.head_nextValue && tmp64334658 == tmp6 && tmp54334658 == tmp5 && tmp44334658 == tmp4 && value4334658 == value && $result4334658 == $result && this4334658 == this && tid4334658 == tid && $pc4334658 == $pc;
 assume $recorded.state4334658 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Stack.null;                                                                        
 } else {                                                                                           
  assert this != Stack.null;                                                                               // (40.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4334658);                                                              
 assert $pc != PhaseError;                                                                                 // (40.9): Reduction failure
 tmp6 := Stack.head[this];                                                                          
                                                                                                    
 // 40.9: tmp5 := tmp6.next;                                                                        
                                                                                                    
                                                                                                    
 moverPath4334661 := ReadEval.Node.next(tid: Tid,tmp6: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334661 := m#moverPath(moverPath4334661);                                                     
 path4334661 := p#moverPath(moverPath4334661);                                                      
 assume Node._state4334661 == Node._state && Node.item4334661 == Node.item && Node.next4334661 == Node.next && Node._lock4334661 == Node._lock && Stack._state4334661 == Stack._state && Stack.head4334661 == Stack.head && Stack._lock4334661 == Stack._lock && StackWithCAS._state4334661 == StackWithCAS._state && StackWithCAS.head4334661 == StackWithCAS.head && StackWithCAS._lock4334661 == StackWithCAS._lock && StackWithCAS.head_nextThread4334661 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334661 == StackWithCAS.head_nextValue && tmp64334661 == tmp6 && tmp54334661 == tmp5 && tmp44334661 == tmp4 && value4334661 == value && $result4334661 == $result && this4334661 == this && tid4334661 == tid && $pc4334661 == $pc;
 assume $recorded.state4334661 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume tmp6 != Node.null;                                                                         
 } else {                                                                                           
  assert tmp6 != Node.null;                                                                                // (40.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4334661);                                                              
 assert $pc != PhaseError;                                                                                 // (40.9): Reduction failure
 tmp5 := Node.next[tmp6];                                                                           
                                                                                                    
                                                                                                    
 // 40.9: this.head := tmp5;                                                                        
                                                                                                    
                                                                                                    
 moverPath4334664 := WriteEval.Stack.head(tid: Tid,this: Stack,tmp5: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334664 := m#moverPath(moverPath4334664);                                                     
 path4334664 := p#moverPath(moverPath4334664);                                                      
 assume Node._state4334664 == Node._state && Node.item4334664 == Node.item && Node.next4334664 == Node.next && Node._lock4334664 == Node._lock && Stack._state4334664 == Stack._state && Stack.head4334664 == Stack.head && Stack._lock4334664 == Stack._lock && StackWithCAS._state4334664 == StackWithCAS._state && StackWithCAS.head4334664 == StackWithCAS.head && StackWithCAS._lock4334664 == StackWithCAS._lock && StackWithCAS.head_nextThread4334664 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334664 == StackWithCAS.head_nextValue && tmp64334664 == tmp6 && tmp54334664 == tmp5 && tmp44334664 == tmp4 && value4334664 == value && $result4334664 == $result && this4334664 == this && tid4334664 == tid && $pc4334664 == $pc;
 assume $recorded.state4334664 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Stack.null;                                                                        
 } else {                                                                                           
  assert this != Stack.null;                                                                               // (40.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover4334664);                                                              
 assert $pc != PhaseError;                                                                                 // (40.9): Reduction failure
 Stack.head[this] := tmp5;                                                                          
 if (isLocal(Node._state[tmp5], tid)) {                                                             
  Node._state[tmp5] := SHARED();                                                                    
  assert isSharedAssignable(Node._state[Node.next[tmp5]]);                                                 // (40.9): tmp5 became shared, but tmp5.next may not be shared.
 }                                                                                                  
                                                                                                    
 if ($pc == PreCommit) {                                                                            
  assume this != Stack.null;                                                                        
 } else {                                                                                           
  assert this != Stack.null;                                                                               // (41.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Stack._lock[this] == tid;                                                                          // (41.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (41.9): Reduction failure
 Stack._lock[this] := Tid.null;                                                                     
                                                                                                    
 // 42.9:  return value;                                                                            
                                                                                                    
 assume Node._state4334668 == Node._state && Node.item4334668 == Node.item && Node.next4334668 == Node.next && Node._lock4334668 == Node._lock && Stack._state4334668 == Stack._state && Stack.head4334668 == Stack.head && Stack._lock4334668 == Stack._lock && StackWithCAS._state4334668 == StackWithCAS._state && StackWithCAS.head4334668 == StackWithCAS.head && StackWithCAS._lock4334668 == StackWithCAS._lock && StackWithCAS.head_nextThread4334668 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334668 == StackWithCAS.head_nextValue && tmp64334668 == tmp6 && tmp54334668 == tmp5 && tmp44334668 == tmp4 && value4334668 == value && $result4334668 == $result && this4334668 == this && tid4334668 == tid;
 assume $recorded.state4334668 == 1;                                                                
 $result := value;                                                                                  
 return;                                                                                            
                                                                                                    
 // 29.22: // return -1;                                                                            
                                                                                                    
 assume Node._state4334672 == Node._state && Node.item4334672 == Node.item && Node.next4334672 == Node.next && Node._lock4334672 == Node._lock && Stack._state4334672 == Stack._state && Stack.head4334672 == Stack.head && Stack._lock4334672 == Stack._lock && StackWithCAS._state4334672 == StackWithCAS._state && StackWithCAS.head4334672 == StackWithCAS.head && StackWithCAS._lock4334672 == StackWithCAS._lock && StackWithCAS.head_nextThread4334672 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334672 == StackWithCAS.head_nextValue && tmp64334672 == tmp6 && tmp54334672 == tmp5 && tmp44334672 == tmp4 && value4334672 == value && $result4334672 == $result && this4334672 == this && tid4334672 == tid;
 assume $recorded.state4334672 == 1;                                                                
 $result := -1;                                                                                     
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  Stack.pop2(tid:Tid, this : Stack)                                                        
returns ($result : int)                                                                             
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Stack._state;                                                                              
modifies Stack.head;                                                                                
modifies Stack._lock;                                                                               
modifies StackWithCAS._state;                                                                       
modifies StackWithCAS.head;                                                                         
modifies StackWithCAS._lock;                                                                        
modifies StackWithCAS.head_nextThread;                                                              
modifies StackWithCAS.head_nextValue;                                                               
                                                                                                    
requires ValidTid(tid);                                                                                    // (45.5): Bad tid
requires isShared(Stack._state[this]);                                                                     // (45.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
{                                                                                                   
 var Node.next4334716: [Node]Node;                                                                  
 var $recorded.state4334743: int;                                                                   
 var tid4334728: Tid;                                                                               
 var Node._state4334740: [Node]State;                                                               
 var StackWithCAS.head_nextValue4334728: [StackWithCAS]Node;                                        
 var StackWithCAS._state4334728: [StackWithCAS]State;                                               
 var Node.next4334737: [Node]Node;                                                                  
 var moverPath4334737: MoverPath;                                                                   
 var mover4334697: Mover;                                                                           
 var StackWithCAS.head_nextThread4334725: [StackWithCAS]Tid;                                        
 var StackWithCAS.head_nextValue4334725: [StackWithCAS]Node;                                        
 var StackWithCAS.head4334716_bottom: [StackWithCAS]Node;                                           
 var Node._state4334716_bottom: [Node]State;                                                        
 var $recorded.state4334740: int;                                                                   
 var tid4334747: Tid;                                                                               
 var StackWithCAS.head_nextThread4334737: [StackWithCAS]Tid;                                        
 var StackWithCAS.head_nextValue4334716: [StackWithCAS]Node;                                        
 var $recorded.state4334713_post: int;                                                              
 var Node._lock4334751: [Node]Tid;                                                                  
 var tmp74334713_post: bool;                                                                        
 var Stack._lock4334713: [Stack]Tid;                                                                
 var $pc4334697: Phase;                                                                             
 var tmp104334743: Node;                                                                            
 var path4334728: int;                                                                              
 var this4334740: Stack;                                                                            
 var StackWithCAS.head_nextValue4334713_post: [StackWithCAS]Node;                                   
 var $pc4334740: Phase;                                                                             
 var Stack.head4334697: [Stack]Node;                                                                
 var tmp94334713: Node;                                                                             
 var $pc4334737: Phase;                                                                             
 var StackWithCAS._lock4334743: [StackWithCAS]Tid;                                                  
 var Stack._lock4334747: [Stack]Tid;                                                                
 var tmp12: Node;                                                                                   
 var this4334716_bottom: Stack;                                                                     
 var Node.item4334713: [Node]int;                                                                   
 var tid4334751: Tid;                                                                               
 var StackWithCAS._lock4334713: [StackWithCAS]Tid;                                                  
 var StackWithCAS.head_nextThread4334747: [StackWithCAS]Tid;                                        
 var StackWithCAS.head4334743: [StackWithCAS]Node;                                                  
 var StackWithCAS._lock4334737: [StackWithCAS]Tid;                                                  
 var Stack._state4334716_bottom: [Stack]State;                                                      
 var $pc4334716_bottom: Phase;                                                                      
 var StackWithCAS.head4334728: [StackWithCAS]Node;                                                  
 var moverPath4334725: MoverPath;                                                                   
 var StackWithCAS._state4334713: [StackWithCAS]State;                                               
 var Node.item4334740: [Node]int;                                                                   
 var Node.item4334713_post: [Node]int;                                                              
 var Stack._state4334713: [Stack]State;                                                             
 var Stack.head4334713: [Stack]Node;                                                                
 var Stack.head4334740: [Stack]Node;                                                                
 var Stack.head4334716: [Stack]Node;                                                                
 var tmp94334697: Node;                                                                             
 var StackWithCAS._lock4334725: [StackWithCAS]Tid;                                                  
 var this4334743: Stack;                                                                            
 var $pc4334728: Phase;                                                                             
 var StackWithCAS._state4334751: [StackWithCAS]State;                                               
 var StackWithCAS.head4334713: [StackWithCAS]Node;                                                  
 var StackWithCAS.head_nextValue4334697: [StackWithCAS]Node;                                        
 var StackWithCAS.head_nextValue4334743: [StackWithCAS]Node;                                        
 var tmp84334713_post: bool;                                                                        
 var Node._lock4334713_post: [Node]Tid;                                                             
 var $result4334713_post: int;                                                                      
 var Node._lock4334725: [Node]Tid;                                                                  
 var $recorded.state4334716: int;                                                                   
 var Node._lock4334728: [Node]Tid;                                                                  
 var this4334716: Stack;                                                                            
 var this4334751: Stack;                                                                            
 var $result4334697: int;                                                                           
 var Node.item4334697: [Node]int;                                                                   
 var Node._lock4334697: [Node]Tid;                                                                  
 var Stack._state4334725: [Stack]State;                                                             
 var Node._state4334713_post: [Node]State;                                                          
 var StackWithCAS.head_nextThread4334716_bottom: [StackWithCAS]Tid;                                 
 var StackWithCAS.head_nextThread4334713: [StackWithCAS]Tid;                                        
 var tmp124334751: Node;                                                                            
 var Node.next4334743: [Node]Node;                                                                  
 var mover4334743: Mover;                                                                           
 var Stack.head4334743: [Stack]Node;                                                                
 var StackWithCAS._state4334747: [StackWithCAS]State;                                               
 var this4334728: Stack;                                                                            
 var tmp104334728: Node;                                                                            
 var this4334697: Stack;                                                                            
 var value: int;                                                                                    
 var $result4334728: int;                                                                           
 var Stack._lock4334725: [Stack]Tid;                                                                
 var StackWithCAS.head_nextValue4334747: [StackWithCAS]Node;                                        
 var value4334728: int;                                                                             
 var tmp84334713: bool;                                                                             
 var Node.next4334751: [Node]Node;                                                                  
 var $result4334725: int;                                                                           
 var Stack._lock4334728: [Stack]Tid;                                                                
 var $result4334740: int;                                                                           
 var StackWithCAS._state4334743: [StackWithCAS]State;                                               
 var StackWithCAS.head4334716: [StackWithCAS]Node;                                                  
 var Node._state4334747: [Node]State;                                                               
 var StackWithCAS.head4334713_post: [StackWithCAS]Node;                                             
 var Stack._state4334743: [Stack]State;                                                             
 var Node.next4334747: [Node]Node;                                                                  
 var moverPath4334728: MoverPath;                                                                   
 var StackWithCAS._lock4334740: [StackWithCAS]Tid;                                                  
 var $recorded.state4334737: int;                                                                   
 var Node._lock4334716_bottom: [Node]Tid;                                                           
 var Node.item4334751: [Node]int;                                                                   
 var StackWithCAS._state4334713_post: [StackWithCAS]State;                                          
 var $result4334751: int;                                                                           
 var mover4334740: Mover;                                                                           
 var StackWithCAS.head_nextValue4334751: [StackWithCAS]Node;                                        
 var Node.item4334716_bottom: [Node]int;                                                            
 var Stack.head4334728: [Stack]Node;                                                                
 var tmp114334740: Node;                                                                            
 var StackWithCAS._lock4334747: [StackWithCAS]Tid;                                                  
 var tid4334743: Tid;                                                                               
 var StackWithCAS._state4334740: [StackWithCAS]State;                                               
 var StackWithCAS.head_nextThread4334728: [StackWithCAS]Tid;                                        
 var tid4334713: Tid;                                                                               
 var StackWithCAS.head4334740: [StackWithCAS]Node;                                                  
 var tmp9: Node;                                                                                    
 var value4334751: int;                                                                             
 var tmp114334747: Node;                                                                            
 var Node._lock4334747: [Node]Tid;                                                                  
 var Node.item4334728: [Node]int;                                                                   
 var StackWithCAS.head4334697: [StackWithCAS]Node;                                                  
 var $recorded.state4334697: int;                                                                   
 var tmp104334725: Node;                                                                            
 var StackWithCAS.head_nextThread4334713_post: [StackWithCAS]Tid;                                   
 var path4334697: int;                                                                              
 var $recorded.state4334725: int;                                                                   
 var Stack.head4334725: [Stack]Node;                                                                
 var Node._state4334728: [Node]State;                                                               
 var tmp114334737: Node;                                                                            
 var StackWithCAS._lock4334728: [StackWithCAS]Tid;                                                  
 var Node._lock4334740: [Node]Tid;                                                                  
 var value4334737: int;                                                                             
 var path4334725: int;                                                                              
 var moverPath4334697: MoverPath;                                                                   
 var StackWithCAS.head4334737: [StackWithCAS]Node;                                                  
 var tmp104334737: Node;                                                                            
 var tmp124334747: Node;                                                                            
 var $pc4334713: Phase;                                                                             
 var Stack._state4334751: [Stack]State;                                                             
 var Stack._lock4334697: [Stack]Tid;                                                                
 var $result4334737: int;                                                                           
 var StackWithCAS.head_nextThread4334716: [StackWithCAS]Tid;                                        
 var $recorded.state4334751: int;                                                                   
 var phase4334716: Phase;                                                                           
 var Stack._state4334747: [Stack]State;                                                             
 var value4334740: int;                                                                             
 var StackWithCAS._lock4334716: [StackWithCAS]Tid;                                                  
 var tmp114334743: Node;                                                                            
 var $pc4334751: Phase;                                                                             
 var Node._state4334716: [Node]State;                                                               
 var $recorded.state4334716_bottom: int;                                                            
 var tmp124334737: Node;                                                                            
 var Node.item4334725: [Node]int;                                                                   
 var StackWithCAS._lock4334716_bottom: [StackWithCAS]Tid;                                           
 var StackWithCAS.head_nextValue4334737: [StackWithCAS]Node;                                        
 var mover4334737: Mover;                                                                           
 var StackWithCAS.head4334751: [StackWithCAS]Node;                                                  
 var StackWithCAS.head_nextValue4334716_bottom: [StackWithCAS]Node;                                 
 var $pc4334747: Phase;                                                                             
 var mover4334725: Mover;                                                                           
 var Node._state4334743: [Node]State;                                                               
 var StackWithCAS._state4334725: [StackWithCAS]State;                                               
 var tid4334697: Tid;                                                                               
 var $pc4334713_post: Phase;                                                                        
 var StackWithCAS.head_nextThread4334751: [StackWithCAS]Tid;                                        
 var value4334747: int;                                                                             
 var tmp10: Node;                                                                                   
 var this4334713_post: Stack;                                                                       
 var this4334747: Stack;                                                                            
 var StackWithCAS._state4334737: [StackWithCAS]State;                                               
 var this4334737: Stack;                                                                            
 var tmp124334743: Node;                                                                            
 var StackWithCAS.head4334747: [StackWithCAS]Node;                                                  
 var $result4334747: int;                                                                           
 var tmp7: bool;                                                                                    
 var Node._lock4334737: [Node]Tid;                                                                  
 var $result4334716_bottom: int;                                                                    
 var this4334725: Stack;                                                                            
 var Stack._lock4334713_post: [Stack]Tid;                                                           
 var Node._state4334697: [Node]State;                                                               
 var Node._lock4334716: [Node]Tid;                                                                  
 var tid4334713_post: Tid;                                                                          
 var Node.item4334747: [Node]int;                                                                   
 var value4334725: int;                                                                             
 var StackWithCAS.head_nextValue4334713: [StackWithCAS]Node;                                        
 var Stack._lock4334716: [Stack]Tid;                                                                
 var path4334743: int;                                                                              
 var tid4334740: Tid;                                                                               
 var Stack._state4334697: [Stack]State;                                                             
 var Stack._state4334716: [Stack]State;                                                             
 var Node.next4334697: [Node]Node;                                                                  
 var tid4334716: Tid;                                                                               
 var Stack.head4334747: [Stack]Node;                                                                
 var Node.next4334716_bottom: [Node]Node;                                                           
 var $result4334743: int;                                                                           
 var Stack._state4334713_post: [Stack]State;                                                        
 var Node.item4334716: [Node]int;                                                                   
 var $result4334716: int;                                                                           
 var tid4334725: Tid;                                                                               
 var Stack._lock4334716_bottom: [Stack]Tid;                                                         
 var tmp124334740: Node;                                                                            
 var Node.item4334737: [Node]int;                                                                   
 var tid4334737: Tid;                                                                               
 var moverPath4334743: MoverPath;                                                                   
 var StackWithCAS.head4334725: [StackWithCAS]Node;                                                  
 var Node._state4334737: [Node]State;                                                               
 var StackWithCAS._lock4334713_post: [StackWithCAS]Tid;                                             
 var tmp11: Node;                                                                                   
 var tmp104334751: Node;                                                                            
 var Node._state4334725: [Node]State;                                                               
 var $recorded.state4334747: int;                                                                   
 var tmp74334713: bool;                                                                             
 var tmp84334697: bool;                                                                             
 var tid4334716_bottom: Tid;                                                                        
 var $recorded.state4334713: int;                                                                   
 var Node.next4334725: [Node]Node;                                                                  
 var moverPath4334740: MoverPath;                                                                   
 var $pc4334743: Phase;                                                                             
 var StackWithCAS.head_nextThread4334743: [StackWithCAS]Tid;                                        
 var Stack.head4334751: [Stack]Node;                                                                
 var StackWithCAS._lock4334751: [StackWithCAS]Tid;                                                  
 var Node.next4334713_post: [Node]Node;                                                             
 var path4334740: int;                                                                              
 var tmp104334747: Node;                                                                            
 var Node._lock4334713: [Node]Tid;                                                                  
 var Stack._state4334740: [Stack]State;                                                             
 var StackWithCAS._lock4334697: [StackWithCAS]Tid;                                                  
 var Stack._lock4334743: [Stack]Tid;                                                                
 var StackWithCAS._state4334697: [StackWithCAS]State;                                               
 var tmp104334740: Node;                                                                            
 var Node._state4334713: [Node]State;                                                               
 var $result4334713: int;                                                                           
 var $pc4334716: Phase;                                                                             
 var tmp8: bool;                                                                                    
 var mover4334728: Mover;                                                                           
 var value4334743: int;                                                                             
 var Node.next4334713: [Node]Node;                                                                  
 var this4334713: Stack;                                                                            
 var Node.next4334740: [Node]Node;                                                                  
 var StackWithCAS.head_nextThread4334697: [StackWithCAS]Tid;                                        
 var tmp74334697: bool;                                                                             
 var Node._state4334751: [Node]State;                                                               
 var StackWithCAS.head_nextThread4334740: [StackWithCAS]Tid;                                        
 var tmp114334751: Node;                                                                            
 var $recorded.state4334728: int;                                                                   
 var Node.next4334728: [Node]Node;                                                                  
 var Stack._lock4334737: [Stack]Tid;                                                                
 var tmp94334713_post: Node;                                                                        
 var Stack.head4334713_post: [Stack]Node;                                                           
 var Stack._state4334737: [Stack]State;                                                             
 var $pc4334725: Phase;                                                                             
 var StackWithCAS._state4334716_bottom: [StackWithCAS]State;                                        
 var Stack._state4334728: [Stack]State;                                                             
 var Stack.head4334737: [Stack]Node;                                                                
 var StackWithCAS.head_nextValue4334740: [StackWithCAS]Node;                                        
 var Stack._lock4334740: [Stack]Tid;                                                                
 var Node._lock4334743: [Node]Tid;                                                                  
 var Stack._lock4334751: [Stack]Tid;                                                                
 var Stack.head4334716_bottom: [Stack]Node;                                                         
 var StackWithCAS._state4334716: [StackWithCAS]State;                                               
 var path4334737: int;                                                                              
 var Node.item4334743: [Node]int;                                                                   
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state4334716 == Node._state && Node.item4334716 == Node.item && Node.next4334716 == Node.next && Node._lock4334716 == Node._lock && Stack._state4334716 == Stack._state && Stack.head4334716 == Stack.head && Stack._lock4334716 == Stack._lock && StackWithCAS._state4334716 == StackWithCAS._state && StackWithCAS.head4334716 == StackWithCAS.head && StackWithCAS._lock4334716 == StackWithCAS._lock && StackWithCAS.head_nextThread4334716 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334716 == StackWithCAS.head_nextValue && $result4334716 == $result && this4334716 == this && tid4334716 == tid;
 assume $recorded.state4334716 == 1;                                                                
                                                                                                    
 // 48.9: while (true)                                                                              
                                                                                                    
 phase4334716 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (45.5): Bad tid
  invariant isShared(Stack._state[this]);                                                                  // (45.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
  invariant true;                                                                                   
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state4334716,Node.item4334716,Node.next4334716,Node._lock4334716,Stack._state4334716,Stack.head4334716,Stack._lock4334716,StackWithCAS._state4334716,StackWithCAS.head4334716,StackWithCAS._lock4334716,StackWithCAS.head_nextThread4334716,StackWithCAS.head_nextValue4334716));       // (48.9): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state4334716,Node.item4334716,Node.next4334716,Node._lock4334716,Stack._state4334716,Stack.head4334716,Stack._lock4334716,StackWithCAS._state4334716,StackWithCAS.head4334716,StackWithCAS._lock4334716,StackWithCAS.head_nextThread4334716,StackWithCAS.head_nextValue4334716));       // (48.9): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Stack :: Invariant.Y_Stack.head(tid : Tid, _this, Stack.head[_this] ,Node._state4334716,Node.item4334716,Node.next4334716,Node._lock4334716,Stack._state4334716,Stack.head4334716,Stack._lock4334716,StackWithCAS._state4334716,StackWithCAS.head4334716,StackWithCAS._lock4334716,StackWithCAS.head_nextThread4334716,StackWithCAS.head_nextValue4334716));       // (48.9): Loop does not preserve yields_as annotation for field head
  invariant (forall _this : StackWithCAS :: Invariant.Y_StackWithCAS.head(tid : Tid, _this, StackWithCAS.head[_this] ,Node._state4334716,Node.item4334716,Node.next4334716,Node._lock4334716,Stack._state4334716,Stack.head4334716,Stack._lock4334716,StackWithCAS._state4334716,StackWithCAS.head4334716,StackWithCAS._lock4334716,StackWithCAS.head_nextThread4334716,StackWithCAS.head_nextValue4334716));       // (48.9): Loop does not preserve yields_as annotation for field head
  invariant phase4334716 == $pc;                                                                           // (48.9): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (48.9): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 48.16: boolean tmp7;                                                                           
                                                                                                    
                                                                                                    
  // 48.16: tmp7 = true;                                                                            
                                                                                                    
  tmp7 := true;                                                                                     
  if (!(tmp7)) {                                                                                    
                                                                                                    
   // 48.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (51.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assume Stack._lock[this] == Tid.null;                                                             
  $pc := transition($pc, _R);                                                                       
  assert $pc != PhaseError;                                                                                // (51.13): Reduction failure
  Stack._lock[this] := tid;                                                                         
                                                                                                    
  // 52.13: boolean tmp8;                                                                           
                                                                                                    
                                                                                                    
  // 52.13: Node tmp9;                                                                              
                                                                                                    
                                                                                                    
  // 52.13: tmp9 := this.head;                                                                      
                                                                                                    
                                                                                                    
  moverPath4334697 := ReadEval.Stack.head(tid: Tid,this: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
  mover4334697 := m#moverPath(moverPath4334697);                                                    
  path4334697 := p#moverPath(moverPath4334697);                                                     
  assume Node._state4334697 == Node._state && Node.item4334697 == Node.item && Node.next4334697 == Node.next && Node._lock4334697 == Node._lock && Stack._state4334697 == Stack._state && Stack.head4334697 == Stack.head && Stack._lock4334697 == Stack._lock && StackWithCAS._state4334697 == StackWithCAS._state && StackWithCAS.head4334697 == StackWithCAS.head && StackWithCAS._lock4334697 == StackWithCAS._lock && StackWithCAS.head_nextThread4334697 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334697 == StackWithCAS.head_nextValue && tmp94334697 == tmp9 && tmp84334697 == tmp8 && tmp74334697 == tmp7 && $result4334697 == $result && this4334697 == this && tid4334697 == tid && $pc4334697 == $pc;
  assume $recorded.state4334697 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (52.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4334697);                                                             
  assert $pc != PhaseError;                                                                                // (52.13): Reduction failure
  tmp9 := Stack.head[this];                                                                         
                                                                                                    
  // 52.13: tmp8 = tmp9 == Node.null;                                                               
                                                                                                    
  tmp8 := (tmp9==Node.null);                                                                        
  if (tmp8 /* lowered (Stack.head[this]==Node.null) */) {                                           
                                                                                                    
   // 52.38: break;                                                                                 
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (53.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert Stack._lock[this] == tid;                                                                         // (53.13): lock not held
  $pc := transition($pc, _L);                                                                       
  assert $pc != PhaseError;                                                                                // (53.13): Reduction failure
  Stack._lock[this] := Tid.null;                                                                    
                                                                                                    
  // 54.13: yield;                                                                                  
                                                                                                    
  assume Node._state4334713 == Node._state && Node.item4334713 == Node.item && Node.next4334713 == Node.next && Node._lock4334713 == Node._lock && Stack._state4334713 == Stack._state && Stack.head4334713 == Stack.head && Stack._lock4334713 == Stack._lock && StackWithCAS._state4334713 == StackWithCAS._state && StackWithCAS.head4334713 == StackWithCAS.head && StackWithCAS._lock4334713 == StackWithCAS._lock && StackWithCAS.head_nextThread4334713 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334713 == StackWithCAS.head_nextValue && tmp94334713 == tmp9 && tmp84334713 == tmp8 && tmp74334713 == tmp7 && $result4334713 == $result && this4334713 == this && tid4334713 == tid;
  assume $recorded.state4334713 == 1;                                                               
  call Yield(tid);                                                                                  
  $pc := PreCommit;                                                                                 
  assume Node._state4334713_post == Node._state && Node.item4334713_post == Node.item && Node.next4334713_post == Node.next && Node._lock4334713_post == Node._lock && Stack._state4334713_post == Stack._state && Stack.head4334713_post == Stack.head && Stack._lock4334713_post == Stack._lock && StackWithCAS._state4334713_post == StackWithCAS._state && StackWithCAS.head4334713_post == StackWithCAS.head && StackWithCAS._lock4334713_post == StackWithCAS._lock && StackWithCAS.head_nextThread4334713_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334713_post == StackWithCAS.head_nextValue && tmp94334713_post == tmp9 && tmp84334713_post == tmp8 && tmp74334713_post == tmp7 && $result4334713_post == $result && this4334713_post == this && tid4334713_post == tid;
  assume $recorded.state4334713_post == 1;                                                          
  assume Node._state4334716_bottom == Node._state && Node.item4334716_bottom == Node.item && Node.next4334716_bottom == Node.next && Node._lock4334716_bottom == Node._lock && Stack._state4334716_bottom == Stack._state && Stack.head4334716_bottom == Stack.head && Stack._lock4334716_bottom == Stack._lock && StackWithCAS._state4334716_bottom == StackWithCAS._state && StackWithCAS.head4334716_bottom == StackWithCAS.head && StackWithCAS._lock4334716_bottom == StackWithCAS._lock && StackWithCAS.head_nextThread4334716_bottom == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334716_bottom == StackWithCAS.head_nextValue && $result4334716_bottom == $result && this4334716_bottom == this && tid4334716_bottom == tid;
  assume $recorded.state4334716_bottom == 1;                                                        
  assert phase4334716 == $pc;                                                                              // (48.9): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 56.9: int value;                                                                                
                                                                                                    
                                                                                                    
 // 56.9: Node tmp10;                                                                               
                                                                                                    
                                                                                                    
 // 56.9: tmp10 := this.head;                                                                       
                                                                                                    
                                                                                                    
 moverPath4334725 := ReadEval.Stack.head(tid: Tid,this: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334725 := m#moverPath(moverPath4334725);                                                     
 path4334725 := p#moverPath(moverPath4334725);                                                      
 assume Node._state4334725 == Node._state && Node.item4334725 == Node.item && Node.next4334725 == Node.next && Node._lock4334725 == Node._lock && Stack._state4334725 == Stack._state && Stack.head4334725 == Stack.head && Stack._lock4334725 == Stack._lock && StackWithCAS._state4334725 == StackWithCAS._state && StackWithCAS.head4334725 == StackWithCAS.head && StackWithCAS._lock4334725 == StackWithCAS._lock && StackWithCAS.head_nextThread4334725 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334725 == StackWithCAS.head_nextValue && tmp104334725 == tmp10 && value4334725 == value && $result4334725 == $result && this4334725 == this && tid4334725 == tid && $pc4334725 == $pc;
 assume $recorded.state4334725 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Stack.null;                                                                        
 } else {                                                                                           
  assert this != Stack.null;                                                                               // (56.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4334725);                                                              
 assert $pc != PhaseError;                                                                                 // (56.9): Reduction failure
 tmp10 := Stack.head[this];                                                                         
                                                                                                    
 // 56.9: value := tmp10.item;                                                                      
                                                                                                    
                                                                                                    
 moverPath4334728 := ReadEval.Node.item(tid: Tid,tmp10: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334728 := m#moverPath(moverPath4334728);                                                     
 path4334728 := p#moverPath(moverPath4334728);                                                      
 assume Node._state4334728 == Node._state && Node.item4334728 == Node.item && Node.next4334728 == Node.next && Node._lock4334728 == Node._lock && Stack._state4334728 == Stack._state && Stack.head4334728 == Stack.head && Stack._lock4334728 == Stack._lock && StackWithCAS._state4334728 == StackWithCAS._state && StackWithCAS.head4334728 == StackWithCAS.head && StackWithCAS._lock4334728 == StackWithCAS._lock && StackWithCAS.head_nextThread4334728 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334728 == StackWithCAS.head_nextValue && tmp104334728 == tmp10 && value4334728 == value && $result4334728 == $result && this4334728 == this && tid4334728 == tid && $pc4334728 == $pc;
 assume $recorded.state4334728 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume tmp10 != Node.null;                                                                        
 } else {                                                                                           
  assert tmp10 != Node.null;                                                                               // (56.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4334728);                                                              
 assert $pc != PhaseError;                                                                                 // (56.9): Reduction failure
 value := Node.item[tmp10];                                                                         
                                                                                                    
 // 57.9: Node tmp11;                                                                               
                                                                                                    
                                                                                                    
 // 57.9: Node tmp12;                                                                               
                                                                                                    
                                                                                                    
 // 57.9: tmp12 := this.head;                                                                       
                                                                                                    
                                                                                                    
 moverPath4334737 := ReadEval.Stack.head(tid: Tid,this: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334737 := m#moverPath(moverPath4334737);                                                     
 path4334737 := p#moverPath(moverPath4334737);                                                      
 assume Node._state4334737 == Node._state && Node.item4334737 == Node.item && Node.next4334737 == Node.next && Node._lock4334737 == Node._lock && Stack._state4334737 == Stack._state && Stack.head4334737 == Stack.head && Stack._lock4334737 == Stack._lock && StackWithCAS._state4334737 == StackWithCAS._state && StackWithCAS.head4334737 == StackWithCAS.head && StackWithCAS._lock4334737 == StackWithCAS._lock && StackWithCAS.head_nextThread4334737 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334737 == StackWithCAS.head_nextValue && tmp124334737 == tmp12 && tmp114334737 == tmp11 && tmp104334737 == tmp10 && value4334737 == value && $result4334737 == $result && this4334737 == this && tid4334737 == tid && $pc4334737 == $pc;
 assume $recorded.state4334737 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Stack.null;                                                                        
 } else {                                                                                           
  assert this != Stack.null;                                                                               // (57.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4334737);                                                              
 assert $pc != PhaseError;                                                                                 // (57.9): Reduction failure
 tmp12 := Stack.head[this];                                                                         
                                                                                                    
 // 57.9: tmp11 := tmp12.next;                                                                      
                                                                                                    
                                                                                                    
 moverPath4334740 := ReadEval.Node.next(tid: Tid,tmp12: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334740 := m#moverPath(moverPath4334740);                                                     
 path4334740 := p#moverPath(moverPath4334740);                                                      
 assume Node._state4334740 == Node._state && Node.item4334740 == Node.item && Node.next4334740 == Node.next && Node._lock4334740 == Node._lock && Stack._state4334740 == Stack._state && Stack.head4334740 == Stack.head && Stack._lock4334740 == Stack._lock && StackWithCAS._state4334740 == StackWithCAS._state && StackWithCAS.head4334740 == StackWithCAS.head && StackWithCAS._lock4334740 == StackWithCAS._lock && StackWithCAS.head_nextThread4334740 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334740 == StackWithCAS.head_nextValue && tmp124334740 == tmp12 && tmp114334740 == tmp11 && tmp104334740 == tmp10 && value4334740 == value && $result4334740 == $result && this4334740 == this && tid4334740 == tid && $pc4334740 == $pc;
 assume $recorded.state4334740 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume tmp12 != Node.null;                                                                        
 } else {                                                                                           
  assert tmp12 != Node.null;                                                                               // (57.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4334740);                                                              
 assert $pc != PhaseError;                                                                                 // (57.9): Reduction failure
 tmp11 := Node.next[tmp12];                                                                         
                                                                                                    
                                                                                                    
 // 57.9: this.head := tmp11;                                                                       
                                                                                                    
                                                                                                    
 moverPath4334743 := WriteEval.Stack.head(tid: Tid,this: Stack,tmp11: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 mover4334743 := m#moverPath(moverPath4334743);                                                     
 path4334743 := p#moverPath(moverPath4334743);                                                      
 assume Node._state4334743 == Node._state && Node.item4334743 == Node.item && Node.next4334743 == Node.next && Node._lock4334743 == Node._lock && Stack._state4334743 == Stack._state && Stack.head4334743 == Stack.head && Stack._lock4334743 == Stack._lock && StackWithCAS._state4334743 == StackWithCAS._state && StackWithCAS.head4334743 == StackWithCAS.head && StackWithCAS._lock4334743 == StackWithCAS._lock && StackWithCAS.head_nextThread4334743 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334743 == StackWithCAS.head_nextValue && tmp124334743 == tmp12 && tmp114334743 == tmp11 && tmp104334743 == tmp10 && value4334743 == value && $result4334743 == $result && this4334743 == this && tid4334743 == tid && $pc4334743 == $pc;
 assume $recorded.state4334743 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Stack.null;                                                                        
 } else {                                                                                           
  assert this != Stack.null;                                                                               // (57.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover4334743);                                                              
 assert $pc != PhaseError;                                                                                 // (57.9): Reduction failure
 Stack.head[this] := tmp11;                                                                         
 if (isLocal(Node._state[tmp11], tid)) {                                                            
  Node._state[tmp11] := SHARED();                                                                   
  assert isSharedAssignable(Node._state[Node.next[tmp11]]);                                                // (57.9): tmp11 became shared, but tmp11.next may not be shared.
 }                                                                                                  
                                                                                                    
 if ($pc == PreCommit) {                                                                            
  assume this != Stack.null;                                                                        
 } else {                                                                                           
  assert this != Stack.null;                                                                               // (58.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Stack._lock[this] == tid;                                                                          // (58.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (58.9): Reduction failure
 Stack._lock[this] := Tid.null;                                                                     
                                                                                                    
 // 59.9:  return value;                                                                            
                                                                                                    
 assume Node._state4334747 == Node._state && Node.item4334747 == Node.item && Node.next4334747 == Node.next && Node._lock4334747 == Node._lock && Stack._state4334747 == Stack._state && Stack.head4334747 == Stack.head && Stack._lock4334747 == Stack._lock && StackWithCAS._state4334747 == StackWithCAS._state && StackWithCAS.head4334747 == StackWithCAS.head && StackWithCAS._lock4334747 == StackWithCAS._lock && StackWithCAS.head_nextThread4334747 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334747 == StackWithCAS.head_nextValue && tmp124334747 == tmp12 && tmp114334747 == tmp11 && tmp104334747 == tmp10 && value4334747 == value && $result4334747 == $result && this4334747 == this && tid4334747 == tid;
 assume $recorded.state4334747 == 1;                                                                
 $result := value;                                                                                  
 return;                                                                                            
                                                                                                    
 // 47.23: // return -1;                                                                            
                                                                                                    
 assume Node._state4334751 == Node._state && Node.item4334751 == Node.item && Node.next4334751 == Node.next && Node._lock4334751 == Node._lock && Stack._state4334751 == Stack._state && Stack.head4334751 == Stack.head && Stack._lock4334751 == Stack._lock && StackWithCAS._state4334751 == StackWithCAS._state && StackWithCAS.head4334751 == StackWithCAS.head && StackWithCAS._lock4334751 == StackWithCAS._lock && StackWithCAS.head_nextThread4334751 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334751 == StackWithCAS.head_nextValue && tmp124334751 == tmp12 && tmp114334751 == tmp11 && tmp104334751 == tmp10 && value4334751 == value && $result4334751 == $result && this4334751 == this && tid4334751 == tid;
 assume $recorded.state4334751 == 1;                                                                
 $result := -1;                                                                                     
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl StackWithCAS ***/                                                                   
                                                                                                    
type StackWithCAS;                                                                                  
const unique StackWithCAS.null: StackWithCAS;                                                       
var StackWithCAS._state: [StackWithCAS]State;                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var StackWithCAS.head: [StackWithCAS]Node;                                                          
                                                                                                    
function {:inline} ReadEval.StackWithCAS.head(tid: Tid,this : StackWithCAS,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(StackWithCAS._state[this], tid)) then                                                  
  if (isLocal(StackWithCAS._state[this], tid)) then                                                 
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.StackWithCAS.head(tid: Tid,this : StackWithCAS,newValue: Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(StackWithCAS._state[this], tid)) then                                                  
  if (isLocal(StackWithCAS._state[this], tid)) then                                                 
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var StackWithCAS._lock: [StackWithCAS]Tid;                                                          
                                                                                                    
function {:inline} ReadEval.StackWithCAS._lock(tid: Tid,this : StackWithCAS,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(StackWithCAS._state[this], tid)) then                                                  
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((StackWithCAS._lock[this]==tid)) then                                                        
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((StackWithCAS._lock[this]==Tid.null)&&(newValue==tid))) then                                
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((StackWithCAS._lock[this]==tid)&&(newValue==Tid.null))) then                               
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.StackWithCAS._lock(tid: Tid,this : StackWithCAS,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(StackWithCAS._state[this], tid)) then                                                  
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((StackWithCAS._lock[this]==tid)) then                                                        
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((StackWithCAS._lock[this]==Tid.null)&&(newValue==tid))) then                                
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((StackWithCAS._lock[this]==tid)&&(newValue==Tid.null))) then                               
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var StackWithCAS.head_nextThread: [StackWithCAS]Tid;                                                
                                                                                                    
function {:inline} ReadEval.StackWithCAS.head_nextThread(tid: Tid,this : StackWithCAS,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(StackWithCAS._state[this], tid)) then                                                  
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((StackWithCAS.head_nextThread[this]==tid)) then                                               
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.StackWithCAS.head_nextThread(tid: Tid,this : StackWithCAS,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(StackWithCAS._state[this], tid)) then                                                  
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((StackWithCAS.head_nextThread[this]==tid)) then                                               
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var StackWithCAS.head_nextValue: [StackWithCAS]Node;                                                
                                                                                                    
function {:inline} ReadEval.StackWithCAS.head_nextValue(tid: Tid,this : StackWithCAS,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(StackWithCAS._state[this], tid)) then                                                  
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((StackWithCAS.head_nextThread[this]==tid)) then                                               
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.StackWithCAS.head_nextValue(tid: Tid,this : StackWithCAS,newValue: Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(StackWithCAS._state[this], tid)) then                                                  
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((StackWithCAS.head_nextThread[this]==tid)) then                                               
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  StackWithCAS.push(tid:Tid, this : StackWithCAS, v : int)                                 
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Stack._state;                                                                              
modifies Stack.head;                                                                                
modifies Stack._lock;                                                                               
modifies StackWithCAS._state;                                                                       
modifies StackWithCAS.head;                                                                         
modifies StackWithCAS._lock;                                                                        
modifies StackWithCAS.head_nextThread;                                                              
modifies StackWithCAS.head_nextValue;                                                               
                                                                                                    
requires ValidTid(tid);                                                                                    // (68.2): Bad tid
requires isShared(StackWithCAS._state[this]);                                                              // (68.2): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
{                                                                                                   
 var this4334968: StackWithCAS;                                                                     
 var $pc4334905: Phase;                                                                             
 var $recorded.state4335017: int;                                                                   
 var Node._state4334791: [Node]State;                                                               
 var StackWithCAS._state4334841: [StackWithCAS]State;                                               
 var Node.item4334846: [Node]int;                                                                   
 var nu4334889: Node;                                                                               
 var Node.next4334965: [Node]Node;                                                                  
 var StackWithCAS.head4334998: [StackWithCAS]Node;                                                  
 var Node.item4335035: [Node]int;                                                                   
 var mover4334797: Mover;                                                                           
 var Node._lock4334905_post: [Node]Tid;                                                             
 var StackWithCAS.head4334797: [StackWithCAS]Node;                                                  
 var $recorded.state4334995: int;                                                                   
 var Node.next4334803: [Node]Node;                                                                  
 var Stack._state4334889: [Stack]State;                                                             
 var StackWithCAS.head_nextValue4335035: [StackWithCAS]Node;                                        
 var this4335035: StackWithCAS;                                                                     
 var StackWithCAS._lock4334905: [StackWithCAS]Tid;                                                  
 var _casable4334846: bool;                                                                         
 var _currentValue4334995: Node;                                                                    
 var $recorded.state4335010: int;                                                                   
 var StackWithCAS._lock4334846: [StackWithCAS]Tid;                                                  
 var StackWithCAS._lock4334968: [StackWithCAS]Tid;                                                  
 var $recorded.state4334905: int;                                                                   
 var v4334892: int;                                                                                 
 var next$2544334889: Node;                                                                         
 var StackWithCAS._lock4334998: [StackWithCAS]Tid;                                                  
 var next: Node;                                                                                    
 var StackWithCAS.head_nextThread4334889: [StackWithCAS]Tid;                                        
 var nu4334905_post: Node;                                                                          
 var _C_v4334846: Node;                                                                             
 var _C_t: Tid;                                                                                     
 var Stack.head4334905_post: [Stack]Node;                                                           
 var next4334841: Node;                                                                             
 var next4334892: Node;                                                                             
 var StackWithCAS._lock4334841: [StackWithCAS]Tid;                                                  
 var tmp144334965: bool;                                                                            
 var StackWithCAS.head4335017: [StackWithCAS]Node;                                                  
 var tmp134335010: bool;                                                                            
 var moverPath4335017: MoverPath;                                                                   
 var tmp144335017: bool;                                                                            
 var StackWithCAS.head_nextValue4334998: [StackWithCAS]Node;                                        
 var Node.next4334846: [Node]Node;                                                                  
 var StackWithCAS.head4335035: [StackWithCAS]Node;                                                  
 var moverPath4335010: MoverPath;                                                                   
 var item$2544334892: int;                                                                          
 var _currentValue4334998: Node;                                                                    
 var Node.next4335035: [Node]Node;                                                                  
 var Stack.head4335035: [Stack]Node;                                                                
 var moverPath4334841: MoverPath;                                                                   
 var tmpValue: Node;                                                                                
 var _m4334968: Mover;                                                                              
 var _casable: bool;                                                                                
 var next4334995: Node;                                                                             
 var Node._state4334995: [Node]State;                                                               
 var StackWithCAS._lock4334905_post: [StackWithCAS]Tid;                                             
 var Stack.head4334972: [Stack]Node;                                                                
 var Node.next4334892: [Node]Node;                                                                  
 var tid4334972: Tid;                                                                               
 var StackWithCAS._lock4334803: [StackWithCAS]Tid;                                                  
 var nu4334965: Node;                                                                               
 var mover4334803: Mover;                                                                           
 var Node.next4334797: [Node]Node;                                                                  
 var StackWithCAS.head_nextValue4334905_post: [StackWithCAS]Node;                                   
 var next4334972: Node;                                                                             
 var Node._state4334892: [Node]State;                                                               
 var path4334803: int;                                                                              
 var $pc4335017: Phase;                                                                             
 var Node._state4335034: [Node]State;                                                               
 var Node.next4334905_post: [Node]Node;                                                             
 var nu4334995: Node;                                                                               
 var StackWithCAS.head_nextValue4334968: [StackWithCAS]Node;                                        
 var StackWithCAS.head4335034: [StackWithCAS]Node;                                                  
 var StackWithCAS.head_nextThread4334803: [StackWithCAS]Tid;                                        
 var tmp144334968: bool;                                                                            
 var StackWithCAS.head_nextThread4334791: [StackWithCAS]Tid;                                        
 var Node.next4335034_bottom: [Node]Node;                                                           
 var StackWithCAS.head_nextThread4335035: [StackWithCAS]Tid;                                        
 var tmp134334892: bool;                                                                            
 var tid4334797: Tid;                                                                               
 var Stack._state4334905_post: [Stack]State;                                                        
 var StackWithCAS.head_nextValue4334972: [StackWithCAS]Node;                                        
 var moverPath4334998: MoverPath;                                                                   
 var $recorded.state4334998: int;                                                                   
 var StackWithCAS._state4334968: [StackWithCAS]State;                                               
 var StackWithCAS._state4334905_post: [StackWithCAS]State;                                          
 var $recorded.state4335034: int;                                                                   
 var moverPath4334965: MoverPath;                                                                   
 var _C_t4334791: Tid;                                                                              
 var ctmp43134594334972: bool;                                                                      
 var tid4334846: Tid;                                                                               
 var nu4335010: Node;                                                                               
 var Stack._state4335034: [Stack]State;                                                             
 var StackWithCAS.head4334889: [StackWithCAS]Node;                                                  
 var v4334841: int;                                                                                 
 var StackWithCAS.head4334972: [StackWithCAS]Node;                                                  
 var Stack._state4334905: [Stack]State;                                                             
 var $pc4334972: Phase;                                                                             
 var moverPath4334968: MoverPath;                                                                   
 var _currentValue4334841: Node;                                                                    
 var tmp144334995: bool;                                                                            
 var _m4334965: Mover;                                                                              
 var tid4334998: Tid;                                                                               
 var moverPath4334995: MoverPath;                                                                   
 var Node._state4334846: [Node]State;                                                               
 var Node._lock4334972: [Node]Tid;                                                                  
 var tmpValue4334968: Node;                                                                         
 var Node._lock4334998: [Node]Tid;                                                                  
 var mover4334998: Mover;                                                                           
 var mover4334791: Mover;                                                                           
 var tid4335034_bottom: Tid;                                                                        
 var Node._state4334972: [Node]State;                                                               
 var StackWithCAS.head_nextValue4334791: [StackWithCAS]Node;                                        
 var _R_t4334846: Mover;                                                                            
 var v4334995: int;                                                                                 
 var this4335017: StackWithCAS;                                                                     
 var StackWithCAS.head4334968: [StackWithCAS]Node;                                                  
 var path4334995: int;                                                                              
 var phase4335034: Phase;                                                                           
 var StackWithCAS.head_nextThread4334846: [StackWithCAS]Tid;                                        
 var StackWithCAS.head_nextValue4335034_bottom: [StackWithCAS]Node;                                 
 var ctmp4313459: bool;                                                                             
 var this4334892: StackWithCAS;                                                                     
 var path4334846: int;                                                                              
 var this4334889: StackWithCAS;                                                                     
 var StackWithCAS._lock4335034_bottom: [StackWithCAS]Tid;                                           
 var Stack.head4334995: [Stack]Node;                                                                
 var tmp134334972: bool;                                                                            
 var Node.next4334841: [Node]Node;                                                                  
 var Node._state4335034_bottom: [Node]State;                                                        
 var Node._state4335017: [Node]State;                                                               
 var tmpTid4334968: Tid;                                                                            
 var Node.item4334972: [Node]int;                                                                   
 var StackWithCAS.head_nextValue4335034: [StackWithCAS]Node;                                        
 var $recorded.state4334841: int;                                                                   
 var mover4334841: Mover;                                                                           
 var Node._state4335010: [Node]State;                                                               
 var ctmp43134594335010: bool;                                                                      
 var StackWithCAS.head4334791: [StackWithCAS]Node;                                                  
 var v4334846: int;                                                                                 
 var $pc4334905_post: Phase;                                                                        
 var StackWithCAS.head_nextValue4334892: [StackWithCAS]Node;                                        
 var moverPath4334803: MoverPath;                                                                   
 var tid4335035: Tid;                                                                               
 var Stack._lock4335034_bottom: [Stack]Tid;                                                         
 var tmp134334889: bool;                                                                            
 var StackWithCAS._lock4334995: [StackWithCAS]Tid;                                                  
 var Stack._lock4334965: [Stack]Tid;                                                                
 var tmp134334968: bool;                                                                            
 var Stack.head4334803: [Stack]Node;                                                                
 var tmp144334998: bool;                                                                            
 var _C_v4334841: Node;                                                                             
 var $recorded.state4334892: int;                                                                   
 var Node._lock4334892: [Node]Tid;                                                                  
 var StackWithCAS.head_nextValue4335010: [StackWithCAS]Node;                                        
 var StackWithCAS.head_nextThread4335010: [StackWithCAS]Tid;                                        
 var Node.next4335010: [Node]Node;                                                                  
 var Stack._state4335017: [Stack]State;                                                             
 var Stack.head4334905: [Stack]Node;                                                                
 var mover4334889: Mover;                                                                           
 var StackWithCAS._state4335035: [StackWithCAS]State;                                               
 var path4334965: int;                                                                              
 var $pc4335010: Phase;                                                                             
 var Stack._lock4335010: [Stack]Tid;                                                                
 var StackWithCAS._lock4335035: [StackWithCAS]Tid;                                                  
 var Node.item4334905_post: [Node]int;                                                              
 var v4334968: int;                                                                                 
 var tid4334803: Tid;                                                                               
 var next4334846: Node;                                                                             
 var $pc4334803: Phase;                                                                             
 var this4334905: StackWithCAS;                                                                     
 var this4334797: StackWithCAS;                                                                     
 var this$2544334892: Node;                                                                         
 var StackWithCAS._state4334905: [StackWithCAS]State;                                               
 var _R_t4334841: Mover;                                                                            
 var v4335034_bottom: int;                                                                          
 var Node._lock4334889: [Node]Tid;                                                                  
 var Node.next4334995: [Node]Node;                                                                  
 var _C_v: Node;                                                                                    
 var StackWithCAS.head_nextValue4334889: [StackWithCAS]Node;                                        
 var Node._lock4334968: [Node]Tid;                                                                  
 var moverPath4334892: MoverPath;                                                                   
 var tmp134334905_post: bool;                                                                       
 var nu4334998: Node;                                                                               
 var Stack.head4335034_bottom: [Stack]Node;                                                         
 var Stack._state4335034_bottom: [Stack]State;                                                      
 var Node.next4334889: [Node]Node;                                                                  
 var Stack.head4334791: [Stack]Node;                                                                
 var mover4334965: Mover;                                                                           
 var $pc4334998: Phase;                                                                             
 var ctmp43134594335017: bool;                                                                      
 var Stack._lock4334892: [Stack]Tid;                                                                
 var StackWithCAS.head_nextThread4334892: [StackWithCAS]Tid;                                        
 var tmp134334905: bool;                                                                            
 var StackWithCAS.head_nextValue4334797: [StackWithCAS]Node;                                        
 var path4334998: int;                                                                              
 var tmpValue4334972: Node;                                                                         
 var StackWithCAS._lock4334797: [StackWithCAS]Tid;                                                  
 var Node._state4334889: [Node]State;                                                               
 var this4334995: StackWithCAS;                                                                     
 var Node._lock4335017: [Node]Tid;                                                                  
 var this4334972: StackWithCAS;                                                                     
 var Node._state4334965: [Node]State;                                                               
 var $recorded.state4334797: int;                                                                   
 var StackWithCAS._state4335010: [StackWithCAS]State;                                               
 var Node._lock4334846: [Node]Tid;                                                                  
 var Stack._state4334803: [Stack]State;                                                             
 var StackWithCAS.head4334905_post: [StackWithCAS]Node;                                             
 var Node.item4334791: [Node]int;                                                                   
 var this4334998: StackWithCAS;                                                                     
 var this$254: Node;                                                                                
 var Stack._lock4335017: [Stack]Tid;                                                                
 var $pc4335034: Phase;                                                                             
 var v4335034: int;                                                                                 
 var this4334905_post: StackWithCAS;                                                                
 var _C_t4334846: Tid;                                                                              
 var Node._lock4334797: [Node]Tid;                                                                  
 var ctmp43134594334965: bool;                                                                      
 var v4334791: int;                                                                                 
 var StackWithCAS.head_nextThread4334972: [StackWithCAS]Tid;                                        
 var StackWithCAS._state4334846: [StackWithCAS]State;                                               
 var Node.item4335034_bottom: [Node]int;                                                            
 var nu4334968: Node;                                                                               
 var Stack._state4334892: [Stack]State;                                                             
 var Node._lock4334841: [Node]Tid;                                                                  
 var v4334889: int;                                                                                 
 var path4335010: int;                                                                              
 var ctmp43134594334995: bool;                                                                      
 var Node._state4335035: [Node]State;                                                               
 var $pc4334995: Phase;                                                                             
 var _currentValue4335010: Node;                                                                    
 var _m4334972: Mover;                                                                              
 var tmp134335017: bool;                                                                            
 var StackWithCAS._lock4334972: [StackWithCAS]Tid;                                                  
 var Stack.head4334841: [Stack]Node;                                                                
 var StackWithCAS.head4335034_bottom: [StackWithCAS]Node;                                           
 var moverPath4334797: MoverPath;                                                                   
 var _currentValue4334803: Node;                                                                    
 var StackWithCAS.head_nextThread4335034_bottom: [StackWithCAS]Tid;                                 
 var nu4334892: Node;                                                                               
 var Stack._state4335035: [Stack]State;                                                             
 var StackWithCAS._lock4334892: [StackWithCAS]Tid;                                                  
 var moverPath4334846: MoverPath;                                                                   
 var Stack.head4335034: [Stack]Node;                                                                
 var StackWithCAS._state4334995: [StackWithCAS]State;                                               
 var v4334797: int;                                                                                 
 var v4334905_post: int;                                                                            
 var Node.next4334905: [Node]Node;                                                                  
 var mover4335010: Mover;                                                                           
 var nu4335017: Node;                                                                               
 var tid4335034: Tid;                                                                               
 var Stack._lock4334968: [Stack]Tid;                                                                
 var _currentValue4334846: Node;                                                                    
 var v4334998: int;                                                                                 
 var $pc4334841: Phase;                                                                             
 var $recorded.state4334905_post: int;                                                              
 var Node.item4334965: [Node]int;                                                                   
 var StackWithCAS._state4334998: [StackWithCAS]State;                                               
 var StackWithCAS._state4334892: [StackWithCAS]State;                                               
 var StackWithCAS.head4334965: [StackWithCAS]Node;                                                  
 var Stack._lock4335035: [Stack]Tid;                                                                
 var StackWithCAS._lock4335034: [StackWithCAS]Tid;                                                  
 var _m4335010: Mover;                                                                              
 var $recorded.state4334968: int;                                                                   
 var Stack.head4334846: [Stack]Node;                                                                
 var $recorded.state4334889: int;                                                                   
 var StackWithCAS._lock4335017: [StackWithCAS]Tid;                                                  
 var path4334791: int;                                                                              
 var $pc4334892: Phase;                                                                             
 var StackWithCAS._lock4334889: [StackWithCAS]Tid;                                                  
 var Node._lock4335010: [Node]Tid;                                                                  
 var tid4334968: Tid;                                                                               
 var Node._state4334797: [Node]State;                                                               
 var Node.item4335010: [Node]int;                                                                   
 var StackWithCAS._state4335034: [StackWithCAS]State;                                               
 var Stack.head4335017: [Stack]Node;                                                                
 var Stack._lock4334846: [Stack]Tid;                                                                
 var StackWithCAS._state4334889: [StackWithCAS]State;                                               
 var tid4334889: Tid;                                                                               
 var tmp134334803: bool;                                                                            
 var _currentValue: Node;                                                                           
 var tid4334995: Tid;                                                                               
 var $pc4334791: Phase;                                                                             
 var tmp134334995: bool;                                                                            
 var mover4334972: Mover;                                                                           
 var $pc4334965: Phase;                                                                             
 var Node.next4334968: [Node]Node;                                                                  
 var StackWithCAS.head4334905: [StackWithCAS]Node;                                                  
 var Stack._state4334968: [Stack]State;                                                             
 var this4334846: StackWithCAS;                                                                     
 var path4334892: int;                                                                              
 var Node._state4334841: [Node]State;                                                               
 var this4334803: StackWithCAS;                                                                     
 var _R_t: Mover;                                                                                   
 var next$254: Node;                                                                                
 var Stack._state4334995: [Stack]State;                                                             
 var tmp144334972: bool;                                                                            
 var path4334972: int;                                                                              
 var tmpTid4334965: Tid;                                                                            
 var Node._state4334968: [Node]State;                                                               
 var tid4334905_post: Tid;                                                                          
 var StackWithCAS.head_nextThread4334995: [StackWithCAS]Tid;                                        
 var Node.next4335017: [Node]Node;                                                                  
 var StackWithCAS.head_nextThread4334965: [StackWithCAS]Tid;                                        
 var _m: Mover;                                                                                     
 var moverPath4334791: MoverPath;                                                                   
 var tid4334841: Tid;                                                                               
 var this$2544334889: Node;                                                                         
 var $recorded.state4335034_bottom: int;                                                            
 var _C_v4334803: Node;                                                                             
 var Node._lock4334965: [Node]Tid;                                                                  
 var Node._lock4334905: [Node]Tid;                                                                  
 var tmp134334791: bool;                                                                            
 var tid4335010: Tid;                                                                               
 var StackWithCAS.head4334803: [StackWithCAS]Node;                                                  
 var Stack._lock4334905: [Stack]Tid;                                                                
 var moverPath4334889: MoverPath;                                                                   
 var v4334965: int;                                                                                 
 var Node.item4335017: [Node]int;                                                                   
 var next4334968: Node;                                                                             
 var next4334965: Node;                                                                             
 var StackWithCAS._state4334965: [StackWithCAS]State;                                               
 var _m4335017: Mover;                                                                              
 var this4335034_bottom: StackWithCAS;                                                              
 var next4334797: Node;                                                                             
 var next4334889: Node;                                                                             
 var next4334905_post: Node;                                                                        
 var StackWithCAS._lock4334965: [StackWithCAS]Tid;                                                  
 var StackWithCAS._lock4335010: [StackWithCAS]Tid;                                                  
 var Stack._lock4334889: [Stack]Tid;                                                                
 var StackWithCAS._lock4334791: [StackWithCAS]Tid;                                                  
 var Node.item4334995: [Node]int;                                                                   
 var StackWithCAS.head_nextThread4334841: [StackWithCAS]Tid;                                        
 var Node._lock4335034: [Node]Tid;                                                                  
 var Stack._state4334841: [Stack]State;                                                             
 var StackWithCAS._state4335017: [StackWithCAS]State;                                               
 var Stack.head4334797: [Stack]Node;                                                                
 var v4335010: int;                                                                                 
 var Stack._state4334998: [Stack]State;                                                             
 var Stack._lock4335034: [Stack]Tid;                                                                
 var Node.item4334892: [Node]int;                                                                   
 var $pc4334968: Phase;                                                                             
 var Node._state4334905_post: [Node]State;                                                          
 var Stack._state4335010: [Stack]State;                                                             
 var Stack._lock4334995: [Stack]Tid;                                                                
 var tmp144335010: bool;                                                                            
 var StackWithCAS.head_nextThread4335017: [StackWithCAS]Tid;                                        
 var nu4334972: Node;                                                                               
 var StackWithCAS.head_nextValue4334905: [StackWithCAS]Node;                                        
 var next4334803: Node;                                                                             
 var ctmp43134594334998: bool;                                                                      
 var next4335017: Node;                                                                             
 var ctmp43134594334968: bool;                                                                      
 var tid4334905: Tid;                                                                               
 var Stack.head4334889: [Stack]Node;                                                                
 var StackWithCAS.head_nextValue4334841: [StackWithCAS]Node;                                        
 var mover4334995: Mover;                                                                           
 var Stack._lock4334841: [Stack]Tid;                                                                
 var path4334841: int;                                                                              
 var StackWithCAS._state4335034_bottom: [StackWithCAS]State;                                        
 var Node.item4334905: [Node]int;                                                                   
 var path4335017: int;                                                                              
 var Stack._state4334972: [Stack]State;                                                             
 var Node._lock4334995: [Node]Tid;                                                                  
 var StackWithCAS._state4334972: [StackWithCAS]State;                                               
 var Node._lock4334803: [Node]Tid;                                                                  
 var StackWithCAS.head4335010: [StackWithCAS]Node;                                                  
 var StackWithCAS._state4334791: [StackWithCAS]State;                                               
 var v4334905: int;                                                                                 
 var StackWithCAS.head_nextValue4334965: [StackWithCAS]Node;                                        
 var Node.next4335034: [Node]Node;                                                                  
 var StackWithCAS._state4334797: [StackWithCAS]State;                                               
 var Stack._state4334846: [Stack]State;                                                             
 var tmpTid: Tid;                                                                                   
 var _C_t4334803: Tid;                                                                              
 var next4335010: Node;                                                                             
 var item$2544334889: int;                                                                          
 var next$2544334892: Node;                                                                         
 var tid4335017: Tid;                                                                               
 var StackWithCAS.head4334892: [StackWithCAS]Node;                                                  
 var Stack.head4335010: [Stack]Node;                                                                
 var Node.item4335034: [Node]int;                                                                   
 var $recorded.state4335035: int;                                                                   
 var Node.next4334972: [Node]Node;                                                                  
 var mover4334968: Mover;                                                                           
 var Stack._lock4334972: [Stack]Tid;                                                                
 var tmp14: bool;                                                                                   
 var Stack._state4334791: [Stack]State;                                                             
 var _C_t4334797: Tid;                                                                              
 var StackWithCAS.head_nextValue4334803: [StackWithCAS]Node;                                        
 var StackWithCAS.head_nextValue4334846: [StackWithCAS]Node;                                        
 var tmp134334965: bool;                                                                            
 var Stack._lock4334998: [Stack]Tid;                                                                
 var this4335010: StackWithCAS;                                                                     
 var Node._lock4335034_bottom: [Node]Tid;                                                           
 var Node.item4334841: [Node]int;                                                                   
 var tmp134334797: bool;                                                                            
 var StackWithCAS.head_nextThread4334905_post: [StackWithCAS]Tid;                                   
 var tmpTid4334972: Tid;                                                                            
 var tmp13: bool;                                                                                   
 var Node._lock4334791: [Node]Tid;                                                                  
 var $recorded.state4334846: int;                                                                   
 var v4334803: int;                                                                                 
 var Node.item4334889: [Node]int;                                                                   
 var mover4335017: Mover;                                                                           
 var _casable4334841: bool;                                                                         
 var Node._state4334803: [Node]State;                                                               
 var moverPath4334972: MoverPath;                                                                   
 var path4334889: int;                                                                              
 var mover4334892: Mover;                                                                           
 var StackWithCAS.head_nextThread4334905: [StackWithCAS]Tid;                                        
 var tmp134334846: bool;                                                                            
 var path4334968: int;                                                                              
 var $recorded.state4334791: int;                                                                   
 var v4335017: int;                                                                                 
 var next4334791: Node;                                                                             
 var $recorded.state4334972: int;                                                                   
 var StackWithCAS.head_nextThread4334797: [StackWithCAS]Tid;                                        
 var StackWithCAS.head_nextValue4334995: [StackWithCAS]Node;                                        
 var item$254: int;                                                                                 
 var Node.item4334803: [Node]int;                                                                   
 var $recorded.state4334803: int;                                                                   
 var Stack._state4334965: [Stack]State;                                                             
 var Stack._lock4334797: [Stack]Tid;                                                                
 var StackWithCAS._state4334803: [StackWithCAS]State;                                               
 var v4334972: int;                                                                                 
 var StackWithCAS.head_nextThread4334968: [StackWithCAS]Tid;                                        
 var _C_v4334797: Node;                                                                             
 var $pc4334797: Phase;                                                                             
 var tid4334791: Tid;                                                                               
 var path4334797: int;                                                                              
 var next4334905: Node;                                                                             
 var Stack.head4334968: [Stack]Node;                                                                
 var this4334841: StackWithCAS;                                                                     
 var Stack.head4334965: [Stack]Node;                                                                
 var StackWithCAS.head_nextThread4334998: [StackWithCAS]Tid;                                        
 var mover4334846: Mover;                                                                           
 var Node._lock4335035: [Node]Tid;                                                                  
 var Node.item4334797: [Node]int;                                                                   
 var tid4334892: Tid;                                                                               
 var tmp134334841: bool;                                                                            
 var _C_t4334841: Tid;                                                                              
 var Node._state4334905: [Node]State;                                                               
 var StackWithCAS.head4334846: [StackWithCAS]Node;                                                  
 var this4334791: StackWithCAS;                                                                     
 var Node.item4334968: [Node]int;                                                                   
 var nu4334905: Node;                                                                               
 var $pc4335035: Phase;                                                                             
 var Node.item4334998: [Node]int;                                                                   
 var $pc4335034_bottom: Phase;                                                                      
 var Stack.head4334892: [Stack]Node;                                                                
 var Stack.head4334998: [Stack]Node;                                                                
 var next4334998: Node;                                                                             
 var StackWithCAS.head4334995: [StackWithCAS]Node;                                                  
 var this4334965: StackWithCAS;                                                                     
 var Stack._state4334797: [Stack]State;                                                             
 var Stack._lock4334791: [Stack]Tid;                                                                
 var _currentValue4335017: Node;                                                                    
 var tid4334965: Tid;                                                                               
 var StackWithCAS.head_nextThread4335034: [StackWithCAS]Tid;                                        
 var $recorded.state4334965: int;                                                                   
 var this4335034: StackWithCAS;                                                                     
 var Stack._lock4334905_post: [Stack]Tid;                                                           
 var StackWithCAS.head_nextValue4335017: [StackWithCAS]Node;                                        
 var nu: Node;                                                                                      
 var Node.next4334791: [Node]Node;                                                                  
 var v4335035: int;                                                                                 
 var $pc4334846: Phase;                                                                             
 var $pc4334889: Phase;                                                                             
 var StackWithCAS.head4334841: [StackWithCAS]Node;                                                  
 var tmp134334998: bool;                                                                            
 var tmpValue4334965: Node;                                                                         
 var Node._state4334998: [Node]State;                                                               
 var Node.next4334998: [Node]Node;                                                                  
 var Stack._lock4334803: [Stack]Tid;                                                                
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state4335034 == Node._state && Node.item4335034 == Node.item && Node.next4335034 == Node.next && Node._lock4335034 == Node._lock && Stack._state4335034 == Stack._state && Stack.head4335034 == Stack.head && Stack._lock4335034 == Stack._lock && StackWithCAS._state4335034 == StackWithCAS._state && StackWithCAS.head4335034 == StackWithCAS.head && StackWithCAS._lock4335034 == StackWithCAS._lock && StackWithCAS.head_nextThread4335034 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335034 == StackWithCAS.head_nextValue && v4335034 == v && this4335034 == this && tid4335034 == tid;
 assume $recorded.state4335034 == 1;                                                                
                                                                                                    
 // 69.9: while (true)   {                                                                          
                                                                                                    
 phase4335034 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (68.2): Bad tid
  invariant isShared(StackWithCAS._state[this]);                                                           // (68.2): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state4335034,Node.item4335034,Node.next4335034,Node._lock4335034,Stack._state4335034,Stack.head4335034,Stack._lock4335034,StackWithCAS._state4335034,StackWithCAS.head4335034,StackWithCAS._lock4335034,StackWithCAS.head_nextThread4335034,StackWithCAS.head_nextValue4335034));       // (69.9): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state4335034,Node.item4335034,Node.next4335034,Node._lock4335034,Stack._state4335034,Stack.head4335034,Stack._lock4335034,StackWithCAS._state4335034,StackWithCAS.head4335034,StackWithCAS._lock4335034,StackWithCAS.head_nextThread4335034,StackWithCAS.head_nextValue4335034));       // (69.9): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Stack :: Invariant.Y_Stack.head(tid : Tid, _this, Stack.head[_this] ,Node._state4335034,Node.item4335034,Node.next4335034,Node._lock4335034,Stack._state4335034,Stack.head4335034,Stack._lock4335034,StackWithCAS._state4335034,StackWithCAS.head4335034,StackWithCAS._lock4335034,StackWithCAS.head_nextThread4335034,StackWithCAS.head_nextValue4335034));       // (69.9): Loop does not preserve yields_as annotation for field head
  invariant (forall _this : StackWithCAS :: Invariant.Y_StackWithCAS.head(tid : Tid, _this, StackWithCAS.head[_this] ,Node._state4335034,Node.item4335034,Node.next4335034,Node._lock4335034,Stack._state4335034,Stack.head4335034,Stack._lock4335034,StackWithCAS._state4335034,StackWithCAS.head4335034,StackWithCAS._lock4335034,StackWithCAS.head_nextThread4335034,StackWithCAS.head_nextValue4335034));       // (69.9): Loop does not preserve yields_as annotation for field head
  invariant phase4335034 == $pc;                                                                           // (69.9): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (69.9): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 69.16: boolean tmp13;                                                                          
                                                                                                    
                                                                                                    
  // 69.16: tmp13 = true;                                                                           
                                                                                                    
  tmp13 := true;                                                                                    
  if (!(tmp13)) {                                                                                   
                                                                                                    
   // 69.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 70.13: Node next;                                                                              
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 70.13: Tid _C_t;                                                                               
                                                                                                    
                                                                                                    
  // 70.13: _C_t := this.head_nextThread  as B;                                                     
                                                                                                    
                                                                                                    
  moverPath4334791 := ReadEval.StackWithCAS.head_nextThread(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
  mover4334791 := m#moverPath(moverPath4334791);                                                    
  path4334791 := p#moverPath(moverPath4334791);                                                     
  assume Node._state4334791 == Node._state && Node.item4334791 == Node.item && Node.next4334791 == Node.next && Node._lock4334791 == Node._lock && Stack._state4334791 == Stack._state && Stack.head4334791 == Stack.head && Stack._lock4334791 == Stack._lock && StackWithCAS._state4334791 == StackWithCAS._state && StackWithCAS.head4334791 == StackWithCAS.head && StackWithCAS._lock4334791 == StackWithCAS._lock && StackWithCAS.head_nextThread4334791 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334791 == StackWithCAS.head_nextValue && _C_t4334791 == _C_t && next4334791 == next && tmp134334791 == tmp13 && v4334791 == v && this4334791 == this && tid4334791 == tid && $pc4334791 == $pc;
  assume $recorded.state4334791 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != StackWithCAS.null;                                                                
  } else {                                                                                          
   assert this != StackWithCAS.null;                                                                       // (70.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (70.13): Reduction failure
  _C_t := StackWithCAS.head_nextThread[this];                                                       
                                                                                                    
  // 70.13: Node _C_v;                                                                              
                                                                                                    
                                                                                                    
  // 70.13: _C_v := this.head_nextValue  as B;                                                      
                                                                                                    
                                                                                                    
  moverPath4334797 := ReadEval.StackWithCAS.head_nextValue(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
  mover4334797 := m#moverPath(moverPath4334797);                                                    
  path4334797 := p#moverPath(moverPath4334797);                                                     
  assume Node._state4334797 == Node._state && Node.item4334797 == Node.item && Node.next4334797 == Node.next && Node._lock4334797 == Node._lock && Stack._state4334797 == Stack._state && Stack.head4334797 == Stack.head && Stack._lock4334797 == Stack._lock && StackWithCAS._state4334797 == StackWithCAS._state && StackWithCAS.head4334797 == StackWithCAS.head && StackWithCAS._lock4334797 == StackWithCAS._lock && StackWithCAS.head_nextThread4334797 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334797 == StackWithCAS.head_nextValue && _C_v4334797 == _C_v && _C_t4334797 == _C_t && next4334797 == next && tmp134334797 == tmp13 && v4334797 == v && this4334797 == this && tid4334797 == tid && $pc4334797 == $pc;
  assume $recorded.state4334797 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != StackWithCAS.null;                                                                
  } else {                                                                                          
   assert this != StackWithCAS.null;                                                                       // (70.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (70.13): Reduction failure
  _C_v := StackWithCAS.head_nextValue[this];                                                        
                                                                                                    
  // 70.13: Node _currentValue;                                                                     
                                                                                                    
                                                                                                    
  // 70.13: _currentValue := this.head  as B;                                                       
                                                                                                    
                                                                                                    
  moverPath4334803 := ReadEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
  mover4334803 := m#moverPath(moverPath4334803);                                                    
  path4334803 := p#moverPath(moverPath4334803);                                                     
  assume Node._state4334803 == Node._state && Node.item4334803 == Node.item && Node.next4334803 == Node.next && Node._lock4334803 == Node._lock && Stack._state4334803 == Stack._state && Stack.head4334803 == Stack.head && Stack._lock4334803 == Stack._lock && StackWithCAS._state4334803 == StackWithCAS._state && StackWithCAS.head4334803 == StackWithCAS.head && StackWithCAS._lock4334803 == StackWithCAS._lock && StackWithCAS.head_nextThread4334803 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334803 == StackWithCAS.head_nextValue && _currentValue4334803 == _currentValue && _C_v4334803 == _C_v && _C_t4334803 == _C_t && next4334803 == next && tmp134334803 == tmp13 && v4334803 == v && this4334803 == this && tid4334803 == tid && $pc4334803 == $pc;
  assume $recorded.state4334803 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != StackWithCAS.null;                                                                
  } else {                                                                                          
   assert this != StackWithCAS.null;                                                                       // (70.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (70.13): Reduction failure
  _currentValue := StackWithCAS.head[this];                                                         
                                                                                                    
  // 70.13: Mover _R_t;                                                                             
                                                                                                    
                                                                                                    
  // 70.13: _R_t = readPermission(this.head);                                                       
                                                                                                    
  _R_t := m#moverPath(ReadEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue));
                                                                                                    
  // 70.13: boolean _casable;                                                                       
                                                                                                    
                                                                                                    
  // 70.13: _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
                                                                                                    
  _casable := ((((_R_t!=_E)&&false)&&(_C_t==tid))&&(_C_v==_currentValue));                          
  if (_casable) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 70.13: next := this.head  as R;                                                               
                                                                                                    
                                                                                                    
   moverPath4334841 := ReadEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
   mover4334841 := m#moverPath(moverPath4334841);                                                   
   path4334841 := p#moverPath(moverPath4334841);                                                    
   assume Node._state4334841 == Node._state && Node.item4334841 == Node.item && Node.next4334841 == Node.next && Node._lock4334841 == Node._lock && Stack._state4334841 == Stack._state && Stack.head4334841 == Stack.head && Stack._lock4334841 == Stack._lock && StackWithCAS._state4334841 == StackWithCAS._state && StackWithCAS.head4334841 == StackWithCAS.head && StackWithCAS._lock4334841 == StackWithCAS._lock && StackWithCAS.head_nextThread4334841 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334841 == StackWithCAS.head_nextValue && _casable4334841 == _casable && _R_t4334841 == _R_t && _currentValue4334841 == _currentValue && _C_v4334841 == _C_v && _C_t4334841 == _C_t && next4334841 == next && tmp134334841 == tmp13 && v4334841 == v && this4334841 == this && tid4334841 == tid && $pc4334841 == $pc;
   assume $recorded.state4334841 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != StackWithCAS.null;                                                               
   } else {                                                                                         
    assert this != StackWithCAS.null;                                                                      // (70.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, _R);                                                                      
   assert $pc != PhaseError;                                                                               // (70.13): Reduction failure
   next := StackWithCAS.head[this];                                                                 
  } else {                                                                                          
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 70.13: next := this.head;                                                                     
                                                                                                    
                                                                                                    
   moverPath4334846 := ReadEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
   mover4334846 := m#moverPath(moverPath4334846);                                                   
   path4334846 := p#moverPath(moverPath4334846);                                                    
   assume Node._state4334846 == Node._state && Node.item4334846 == Node.item && Node.next4334846 == Node.next && Node._lock4334846 == Node._lock && Stack._state4334846 == Stack._state && Stack.head4334846 == Stack.head && Stack._lock4334846 == Stack._lock && StackWithCAS._state4334846 == StackWithCAS._state && StackWithCAS.head4334846 == StackWithCAS.head && StackWithCAS._lock4334846 == StackWithCAS._lock && StackWithCAS.head_nextThread4334846 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334846 == StackWithCAS.head_nextValue && _casable4334846 == _casable && _R_t4334846 == _R_t && _currentValue4334846 == _currentValue && _C_v4334846 == _C_v && _C_t4334846 == _C_t && next4334846 == next && tmp134334846 == tmp13 && v4334846 == v && this4334846 == this && tid4334846 == tid && $pc4334846 == $pc;
   assume $recorded.state4334846 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != StackWithCAS.null;                                                               
   } else {                                                                                         
    assert this != StackWithCAS.null;                                                                      // (70.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4334846);                                                            
   assert $pc != PhaseError;                                                                               // (70.13): Reduction failure
   next := StackWithCAS.head[this];                                                                 
  }                                                                                                 
                                                                                                    
  // 71.13: Node nu;                                                                                
                                                                                                    
                                                                                                    
  // 71.13: nu = new Node();                                                                        
                                                                                                    
  havoc nu;                                                                                         
  assume nu != Node.null && isFresh(Node._state[nu]);                                               
  Node._state[nu] := LOCAL(tid);                                                                    
  assume Node.item[nu]  == 0;                                                                       
  assume Node.next[nu]  == Node.null;                                                               
  assume Node._lock[nu]  == Tid.null;                                                               
  // inlined: nu.init(v,next)}                                                                      
  exit$254_top:                                                                                     
                                                                                                    
  // 71.13: int item$254;                                                                           
                                                                                                    
                                                                                                    
  // 71.13: Node next$254;                                                                          
                                                                                                    
                                                                                                    
  // 71.13: Node this$254;                                                                          
                                                                                                    
                                                                                                    
  // 71.13: item$254 = v;                                                                           
                                                                                                    
  item$254 := v;                                                                                    
                                                                                                    
  // 71.13: next$254 = next;                                                                        
                                                                                                    
  next$254 := next;                                                                                 
                                                                                                    
  // 71.13: this$254 = nu;                                                                          
                                                                                                    
  this$254 := nu;                                                                                   
                                                                                                    
  // 7.3: assume this$254.item == 0;                                                                
                                                                                                    
  assume (Node.item[this$254]==0);                                                                  
                                                                                                    
  // 7.3: assume this$254.next == Node.null;                                                        
                                                                                                    
  assume (Node.next[this$254]==Node.null);                                                          
                                                                                                    
                                                                                                    
  // 8.5: this$254.item := item$254;                                                                
                                                                                                    
                                                                                                    
  moverPath4334889 := WriteEval.Node.item(tid: Tid,this$254: Node,item$254: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
  mover4334889 := m#moverPath(moverPath4334889);                                                    
  path4334889 := p#moverPath(moverPath4334889);                                                     
  assume Node._state4334889 == Node._state && Node.item4334889 == Node.item && Node.next4334889 == Node.next && Node._lock4334889 == Node._lock && Stack._state4334889 == Stack._state && Stack.head4334889 == Stack.head && Stack._lock4334889 == Stack._lock && StackWithCAS._state4334889 == StackWithCAS._state && StackWithCAS.head4334889 == StackWithCAS.head && StackWithCAS._lock4334889 == StackWithCAS._lock && StackWithCAS.head_nextThread4334889 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334889 == StackWithCAS.head_nextValue && this$2544334889 == this$254 && next$2544334889 == next$254 && item$2544334889 == item$254 && nu4334889 == nu && next4334889 == next && tmp134334889 == tmp13 && v4334889 == v && this4334889 == this && tid4334889 == tid && $pc4334889 == $pc;
  assume $recorded.state4334889 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this$254 != Node.null;                                                                    
  } else {                                                                                          
   assert this$254 != Node.null;                                                                           // (8.5): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover4334889);                                                             
  assert $pc != PhaseError;                                                                                // (8.5): Reduction failure
  Node.item[this$254] := item$254;                                                                  
                                                                                                    
                                                                                                    
  // 9.5: this$254.next := next$254;                                                                
                                                                                                    
                                                                                                    
  moverPath4334892 := WriteEval.Node.next(tid: Tid,this$254: Node,next$254: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
  mover4334892 := m#moverPath(moverPath4334892);                                                    
  path4334892 := p#moverPath(moverPath4334892);                                                     
  assume Node._state4334892 == Node._state && Node.item4334892 == Node.item && Node.next4334892 == Node.next && Node._lock4334892 == Node._lock && Stack._state4334892 == Stack._state && Stack.head4334892 == Stack.head && Stack._lock4334892 == Stack._lock && StackWithCAS._state4334892 == StackWithCAS._state && StackWithCAS.head4334892 == StackWithCAS.head && StackWithCAS._lock4334892 == StackWithCAS._lock && StackWithCAS.head_nextThread4334892 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334892 == StackWithCAS.head_nextValue && this$2544334892 == this$254 && next$2544334892 == next$254 && item$2544334892 == item$254 && nu4334892 == nu && next4334892 == next && tmp134334892 == tmp13 && v4334892 == v && this4334892 == this && tid4334892 == tid && $pc4334892 == $pc;
  assume $recorded.state4334892 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this$254 != Node.null;                                                                    
  } else {                                                                                          
   assert this$254 != Node.null;                                                                           // (9.5): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover4334892);                                                             
  assert $pc != PhaseError;                                                                                // (9.5): Reduction failure
  Node.next[this$254] := next$254;                                                                  
  if (isLocal(Node._state[next$254], tid)) {                                                        
   Node._state[next$254] := SHARED();                                                               
   assert isSharedAssignable(Node._state[Node.next[next$254]]);                                            // (9.5): next$254 became shared, but next$254.next may not be shared.
  }                                                                                                 
                                                                                                    
                                                                                                    
  // 7.29: break exit$254;                                                                          
                                                                                                    
  goto exit$254_bottom;                                                                             
  exit$254_bottom:                                                                                  
                                                                                                    
  // 72.13: yield;                                                                                  
                                                                                                    
  assume Node._state4334905 == Node._state && Node.item4334905 == Node.item && Node.next4334905 == Node.next && Node._lock4334905 == Node._lock && Stack._state4334905 == Stack._state && Stack.head4334905 == Stack.head && Stack._lock4334905 == Stack._lock && StackWithCAS._state4334905 == StackWithCAS._state && StackWithCAS.head4334905 == StackWithCAS.head && StackWithCAS._lock4334905 == StackWithCAS._lock && StackWithCAS.head_nextThread4334905 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334905 == StackWithCAS.head_nextValue && nu4334905 == nu && next4334905 == next && tmp134334905 == tmp13 && v4334905 == v && this4334905 == this && tid4334905 == tid;
  assume $recorded.state4334905 == 1;                                                               
  call Yield(tid);                                                                                  
  $pc := PreCommit;                                                                                 
  assume Node._state4334905_post == Node._state && Node.item4334905_post == Node.item && Node.next4334905_post == Node.next && Node._lock4334905_post == Node._lock && Stack._state4334905_post == Stack._state && Stack.head4334905_post == Stack.head && Stack._lock4334905_post == Stack._lock && StackWithCAS._state4334905_post == StackWithCAS._state && StackWithCAS.head4334905_post == StackWithCAS.head && StackWithCAS._lock4334905_post == StackWithCAS._lock && StackWithCAS.head_nextThread4334905_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334905_post == StackWithCAS.head_nextValue && nu4334905_post == nu && next4334905_post == next && tmp134334905_post == tmp13 && v4334905_post == v && this4334905_post == this && tid4334905_post == tid;
  assume $recorded.state4334905_post == 1;                                                          
                                                                                                    
  // 73.13: boolean tmp14;                                                                          
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 73.13: boolean ctmp4313459;                                                                    
                                                                                                    
                                                                                                    
  // 73.13: ctmp4313459 = *;                                                                        
                                                                                                    
  havoc ctmp4313459;                                                                                
  if (ctmp4313459) {                                                                                
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 73.13: tmp14 = false;                                                                         
                                                                                                    
   tmp14 := false;                                                                                  
  } else {                                                                                          
                                                                                                    
   // 73.13: ctmp4313459 = *;                                                                       
                                                                                                    
   havoc ctmp4313459;                                                                               
   if (ctmp4313459) {                                                                               
                                                                                                    
    // 73.13: Tid tmpTid;                                                                           
                                                                                                    
                                                                                                    
    // 73.13: Node tmpValue;                                                                        
                                                                                                    
                                                                                                    
    // 73.13: Mover _m;                                                                             
                                                                                                    
                                                                                                    
    // 73.13: _m = writePermission(this.head, nu);                                                  
                                                                                                    
    _m := m#moverPath(WriteEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,nu: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue));
                                                                                                    
    // 73.13: assume this.head == next;                                                             
                                                                                                    
    assume (StackWithCAS.head[this]==next);                                                         
                                                                                                    
    // 73.13: assume !goesWrong(_m);                                                                
                                                                                                    
    assume !(transition($pc, _m) == PhaseError);                                                    
                                                                                                    
    // 73.13: assume this.head_nextThread == tid;                                                   
                                                                                                    
    assume (StackWithCAS.head_nextThread[this]==tid);                                               
                                                                                                    
    // 73.13: assume this.head_nextValue == next;                                                   
                                                                                                    
    assume (StackWithCAS.head_nextValue[this]==next);                                               
                                                                                                    
                                                                                                    
    // 73.13: this.head_nextThread := tmpTid as B;                                                  
                                                                                                    
                                                                                                    
    moverPath4334965 := WriteEval.StackWithCAS.head_nextThread(tid: Tid,this: StackWithCAS,tmpTid: Tid,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
    mover4334965 := m#moverPath(moverPath4334965);                                                  
    path4334965 := p#moverPath(moverPath4334965);                                                   
    assume Node._state4334965 == Node._state && Node.item4334965 == Node.item && Node.next4334965 == Node.next && Node._lock4334965 == Node._lock && Stack._state4334965 == Stack._state && Stack.head4334965 == Stack.head && Stack._lock4334965 == Stack._lock && StackWithCAS._state4334965 == StackWithCAS._state && StackWithCAS.head4334965 == StackWithCAS.head && StackWithCAS._lock4334965 == StackWithCAS._lock && StackWithCAS.head_nextThread4334965 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334965 == StackWithCAS.head_nextValue && _m4334965 == _m && tmpValue4334965 == tmpValue && tmpTid4334965 == tmpTid && ctmp43134594334965 == ctmp4313459 && tmp144334965 == tmp14 && nu4334965 == nu && next4334965 == next && tmp134334965 == tmp13 && v4334965 == v && this4334965 == this && tid4334965 == tid && $pc4334965 == $pc;
    assume $recorded.state4334965 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != StackWithCAS.null;                                                              
    } else {                                                                                        
     assert this != StackWithCAS.null;                                                                     // (73.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (73.13): Reduction failure
    StackWithCAS.head_nextThread[this] := tmpTid;                                                   
                                                                                                    
                                                                                                    
    // 73.13: this.head_nextValue := tmpValue as B;                                                 
                                                                                                    
                                                                                                    
    moverPath4334968 := WriteEval.StackWithCAS.head_nextValue(tid: Tid,this: StackWithCAS,tmpValue: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
    mover4334968 := m#moverPath(moverPath4334968);                                                  
    path4334968 := p#moverPath(moverPath4334968);                                                   
    assume Node._state4334968 == Node._state && Node.item4334968 == Node.item && Node.next4334968 == Node.next && Node._lock4334968 == Node._lock && Stack._state4334968 == Stack._state && Stack.head4334968 == Stack.head && Stack._lock4334968 == Stack._lock && StackWithCAS._state4334968 == StackWithCAS._state && StackWithCAS.head4334968 == StackWithCAS.head && StackWithCAS._lock4334968 == StackWithCAS._lock && StackWithCAS.head_nextThread4334968 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334968 == StackWithCAS.head_nextValue && _m4334968 == _m && tmpValue4334968 == tmpValue && tmpTid4334968 == tmpTid && ctmp43134594334968 == ctmp4313459 && tmp144334968 == tmp14 && nu4334968 == nu && next4334968 == next && tmp134334968 == tmp13 && v4334968 == v && this4334968 == this && tid4334968 == tid && $pc4334968 == $pc;
    assume $recorded.state4334968 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != StackWithCAS.null;                                                              
    } else {                                                                                        
     assert this != StackWithCAS.null;                                                                     // (73.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (73.13): Reduction failure
    StackWithCAS.head_nextValue[this] := tmpValue;                                                  
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 73.13: this.head := nu;                                                                      
                                                                                                    
                                                                                                    
    moverPath4334972 := WriteEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,nu: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
    mover4334972 := m#moverPath(moverPath4334972);                                                  
    path4334972 := p#moverPath(moverPath4334972);                                                   
    assume Node._state4334972 == Node._state && Node.item4334972 == Node.item && Node.next4334972 == Node.next && Node._lock4334972 == Node._lock && Stack._state4334972 == Stack._state && Stack.head4334972 == Stack.head && Stack._lock4334972 == Stack._lock && StackWithCAS._state4334972 == StackWithCAS._state && StackWithCAS.head4334972 == StackWithCAS.head && StackWithCAS._lock4334972 == StackWithCAS._lock && StackWithCAS.head_nextThread4334972 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334972 == StackWithCAS.head_nextValue && _m4334972 == _m && tmpValue4334972 == tmpValue && tmpTid4334972 == tmpTid && ctmp43134594334972 == ctmp4313459 && tmp144334972 == tmp14 && nu4334972 == nu && next4334972 == next && tmp134334972 == tmp13 && v4334972 == v && this4334972 == this && tid4334972 == tid && $pc4334972 == $pc;
    assume $recorded.state4334972 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != StackWithCAS.null;                                                              
    } else {                                                                                        
     assert this != StackWithCAS.null;                                                                     // (73.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover4334972);                                                           
    assert $pc != PhaseError;                                                                              // (73.13): Reduction failure
    StackWithCAS.head[this] := nu;                                                                  
    if (isLocal(Node._state[nu], tid)) {                                                            
     Node._state[nu] := SHARED();                                                                   
     assert isSharedAssignable(Node._state[Node.next[nu]]);                                                // (73.13): nu became shared, but nu.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 73.13: tmp14 = true;                                                                         
                                                                                                    
    tmp14 := true;                                                                                  
   } else {                                                                                         
                                                                                                    
    // 73.13: assume this.head_nextThread == tid;                                                   
                                                                                                    
    assume (StackWithCAS.head_nextThread[this]==tid);                                               
                                                                                                    
    // 73.13: assume this.head_nextValue == next;                                                   
                                                                                                    
    assume (StackWithCAS.head_nextValue[this]==next);                                               
                                                                                                    
    // 73.13: Node _currentValue;                                                                   
                                                                                                    
                                                                                                    
    // 73.13: _currentValue := this.head  as B;                                                     
                                                                                                    
                                                                                                    
    moverPath4334995 := ReadEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
    mover4334995 := m#moverPath(moverPath4334995);                                                  
    path4334995 := p#moverPath(moverPath4334995);                                                   
    assume Node._state4334995 == Node._state && Node.item4334995 == Node.item && Node.next4334995 == Node.next && Node._lock4334995 == Node._lock && Stack._state4334995 == Stack._state && Stack.head4334995 == Stack.head && Stack._lock4334995 == Stack._lock && StackWithCAS._state4334995 == StackWithCAS._state && StackWithCAS.head4334995 == StackWithCAS.head && StackWithCAS._lock4334995 == StackWithCAS._lock && StackWithCAS.head_nextThread4334995 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334995 == StackWithCAS.head_nextValue && _currentValue4334995 == _currentValue && ctmp43134594334995 == ctmp4313459 && tmp144334995 == tmp14 && nu4334995 == nu && next4334995 == next && tmp134334995 == tmp13 && v4334995 == v && this4334995 == this && tid4334995 == tid && $pc4334995 == $pc;
    assume $recorded.state4334995 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != StackWithCAS.null;                                                              
    } else {                                                                                        
     assert this != StackWithCAS.null;                                                                     // (73.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
                                                                                                    
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (73.13): Reduction failure
    _currentValue := StackWithCAS.head[this];                                                       
                                                                                                    
                                                                                                    
    // 73.13: this.head := next as B;                                                               
                                                                                                    
                                                                                                    
    moverPath4334998 := WriteEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,next: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
    mover4334998 := m#moverPath(moverPath4334998);                                                  
    path4334998 := p#moverPath(moverPath4334998);                                                   
    assume Node._state4334998 == Node._state && Node.item4334998 == Node.item && Node.next4334998 == Node.next && Node._lock4334998 == Node._lock && Stack._state4334998 == Stack._state && Stack.head4334998 == Stack.head && Stack._lock4334998 == Stack._lock && StackWithCAS._state4334998 == StackWithCAS._state && StackWithCAS.head4334998 == StackWithCAS.head && StackWithCAS._lock4334998 == StackWithCAS._lock && StackWithCAS.head_nextThread4334998 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4334998 == StackWithCAS.head_nextValue && _currentValue4334998 == _currentValue && ctmp43134594334998 == ctmp4313459 && tmp144334998 == tmp14 && nu4334998 == nu && next4334998 == next && tmp134334998 == tmp13 && v4334998 == v && this4334998 == this && tid4334998 == tid && $pc4334998 == $pc;
    assume $recorded.state4334998 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != StackWithCAS.null;                                                              
    } else {                                                                                        
     assert this != StackWithCAS.null;                                                                     // (73.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (73.13): Reduction failure
    StackWithCAS.head[this] := next;                                                                
    if (isLocal(Node._state[next], tid)) {                                                          
     Node._state[next] := SHARED();                                                                 
     assert isSharedAssignable(Node._state[Node.next[next]]);                                              // (73.13): next became shared, but next.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 73.13: Mover _m;                                                                             
                                                                                                    
                                                                                                    
    // 73.13: _m = writePermission(this.head, nu);                                                  
                                                                                                    
    _m := m#moverPath(WriteEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,nu: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue));
                                                                                                    
                                                                                                    
    // 73.13: this.head := _currentValue as B;                                                      
                                                                                                    
                                                                                                    
    moverPath4335010 := WriteEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,_currentValue: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
    mover4335010 := m#moverPath(moverPath4335010);                                                  
    path4335010 := p#moverPath(moverPath4335010);                                                   
    assume Node._state4335010 == Node._state && Node.item4335010 == Node.item && Node.next4335010 == Node.next && Node._lock4335010 == Node._lock && Stack._state4335010 == Stack._state && Stack.head4335010 == Stack.head && Stack._lock4335010 == Stack._lock && StackWithCAS._state4335010 == StackWithCAS._state && StackWithCAS.head4335010 == StackWithCAS.head && StackWithCAS._lock4335010 == StackWithCAS._lock && StackWithCAS.head_nextThread4335010 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335010 == StackWithCAS.head_nextValue && _m4335010 == _m && _currentValue4335010 == _currentValue && ctmp43134594335010 == ctmp4313459 && tmp144335010 == tmp14 && nu4335010 == nu && next4335010 == next && tmp134335010 == tmp13 && v4335010 == v && this4335010 == this && tid4335010 == tid && $pc4335010 == $pc;
    assume $recorded.state4335010 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != StackWithCAS.null;                                                              
    } else {                                                                                        
     assert this != StackWithCAS.null;                                                                     // (73.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (73.13): Reduction failure
    StackWithCAS.head[this] := _currentValue;                                                       
    if (isLocal(Node._state[_currentValue], tid)) {                                                 
     Node._state[_currentValue] := SHARED();                                                        
     assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                     // (73.13): _currentValue became shared, but _currentValue.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 73.13: assume goesWrong(_m);                                                                 
                                                                                                    
    assume transition($pc, _m) == PhaseError;                                                       
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 73.13: this.head := nu;                                                                      
                                                                                                    
                                                                                                    
    moverPath4335017 := WriteEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,nu: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
    mover4335017 := m#moverPath(moverPath4335017);                                                  
    path4335017 := p#moverPath(moverPath4335017);                                                   
    assume Node._state4335017 == Node._state && Node.item4335017 == Node.item && Node.next4335017 == Node.next && Node._lock4335017 == Node._lock && Stack._state4335017 == Stack._state && Stack.head4335017 == Stack.head && Stack._lock4335017 == Stack._lock && StackWithCAS._state4335017 == StackWithCAS._state && StackWithCAS.head4335017 == StackWithCAS.head && StackWithCAS._lock4335017 == StackWithCAS._lock && StackWithCAS.head_nextThread4335017 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335017 == StackWithCAS.head_nextValue && _m4335017 == _m && _currentValue4335017 == _currentValue && ctmp43134594335017 == ctmp4313459 && tmp144335017 == tmp14 && nu4335017 == nu && next4335017 == next && tmp134335017 == tmp13 && v4335017 == v && this4335017 == this && tid4335017 == tid && $pc4335017 == $pc;
    assume $recorded.state4335017 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != StackWithCAS.null;                                                              
    } else {                                                                                        
     assert this != StackWithCAS.null;                                                                     // (73.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover4335017);                                                           
    assert $pc != PhaseError;                                                                              // (73.13): Reduction failure
    StackWithCAS.head[this] := nu;                                                                  
    if (isLocal(Node._state[nu], tid)) {                                                            
     Node._state[nu] := SHARED();                                                                   
     assert isSharedAssignable(Node._state[Node.next[nu]]);                                                // (73.13): nu became shared, but nu.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 73.13: tmp14 = false;                                                                        
                                                                                                    
    tmp14 := false;                                                                                 
   }                                                                                                
  }                                                                                                 
  if (tmp14) {                                                                                      
                                                                                                    
   // 74.15: break;                                                                                 
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
  assume Node._state4335034_bottom == Node._state && Node.item4335034_bottom == Node.item && Node.next4335034_bottom == Node.next && Node._lock4335034_bottom == Node._lock && Stack._state4335034_bottom == Stack._state && Stack.head4335034_bottom == Stack.head && Stack._lock4335034_bottom == Stack._lock && StackWithCAS._state4335034_bottom == StackWithCAS._state && StackWithCAS.head4335034_bottom == StackWithCAS.head && StackWithCAS._lock4335034_bottom == StackWithCAS._lock && StackWithCAS.head_nextThread4335034_bottom == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335034_bottom == StackWithCAS.head_nextValue && v4335034_bottom == v && this4335034_bottom == this && tid4335034_bottom == tid;
  assume $recorded.state4335034_bottom == 1;                                                        
  assert phase4335034 == $pc;                                                                              // (69.9): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 68.26: // return;                                                                               
                                                                                                    
 assume Node._state4335035 == Node._state && Node.item4335035 == Node.item && Node.next4335035 == Node.next && Node._lock4335035 == Node._lock && Stack._state4335035 == Stack._state && Stack.head4335035 == Stack.head && Stack._lock4335035 == Stack._lock && StackWithCAS._state4335035 == StackWithCAS._state && StackWithCAS.head4335035 == StackWithCAS.head && StackWithCAS._lock4335035 == StackWithCAS._lock && StackWithCAS.head_nextThread4335035 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335035 == StackWithCAS.head_nextValue && v4335035 == v && this4335035 == this && tid4335035 == tid;
 assume $recorded.state4335035 == 1;                                                                
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  StackWithCAS.pop(tid:Tid, this : StackWithCAS)                                           
returns ($result : int)                                                                             
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Stack._state;                                                                              
modifies Stack.head;                                                                                
modifies Stack._lock;                                                                               
modifies StackWithCAS._state;                                                                       
modifies StackWithCAS.head;                                                                         
modifies StackWithCAS._lock;                                                                        
modifies StackWithCAS.head_nextThread;                                                              
modifies StackWithCAS.head_nextValue;                                                               
                                                                                                    
requires ValidTid(tid);                                                                                    // (79.2): Bad tid
requires isShared(StackWithCAS._state[this]);                                                              // (79.2): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
{                                                                                                   
 var this4335065: StackWithCAS;                                                                     
 var Stack.head4335262: [Stack]Node;                                                                
 var $result4335198: int;                                                                           
 var $pc4335272_post: Phase;                                                                        
 var _R_t4335114: Mover;                                                                            
 var mover4335195: Mover;                                                                           
 var Node._lock4335275_bottom: [Node]Tid;                                                           
 var StackWithCAS.head_nextThread4335272: [StackWithCAS]Tid;                                        
 var StackWithCAS._lock4335278: [StackWithCAS]Tid;                                                  
 var StackWithCAS.head4335278: [StackWithCAS]Node;                                                  
 var Stack._lock4335065: [Stack]Tid;                                                                
 var $result4335135: int;                                                                           
 var moverPath4335198: MoverPath;                                                                   
 var path4335059: int;                                                                              
 var Stack._lock4335275_bottom: [Stack]Tid;                                                         
 var _casable4335109: bool;                                                                         
 var Stack._lock4335059: [Stack]Tid;                                                                
 var StackWithCAS._lock4335118: [StackWithCAS]Tid;                                                  
 var Stack.head4335195: [Stack]Node;                                                                
 var StackWithCAS.head_nextValue4335198: [StackWithCAS]Node;                                        
 var StackWithCAS._lock4335065: [StackWithCAS]Tid;                                                  
 var StackWithCAS._state4335059: [StackWithCAS]State;                                               
 var StackWithCAS.head_nextValue4335240: [StackWithCAS]Node;                                        
 var tid4335240: Tid;                                                                               
 var top4335264: Node;                                                                              
 var path4335109: int;                                                                              
 var $recorded.state4335247: int;                                                                   
 var $recorded.state4335065: int;                                                                   
 var Node._lock4335135: [Node]Tid;                                                                  
 var Stack.head4335065: [Stack]Node;                                                                
 var tmp154335240: bool;                                                                            
 var Node.item4335109: [Node]int;                                                                   
 var path4335198: int;                                                                              
 var path4335195: int;                                                                              
 var next: Node;                                                                                    
 var _casable4335114: bool;                                                                         
 var _C_t: Tid;                                                                                     
 var Stack._lock4335202: [Stack]Tid;                                                                
 var ctmp43135514335202: bool;                                                                      
 var tid4335264: Tid;                                                                               
 var Stack.head4335240: [Stack]Node;                                                                
 var tmp164335247: bool;                                                                            
 var _currentValue4335071: Node;                                                                    
 var StackWithCAS._lock4335118_post: [StackWithCAS]Tid;                                             
 var $result4335275: int;                                                                           
 var $pc4335262: Phase;                                                                             
 var StackWithCAS._state4335240: [StackWithCAS]State;                                               
 var $pc4335247: Phase;                                                                             
 var StackWithCAS._lock4335202: [StackWithCAS]Tid;                                                  
 var Node._state4335264: [Node]State;                                                               
 var Stack.head4335118_post: [Stack]Node;                                                           
 var StackWithCAS._lock4335071: [StackWithCAS]Tid;                                                  
 var StackWithCAS.head_nextValue4335247: [StackWithCAS]Node;                                        
 var tmp154335202: bool;                                                                            
 var $result4335114: int;                                                                           
 var StackWithCAS.head4335109: [StackWithCAS]Node;                                                  
 var this4335135: StackWithCAS;                                                                     
 var $pc4335114: Phase;                                                                             
 var Node.next4335202: [Node]Node;                                                                  
 var tid4335135: Tid;                                                                               
 var Stack._state4335264: [Stack]State;                                                             
 var StackWithCAS.head_nextValue4335225: [StackWithCAS]Node;                                        
 var tid4335275_bottom: Tid;                                                                        
 var _C_t4335059: Tid;                                                                              
 var Node._lock4335240: [Node]Tid;                                                                  
 var Node.item4335135: [Node]int;                                                                   
 var $recorded.state4335109: int;                                                                   
 var Node._lock4335228: [Node]Tid;                                                                  
 var Stack._lock4335278: [Stack]Tid;                                                                
 var this4335202: StackWithCAS;                                                                     
 var StackWithCAS.head_nextValue4335262: [StackWithCAS]Node;                                        
 var _C_v4335071: Node;                                                                             
 var Node._lock4335278: [Node]Tid;                                                                  
 var tid4335272: Tid;                                                                               
 var StackWithCAS._lock4335240: [StackWithCAS]Tid;                                                  
 var $recorded.state4335198: int;                                                                   
 var tmpValue: Node;                                                                                
 var _casable: bool;                                                                                
 var top4335065: Node;                                                                              
 var $recorded.state4335272_post: int;                                                              
 var _C_v4335065: Node;                                                                             
 var Node._lock4335071: [Node]Tid;                                                                  
 var moverPath4335262: MoverPath;                                                                   
 var tmpValue4335195: Node;                                                                         
 var Node._state4335225: [Node]State;                                                               
 var StackWithCAS.head4335275_bottom: [StackWithCAS]Node;                                           
 var _currentValue4335240: Node;                                                                    
 var StackWithCAS.head4335264: [StackWithCAS]Node;                                                  
 var $result4335118: int;                                                                           
 var Stack._lock4335118: [Stack]Tid;                                                                
 var next4335135: Node;                                                                             
 var $result4335071: int;                                                                           
 var mover4335071: Mover;                                                                           
 var Stack._state4335118: [Stack]State;                                                             
 var this4335272_post: StackWithCAS;                                                                
 var StackWithCAS._state4335225: [StackWithCAS]State;                                               
 var Node.item4335202: [Node]int;                                                                   
 var StackWithCAS._state4335118: [StackWithCAS]State;                                               
 var StackWithCAS.head_nextThread4335275_bottom: [StackWithCAS]Tid;                                 
 var Stack.head4335225: [Stack]Node;                                                                
 var StackWithCAS._state4335272: [StackWithCAS]State;                                               
 var tmp154335272: bool;                                                                            
 var Stack.head4335202: [Stack]Node;                                                                
 var StackWithCAS._state4335118_post: [StackWithCAS]State;                                          
 var StackWithCAS.head4335118_post: [StackWithCAS]Node;                                             
 var Stack.head4335118: [Stack]Node;                                                                
 var _currentValue4335225: Node;                                                                    
 var tid4335228: Tid;                                                                               
 var top4335240: Node;                                                                              
 var Node._state4335109: [Node]State;                                                               
 var StackWithCAS.head4335228: [StackWithCAS]Node;                                                  
 var tmp154335065: bool;                                                                            
 var Stack._lock4335272_post: [Stack]Tid;                                                           
 var StackWithCAS.head_nextThread4335135: [StackWithCAS]Tid;                                        
 var $pc4335118: Phase;                                                                             
 var path4335228: int;                                                                              
 var mover4335135: Mover;                                                                           
 var _m4335240: Mover;                                                                              
 var mover4335065: Mover;                                                                           
 var Stack.head4335198: [Stack]Node;                                                                
 var mover4335225: Mover;                                                                           
 var Stack._lock4335114: [Stack]Tid;                                                                
 var tmp164335228: bool;                                                                            
 var tid4335114: Tid;                                                                               
 var tmp16: bool;                                                                                   
 var Node._state4335114: [Node]State;                                                               
 var Stack.head4335109: [Stack]Node;                                                                
 var tid4335118: Tid;                                                                               
 var moverPath4335195: MoverPath;                                                                   
 var Stack.head4335228: [Stack]Node;                                                                
 var tmp154335228: bool;                                                                            
 var _C_v4335109: Node;                                                                             
 var _m4335198: Mover;                                                                              
 var tmp154335109: bool;                                                                            
 var StackWithCAS.head_nextValue4335228: [StackWithCAS]Node;                                        
 var this4335195: StackWithCAS;                                                                     
 var tmp174335264: bool;                                                                            
 var tmpValue4335198: Node;                                                                         
 var Node.item4335247: [Node]int;                                                                   
 var top4335262: Node;                                                                              
 var path4335071: int;                                                                              
 var StackWithCAS.head4335065: [StackWithCAS]Node;                                                  
 var mover4335262: Mover;                                                                           
 var Stack.head4335272_post: [Stack]Node;                                                           
 var StackWithCAS.head_nextValue4335278: [StackWithCAS]Node;                                        
 var moverPath4335225: MoverPath;                                                                   
 var top4335109: Node;                                                                              
 var path4335202: int;                                                                              
 var StackWithCAS.head4335240: [StackWithCAS]Node;                                                  
 var Node.item4335272: [Node]int;                                                                   
 var this4335247: StackWithCAS;                                                                     
 var $result4335247: int;                                                                           
 var this4335225: StackWithCAS;                                                                     
 var $result4335240: int;                                                                           
 var $recorded.state4335118: int;                                                                   
 var Stack.head4335247: [Stack]Node;                                                                
 var ctmp43135514335225: bool;                                                                      
 var Node._lock4335275: [Node]Tid;                                                                  
 var StackWithCAS.head4335195: [StackWithCAS]Node;                                                  
 var tmp164335240: bool;                                                                            
 var Stack._lock4335275: [Stack]Tid;                                                                
 var $result4335202: int;                                                                           
 var StackWithCAS.head_nextThread4335195: [StackWithCAS]Tid;                                        
 var top4335118: Node;                                                                              
 var mover4335198: Mover;                                                                           
 var Stack.head4335278: [Stack]Node;                                                                
 var StackWithCAS._state4335202: [StackWithCAS]State;                                               
 var next4335247: Node;                                                                             
 var tmp164335198: bool;                                                                            
 var StackWithCAS.head4335262: [StackWithCAS]Node;                                                  
 var StackWithCAS.head_nextValue4335264: [StackWithCAS]Node;                                        
 var $result4335264: int;                                                                           
 var $pc4335275_bottom: Phase;                                                                      
 var Stack.head4335071: [Stack]Node;                                                                
 var top4335247: Node;                                                                              
 var StackWithCAS._lock4335195: [StackWithCAS]Tid;                                                  
 var StackWithCAS._state4335278: [StackWithCAS]State;                                               
 var Stack._lock4335109: [Stack]Tid;                                                                
 var Node.item4335065: [Node]int;                                                                   
 var $recorded.state4335240: int;                                                                   
 var StackWithCAS.head_nextValue4335118: [StackWithCAS]Node;                                        
 var StackWithCAS.head_nextThread4335118: [StackWithCAS]Tid;                                        
 var StackWithCAS._state4335109: [StackWithCAS]State;                                               
 var tid4335195: Tid;                                                                               
 var mover4335059: Mover;                                                                           
 var Stack._state4335275: [Stack]State;                                                             
 var mover4335240: Mover;                                                                           
 var StackWithCAS.head_nextThread4335114: [StackWithCAS]Tid;                                        
 var Node._state4335195: [Node]State;                                                               
 var ctmp43135514335240: bool;                                                                      
 var tmp164335202: bool;                                                                            
 var this4335228: StackWithCAS;                                                                     
 var ctmp4313551: bool;                                                                             
 var _C_t4335065: Tid;                                                                              
 var moverPath4335114: MoverPath;                                                                   
 var Stack.head4335135: [Stack]Node;                                                                
 var tid4335247: Tid;                                                                               
 var tmp164335195: bool;                                                                            
 var mover4335247: Mover;                                                                           
 var Node._lock4335118_post: [Node]Tid;                                                             
 var $recorded.state4335275: int;                                                                   
 var path4335247: int;                                                                              
 var _currentValue4335247: Node;                                                                    
 var $result4335262: int;                                                                           
 var mover4335109: Mover;                                                                           
 var tmp154335118: bool;                                                                            
 var Node.next4335272_post: [Node]Node;                                                             
 var Stack._lock4335071: [Stack]Tid;                                                                
 var tmp154335195: bool;                                                                            
 var tid4335262: Tid;                                                                               
 var tmp154335262: bool;                                                                            
 var top4335114: Node;                                                                              
 var StackWithCAS.head4335114: [StackWithCAS]Node;                                                  
 var StackWithCAS.head_nextValue4335071: [StackWithCAS]Node;                                        
 var Stack._state4335195: [Stack]State;                                                             
 var _C_v: Node;                                                                                    
 var Node.next4335264: [Node]Node;                                                                  
 var StackWithCAS.head_nextValue4335272_post: [StackWithCAS]Node;                                   
 var tid4335118_post: Tid;                                                                          
 var Stack._state4335228: [Stack]State;                                                             
 var tmp164335272_post: bool;                                                                       
 var Node.next4335275: [Node]Node;                                                                  
 var Stack._state4335109: [Stack]State;                                                             
 var tid4335071: Tid;                                                                               
 var Node.item4335272_post: [Node]int;                                                              
 var Node.item4335264: [Node]int;                                                                   
 var $recorded.state4335272: int;                                                                   
 var $pc4335272: Phase;                                                                             
 var StackWithCAS.head_nextValue4335065: [StackWithCAS]Node;                                        
 var tmp154335071: bool;                                                                            
 var StackWithCAS.head_nextThread4335262: [StackWithCAS]Tid;                                        
 var StackWithCAS.head_nextValue4335135: [StackWithCAS]Node;                                        
 var StackWithCAS.head_nextValue4335114: [StackWithCAS]Node;                                        
 var $result4335118_post: int;                                                                      
 var this4335109: StackWithCAS;                                                                     
 var tmp154335118_post: bool;                                                                       
 var Node.next4335195: [Node]Node;                                                                  
 var Node.item4335225: [Node]int;                                                                   
 var Stack._state4335118_post: [Stack]State;                                                        
 var Stack._state4335240: [Stack]State;                                                             
 var Stack._state4335202: [Stack]State;                                                             
 var tmp164335264: bool;                                                                            
 var tmp174335202: bool;                                                                            
 var Node._state4335228: [Node]State;                                                               
 var StackWithCAS._lock4335264: [StackWithCAS]Tid;                                                  
 var tmp164335262: bool;                                                                            
 var StackWithCAS._state4335247: [StackWithCAS]State;                                               
 var StackWithCAS.head4335071: [StackWithCAS]Node;                                                  
 var this4335118_post: StackWithCAS;                                                                
 var StackWithCAS.head_nextThread4335275: [StackWithCAS]Tid;                                        
 var Node._lock4335247: [Node]Tid;                                                                  
 var next4335240: Node;                                                                             
 var $result4335272_post: int;                                                                      
 var StackWithCAS.head_nextThread4335118_post: [StackWithCAS]Tid;                                   
 var top4335059: Node;                                                                              
 var $pc4335228: Phase;                                                                             
 var $result4335275_bottom: int;                                                                    
 var $recorded.state4335059: int;                                                                   
 var Stack._lock4335135: [Stack]Tid;                                                                
 var Stack._lock4335225: [Stack]Tid;                                                                
 var Stack._lock4335247: [Stack]Tid;                                                                
 var Node.next4335240: [Node]Node;                                                                  
 var _m4335195: Mover;                                                                              
 var this4335118: StackWithCAS;                                                                     
 var tmp154335264: bool;                                                                            
 var tmp154335272_post: bool;                                                                       
 var Stack._lock4335240: [Stack]Tid;                                                                
 var Node.item4335059: [Node]int;                                                                   
 var Node.next4335262: [Node]Node;                                                                  
 var path4335262: int;                                                                              
 var Stack._lock4335264: [Stack]Tid;                                                                
 var tmp164335135: bool;                                                                            
 var Stack.head4335264: [Stack]Node;                                                                
 var path4335114: int;                                                                              
 var StackWithCAS.head_nextThread4335247: [StackWithCAS]Tid;                                        
 var StackWithCAS.head_nextThread4335225: [StackWithCAS]Tid;                                        
 var _currentValue4335109: Node;                                                                    
 var $result4335065: int;                                                                           
 var StackWithCAS.head_nextValue4335272: [StackWithCAS]Node;                                        
 var this4335071: StackWithCAS;                                                                     
 var Stack.head4335272: [Stack]Node;                                                                
 var Stack._lock4335228: [Stack]Tid;                                                                
 var Stack._state4335071: [Stack]State;                                                             
 var this4335264: StackWithCAS;                                                                     
 var StackWithCAS.head_nextValue4335118_post: [StackWithCAS]Node;                                   
 var moverPath4335065: MoverPath;                                                                   
 var StackWithCAS._state4335275_bottom: [StackWithCAS]State;                                        
 var moverPath4335135: MoverPath;                                                                   
 var next4335198: Node;                                                                             
 var StackWithCAS._lock4335228: [StackWithCAS]Tid;                                                  
 var $recorded.state4335225: int;                                                                   
 var tmp18: int;                                                                                    
 var StackWithCAS._lock4335272_post: [StackWithCAS]Tid;                                             
 var $pc4335198: Phase;                                                                             
 var Stack._state4335065: [Stack]State;                                                             
 var Stack._state4335114: [Stack]State;                                                             
 var path4335225: int;                                                                              
 var Node._state4335272: [Node]State;                                                               
 var _currentValue4335228: Node;                                                                    
 var StackWithCAS.head4335272_post: [StackWithCAS]Node;                                             
 var tmp15: bool;                                                                                   
 var StackWithCAS._state4335065: [StackWithCAS]State;                                               
 var top4335202: Node;                                                                              
 var Node._lock4335202: [Node]Tid;                                                                  
 var tid4335275: Tid;                                                                               
 var tmp174335198: bool;                                                                            
 var Node.next4335071: [Node]Node;                                                                  
 var Node._state4335059: [Node]State;                                                               
 var $pc4335118_post: Phase;                                                                        
 var Node._state4335118_post: [Node]State;                                                          
 var Node._lock4335109: [Node]Tid;                                                                  
 var $recorded.state4335264: int;                                                                   
 var Stack._state4335225: [Stack]State;                                                             
 var Node.next4335225: [Node]Node;                                                                  
 var Node._state4335065: [Node]State;                                                               
 var Node._lock4335272: [Node]Tid;                                                                  
 var Node._lock4335118: [Node]Tid;                                                                  
 var mover4335228: Mover;                                                                           
 var Stack._state4335272_post: [Stack]State;                                                        
 var $result4335195: int;                                                                           
 var Stack.head4335275_bottom: [Stack]Node;                                                         
 var Node.next4335118_post: [Node]Node;                                                             
 var tid4335272_post: Tid;                                                                          
 var tmp154335135: bool;                                                                            
 var StackWithCAS.head_nextValue4335202: [StackWithCAS]Node;                                        
 var top4335272: Node;                                                                              
 var StackWithCAS._lock4335059: [StackWithCAS]Tid;                                                  
 var Stack._lock4335272: [Stack]Tid;                                                                
 var Stack._lock4335195: [Stack]Tid;                                                                
 var Stack.head4335114: [Stack]Node;                                                                
 var StackWithCAS.head_nextThread4335278: [StackWithCAS]Tid;                                        
 var Node.item4335114: [Node]int;                                                                   
 var top4335225: Node;                                                                              
 var Node.next4335272: [Node]Node;                                                                  
 var $pc4335135: Phase;                                                                             
 var $pc4335071: Phase;                                                                             
 var $pc4335275: Phase;                                                                             
 var Node.item4335195: [Node]int;                                                                   
 var Stack._state4335275_bottom: [Stack]State;                                                      
 var Stack._state4335272: [Stack]State;                                                             
 var _currentValue: Node;                                                                           
 var StackWithCAS.head_nextThread4335198: [StackWithCAS]Tid;                                        
 var Node.item4335278: [Node]int;                                                                   
 var StackWithCAS.head4335059: [StackWithCAS]Node;                                                  
 var moverPath4335059: MoverPath;                                                                   
 var ctmp43135514335198: bool;                                                                      
 var ctmp43135514335228: bool;                                                                      
 var StackWithCAS.head4335118: [StackWithCAS]Node;                                                  
 var StackWithCAS.head_nextThread4335240: [StackWithCAS]Tid;                                        
 var Node.next4335114: [Node]Node;                                                                  
 var _C_v4335114: Node;                                                                             
 var _R_t: Mover;                                                                                   
 var StackWithCAS.head4335135: [StackWithCAS]Node;                                                  
 var StackWithCAS.head_nextValue4335109: [StackWithCAS]Node;                                        
 var next4335225: Node;                                                                             
 var top4335272_post: Node;                                                                         
 var Stack._state4335135: [Stack]State;                                                             
 var tmp174335225: bool;                                                                            
 var moverPath4335202: MoverPath;                                                                   
 var Stack._lock4335262: [Stack]Tid;                                                                
 var $result4335225: int;                                                                           
 var StackWithCAS._lock4335275_bottom: [StackWithCAS]Tid;                                           
 var StackWithCAS._state4335071: [StackWithCAS]State;                                               
 var Node.next4335118: [Node]Node;                                                                  
 var tid4335198: Tid;                                                                               
 var _m: Mover;                                                                                     
 var _C_t4335109: Tid;                                                                              
 var Stack._state4335247: [Stack]State;                                                             
 var Stack._state4335262: [Stack]State;                                                             
 var moverPath4335228: MoverPath;                                                                   
 var $recorded.state4335278: int;                                                                   
 var Node.next4335275_bottom: [Node]Node;                                                           
 var this4335240: StackWithCAS;                                                                     
 var tmpTid4335195: Tid;                                                                            
 var Node.item4335071: [Node]int;                                                                   
 var StackWithCAS.head4335202: [StackWithCAS]Node;                                                  
 var Node._state4335071: [Node]State;                                                               
 var tid4335278: Tid;                                                                               
 var StackWithCAS._lock4335114: [StackWithCAS]Tid;                                                  
 var top4335195: Node;                                                                              
 var StackWithCAS._lock4335262: [StackWithCAS]Tid;                                                  
 var StackWithCAS.head_nextThread4335059: [StackWithCAS]Tid;                                        
 var top4335071: Node;                                                                              
 var Stack._lock4335118_post: [Stack]Tid;                                                           
 var StackWithCAS.head_nextThread4335071: [StackWithCAS]Tid;                                        
 var next4335202: Node;                                                                             
 var Node._state4335275_bottom: [Node]State;                                                        
 var Node.next4335135: [Node]Node;                                                                  
 var this4335262: StackWithCAS;                                                                     
 var tmp174335247: bool;                                                                            
 var tmp174335262: bool;                                                                            
 var StackWithCAS._state4335195: [StackWithCAS]State;                                               
 var Node._state4335262: [Node]State;                                                               
 var Node._lock4335225: [Node]Tid;                                                                  
 var Stack._state4335198: [Stack]State;                                                             
 var tmp184335262: int;                                                                             
 var _m4335247: Mover;                                                                              
 var _R_t4335109: Mover;                                                                            
 var Node.next4335059: [Node]Node;                                                                  
 var tid4335065: Tid;                                                                               
 var Node.item4335262: [Node]int;                                                                   
 var Node._state4335278: [Node]State;                                                               
 var next4335228: Node;                                                                             
 var StackWithCAS._lock4335109: [StackWithCAS]Tid;                                                  
 var $recorded.state4335262: int;                                                                   
 var StackWithCAS._lock4335275: [StackWithCAS]Tid;                                                  
 var Node.next4335109: [Node]Node;                                                                  
 var tid4335202: Tid;                                                                               
 var $pc4335278: Phase;                                                                             
 var $result4335109: int;                                                                           
 var $recorded.state4335114: int;                                                                   
 var tmp154335114: bool;                                                                            
 var this4335114: StackWithCAS;                                                                     
 var _currentValue4335114: Node;                                                                    
 var $result4335272: int;                                                                           
 var this4335272: StackWithCAS;                                                                     
 var Node.next4335228: [Node]Node;                                                                  
 var Node.next4335065: [Node]Node;                                                                  
 var tmp184335264: int;                                                                             
 var mover4335202: Mover;                                                                           
 var StackWithCAS.head_nextValue4335059: [StackWithCAS]Node;                                        
 var this4335275_bottom: StackWithCAS;                                                              
 var StackWithCAS._state4335114: [StackWithCAS]State;                                               
 var tmp154335198: bool;                                                                            
 var Node.item4335118_post: [Node]int;                                                              
 var StackWithCAS._state4335135: [StackWithCAS]State;                                               
 var Node._state4335272_post: [Node]State;                                                          
 var Stack._lock4335198: [Stack]Tid;                                                                
 var Node._state4335118: [Node]State;                                                               
 var Node.item4335275_bottom: [Node]int;                                                            
 var this4335198: StackWithCAS;                                                                     
 var tmpValue4335202: Node;                                                                         
 var tmp174335240: bool;                                                                            
 var StackWithCAS._lock4335247: [StackWithCAS]Tid;                                                  
 var ctmp43135514335195: bool;                                                                      
 var $recorded.state4335071: int;                                                                   
 var Node._lock4335264: [Node]Tid;                                                                  
 var ctmp43135514335247: bool;                                                                      
 var StackWithCAS.head_nextThread4335264: [StackWithCAS]Tid;                                        
 var StackWithCAS.head4335225: [StackWithCAS]Node;                                                  
 var _m4335202: Mover;                                                                              
 var tmpTid: Tid;                                                                                   
 var $pc4335264: Phase;                                                                             
 var $recorded.state4335202: int;                                                                   
 var StackWithCAS.head_nextThread4335065: [StackWithCAS]Tid;                                        
 var $recorded.state4335195: int;                                                                   
 var this4335059: StackWithCAS;                                                                     
 var next4335195: Node;                                                                             
 var top4335228: Node;                                                                              
 var $result4335278: int;                                                                           
 var next4335262: Node;                                                                             
 var StackWithCAS.head4335275: [StackWithCAS]Node;                                                  
 var tid4335109: Tid;                                                                               
 var StackWithCAS._lock4335198: [StackWithCAS]Tid;                                                  
 var $recorded.state4335228: int;                                                                   
 var tid4335059: Tid;                                                                               
 var StackWithCAS._state4335198: [StackWithCAS]State;                                               
 var Node._state4335275: [Node]State;                                                               
 var StackWithCAS.head4335247: [StackWithCAS]Node;                                                  
 var StackWithCAS._state4335228: [StackWithCAS]State;                                               
 var Node._lock4335262: [Node]Tid;                                                                  
 var $result4335228: int;                                                                           
 var StackWithCAS._lock4335135: [StackWithCAS]Tid;                                                  
 var tid4335225: Tid;                                                                               
 var $result4335059: int;                                                                           
 var tmp17: bool;                                                                                   
 var tmp164335225: bool;                                                                            
 var StackWithCAS.head_nextThread4335202: [StackWithCAS]Tid;                                        
 var Node._lock4335114: [Node]Tid;                                                                  
 var StackWithCAS.head4335272: [StackWithCAS]Node;                                                  
 var path4335240: int;                                                                              
 var _C_t4335114: Tid;                                                                              
 var mover4335114: Mover;                                                                           
 var Node._state4335135: [Node]State;                                                               
 var StackWithCAS.head_nextValue4335195: [StackWithCAS]Node;                                        
 var StackWithCAS._lock4335225: [StackWithCAS]Tid;                                                  
 var $recorded.state4335135: int;                                                                   
 var Node._lock4335059: [Node]Tid;                                                                  
 var $pc4335225: Phase;                                                                             
 var Node.item4335228: [Node]int;                                                                   
 var phase4335275: Phase;                                                                           
 var Node.item4335240: [Node]int;                                                                   
 var top4335118_post: Node;                                                                         
 var path4335065: int;                                                                              
 var StackWithCAS._state4335264: [StackWithCAS]State;                                               
 var Stack._state4335278: [Stack]State;                                                             
 var tmp164335272: bool;                                                                            
 var Node._state4335247: [Node]State;                                                               
 var Node.item4335275: [Node]int;                                                                   
 var StackWithCAS._state4335262: [StackWithCAS]State;                                               
 var $pc4335109: Phase;                                                                             
 var $pc4335202: Phase;                                                                             
 var Node._lock4335065: [Node]Tid;                                                                  
 var StackWithCAS.head4335198: [StackWithCAS]Node;                                                  
 var top4335135: Node;                                                                              
 var Stack._state4335059: [Stack]State;                                                             
 var StackWithCAS._lock4335272: [StackWithCAS]Tid;                                                  
 var Node.next4335247: [Node]Node;                                                                  
 var moverPath4335240: MoverPath;                                                                   
 var tmp154335247: bool;                                                                            
 var $pc4335065: Phase;                                                                             
 var moverPath4335109: MoverPath;                                                                   
 var Node._lock4335272_post: [Node]Tid;                                                             
 var Node.item4335198: [Node]int;                                                                   
 var StackWithCAS.head_nextThread4335272_post: [StackWithCAS]Tid;                                   
 var $pc4335240: Phase;                                                                             
 var top4335198: Node;                                                                              
 var _C_t4335071: Tid;                                                                              
 var StackWithCAS._state4335275: [StackWithCAS]State;                                               
 var StackWithCAS._state4335272_post: [StackWithCAS]State;                                          
 var Stack.head4335275: [Stack]Node;                                                                
 var StackWithCAS.head_nextThread4335109: [StackWithCAS]Tid;                                        
 var $recorded.state4335118_post: int;                                                              
 var tmp174335195: bool;                                                                            
 var StackWithCAS.head_nextValue4335275_bottom: [StackWithCAS]Node;                                 
 var StackWithCAS.head_nextThread4335228: [StackWithCAS]Tid;                                        
 var Node._state4335240: [Node]State;                                                               
 var path4335135: int;                                                                              
 var Node.next4335278: [Node]Node;                                                                  
 var tmp154335225: bool;                                                                            
 var this4335278: StackWithCAS;                                                                     
 var moverPath4335071: MoverPath;                                                                   
 var Stack.head4335059: [Stack]Node;                                                                
 var tmp174335228: bool;                                                                            
 var $recorded.state4335275_bottom: int;                                                            
 var tmpTid4335202: Tid;                                                                            
 var Node._state4335202: [Node]State;                                                               
 var tmpTid4335198: Tid;                                                                            
 var this4335275: StackWithCAS;                                                                     
 var Node._lock4335198: [Node]Tid;                                                                  
 var tmp154335059: bool;                                                                            
 var top: Node;                                                                                     
 var next4335264: Node;                                                                             
 var Node._state4335198: [Node]State;                                                               
 var $pc4335195: Phase;                                                                             
 var Node.next4335198: [Node]Node;                                                                  
 var Node.item4335118: [Node]int;                                                                   
 var Node._lock4335195: [Node]Tid;                                                                  
 var $pc4335059: Phase;                                                                             
 var StackWithCAS.head_nextValue4335275: [StackWithCAS]Node;                                        
 var moverPath4335247: MoverPath;                                                                   
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state4335275 == Node._state && Node.item4335275 == Node.item && Node.next4335275 == Node.next && Node._lock4335275 == Node._lock && Stack._state4335275 == Stack._state && Stack.head4335275 == Stack.head && Stack._lock4335275 == Stack._lock && StackWithCAS._state4335275 == StackWithCAS._state && StackWithCAS.head4335275 == StackWithCAS.head && StackWithCAS._lock4335275 == StackWithCAS._lock && StackWithCAS.head_nextThread4335275 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335275 == StackWithCAS.head_nextValue && $result4335275 == $result && this4335275 == this && tid4335275 == tid;
 assume $recorded.state4335275 == 1;                                                                
                                                                                                    
 // 82.6: while (true)   {                                                                          
                                                                                                    
 phase4335275 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (79.2): Bad tid
  invariant isShared(StackWithCAS._state[this]);                                                           // (79.2): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state4335275,Node.item4335275,Node.next4335275,Node._lock4335275,Stack._state4335275,Stack.head4335275,Stack._lock4335275,StackWithCAS._state4335275,StackWithCAS.head4335275,StackWithCAS._lock4335275,StackWithCAS.head_nextThread4335275,StackWithCAS.head_nextValue4335275));       // (82.6): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state4335275,Node.item4335275,Node.next4335275,Node._lock4335275,Stack._state4335275,Stack.head4335275,Stack._lock4335275,StackWithCAS._state4335275,StackWithCAS.head4335275,StackWithCAS._lock4335275,StackWithCAS.head_nextThread4335275,StackWithCAS.head_nextValue4335275));       // (82.6): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Stack :: Invariant.Y_Stack.head(tid : Tid, _this, Stack.head[_this] ,Node._state4335275,Node.item4335275,Node.next4335275,Node._lock4335275,Stack._state4335275,Stack.head4335275,Stack._lock4335275,StackWithCAS._state4335275,StackWithCAS.head4335275,StackWithCAS._lock4335275,StackWithCAS.head_nextThread4335275,StackWithCAS.head_nextValue4335275));       // (82.6): Loop does not preserve yields_as annotation for field head
  invariant (forall _this : StackWithCAS :: Invariant.Y_StackWithCAS.head(tid : Tid, _this, StackWithCAS.head[_this] ,Node._state4335275,Node.item4335275,Node.next4335275,Node._lock4335275,Stack._state4335275,Stack.head4335275,Stack._lock4335275,StackWithCAS._state4335275,StackWithCAS.head4335275,StackWithCAS._lock4335275,StackWithCAS.head_nextThread4335275,StackWithCAS.head_nextValue4335275));       // (82.6): Loop does not preserve yields_as annotation for field head
  invariant phase4335275 == $pc;                                                                           // (82.6): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (82.6): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 82.13: boolean tmp15;                                                                          
                                                                                                    
                                                                                                    
  // 82.13: tmp15 = true;                                                                           
                                                                                                    
  tmp15 := true;                                                                                    
  if (!(tmp15)) {                                                                                   
                                                                                                    
   // 82.6: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 84.8: Node top;                                                                                
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 84.8: Tid _C_t;                                                                                
                                                                                                    
                                                                                                    
  // 84.8: _C_t := this.head_nextThread  as B;                                                      
                                                                                                    
                                                                                                    
  moverPath4335059 := ReadEval.StackWithCAS.head_nextThread(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
  mover4335059 := m#moverPath(moverPath4335059);                                                    
  path4335059 := p#moverPath(moverPath4335059);                                                     
  assume Node._state4335059 == Node._state && Node.item4335059 == Node.item && Node.next4335059 == Node.next && Node._lock4335059 == Node._lock && Stack._state4335059 == Stack._state && Stack.head4335059 == Stack.head && Stack._lock4335059 == Stack._lock && StackWithCAS._state4335059 == StackWithCAS._state && StackWithCAS.head4335059 == StackWithCAS.head && StackWithCAS._lock4335059 == StackWithCAS._lock && StackWithCAS.head_nextThread4335059 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335059 == StackWithCAS.head_nextValue && _C_t4335059 == _C_t && top4335059 == top && tmp154335059 == tmp15 && $result4335059 == $result && this4335059 == this && tid4335059 == tid && $pc4335059 == $pc;
  assume $recorded.state4335059 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != StackWithCAS.null;                                                                
  } else {                                                                                          
   assert this != StackWithCAS.null;                                                                       // (84.8): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (84.8): Reduction failure
  _C_t := StackWithCAS.head_nextThread[this];                                                       
                                                                                                    
  // 84.8: Node _C_v;                                                                               
                                                                                                    
                                                                                                    
  // 84.8: _C_v := this.head_nextValue  as B;                                                       
                                                                                                    
                                                                                                    
  moverPath4335065 := ReadEval.StackWithCAS.head_nextValue(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
  mover4335065 := m#moverPath(moverPath4335065);                                                    
  path4335065 := p#moverPath(moverPath4335065);                                                     
  assume Node._state4335065 == Node._state && Node.item4335065 == Node.item && Node.next4335065 == Node.next && Node._lock4335065 == Node._lock && Stack._state4335065 == Stack._state && Stack.head4335065 == Stack.head && Stack._lock4335065 == Stack._lock && StackWithCAS._state4335065 == StackWithCAS._state && StackWithCAS.head4335065 == StackWithCAS.head && StackWithCAS._lock4335065 == StackWithCAS._lock && StackWithCAS.head_nextThread4335065 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335065 == StackWithCAS.head_nextValue && _C_v4335065 == _C_v && _C_t4335065 == _C_t && top4335065 == top && tmp154335065 == tmp15 && $result4335065 == $result && this4335065 == this && tid4335065 == tid && $pc4335065 == $pc;
  assume $recorded.state4335065 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != StackWithCAS.null;                                                                
  } else {                                                                                          
   assert this != StackWithCAS.null;                                                                       // (84.8): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (84.8): Reduction failure
  _C_v := StackWithCAS.head_nextValue[this];                                                        
                                                                                                    
  // 84.8: Node _currentValue;                                                                      
                                                                                                    
                                                                                                    
  // 84.8: _currentValue := this.head  as B;                                                        
                                                                                                    
                                                                                                    
  moverPath4335071 := ReadEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
  mover4335071 := m#moverPath(moverPath4335071);                                                    
  path4335071 := p#moverPath(moverPath4335071);                                                     
  assume Node._state4335071 == Node._state && Node.item4335071 == Node.item && Node.next4335071 == Node.next && Node._lock4335071 == Node._lock && Stack._state4335071 == Stack._state && Stack.head4335071 == Stack.head && Stack._lock4335071 == Stack._lock && StackWithCAS._state4335071 == StackWithCAS._state && StackWithCAS.head4335071 == StackWithCAS.head && StackWithCAS._lock4335071 == StackWithCAS._lock && StackWithCAS.head_nextThread4335071 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335071 == StackWithCAS.head_nextValue && _currentValue4335071 == _currentValue && _C_v4335071 == _C_v && _C_t4335071 == _C_t && top4335071 == top && tmp154335071 == tmp15 && $result4335071 == $result && this4335071 == this && tid4335071 == tid && $pc4335071 == $pc;
  assume $recorded.state4335071 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != StackWithCAS.null;                                                                
  } else {                                                                                          
   assert this != StackWithCAS.null;                                                                       // (84.8): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (84.8): Reduction failure
  _currentValue := StackWithCAS.head[this];                                                         
                                                                                                    
  // 84.8: Mover _R_t;                                                                              
                                                                                                    
                                                                                                    
  // 84.8: _R_t = readPermission(this.head);                                                        
                                                                                                    
  _R_t := m#moverPath(ReadEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue));
                                                                                                    
  // 84.8: boolean _casable;                                                                        
                                                                                                    
                                                                                                    
  // 84.8: _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                   
                                                                                                    
  _casable := ((((_R_t!=_E)&&false)&&(_C_t==tid))&&(_C_v==_currentValue));                          
  if (_casable) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 84.8: top := this.head  as R;                                                                 
                                                                                                    
                                                                                                    
   moverPath4335109 := ReadEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
   mover4335109 := m#moverPath(moverPath4335109);                                                   
   path4335109 := p#moverPath(moverPath4335109);                                                    
   assume Node._state4335109 == Node._state && Node.item4335109 == Node.item && Node.next4335109 == Node.next && Node._lock4335109 == Node._lock && Stack._state4335109 == Stack._state && Stack.head4335109 == Stack.head && Stack._lock4335109 == Stack._lock && StackWithCAS._state4335109 == StackWithCAS._state && StackWithCAS.head4335109 == StackWithCAS.head && StackWithCAS._lock4335109 == StackWithCAS._lock && StackWithCAS.head_nextThread4335109 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335109 == StackWithCAS.head_nextValue && _casable4335109 == _casable && _R_t4335109 == _R_t && _currentValue4335109 == _currentValue && _C_v4335109 == _C_v && _C_t4335109 == _C_t && top4335109 == top && tmp154335109 == tmp15 && $result4335109 == $result && this4335109 == this && tid4335109 == tid && $pc4335109 == $pc;
   assume $recorded.state4335109 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != StackWithCAS.null;                                                               
   } else {                                                                                         
    assert this != StackWithCAS.null;                                                                      // (84.8): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, _R);                                                                      
   assert $pc != PhaseError;                                                                               // (84.8): Reduction failure
   top := StackWithCAS.head[this];                                                                  
  } else {                                                                                          
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 84.8: top := this.head;                                                                       
                                                                                                    
                                                                                                    
   moverPath4335114 := ReadEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
   mover4335114 := m#moverPath(moverPath4335114);                                                   
   path4335114 := p#moverPath(moverPath4335114);                                                    
   assume Node._state4335114 == Node._state && Node.item4335114 == Node.item && Node.next4335114 == Node.next && Node._lock4335114 == Node._lock && Stack._state4335114 == Stack._state && Stack.head4335114 == Stack.head && Stack._lock4335114 == Stack._lock && StackWithCAS._state4335114 == StackWithCAS._state && StackWithCAS.head4335114 == StackWithCAS.head && StackWithCAS._lock4335114 == StackWithCAS._lock && StackWithCAS.head_nextThread4335114 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335114 == StackWithCAS.head_nextValue && _casable4335114 == _casable && _R_t4335114 == _R_t && _currentValue4335114 == _currentValue && _C_v4335114 == _C_v && _C_t4335114 == _C_t && top4335114 == top && tmp154335114 == tmp15 && $result4335114 == $result && this4335114 == this && tid4335114 == tid && $pc4335114 == $pc;
   assume $recorded.state4335114 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != StackWithCAS.null;                                                               
   } else {                                                                                         
    assert this != StackWithCAS.null;                                                                      // (84.8): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4335114);                                                            
   assert $pc != PhaseError;                                                                               // (84.8): Reduction failure
   top := StackWithCAS.head[this];                                                                  
  }                                                                                                 
                                                                                                    
  // 85.11: yield;                                                                                  
                                                                                                    
  assume Node._state4335118 == Node._state && Node.item4335118 == Node.item && Node.next4335118 == Node.next && Node._lock4335118 == Node._lock && Stack._state4335118 == Stack._state && Stack.head4335118 == Stack.head && Stack._lock4335118 == Stack._lock && StackWithCAS._state4335118 == StackWithCAS._state && StackWithCAS.head4335118 == StackWithCAS.head && StackWithCAS._lock4335118 == StackWithCAS._lock && StackWithCAS.head_nextThread4335118 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335118 == StackWithCAS.head_nextValue && top4335118 == top && tmp154335118 == tmp15 && $result4335118 == $result && this4335118 == this && tid4335118 == tid;
  assume $recorded.state4335118 == 1;                                                               
  call Yield(tid);                                                                                  
  $pc := PreCommit;                                                                                 
  assume Node._state4335118_post == Node._state && Node.item4335118_post == Node.item && Node.next4335118_post == Node.next && Node._lock4335118_post == Node._lock && Stack._state4335118_post == Stack._state && Stack.head4335118_post == Stack.head && Stack._lock4335118_post == Stack._lock && StackWithCAS._state4335118_post == StackWithCAS._state && StackWithCAS.head4335118_post == StackWithCAS.head && StackWithCAS._lock4335118_post == StackWithCAS._lock && StackWithCAS.head_nextThread4335118_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335118_post == StackWithCAS.head_nextValue && top4335118_post == top && tmp154335118_post == tmp15 && $result4335118_post == $result && this4335118_post == this && tid4335118_post == tid;
  assume $recorded.state4335118_post == 1;                                                          
                                                                                                    
  // 86.10: boolean tmp16;                                                                          
                                                                                                    
                                                                                                    
  // 86.10: tmp16 = top != Node.null;                                                               
                                                                                                    
  tmp16 := (top!=Node.null);                                                                        
  if (tmp16 /* lowered (top!=Node.null) */) {                                                       
                                                                                                    
   // 87.10: Node next;                                                                             
                                                                                                    
                                                                                                    
   // 87.10: next := top.next;                                                                      
                                                                                                    
                                                                                                    
   moverPath4335135 := ReadEval.Node.next(tid: Tid,top: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
   mover4335135 := m#moverPath(moverPath4335135);                                                   
   path4335135 := p#moverPath(moverPath4335135);                                                    
   assume Node._state4335135 == Node._state && Node.item4335135 == Node.item && Node.next4335135 == Node.next && Node._lock4335135 == Node._lock && Stack._state4335135 == Stack._state && Stack.head4335135 == Stack.head && Stack._lock4335135 == Stack._lock && StackWithCAS._state4335135 == StackWithCAS._state && StackWithCAS.head4335135 == StackWithCAS.head && StackWithCAS._lock4335135 == StackWithCAS._lock && StackWithCAS.head_nextThread4335135 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335135 == StackWithCAS.head_nextValue && next4335135 == next && tmp164335135 == tmp16 && top4335135 == top && tmp154335135 == tmp15 && $result4335135 == $result && this4335135 == this && tid4335135 == tid && $pc4335135 == $pc;
   assume $recorded.state4335135 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume top != Node.null;                                                                        
   } else {                                                                                         
    assert top != Node.null;                                                                               // (87.10): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4335135);                                                            
   assert $pc != PhaseError;                                                                               // (87.10): Reduction failure
   next := Node.next[top];                                                                          
                                                                                                    
   // 88.13: boolean tmp17;                                                                         
                                                                                                    
   // NoOp: 'TraceOff'                                                                              
                                                                                                    
   // 88.13: boolean ctmp4313551;                                                                   
                                                                                                    
                                                                                                    
   // 88.13: ctmp4313551 = *;                                                                       
                                                                                                    
   havoc ctmp4313551;                                                                               
   if (ctmp4313551) {                                                                               
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
    // 88.13: tmp17 = false;                                                                        
                                                                                                    
    tmp17 := false;                                                                                 
   } else {                                                                                         
                                                                                                    
    // 88.13: ctmp4313551 = *;                                                                      
                                                                                                    
    havoc ctmp4313551;                                                                              
    if (ctmp4313551) {                                                                              
                                                                                                    
     // 88.13: Tid tmpTid;                                                                          
                                                                                                    
                                                                                                    
     // 88.13: Node tmpValue;                                                                       
                                                                                                    
                                                                                                    
     // 88.13: Mover _m;                                                                            
                                                                                                    
                                                                                                    
     // 88.13: _m = writePermission(this.head, next);                                               
                                                                                                    
     _m := m#moverPath(WriteEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,next: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue));
                                                                                                    
     // 88.13: assume this.head == top;                                                             
                                                                                                    
     assume (StackWithCAS.head[this]==top);                                                         
                                                                                                    
     // 88.13: assume !goesWrong(_m);                                                               
                                                                                                    
     assume !(transition($pc, _m) == PhaseError);                                                   
                                                                                                    
     // 88.13: assume this.head_nextThread == tid;                                                  
                                                                                                    
     assume (StackWithCAS.head_nextThread[this]==tid);                                              
                                                                                                    
     // 88.13: assume this.head_nextValue == top;                                                   
                                                                                                    
     assume (StackWithCAS.head_nextValue[this]==top);                                               
                                                                                                    
                                                                                                    
     // 88.13: this.head_nextThread := tmpTid as B;                                                 
                                                                                                    
                                                                                                    
     moverPath4335195 := WriteEval.StackWithCAS.head_nextThread(tid: Tid,this: StackWithCAS,tmpTid: Tid,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
     mover4335195 := m#moverPath(moverPath4335195);                                                 
     path4335195 := p#moverPath(moverPath4335195);                                                  
     assume Node._state4335195 == Node._state && Node.item4335195 == Node.item && Node.next4335195 == Node.next && Node._lock4335195 == Node._lock && Stack._state4335195 == Stack._state && Stack.head4335195 == Stack.head && Stack._lock4335195 == Stack._lock && StackWithCAS._state4335195 == StackWithCAS._state && StackWithCAS.head4335195 == StackWithCAS.head && StackWithCAS._lock4335195 == StackWithCAS._lock && StackWithCAS.head_nextThread4335195 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335195 == StackWithCAS.head_nextValue && _m4335195 == _m && tmpValue4335195 == tmpValue && tmpTid4335195 == tmpTid && ctmp43135514335195 == ctmp4313551 && tmp174335195 == tmp17 && next4335195 == next && tmp164335195 == tmp16 && top4335195 == top && tmp154335195 == tmp15 && $result4335195 == $result && this4335195 == this && tid4335195 == tid && $pc4335195 == $pc;
     assume $recorded.state4335195 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != StackWithCAS.null;                                                             
     } else {                                                                                       
      assert this != StackWithCAS.null;                                                                    // (88.13): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (88.13): Reduction failure
     StackWithCAS.head_nextThread[this] := tmpTid;                                                  
                                                                                                    
                                                                                                    
     // 88.13: this.head_nextValue := tmpValue as B;                                                
                                                                                                    
                                                                                                    
     moverPath4335198 := WriteEval.StackWithCAS.head_nextValue(tid: Tid,this: StackWithCAS,tmpValue: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
     mover4335198 := m#moverPath(moverPath4335198);                                                 
     path4335198 := p#moverPath(moverPath4335198);                                                  
     assume Node._state4335198 == Node._state && Node.item4335198 == Node.item && Node.next4335198 == Node.next && Node._lock4335198 == Node._lock && Stack._state4335198 == Stack._state && Stack.head4335198 == Stack.head && Stack._lock4335198 == Stack._lock && StackWithCAS._state4335198 == StackWithCAS._state && StackWithCAS.head4335198 == StackWithCAS.head && StackWithCAS._lock4335198 == StackWithCAS._lock && StackWithCAS.head_nextThread4335198 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335198 == StackWithCAS.head_nextValue && _m4335198 == _m && tmpValue4335198 == tmpValue && tmpTid4335198 == tmpTid && ctmp43135514335198 == ctmp4313551 && tmp174335198 == tmp17 && next4335198 == next && tmp164335198 == tmp16 && top4335198 == top && tmp154335198 == tmp15 && $result4335198 == $result && this4335198 == this && tid4335198 == tid && $pc4335198 == $pc;
     assume $recorded.state4335198 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != StackWithCAS.null;                                                             
     } else {                                                                                       
      assert this != StackWithCAS.null;                                                                    // (88.13): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (88.13): Reduction failure
     StackWithCAS.head_nextValue[this] := tmpValue;                                                 
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
                                                                                                    
     // 88.13: this.head := next;                                                                   
                                                                                                    
                                                                                                    
     moverPath4335202 := WriteEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,next: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
     mover4335202 := m#moverPath(moverPath4335202);                                                 
     path4335202 := p#moverPath(moverPath4335202);                                                  
     assume Node._state4335202 == Node._state && Node.item4335202 == Node.item && Node.next4335202 == Node.next && Node._lock4335202 == Node._lock && Stack._state4335202 == Stack._state && Stack.head4335202 == Stack.head && Stack._lock4335202 == Stack._lock && StackWithCAS._state4335202 == StackWithCAS._state && StackWithCAS.head4335202 == StackWithCAS.head && StackWithCAS._lock4335202 == StackWithCAS._lock && StackWithCAS.head_nextThread4335202 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335202 == StackWithCAS.head_nextValue && _m4335202 == _m && tmpValue4335202 == tmpValue && tmpTid4335202 == tmpTid && ctmp43135514335202 == ctmp4313551 && tmp174335202 == tmp17 && next4335202 == next && tmp164335202 == tmp16 && top4335202 == top && tmp154335202 == tmp15 && $result4335202 == $result && this4335202 == this && tid4335202 == tid && $pc4335202 == $pc;
     assume $recorded.state4335202 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != StackWithCAS.null;                                                             
     } else {                                                                                       
      assert this != StackWithCAS.null;                                                                    // (88.13): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, mover4335202);                                                          
     assert $pc != PhaseError;                                                                             // (88.13): Reduction failure
     StackWithCAS.head[this] := next;                                                               
     if (isLocal(Node._state[next], tid)) {                                                         
      Node._state[next] := SHARED();                                                                
      assert isSharedAssignable(Node._state[Node.next[next]]);                                             // (88.13): next became shared, but next.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 88.13: tmp17 = true;                                                                        
                                                                                                    
     tmp17 := true;                                                                                 
    } else {                                                                                        
                                                                                                    
     // 88.13: assume this.head_nextThread == tid;                                                  
                                                                                                    
     assume (StackWithCAS.head_nextThread[this]==tid);                                              
                                                                                                    
     // 88.13: assume this.head_nextValue == top;                                                   
                                                                                                    
     assume (StackWithCAS.head_nextValue[this]==top);                                               
                                                                                                    
     // 88.13: Node _currentValue;                                                                  
                                                                                                    
                                                                                                    
     // 88.13: _currentValue := this.head  as B;                                                    
                                                                                                    
                                                                                                    
     moverPath4335225 := ReadEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
     mover4335225 := m#moverPath(moverPath4335225);                                                 
     path4335225 := p#moverPath(moverPath4335225);                                                  
     assume Node._state4335225 == Node._state && Node.item4335225 == Node.item && Node.next4335225 == Node.next && Node._lock4335225 == Node._lock && Stack._state4335225 == Stack._state && Stack.head4335225 == Stack.head && Stack._lock4335225 == Stack._lock && StackWithCAS._state4335225 == StackWithCAS._state && StackWithCAS.head4335225 == StackWithCAS.head && StackWithCAS._lock4335225 == StackWithCAS._lock && StackWithCAS.head_nextThread4335225 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335225 == StackWithCAS.head_nextValue && _currentValue4335225 == _currentValue && ctmp43135514335225 == ctmp4313551 && tmp174335225 == tmp17 && next4335225 == next && tmp164335225 == tmp16 && top4335225 == top && tmp154335225 == tmp15 && $result4335225 == $result && this4335225 == this && tid4335225 == tid && $pc4335225 == $pc;
     assume $recorded.state4335225 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != StackWithCAS.null;                                                             
     } else {                                                                                       
      assert this != StackWithCAS.null;                                                                    // (88.13): Cannot have potential null deference in left-mover part.
     }                                                                                              
                                                                                                    
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (88.13): Reduction failure
     _currentValue := StackWithCAS.head[this];                                                      
                                                                                                    
                                                                                                    
     // 88.13: this.head := top as B;                                                               
                                                                                                    
                                                                                                    
     moverPath4335228 := WriteEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,top: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
     mover4335228 := m#moverPath(moverPath4335228);                                                 
     path4335228 := p#moverPath(moverPath4335228);                                                  
     assume Node._state4335228 == Node._state && Node.item4335228 == Node.item && Node.next4335228 == Node.next && Node._lock4335228 == Node._lock && Stack._state4335228 == Stack._state && Stack.head4335228 == Stack.head && Stack._lock4335228 == Stack._lock && StackWithCAS._state4335228 == StackWithCAS._state && StackWithCAS.head4335228 == StackWithCAS.head && StackWithCAS._lock4335228 == StackWithCAS._lock && StackWithCAS.head_nextThread4335228 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335228 == StackWithCAS.head_nextValue && _currentValue4335228 == _currentValue && ctmp43135514335228 == ctmp4313551 && tmp174335228 == tmp17 && next4335228 == next && tmp164335228 == tmp16 && top4335228 == top && tmp154335228 == tmp15 && $result4335228 == $result && this4335228 == this && tid4335228 == tid && $pc4335228 == $pc;
     assume $recorded.state4335228 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != StackWithCAS.null;                                                             
     } else {                                                                                       
      assert this != StackWithCAS.null;                                                                    // (88.13): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (88.13): Reduction failure
     StackWithCAS.head[this] := top;                                                                
     if (isLocal(Node._state[top], tid)) {                                                          
      Node._state[top] := SHARED();                                                                 
      assert isSharedAssignable(Node._state[Node.next[top]]);                                              // (88.13): top became shared, but top.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 88.13: Mover _m;                                                                            
                                                                                                    
                                                                                                    
     // 88.13: _m = writePermission(this.head, next);                                               
                                                                                                    
     _m := m#moverPath(WriteEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,next: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue));
                                                                                                    
                                                                                                    
     // 88.13: this.head := _currentValue as B;                                                     
                                                                                                    
                                                                                                    
     moverPath4335240 := WriteEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,_currentValue: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
     mover4335240 := m#moverPath(moverPath4335240);                                                 
     path4335240 := p#moverPath(moverPath4335240);                                                  
     assume Node._state4335240 == Node._state && Node.item4335240 == Node.item && Node.next4335240 == Node.next && Node._lock4335240 == Node._lock && Stack._state4335240 == Stack._state && Stack.head4335240 == Stack.head && Stack._lock4335240 == Stack._lock && StackWithCAS._state4335240 == StackWithCAS._state && StackWithCAS.head4335240 == StackWithCAS.head && StackWithCAS._lock4335240 == StackWithCAS._lock && StackWithCAS.head_nextThread4335240 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335240 == StackWithCAS.head_nextValue && _m4335240 == _m && _currentValue4335240 == _currentValue && ctmp43135514335240 == ctmp4313551 && tmp174335240 == tmp17 && next4335240 == next && tmp164335240 == tmp16 && top4335240 == top && tmp154335240 == tmp15 && $result4335240 == $result && this4335240 == this && tid4335240 == tid && $pc4335240 == $pc;
     assume $recorded.state4335240 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != StackWithCAS.null;                                                             
     } else {                                                                                       
      assert this != StackWithCAS.null;                                                                    // (88.13): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (88.13): Reduction failure
     StackWithCAS.head[this] := _currentValue;                                                      
     if (isLocal(Node._state[_currentValue], tid)) {                                                
      Node._state[_currentValue] := SHARED();                                                       
      assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                    // (88.13): _currentValue became shared, but _currentValue.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 88.13: assume goesWrong(_m);                                                                
                                                                                                    
     assume transition($pc, _m) == PhaseError;                                                      
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
                                                                                                    
     // 88.13: this.head := next;                                                                   
                                                                                                    
                                                                                                    
     moverPath4335247 := WriteEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,next: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
     mover4335247 := m#moverPath(moverPath4335247);                                                 
     path4335247 := p#moverPath(moverPath4335247);                                                  
     assume Node._state4335247 == Node._state && Node.item4335247 == Node.item && Node.next4335247 == Node.next && Node._lock4335247 == Node._lock && Stack._state4335247 == Stack._state && Stack.head4335247 == Stack.head && Stack._lock4335247 == Stack._lock && StackWithCAS._state4335247 == StackWithCAS._state && StackWithCAS.head4335247 == StackWithCAS.head && StackWithCAS._lock4335247 == StackWithCAS._lock && StackWithCAS.head_nextThread4335247 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335247 == StackWithCAS.head_nextValue && _m4335247 == _m && _currentValue4335247 == _currentValue && ctmp43135514335247 == ctmp4313551 && tmp174335247 == tmp17 && next4335247 == next && tmp164335247 == tmp16 && top4335247 == top && tmp154335247 == tmp15 && $result4335247 == $result && this4335247 == this && tid4335247 == tid && $pc4335247 == $pc;
     assume $recorded.state4335247 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != StackWithCAS.null;                                                             
     } else {                                                                                       
      assert this != StackWithCAS.null;                                                                    // (88.13): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, mover4335247);                                                          
     assert $pc != PhaseError;                                                                             // (88.13): Reduction failure
     StackWithCAS.head[this] := next;                                                               
     if (isLocal(Node._state[next], tid)) {                                                         
      Node._state[next] := SHARED();                                                                
      assert isSharedAssignable(Node._state[Node.next[next]]);                                             // (88.13): next became shared, but next.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 88.13: tmp17 = false;                                                                       
                                                                                                    
     tmp17 := false;                                                                                
    }                                                                                               
   }                                                                                                
   if (tmp17) {                                                                                     
                                                                                                    
    // 89.14: int tmp18;                                                                            
                                                                                                    
                                                                                                    
    // 89.14: tmp18 := top.item;                                                                    
                                                                                                    
                                                                                                    
    moverPath4335262 := ReadEval.Node.item(tid: Tid,top: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
    mover4335262 := m#moverPath(moverPath4335262);                                                  
    path4335262 := p#moverPath(moverPath4335262);                                                   
    assume Node._state4335262 == Node._state && Node.item4335262 == Node.item && Node.next4335262 == Node.next && Node._lock4335262 == Node._lock && Stack._state4335262 == Stack._state && Stack.head4335262 == Stack.head && Stack._lock4335262 == Stack._lock && StackWithCAS._state4335262 == StackWithCAS._state && StackWithCAS.head4335262 == StackWithCAS.head && StackWithCAS._lock4335262 == StackWithCAS._lock && StackWithCAS.head_nextThread4335262 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335262 == StackWithCAS.head_nextValue && tmp184335262 == tmp18 && tmp174335262 == tmp17 && next4335262 == next && tmp164335262 == tmp16 && top4335262 == top && tmp154335262 == tmp15 && $result4335262 == $result && this4335262 == this && tid4335262 == tid && $pc4335262 == $pc;
    assume $recorded.state4335262 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume top != Node.null;                                                                       
    } else {                                                                                        
     assert top != Node.null;                                                                              // (89.14): Cannot have potential null deference in left-mover part.
    }                                                                                               
                                                                                                    
    $pc := transition($pc, mover4335262);                                                           
    assert $pc != PhaseError;                                                                              // (89.14): Reduction failure
    tmp18 := Node.item[top];                                                                        
                                                                                                    
    // 89.14:  return tmp18;                                                                        
                                                                                                    
    assume Node._state4335264 == Node._state && Node.item4335264 == Node.item && Node.next4335264 == Node.next && Node._lock4335264 == Node._lock && Stack._state4335264 == Stack._state && Stack.head4335264 == Stack.head && Stack._lock4335264 == Stack._lock && StackWithCAS._state4335264 == StackWithCAS._state && StackWithCAS.head4335264 == StackWithCAS.head && StackWithCAS._lock4335264 == StackWithCAS._lock && StackWithCAS.head_nextThread4335264 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335264 == StackWithCAS.head_nextValue && tmp184335264 == tmp18 && tmp174335264 == tmp17 && next4335264 == next && tmp164335264 == tmp16 && top4335264 == top && tmp154335264 == tmp15 && $result4335264 == $result && this4335264 == this && tid4335264 == tid;
    assume $recorded.state4335264 == 1;                                                             
    $result := tmp18;                                                                               
    return;                                                                                         
   } else {                                                                                         
   }                                                                                                
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 92.10: yield;                                                                                  
                                                                                                    
  assume Node._state4335272 == Node._state && Node.item4335272 == Node.item && Node.next4335272 == Node.next && Node._lock4335272 == Node._lock && Stack._state4335272 == Stack._state && Stack.head4335272 == Stack.head && Stack._lock4335272 == Stack._lock && StackWithCAS._state4335272 == StackWithCAS._state && StackWithCAS.head4335272 == StackWithCAS.head && StackWithCAS._lock4335272 == StackWithCAS._lock && StackWithCAS.head_nextThread4335272 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335272 == StackWithCAS.head_nextValue && tmp164335272 == tmp16 && top4335272 == top && tmp154335272 == tmp15 && $result4335272 == $result && this4335272 == this && tid4335272 == tid;
  assume $recorded.state4335272 == 1;                                                               
  call Yield(tid);                                                                                  
  $pc := PreCommit;                                                                                 
  assume Node._state4335272_post == Node._state && Node.item4335272_post == Node.item && Node.next4335272_post == Node.next && Node._lock4335272_post == Node._lock && Stack._state4335272_post == Stack._state && Stack.head4335272_post == Stack.head && Stack._lock4335272_post == Stack._lock && StackWithCAS._state4335272_post == StackWithCAS._state && StackWithCAS.head4335272_post == StackWithCAS.head && StackWithCAS._lock4335272_post == StackWithCAS._lock && StackWithCAS.head_nextThread4335272_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335272_post == StackWithCAS.head_nextValue && tmp164335272_post == tmp16 && top4335272_post == top && tmp154335272_post == tmp15 && $result4335272_post == $result && this4335272_post == this && tid4335272_post == tid;
  assume $recorded.state4335272_post == 1;                                                          
  assume Node._state4335275_bottom == Node._state && Node.item4335275_bottom == Node.item && Node.next4335275_bottom == Node.next && Node._lock4335275_bottom == Node._lock && Stack._state4335275_bottom == Stack._state && Stack.head4335275_bottom == Stack.head && Stack._lock4335275_bottom == Stack._lock && StackWithCAS._state4335275_bottom == StackWithCAS._state && StackWithCAS.head4335275_bottom == StackWithCAS.head && StackWithCAS._lock4335275_bottom == StackWithCAS._lock && StackWithCAS.head_nextThread4335275_bottom == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335275_bottom == StackWithCAS.head_nextValue && $result4335275_bottom == $result && this4335275_bottom == this && tid4335275_bottom == tid;
  assume $recorded.state4335275_bottom == 1;                                                        
  assert phase4335275 == $pc;                                                                              // (82.6): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 81.22: // return -1;                                                                            
                                                                                                    
 assume Node._state4335278 == Node._state && Node.item4335278 == Node.item && Node.next4335278 == Node.next && Node._lock4335278 == Node._lock && Stack._state4335278 == Stack._state && Stack.head4335278 == Stack.head && Stack._lock4335278 == Stack._lock && StackWithCAS._state4335278 == StackWithCAS._state && StackWithCAS.head4335278 == StackWithCAS.head && StackWithCAS._lock4335278 == StackWithCAS._lock && StackWithCAS.head_nextThread4335278 == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue4335278 == StackWithCAS.head_nextValue && $result4335278 == $result && this4335278 == this && tid4335278 == tid;
 assume $recorded.state4335278 == 1;                                                                
 $result := -1;                                                                                     
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.head: [Stack]Node,Stack._lock: [Stack]Tid,StackWithCAS._state: [StackWithCAS]State,StackWithCAS.head: [StackWithCAS]Node,StackWithCAS._lock: [StackWithCAS]Tid,StackWithCAS.head_nextThread: [StackWithCAS]Tid,StackWithCAS.head_nextValue: [StackWithCAS]Node) returns (bool) {
  true &&                                                                                           
  (forall _i: Node  :: _i == Node.null <==> isNull(Node._state[_i])) &&                             
  (forall _i: Stack  :: _i == Stack.null <==> isNull(Stack._state[_i])) &&                          
  (forall _i: StackWithCAS  :: _i == StackWithCAS.null <==> isNull(StackWithCAS._state[_i])) &&     
  (forall _i: Node ::  (isShared(Node._state[_i]) ==> isSharedAssignable(Node._state[Node.next[_i]]))) &&
  (forall _i: Node ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Node._state[_i],_t) ==> isLocalAssignable(Node._state[Node.next[_i]], _t)))) &&
  (forall _i: Stack ::  (isShared(Stack._state[_i]) ==> isSharedAssignable(Node._state[Stack.head[_i]]))) &&
  (forall _i: Stack ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Stack._state[_i],_t) ==> isLocalAssignable(Node._state[Stack.head[_i]], _t)))) &&
  (forall _i: StackWithCAS ::  (isShared(StackWithCAS._state[_i]) ==> isSharedAssignable(Node._state[StackWithCAS.head[_i]]))) &&
  (forall _i: StackWithCAS ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(StackWithCAS._state[_i],_t) ==> isLocalAssignable(Node._state[StackWithCAS.head[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)           
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (2.3): Node.item failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.item(u: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (2.3): Node.item failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.item[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.item[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (2.3): Node.item failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)             
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.item[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.item(u: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (2.3): Node.item failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)                 
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (2.3): Node.item failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)                  
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Node.item[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.item[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (2.3): Node.item failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)         
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (3.3): Node.next failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (3.3): Node.next failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (3.3): Node.next failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)           
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (3.3): Node.next failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)               
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (3.3): Node.next failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)                
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Node.next[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (3.3): Node.next failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Stack.head(t: Tid, u: Tid, v: Node, w: Node, x: Stack)       
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[x], u);                                                         
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Stack.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Stack.head(u: Tid,x: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (16.3): Stack.head failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Stack.head(t: Tid, u: Tid, v: Node, w: Node, x: Stack)        
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[x], u);                                                         
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Stack.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Stack.head(u: Tid,x: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (16.3): Stack.head failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Stack.head(t: Tid, u: Tid, v: Node, w: Node, x: Stack)        
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[x], u);                                                         
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Stack.head[x];                                                                         
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Stack.head[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Stack.head(u: Tid,x: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (16.3): Stack.head failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Stack.head(t: Tid, u: Tid, v: Node, w: Node, x: Stack)         
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[x], u);                                                         
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Stack.head[x];                                                                         
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Stack.head(u: Tid,x: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (16.3): Stack.head failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Stack.head(t: Tid, u: Tid, v: Node, w: Node, x: Stack)             
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[x], u);                                                         
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Stack.head(t: Tid,x: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Stack.head(u: Tid,x: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (16.3): Stack.head failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Stack.head(t: Tid, u: Tid, v: Node, w: Node, x: Stack)              
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[x], u);                                                         
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Stack.head[x];                                                                         
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Stack.head(t: Tid,x: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Stack.head[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Stack.head(u: Tid,x: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (16.3): Stack.head failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, x: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(StackWithCAS._state[x], u);                                                  
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,x: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (66.2): StackWithCAS.head failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, x: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(StackWithCAS._state[x], u);                                                  
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.StackWithCAS.head(u: Tid,x: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (66.2): StackWithCAS.head failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, x: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(StackWithCAS._state[x], u);                                                  
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == StackWithCAS.head[x];                                                                  
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 StackWithCAS.head[x] := havocValue;                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,x: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (66.2): StackWithCAS.head failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, x: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(StackWithCAS._state[x], u);                                                  
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == StackWithCAS.head[x];                                                                  
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.StackWithCAS.head(u: Tid,x: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (66.2): StackWithCAS.head failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, x: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(StackWithCAS._state[x], u);                                                  
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.StackWithCAS.head(t: Tid,x: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,x: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (66.2): StackWithCAS.head failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, x: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(StackWithCAS._state[x], u);                                                  
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == StackWithCAS.head[x];                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.StackWithCAS.head(t: Tid,x: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 StackWithCAS.head[x] := havocValue;                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,x: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (66.2): StackWithCAS.head failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (2.3): Node.item is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (2.3): Node.item is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (2.3): Node.item is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (2.3): Node.item is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (2.3): Node.item is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (2.3): Node.item is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (2.3): Node.item is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.3): Node.next is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (2.3): Node.item is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (2.3): Node.item is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (2.3): Node.item is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.3): Node.next is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.3): Node.next is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.3): Node.next is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Stack.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.item;                                                                                
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (16.3): Stack.head is not Write-Write Stable with respect to Node.item (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Stack.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.item;                                                                                
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Stack.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Stack.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Stack.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.item;                                                                                
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Stack.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Stack.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Stack.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Stack.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.item;                                                                                
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.head[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (2.3): Node.item is not Read-Write Stable with respect to Stack.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (2.3): Node.item is not Read-Write Stable with respect to Stack.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (2.3): Node.item is not Read-Write Stable with respect to Stack.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Stack.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.item;                                                                                
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Stack.head(u: Tid,y: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Stack.head(u: Tid,y: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (16.3): Stack.head is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (16.3): Stack.head is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (16.3): Stack.head is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.StackWithCAS.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Node.item;                                                                                
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.item (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.StackWithCAS.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Node.item;                                                                                
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: StackWithCAS;                                                                           
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 StackWithCAS.head[y] := w;                                                                         
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.StackWithCAS.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Node.item;                                                                                
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: StackWithCAS;                                                                           
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 StackWithCAS.head[y] := w;                                                                         
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.StackWithCAS.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Node.item;                                                                                
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 StackWithCAS.head[y] := w;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (2.3): Node.item is not Read-Write Stable with respect to StackWithCAS.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (2.3): Node.item is not Read-Write Stable with respect to StackWithCAS.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (2.3): Node.item is not Read-Write Stable with respect to StackWithCAS.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.StackWithCAS.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Node.item;                                                                                
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.StackWithCAS.head(u: Tid,y: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.StackWithCAS.head(u: Tid,y: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (66.2): StackWithCAS.head is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (2.3): Node.item is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.3): Node.next is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.3): Node.next is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.3): Node.next is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (2.3): Node.item is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (2.3): Node.item is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (2.3): Node.item is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.3): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.3): Node.next is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.3): Node.next is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.3): Node.next is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.3): Node.next is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.3): Node.next is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.3): Node.next is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (16.3): Stack.head is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Stack.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Stack.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Stack.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Stack.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Stack.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.head[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.3): Node.next is not Read-Write Stable with respect to Stack.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.3): Node.next is not Read-Write Stable with respect to Stack.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.3): Node.next is not Read-Write Stable with respect to Stack.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Stack.head(u: Tid,y: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Stack.head(u: Tid,y: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (16.3): Stack.head is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (16.3): Stack.head is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (16.3): Stack.head is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Node.next;                                                                                
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Node.next;                                                                                
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: StackWithCAS;                                                                           
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 StackWithCAS.head[y] := w;                                                                         
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Node.next;                                                                                
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: StackWithCAS;                                                                           
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 StackWithCAS.head[y] := w;                                                                         
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Node.next;                                                                                
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 StackWithCAS.head[y] := w;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.3): Node.next is not Read-Write Stable with respect to StackWithCAS.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.3): Node.next is not Read-Write Stable with respect to StackWithCAS.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.3): Node.next is not Read-Write Stable with respect to StackWithCAS.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Node.next;                                                                                
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.StackWithCAS.head(u: Tid,y: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.StackWithCAS.head(u: Tid,y: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (66.2): StackWithCAS.head is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Stack.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.head;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Stack.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (2.3): Node.item is not Write-Write Stable with respect to Stack.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to Stack.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Stack.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.head;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var x_mid: Stack;                                                                                  
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Stack.head[x];                                                                             
 Stack.head[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Stack.head[x] := tmpV;                                                                             
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Stack.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.head;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var x_mid: Stack;                                                                                  
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Stack.head[x];                                                                             
 Stack.head[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Stack.head[x] := tmpV;                                                                             
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Stack.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.head;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Stack.head(t: Tid,x: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Stack.head(t: Tid,x: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (16.3): Stack.head is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (16.3): Stack.head is not Read-Write Stable with respect to Node.item (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (16.3): Stack.head is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Stack.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.head;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (2.3): Node.item is not Write-Read Stable with respect to Stack.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (2.3): Node.item is not Write-Read Stable with respect to Stack.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (2.3): Node.item is not Write-Read Stable with respect to Stack.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Stack.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Stack.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.3): Node.next is not Write-Write Stable with respect to Stack.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to Stack.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Stack.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var x_mid: Stack;                                                                                  
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Stack.head[x];                                                                             
 Stack.head[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Stack.head[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Stack.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var x_mid: Stack;                                                                                  
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Stack.head[x];                                                                             
 Stack.head[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Stack.head[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Stack.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Stack.head(t: Tid,x: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Stack.head(t: Tid,x: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (16.3): Stack.head is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (16.3): Stack.head is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (16.3): Stack.head is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Stack.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.3): Node.next is not Write-Read Stable with respect to Stack.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.3): Node.next is not Write-Read Stable with respect to Stack.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.3): Node.next is not Write-Read Stable with respect to Stack.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Stack.head.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Stack.head;                                                                               
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Stack.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (16.3): Stack.head is not Write-Write Stable with respect to Stack.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Stack.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Stack.head.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Stack.head;                                                                               
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var x_mid: Stack;                                                                                  
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Stack.head[x];                                                                             
 Stack.head[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Stack.head[x] := tmpV;                                                                             
 Stack.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Stack.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Stack.head.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Stack.head;                                                                               
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var x_mid: Stack;                                                                                  
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Stack.head[x];                                                                             
 Stack.head[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Stack.head[x] := tmpV;                                                                             
 Stack.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Stack.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to Stack.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Stack.head.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Stack.head;                                                                               
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Stack.head(t: Tid,x: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.head[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Stack.head(t: Tid,x: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (16.3): Stack.head is not Read-Write Stable with respect to Stack.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (16.3): Stack.head is not Read-Write Stable with respect to Stack.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (16.3): Stack.head is not Read-Write Stable with respect to Stack.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Stack.head.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Stack.head;                                                                               
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Stack.head(u: Tid,y: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Stack.head(u: Tid,y: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (16.3): Stack.head is not Write-Read Stable with respect to Stack.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (16.3): Stack.head is not Write-Read Stable with respect to Stack.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (16.3): Stack.head is not Write-Read Stable with respect to Stack.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Stack.head.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Stack.head;                                                                               
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Stack.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Stack.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Stack.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Stack.head.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Stack.head;                                                                               
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: StackWithCAS;                                                                           
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var x_mid: Stack;                                                                                  
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Stack.head[x];                                                                             
 Stack.head[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Stack.head[x] := tmpV;                                                                             
 StackWithCAS.head[y] := w;                                                                         
 _writeByTPost := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Stack.head.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Stack.head;                                                                               
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: StackWithCAS;                                                                           
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var x_mid: Stack;                                                                                  
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Stack.head[x];                                                                             
 Stack.head[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Stack.head[x] := tmpV;                                                                             
 StackWithCAS.head[y] := w;                                                                         
 _writeByTPost := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Stack.head.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Stack.head;                                                                               
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Stack.head(t: Tid,x: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 StackWithCAS.head[y] := w;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Stack.head(t: Tid,x: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (16.3): Stack.head is not Read-Write Stable with respect to StackWithCAS.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (16.3): Stack.head is not Read-Write Stable with respect to StackWithCAS.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (16.3): Stack.head is not Read-Write Stable with respect to StackWithCAS.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Stack.head.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies Stack.head;                                                                               
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.StackWithCAS.head(u: Tid,y: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Stack.head(t: Tid,x: Stack,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.StackWithCAS.head(u: Tid,y: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Read Stable with respect to Stack.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Read Stable with respect to Stack.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (66.2): StackWithCAS.head is not Write-Read Stable with respect to Stack.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.StackWithCAS.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.StackWithCAS.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := StackWithCAS.head[x];                                                                      
 StackWithCAS.head[x] := v;                                                                         
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 StackWithCAS.head[x] := tmpV;                                                                      
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.StackWithCAS.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := StackWithCAS.head[x];                                                                      
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 StackWithCAS.head[x] := tmpV;                                                                      
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.StackWithCAS.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.StackWithCAS.head(t: Tid,x: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.StackWithCAS.head(t: Tid,x: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Read-Write Stable with respect to Node.item (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.StackWithCAS.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (2.3): Node.item is not Write-Read Stable with respect to StackWithCAS.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (2.3): Node.item is not Write-Read Stable with respect to StackWithCAS.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (2.3): Node.item is not Write-Read Stable with respect to StackWithCAS.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.StackWithCAS.head.Node.item(t: Tid, u: Tid, v: Node, w1: int, w2: int, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpW: int;                                                                                     
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var w2_pre: int;                                                                                   
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w1_pre: int;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v_mid: Node;                                                                                   
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var w2_mid: int;                                                                                   
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var w1_mid: int;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var w2_post: int;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var w1_post: int;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w1: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.item[y];                                                                              
 Node.item[y] := w1;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.item(u: Tid,y: Node,w2: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.item[y] := tmpW;                                                                              
                                                                                                    
 StackWithCAS.head[x] := v;                                                                         
 Node.item[y] := w1;                                                                                
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.item(u: Tid,y: Node,w2: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.StackWithCAS.head.Node.item(t: Tid, u: Tid, v1: Node, v2: Node, w: int, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var v2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var v1_pre: Node;                                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var w_mid: int;                                                                                    
 var v1_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v2_post: Node;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := StackWithCAS.head[x];                                                                      
 StackWithCAS.head[x] := v1;                                                                        
 _writeByTAfterT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 StackWithCAS.head[x] := tmpV;                                                                      
                                                                                                    
 Node.item[y] := w;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v1: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 StackWithCAS.head[x] := v1;                                                                        
 _writeByTAfterUAndT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.StackWithCAS.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.StackWithCAS.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := StackWithCAS.head[x];                                                                      
 StackWithCAS.head[x] := v;                                                                         
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 StackWithCAS.head[x] := tmpV;                                                                      
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.StackWithCAS.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := StackWithCAS.head[x];                                                                      
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 StackWithCAS.head[x] := tmpV;                                                                      
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.StackWithCAS.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.StackWithCAS.head(t: Tid,x: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.StackWithCAS.head(t: Tid,x: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.StackWithCAS.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.3): Node.next is not Write-Read Stable with respect to StackWithCAS.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.3): Node.next is not Write-Read Stable with respect to StackWithCAS.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.3): Node.next is not Write-Read Stable with respect to StackWithCAS.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.StackWithCAS.head.Node.next(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var w2_pre: Node;                                                                                  
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v_mid: Node;                                                                                   
 var w2_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w1: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.next[y];                                                                              
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.next[y] := tmpW;                                                                              
                                                                                                    
 StackWithCAS.head[x] := v;                                                                         
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.StackWithCAS.head.Node.next(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: StackWithCAS, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies StackWithCAS.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var v2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var v1_pre: Node;                                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v1_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Node;                                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v2_post: Node;                                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := StackWithCAS.head[x];                                                                      
 StackWithCAS.head[x] := v1;                                                                        
 _writeByTAfterT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 StackWithCAS.head[x] := tmpV;                                                                      
                                                                                                    
 Node.next[y] := w;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v1: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 StackWithCAS.head[x] := v1;                                                                        
 _writeByTAfterUAndT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.StackWithCAS.head.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Stack._state[y], u);                                                         
 modifies StackWithCAS.head;                                                                        
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.StackWithCAS.head.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Stack._state[y], u);                                                         
 modifies StackWithCAS.head;                                                                        
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := StackWithCAS.head[x];                                                                      
 StackWithCAS.head[x] := v;                                                                         
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 StackWithCAS.head[x] := tmpV;                                                                      
 Stack.head[y] := w;                                                                                
 _writeByTPost := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Stack.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.StackWithCAS.head.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Stack._state[y], u);                                                         
 modifies StackWithCAS.head;                                                                        
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := StackWithCAS.head[x];                                                                      
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 StackWithCAS.head[x] := tmpV;                                                                      
 Stack.head[y] := w;                                                                                
 _writeByTPost := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Stack.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to Stack.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.StackWithCAS.head.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Stack._state[y], u);                                                         
 modifies StackWithCAS.head;                                                                        
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.StackWithCAS.head(t: Tid,x: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.head[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.StackWithCAS.head(t: Tid,x: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Read-Write Stable with respect to Stack.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Read-Write Stable with respect to Stack.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Read-Write Stable with respect to Stack.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.StackWithCAS.head.Stack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Stack._state[y], u);                                                         
 modifies StackWithCAS.head;                                                                        
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Stack.head(u: Tid,y: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Stack.head(u: Tid,y: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (16.3): Stack.head is not Write-Read Stable with respect to StackWithCAS.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (16.3): Stack.head is not Write-Read Stable with respect to StackWithCAS.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (16.3): Stack.head is not Write-Read Stable with respect to StackWithCAS.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.StackWithCAS.head.Stack.head(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: StackWithCAS, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Stack._state[y], u);                                                         
 modifies StackWithCAS.head;                                                                        
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var w2_pre: Node;                                                                                  
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v_mid: Node;                                                                                   
 var w2_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w1: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Stack.head[y];                                                                             
 Stack.head[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Stack.head(u: Tid,y: Stack,w2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Stack.head[y] := tmpW;                                                                             
                                                                                                    
 StackWithCAS.head[x] := v;                                                                         
 Stack.head[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Stack.head(u: Tid,y: Stack,w2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.StackWithCAS.head.Stack.head(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: StackWithCAS, y: Stack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(Stack._state[y], u);                                                         
 modifies StackWithCAS.head;                                                                        
 modifies Stack.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var v2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var v1_pre: Node;                                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v1_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var y_post: Stack;                                                                                 
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v2_post: Node;                                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.head(u: Tid,y: Stack,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := StackWithCAS.head[x];                                                                      
 StackWithCAS.head[x] := v1;                                                                        
 _writeByTAfterT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 StackWithCAS.head[x] := tmpV;                                                                      
                                                                                                    
 Stack.head[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v1: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 StackWithCAS.head[x] := v1;                                                                        
 _writeByTAfterUAndT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.StackWithCAS.head.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies StackWithCAS.head;                                                                        
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.StackWithCAS.head.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies StackWithCAS.head;                                                                        
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: StackWithCAS;                                                                           
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := StackWithCAS.head[x];                                                                      
 StackWithCAS.head[x] := v;                                                                         
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 StackWithCAS.head[x] := tmpV;                                                                      
 StackWithCAS.head[y] := w;                                                                         
 _writeByTPost := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.StackWithCAS.head.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies StackWithCAS.head;                                                                        
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: StackWithCAS;                                                                           
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := StackWithCAS.head[x];                                                                      
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 StackWithCAS.head[x] := tmpV;                                                                      
 StackWithCAS.head[y] := w;                                                                         
 _writeByTPost := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.StackWithCAS.head.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies StackWithCAS.head;                                                                        
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.StackWithCAS.head(t: Tid,x: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 StackWithCAS.head[y] := w;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.StackWithCAS.head(t: Tid,x: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Read-Write Stable with respect to StackWithCAS.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Read-Write Stable with respect to StackWithCAS.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (66.2): StackWithCAS.head is not Read-Write Stable with respect to StackWithCAS.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.StackWithCAS.head.StackWithCAS.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: StackWithCAS, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies StackWithCAS.head;                                                                        
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.StackWithCAS.head(u: Tid,y: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 StackWithCAS.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.StackWithCAS.head(u: Tid,y: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Read Stable with respect to StackWithCAS.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Read Stable with respect to StackWithCAS.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (66.2): StackWithCAS.head is not Write-Read Stable with respect to StackWithCAS.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.StackWithCAS.head.StackWithCAS.head(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: StackWithCAS, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies StackWithCAS.head;                                                                        
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var w2_pre: Node;                                                                                  
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var y_pre: StackWithCAS;                                                                           
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v_mid: Node;                                                                                   
 var w2_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: StackWithCAS;                                                                           
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w1: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := StackWithCAS.head[y];                                                                      
 StackWithCAS.head[y] := w1;                                                                        
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 StackWithCAS.head[y] := tmpW;                                                                      
                                                                                                    
 StackWithCAS.head[x] := v;                                                                         
 StackWithCAS.head[y] := w1;                                                                        
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.StackWithCAS.head.StackWithCAS.head(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: StackWithCAS, y: StackWithCAS)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(StackWithCAS._state[x], t);                                                  
 requires isAccessible(StackWithCAS._state[y], u);                                                  
 modifies StackWithCAS.head;                                                                        
 modifies StackWithCAS.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: StackWithCAS;                                                                           
 var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                     
 var StackWithCAS.head_pre: [StackWithCAS]Node;                                                     
 var v2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                           
 var Node._state_pre: [Node]State;                                                                  
 var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                           
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var v1_pre: Node;                                                                                  
 var $pc_pre: Phase;                                                                                
 var y_pre: StackWithCAS;                                                                           
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var StackWithCAS._state_pre: [StackWithCAS]State;                                                  
 var Stack._state_pre: [Stack]State;                                                                
 var Stack.head_pre: [Stack]Node;                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack.head_mid: [Stack]Node;                                                                   
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var StackWithCAS._lock_mid: [StackWithCAS]Tid;                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var StackWithCAS.head_nextValue_mid: [StackWithCAS]Node;                                           
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var x_mid: StackWithCAS;                                                                           
 var v1_mid: Node;                                                                                  
 var StackWithCAS._state_mid: [StackWithCAS]State;                                                  
 var y_mid: StackWithCAS;                                                                           
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var StackWithCAS.head_mid: [StackWithCAS]Node;                                                     
 var StackWithCAS.head_nextThread_mid: [StackWithCAS]Tid;                                           
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var StackWithCAS._state_post: [StackWithCAS]State;                                                 
 var Stack.head_post: [Stack]Node;                                                                  
 var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                          
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: StackWithCAS;                                                                          
 var $pc_post: Phase;                                                                               
 var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                    
 var Node._lock_post: [Node]Tid;                                                                    
 var StackWithCAS.head_post: [StackWithCAS]Node;                                                    
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                          
 var x_post: StackWithCAS;                                                                          
 var v2_post: Node;                                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.StackWithCAS.head(u: Tid,y: StackWithCAS,w: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := StackWithCAS.head[x];                                                                      
 StackWithCAS.head[x] := v1;                                                                        
 _writeByTAfterT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 StackWithCAS.head[x] := tmpV;                                                                      
                                                                                                    
 StackWithCAS.head[y] := w;                                                                         
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.head_mid == Stack.head && Stack._lock_mid == Stack._lock && StackWithCAS._state_mid == StackWithCAS._state && StackWithCAS.head_mid == StackWithCAS.head && StackWithCAS._lock_mid == StackWithCAS._lock && StackWithCAS.head_nextThread_mid == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_mid == StackWithCAS.head_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v1: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 StackWithCAS.head[x] := v1;                                                                        
 _writeByTAfterUAndT := WriteEval.StackWithCAS.head(t: Tid,x: StackWithCAS,v2: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.head_post == Stack.head && Stack._lock_post == Stack._lock && StackWithCAS._state_post == StackWithCAS._state && StackWithCAS.head_post == StackWithCAS.head && StackWithCAS._lock_post == StackWithCAS._lock && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
requires ValidTid(tid);                                                                             
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Stack._state;                                                                              
modifies Stack.head;                                                                                
modifies Stack._lock;                                                                               
modifies StackWithCAS._state;                                                                       
modifies StackWithCAS.head;                                                                         
modifies StackWithCAS._lock;                                                                        
modifies StackWithCAS.head_nextThread;                                                              
modifies StackWithCAS.head_nextValue;                                                               
ensures StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
ensures Y(tid , old(Node._state), old(Node.item), old(Node.next), old(Node._lock), old(Stack._state), old(Stack.head), old(Stack._lock), old(StackWithCAS._state), old(StackWithCAS.head), old(StackWithCAS._lock), old(StackWithCAS.head_nextThread), old(StackWithCAS.head_nextValue) , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
                                                                                                    
// Node.item:                                                                                       
                                                                                                    
function {:inline} Y_Node.item(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.item(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)), _R)) ==> (Node.item[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.item(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var newValue_yield: int;                                                                            
var u_yield: Tid;                                                                                   
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.item(u: Tid,this: Node,newValue: int,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.item(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.item(tid, this, Node.item[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Transitive(tid : Tid, this: Node, newValue : int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.head_p: [Stack]Node, Stack._lock_p: [Stack]Tid, StackWithCAS._state_p: [StackWithCAS]State, StackWithCAS.head_p: [StackWithCAS]Node, StackWithCAS._lock_p: [StackWithCAS]Tid, StackWithCAS.head_nextThread_p: [StackWithCAS]Tid, StackWithCAS.head_nextValue_p: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                      
var StackWithCAS.head_pre: [StackWithCAS]Node;                                                      
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var newValue_pre: int;                                                                              
var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                            
var Node._state_pre: [Node]State;                                                                   
var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                            
var tid_pre: Tid;                                                                                   
var Stack._lock_pre: [Stack]Tid;                                                                    
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var StackWithCAS._state_pre: [StackWithCAS]State;                                                   
var Stack._state_pre: [Stack]State;                                                                 
var Stack.head_pre: [Stack]Node;                                                                    
var Node.item_pre: [Node]int;                                                                       
                                                                                                    
var StackWithCAS._state_post: [StackWithCAS]State;                                                  
var Stack.head_post: [Stack]Node;                                                                   
var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                           
var Stack._state_post: [Stack]State;                                                                
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var newValue_post: int;                                                                             
var $pc_post: Phase;                                                                                
var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                     
var Node._lock_post: [Node]Tid;                                                                     
var StackWithCAS.head_post: [StackWithCAS]Node;                                                     
var tid_post: Tid;                                                                                  
var Stack._lock_post: [Stack]Tid;                                                                   
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                           
var this_post: Node;                                                                                
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 assume Y_Node.item(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Stack._state_post == Stack._state_p && Stack.head_post == Stack.head_p && Stack._lock_post == Stack._lock_p && StackWithCAS._state_post == StackWithCAS._state_p && StackWithCAS.head_post == StackWithCAS.head_p && StackWithCAS._lock_post == StackWithCAS._lock_p && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread_p && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.item(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
// Node.next:                                                                                       
                                                                                                    
function {:inline} Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.next(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)), _R)) ==> (Node.next[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var u_yield: Tid;                                                                                   
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var newValue_yield: Node;                                                                           
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.next(u: Tid,this: Node,newValue: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, Node.next[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Transitive(tid : Tid, this: Node, newValue : Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.head_p: [Stack]Node, Stack._lock_p: [Stack]Tid, StackWithCAS._state_p: [StackWithCAS]State, StackWithCAS.head_p: [StackWithCAS]Node, StackWithCAS._lock_p: [StackWithCAS]Tid, StackWithCAS.head_nextThread_p: [StackWithCAS]Tid, StackWithCAS.head_nextValue_p: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                      
var StackWithCAS.head_pre: [StackWithCAS]Node;                                                      
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                            
var Node._state_pre: [Node]State;                                                                   
var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                            
var tid_pre: Tid;                                                                                   
var Stack._lock_pre: [Stack]Tid;                                                                    
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var StackWithCAS._state_pre: [StackWithCAS]State;                                                   
var Stack._state_pre: [Stack]State;                                                                 
var Stack.head_pre: [Stack]Node;                                                                    
var Node.item_pre: [Node]int;                                                                       
                                                                                                    
var StackWithCAS._state_post: [StackWithCAS]State;                                                  
var Stack.head_post: [Stack]Node;                                                                   
var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                           
var Stack._state_post: [Stack]State;                                                                
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.item_post: [Node]int;                                                                      
var $pc_post: Phase;                                                                                
var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                     
var Node._lock_post: [Node]Tid;                                                                     
var StackWithCAS.head_post: [StackWithCAS]Node;                                                     
var tid_post: Tid;                                                                                  
var Stack._lock_post: [Stack]Tid;                                                                   
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                           
var this_post: Node;                                                                                
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 assume Y_Node.next(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Stack._state_post == Stack._state_p && Stack.head_post == Stack.head_p && Stack._lock_post == Stack._lock_p && StackWithCAS._state_post == StackWithCAS._state_p && StackWithCAS.head_post == StackWithCAS.head_p && StackWithCAS._lock_post == StackWithCAS._lock_p && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread_p && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.next(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
// Node._lock:                                                                                      
                                                                                                    
function {:inline} Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)), _R)) ==> (Node._lock[this] == newValue))
 &&(((Node._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var u_yield: Tid;                                                                                   
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node._lock(u: Tid,this: Node,newValue: Tid,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)));
 assume leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)), _N);
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, Node._lock[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Transitive(tid : Tid, this: Node, newValue : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.head_p: [Stack]Node, Stack._lock_p: [Stack]Tid, StackWithCAS._state_p: [StackWithCAS]State, StackWithCAS.head_p: [StackWithCAS]Node, StackWithCAS._lock_p: [StackWithCAS]Tid, StackWithCAS.head_nextThread_p: [StackWithCAS]Tid, StackWithCAS.head_nextValue_p: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                      
var StackWithCAS.head_pre: [StackWithCAS]Node;                                                      
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                            
var Node._state_pre: [Node]State;                                                                   
var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                            
var tid_pre: Tid;                                                                                   
var Stack._lock_pre: [Stack]Tid;                                                                    
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var StackWithCAS._state_pre: [StackWithCAS]State;                                                   
var Stack._state_pre: [Stack]State;                                                                 
var Stack.head_pre: [Stack]Node;                                                                    
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
                                                                                                    
var StackWithCAS._state_post: [StackWithCAS]State;                                                  
var Stack.head_post: [Stack]Node;                                                                   
var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                           
var Stack._state_post: [Stack]State;                                                                
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var $pc_post: Phase;                                                                                
var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                     
var Node._lock_post: [Node]Tid;                                                                     
var StackWithCAS.head_post: [StackWithCAS]Node;                                                     
var tid_post: Tid;                                                                                  
var Stack._lock_post: [Stack]Tid;                                                                   
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                           
var this_post: Node;                                                                                
var newValue_post: Tid;                                                                             
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 assume Y_Node._lock(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Stack._state_post == Stack._state_p && Stack.head_post == Stack.head_p && Stack._lock_post == Stack._lock_p && StackWithCAS._state_post == StackWithCAS._state_p && StackWithCAS.head_post == StackWithCAS.head_p && StackWithCAS._lock_post == StackWithCAS._lock_p && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread_p && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
// Stack.head:                                                                                      
                                                                                                    
function {:inline} Y_Stack.head(tid : Tid, this: Stack, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 ((isAccessible(Stack._state[this], tid) && leq(m#moverPath(ReadEval.Stack.head(tid: Tid,this: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)), _R)) ==> (Stack.head[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Stack.head(tid : Tid, this: Stack, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Stack.head.Subsumes.W(tid : Tid, u : Tid, this: Stack, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var Node.item_yield: [Node]int;                                                                     
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var this_yield: Stack;                                                                              
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var u_yield: Tid;                                                                                   
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var newValue_yield: Node;                                                                           
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Stack._state[this], tid);                                                      
 assume isAccessible(Stack._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Stack.head(u: Tid,this: Stack,newValue: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Stack.head(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Stack.head.Reflexive(tid : Tid, this: Stack , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var Node.item_yield: [Node]int;                                                                     
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var this_yield: Stack;                                                                              
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Stack._state[this], tid);                                                      
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Stack.head(tid, this, Stack.head[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Stack.head.Transitive(tid : Tid, this: Stack, newValue : Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.head_p: [Stack]Node, Stack._lock_p: [Stack]Tid, StackWithCAS._state_p: [StackWithCAS]State, StackWithCAS.head_p: [StackWithCAS]Node, StackWithCAS._lock_p: [StackWithCAS]Tid, StackWithCAS.head_nextThread_p: [StackWithCAS]Tid, StackWithCAS.head_nextValue_p: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                      
var StackWithCAS.head_pre: [StackWithCAS]Node;                                                      
var $recorded.state_pre: int;                                                                       
var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                            
var Node._state_pre: [Node]State;                                                                   
var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                            
var this_pre: Stack;                                                                                
var tid_pre: Tid;                                                                                   
var Stack._lock_pre: [Stack]Tid;                                                                    
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var StackWithCAS._state_pre: [StackWithCAS]State;                                                   
var Stack._state_pre: [Stack]State;                                                                 
var Stack.head_pre: [Stack]Node;                                                                    
var Node.item_pre: [Node]int;                                                                       
                                                                                                    
var StackWithCAS._state_post: [StackWithCAS]State;                                                  
var Stack.head_post: [Stack]Node;                                                                   
var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                           
var Stack._state_post: [Stack]State;                                                                
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var this_post: Stack;                                                                               
var Node.item_post: [Node]int;                                                                      
var $pc_post: Phase;                                                                                
var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                     
var Node._lock_post: [Node]Tid;                                                                     
var StackWithCAS.head_post: [StackWithCAS]Node;                                                     
var tid_post: Tid;                                                                                  
var Stack._lock_post: [Stack]Tid;                                                                   
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                           
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Stack._state[this], tid);                                                      
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 assume Y_Stack.head(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Stack._state_post == Stack._state_p && Stack.head_post == Stack.head_p && Stack._lock_post == Stack._lock_p && StackWithCAS._state_post == StackWithCAS._state_p && StackWithCAS.head_post == StackWithCAS.head_p && StackWithCAS._lock_post == StackWithCAS._lock_p && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread_p && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Stack.head(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
// Stack._lock:                                                                                     
                                                                                                    
function {:inline} Y_Stack._lock(tid : Tid, this: Stack, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 ((isAccessible(Stack._state[this], tid) && leq(m#moverPath(ReadEval.Stack._lock(tid: Tid,this: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)), _R)) ==> (Stack._lock[this] == newValue))
 &&(((Stack._lock[this]==tid)==(newValue==tid)))                                                    
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Stack._lock(tid : Tid, this: Stack, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Stack._lock.Subsumes.W(tid : Tid, u : Tid, this: Stack, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var this_yield: Stack;                                                                              
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var u_yield: Tid;                                                                                   
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Stack._state[this], tid);                                                      
 assume isAccessible(Stack._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Stack._lock(u: Tid,this: Stack,newValue: Tid,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)));
 assume leq(m#moverPath(ReadEval.Stack._lock(tid: Tid,this: Stack,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)), _N);
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Stack._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Stack._lock.Reflexive(tid : Tid, this: Stack , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var Node.item_yield: [Node]int;                                                                     
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var this_yield: Stack;                                                                              
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Stack._state[this], tid);                                                      
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Stack._lock(tid, this, Stack._lock[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Stack._lock.Transitive(tid : Tid, this: Stack, newValue : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.head_p: [Stack]Node, Stack._lock_p: [Stack]Tid, StackWithCAS._state_p: [StackWithCAS]State, StackWithCAS.head_p: [StackWithCAS]Node, StackWithCAS._lock_p: [StackWithCAS]Tid, StackWithCAS.head_nextThread_p: [StackWithCAS]Tid, StackWithCAS.head_nextValue_p: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                      
var StackWithCAS.head_pre: [StackWithCAS]Node;                                                      
var $recorded.state_pre: int;                                                                       
var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                            
var Node._state_pre: [Node]State;                                                                   
var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                            
var this_pre: Stack;                                                                                
var tid_pre: Tid;                                                                                   
var Stack._lock_pre: [Stack]Tid;                                                                    
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var StackWithCAS._state_pre: [StackWithCAS]State;                                                   
var Stack._state_pre: [Stack]State;                                                                 
var Stack.head_pre: [Stack]Node;                                                                    
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
                                                                                                    
var StackWithCAS._state_post: [StackWithCAS]State;                                                  
var Stack.head_post: [Stack]Node;                                                                   
var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                           
var Stack._state_post: [Stack]State;                                                                
var $recorded.state_post: int;                                                                      
var this_post: Stack;                                                                               
var Node.item_post: [Node]int;                                                                      
var $pc_post: Phase;                                                                                
var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                     
var Node._lock_post: [Node]Tid;                                                                     
var StackWithCAS.head_post: [StackWithCAS]Node;                                                     
var tid_post: Tid;                                                                                  
var Stack._lock_post: [Stack]Tid;                                                                   
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                           
var newValue_post: Tid;                                                                             
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Stack._state[this], tid);                                                      
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 assume Y_Stack._lock(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Stack._state_post == Stack._state_p && Stack.head_post == Stack.head_p && Stack._lock_post == Stack._lock_p && StackWithCAS._state_post == StackWithCAS._state_p && StackWithCAS.head_post == StackWithCAS.head_p && StackWithCAS._lock_post == StackWithCAS._lock_p && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread_p && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Stack._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
// StackWithCAS.head:                                                                               
                                                                                                    
function {:inline} Y_StackWithCAS.head(tid : Tid, this: StackWithCAS, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 ((isAccessible(StackWithCAS._state[this], tid) && leq(m#moverPath(ReadEval.StackWithCAS.head(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)), _R)) ==> (StackWithCAS.head[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_StackWithCAS.head(tid : Tid, this: StackWithCAS, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_StackWithCAS.head.Subsumes.W(tid : Tid, u : Tid, this: StackWithCAS, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var Node.item_yield: [Node]int;                                                                     
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var u_yield: Tid;                                                                                   
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var this_yield: StackWithCAS;                                                                       
var newValue_yield: Node;                                                                           
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(StackWithCAS._state[this], tid);                                               
 assume isAccessible(StackWithCAS._state[this], u);                                                 
 assume !isError(m#moverPath(WriteEval.StackWithCAS.head(u: Tid,this: StackWithCAS,newValue: Node,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_StackWithCAS.head(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_StackWithCAS.head.Reflexive(tid : Tid, this: StackWithCAS , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var Node.item_yield: [Node]int;                                                                     
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var this_yield: StackWithCAS;                                                                       
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(StackWithCAS._state[this], tid);                                               
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_StackWithCAS.head(tid, this, StackWithCAS.head[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_StackWithCAS.head.Transitive(tid : Tid, this: StackWithCAS, newValue : Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.head_p: [Stack]Node, Stack._lock_p: [Stack]Tid, StackWithCAS._state_p: [StackWithCAS]State, StackWithCAS.head_p: [StackWithCAS]Node, StackWithCAS._lock_p: [StackWithCAS]Tid, StackWithCAS.head_nextThread_p: [StackWithCAS]Tid, StackWithCAS.head_nextValue_p: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                      
var StackWithCAS.head_pre: [StackWithCAS]Node;                                                      
var this_pre: StackWithCAS;                                                                         
var $recorded.state_pre: int;                                                                       
var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                            
var Node._state_pre: [Node]State;                                                                   
var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                            
var tid_pre: Tid;                                                                                   
var Stack._lock_pre: [Stack]Tid;                                                                    
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var StackWithCAS._state_pre: [StackWithCAS]State;                                                   
var Stack._state_pre: [Stack]State;                                                                 
var Stack.head_pre: [Stack]Node;                                                                    
var Node.item_pre: [Node]int;                                                                       
                                                                                                    
var StackWithCAS._state_post: [StackWithCAS]State;                                                  
var Stack.head_post: [Stack]Node;                                                                   
var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                           
var Stack._state_post: [Stack]State;                                                                
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.item_post: [Node]int;                                                                      
var this_post: StackWithCAS;                                                                        
var $pc_post: Phase;                                                                                
var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                     
var Node._lock_post: [Node]Tid;                                                                     
var StackWithCAS.head_post: [StackWithCAS]Node;                                                     
var tid_post: Tid;                                                                                  
var Stack._lock_post: [Stack]Tid;                                                                   
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                           
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(StackWithCAS._state[this], tid);                                               
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 assume Y_StackWithCAS.head(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Stack._state_post == Stack._state_p && Stack.head_post == Stack.head_p && Stack._lock_post == Stack._lock_p && StackWithCAS._state_post == StackWithCAS._state_p && StackWithCAS.head_post == StackWithCAS.head_p && StackWithCAS._lock_post == StackWithCAS._lock_p && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread_p && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_StackWithCAS.head(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
// StackWithCAS._lock:                                                                              
                                                                                                    
function {:inline} Y_StackWithCAS._lock(tid : Tid, this: StackWithCAS, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 ((isAccessible(StackWithCAS._state[this], tid) && leq(m#moverPath(ReadEval.StackWithCAS._lock(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)), _R)) ==> (StackWithCAS._lock[this] == newValue))
 &&(((StackWithCAS._lock[this]==tid)==(newValue==tid)))                                             
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_StackWithCAS._lock(tid : Tid, this: StackWithCAS, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_StackWithCAS._lock.Subsumes.W(tid : Tid, u : Tid, this: StackWithCAS, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var u_yield: Tid;                                                                                   
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var this_yield: StackWithCAS;                                                                       
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(StackWithCAS._state[this], tid);                                               
 assume isAccessible(StackWithCAS._state[this], u);                                                 
 assume !isError(m#moverPath(WriteEval.StackWithCAS._lock(u: Tid,this: StackWithCAS,newValue: Tid,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)));
 assume leq(m#moverPath(ReadEval.StackWithCAS._lock(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)), _N);
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_StackWithCAS._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_StackWithCAS._lock.Reflexive(tid : Tid, this: StackWithCAS , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var Node.item_yield: [Node]int;                                                                     
var StackWithCAS._state_yield: [StackWithCAS]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var StackWithCAS._lock_yield: [StackWithCAS]Tid;                                                    
var StackWithCAS.head_nextThread_yield: [StackWithCAS]Tid;                                          
var Stack.head_yield: [Stack]Node;                                                                  
var Node._lock_yield: [Node]Tid;                                                                    
var StackWithCAS.head_yield: [StackWithCAS]Node;                                                    
var this_yield: StackWithCAS;                                                                       
var Stack._state_yield: [Stack]State;                                                               
var StackWithCAS.head_nextValue_yield: [StackWithCAS]Node;                                          
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(StackWithCAS._state[this], tid);                                               
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.head_yield == Stack.head && Stack._lock_yield == Stack._lock && StackWithCAS._state_yield == StackWithCAS._state && StackWithCAS.head_yield == StackWithCAS.head && StackWithCAS._lock_yield == StackWithCAS._lock && StackWithCAS.head_nextThread_yield == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_yield == StackWithCAS.head_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_StackWithCAS._lock(tid, this, StackWithCAS._lock[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_StackWithCAS._lock.Transitive(tid : Tid, this: StackWithCAS, newValue : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.head_p: [Stack]Node, Stack._lock_p: [Stack]Tid, StackWithCAS._state_p: [StackWithCAS]State, StackWithCAS.head_p: [StackWithCAS]Node, StackWithCAS._lock_p: [StackWithCAS]Tid, StackWithCAS.head_nextThread_p: [StackWithCAS]Tid, StackWithCAS.head_nextValue_p: [StackWithCAS]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var StackWithCAS._lock_pre: [StackWithCAS]Tid;                                                      
var StackWithCAS.head_pre: [StackWithCAS]Node;                                                      
var this_pre: StackWithCAS;                                                                         
var $recorded.state_pre: int;                                                                       
var StackWithCAS.head_nextThread_pre: [StackWithCAS]Tid;                                            
var Node._state_pre: [Node]State;                                                                   
var StackWithCAS.head_nextValue_pre: [StackWithCAS]Node;                                            
var tid_pre: Tid;                                                                                   
var Stack._lock_pre: [Stack]Tid;                                                                    
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var StackWithCAS._state_pre: [StackWithCAS]State;                                                   
var Stack._state_pre: [Stack]State;                                                                 
var Stack.head_pre: [Stack]Node;                                                                    
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
                                                                                                    
var StackWithCAS._state_post: [StackWithCAS]State;                                                  
var Stack.head_post: [Stack]Node;                                                                   
var StackWithCAS.head_nextValue_post: [StackWithCAS]Node;                                           
var Stack._state_post: [Stack]State;                                                                
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var this_post: StackWithCAS;                                                                        
var $pc_post: Phase;                                                                                
var StackWithCAS._lock_post: [StackWithCAS]Tid;                                                     
var Node._lock_post: [Node]Tid;                                                                     
var StackWithCAS.head_post: [StackWithCAS]Node;                                                     
var tid_post: Tid;                                                                                  
var Stack._lock_post: [Stack]Tid;                                                                   
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var StackWithCAS.head_nextThread_post: [StackWithCAS]Tid;                                           
var newValue_post: Tid;                                                                             
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.head_pre == Stack.head && Stack._lock_pre == Stack._lock && StackWithCAS._state_pre == StackWithCAS._state && StackWithCAS.head_pre == StackWithCAS.head && StackWithCAS._lock_pre == StackWithCAS._lock && StackWithCAS.head_nextThread_pre == StackWithCAS.head_nextThread && StackWithCAS.head_nextValue_pre == StackWithCAS.head_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(StackWithCAS._state[this], tid);                                               
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
 assume Y_StackWithCAS._lock(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.head_p, Stack._lock_p, StackWithCAS._state_p, StackWithCAS.head_p, StackWithCAS._lock_p, StackWithCAS.head_nextThread_p, StackWithCAS.head_nextValue_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Stack._state_post == Stack._state_p && Stack.head_post == Stack.head_p && Stack._lock_post == Stack._lock_p && StackWithCAS._state_post == StackWithCAS._state_p && StackWithCAS.head_post == StackWithCAS.head_p && StackWithCAS._lock_post == StackWithCAS._lock_p && StackWithCAS.head_nextThread_post == StackWithCAS.head_nextThread_p && StackWithCAS.head_nextValue_post == StackWithCAS.head_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_StackWithCAS._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue);
}                                                                                                   
// StackWithCAS.head_nextThread:                                                                    
                                                                                                    
function {:inline} Y_StackWithCAS.head_nextThread(tid : Tid, this: StackWithCAS, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 ((isAccessible(StackWithCAS._state[this], tid) && leq(m#moverPath(ReadEval.StackWithCAS.head_nextThread(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)), _R)) ==> (StackWithCAS.head_nextThread[this] == newValue))
 &&(((StackWithCAS.head_nextThread[this]==tid)==>(newValue==tid)))                                  
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_StackWithCAS.head_nextThread(tid : Tid, this: StackWithCAS, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// StackWithCAS.head_nextValue:                                                                     
                                                                                                    
function {:inline} Y_StackWithCAS.head_nextValue(tid : Tid, this: StackWithCAS, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 ((isAccessible(StackWithCAS._state[this], tid) && leq(m#moverPath(ReadEval.StackWithCAS.head_nextValue(tid: Tid,this: StackWithCAS,Node._state,Node.item,Node.next,Node._lock,Stack._state,Stack.head,Stack._lock,StackWithCAS._state,StackWithCAS.head,StackWithCAS._lock,StackWithCAS.head_nextThread,StackWithCAS.head_nextValue)), _R)) ==> (StackWithCAS.head_nextValue[this] == newValue))
 &&(((StackWithCAS.head_nextThread[this]==tid)==>(newValue==StackWithCAS.head_nextValue[this])))    
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_StackWithCAS.head_nextValue(tid : Tid, this: StackWithCAS, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.head: [Stack]Node, Stack._lock: [Stack]Tid, StackWithCAS._state: [StackWithCAS]State, StackWithCAS.head: [StackWithCAS]Node, StackWithCAS._lock: [StackWithCAS]Tid, StackWithCAS.head_nextThread: [StackWithCAS]Tid, StackWithCAS.head_nextValue: [StackWithCAS]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.head_p: [Stack]Node, Stack._lock_p: [Stack]Tid, StackWithCAS._state_p: [StackWithCAS]State, StackWithCAS.head_p: [StackWithCAS]Node, StackWithCAS._lock_p: [StackWithCAS]Tid, StackWithCAS.head_nextThread_p: [StackWithCAS]Tid, StackWithCAS.head_nextValue_p: [StackWithCAS]Node): bool
{                                                                                                   
 (forall this: Node :: Y_Node.item(tid : Tid, this, Node.item_p[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue))
 && (forall this: Node :: Y_Node.next(tid : Tid, this, Node.next_p[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue))
 && (forall this: Node :: Y_Node._lock(tid : Tid, this, Node._lock_p[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue))
 && (forall this: Stack :: Y_Stack.head(tid : Tid, this, Stack.head_p[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue))
 && (forall this: Stack :: Y_Stack._lock(tid : Tid, this, Stack._lock_p[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue))
 && (forall this: StackWithCAS :: Y_StackWithCAS.head(tid : Tid, this, StackWithCAS.head_p[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue))
 && (forall this: StackWithCAS :: Y_StackWithCAS._lock(tid : Tid, this, StackWithCAS._lock_p[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue))
 && (forall this: StackWithCAS :: Y_StackWithCAS.head_nextThread(tid : Tid, this, StackWithCAS.head_nextThread_p[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue))
 && (forall this: StackWithCAS :: Y_StackWithCAS.head_nextValue(tid : Tid, this, StackWithCAS.head_nextValue_p[this] , Node._state, Node.item, Node.next, Node._lock, Stack._state, Stack.head, Stack._lock, StackWithCAS._state, StackWithCAS.head, StackWithCAS._lock, StackWithCAS.head_nextThread, StackWithCAS.head_nextValue))
 && (forall _i : Node :: isShared(Node._state[_i]) ==> isShared(Node._state_p[_i]))                 
 && (forall _i : Node :: isLocal(Node._state[_i], tid) <==> isLocal(Node._state_p[_i], tid))        
 && (forall _i : Stack :: isShared(Stack._state[_i]) ==> isShared(Stack._state_p[_i]))              
 && (forall _i : Stack :: isLocal(Stack._state[_i], tid) <==> isLocal(Stack._state_p[_i], tid))     
 && (forall _i : StackWithCAS :: isShared(StackWithCAS._state[_i]) ==> isShared(StackWithCAS._state_p[_i]))
 && (forall _i : StackWithCAS :: isLocal(StackWithCAS._state[_i], tid) <==> isLocal(StackWithCAS._state_p[_i], tid))
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 2015.1-2325.2: (Method:18.3)
// 2032.1-2032.24: (18.3): Bad tid
// 2033.1-2033.39: (18.3): this is not global
// 2170.1-2170.29: (21.5): Cannot have potential null deference in left-mover part.
// 2174.1-2174.27: (21.5): Reduction failure
// 2176.2-2178.2: (class anchor.sink.VarDeclStmt:22.5)
// 2179.2-2187.39: (class anchor.sink.Alloc:22.5)
// 2188.2-2190.2: (class anchor.sink.VarDeclStmt:22.5)
// 2191.2-2208.27: (class anchor.sink.Read:22.5)
// 2203.1-2203.29: (22.5): Cannot have potential null deference in left-mover part.
// 2207.1-2207.27: (22.5): Reduction failure
// 2211.2-2213.2: (class anchor.sink.VarDeclStmt:22.5)
// 2214.2-2216.2: (class anchor.sink.VarDeclStmt:22.5)
// 2217.2-2219.2: (class anchor.sink.VarDeclStmt:22.5)
// 2220.2-2223.19: (class anchor.sink.Assign:22.5)
// 2224.2-2227.19: (class anchor.sink.Assign:22.5)
// 2228.2-2231.19: (class anchor.sink.Assign:22.5)
// 2232.2-2235.34: (class anchor.sink.Assume:7.3)
// 2236.2-2239.42: (class anchor.sink.Assume:7.3)
// 2241.2-2257.34: (class anchor.sink.Write:8.5)
// 2253.1-2253.32: (8.5): Cannot have potential null deference in left-mover part.
// 2256.1-2256.27: (8.5): Reduction failure
// 2259.2-2280.2: (class anchor.sink.Write:9.5)
// 2271.1-2271.32: (9.5): Cannot have potential null deference in left-mover part.
// 2274.1-2274.27: (9.5): Reduction failure
// 2278.1-2278.63: (9.5): next$253 became shared, but next$253.next may not be shared.
// 2281.2-2284.23: (class anchor.sink.Break:7.29)
// 2287.2-2308.2: (class anchor.sink.Write:23.5)
// 2299.1-2299.29: (23.5): Cannot have potential null deference in left-mover part.
// 2302.1-2302.27: (23.5): Reduction failure
// 2306.1-2306.59: (23.5): node became shared, but node.next may not be shared.
// 2312.1-2312.29: (24.5): Cannot have potential null deference in left-mover part.
// 2314.1-2314.34: (24.5): lock not held
// 2316.1-2316.27: (24.5): Reduction failure
// 2318.2-2324.9: (class anchor.sink.Return:20.29)
// 2326.1-2840.2: (Method:27.5)
// 2343.1-2343.24: (27.5): Bad tid
// 2344.1-2344.39: (27.5): this is not global
// 2617.1-2617.29: (30.9): Cannot have potential null deference in left-mover part.
// 2621.1-2621.27: (30.9): Reduction failure
// 2625.2-2629.14: (class anchor.sink.While:31.9)
// 2631.1-2631.27: (27.5): Bad tid
// 2632.1-2632.42: (27.5): this is not global
// 2634.233-2635.81: (31.9): invariant holds(this, tid) may not hold
// 2635.81-2636.18: (31.9): invariant NextSpecStep(0) may not hold
// 2637.1-2637.374: (31.9): Loop does not preserve yields_as annotation for field item
// 2638.1-2638.374: (31.9): Loop does not preserve yields_as annotation for field next
// 2639.1-2639.377: (31.9): Loop does not preserve yields_as annotation for field head
// 2640.1-2640.398: (31.9): Loop does not preserve yields_as annotation for field head
// 2641.1-2641.33: (31.9): Phase must be invariant at loop head
// 2642.1-2642.30: (31.9): Potentially infinite loop cannot be in post-commit phase.
// 2644.3-2646.3: (class anchor.sink.VarDeclStmt:31.26)
// 2647.3-2649.3: (class anchor.sink.VarDeclStmt:31.16)
// 2650.3-2667.28: (class anchor.sink.Read:31.16)
// 2662.1-2662.30: (31.16): Cannot have potential null deference in left-mover part.
// 2666.1-2666.28: (31.16): Reduction failure
// 2668.3-2671.29: (class anchor.sink.Assign:31.26)
// 2673.4-2676.10: (class anchor.sink.Break:31.9)
// 2682.1-2682.30: (35.13): Cannot have potential null deference in left-mover part.
// 2684.1-2684.35: (35.13): lock not held
// 2686.1-2686.28: (35.13): Reduction failure
// 2688.3-2696.43: (class anchor.sink.Yield:36.13)
// 2700.1-2700.30: (37.13): Cannot have potential null deference in left-mover part.
// 2704.1-2704.28: (37.13): Reduction failure
// 2708.1-2708.30: (31.9): Phase must be invariant at loop head
// 2710.2-2712.2: (class anchor.sink.VarDeclStmt:39.9)
// 2713.2-2715.2: (class anchor.sink.VarDeclStmt:39.9)
// 2716.2-2733.27: (class anchor.sink.Read:39.9)
// 2728.1-2728.29: (39.9): Cannot have potential null deference in left-mover part.
// 2732.1-2732.27: (39.9): Reduction failure
// 2734.2-2751.27: (class anchor.sink.Read:39.9)
// 2746.1-2746.28: (39.9): Cannot have potential null deference in left-mover part.
// 2750.1-2750.27: (39.9): Reduction failure
// 2752.2-2754.2: (class anchor.sink.VarDeclStmt:40.9)
// 2755.2-2757.2: (class anchor.sink.VarDeclStmt:40.9)
// 2758.2-2775.27: (class anchor.sink.Read:40.9)
// 2770.1-2770.29: (40.9): Cannot have potential null deference in left-mover part.
// 2774.1-2774.27: (40.9): Reduction failure
// 2776.2-2793.26: (class anchor.sink.Read:40.9)
// 2788.1-2788.28: (40.9): Cannot have potential null deference in left-mover part.
// 2792.1-2792.27: (40.9): Reduction failure
// 2795.2-2816.2: (class anchor.sink.Write:40.9)
// 2807.1-2807.29: (40.9): Cannot have potential null deference in left-mover part.
// 2810.1-2810.27: (40.9): Reduction failure
// 2814.1-2814.59: (40.9): tmp5 became shared, but tmp5.next may not be shared.
// 2820.1-2820.29: (41.9): Cannot have potential null deference in left-mover part.
// 2822.1-2822.34: (41.9): lock not held
// 2824.1-2824.27: (41.9): Reduction failure
// 2826.2-2832.9: (class anchor.sink.Return:42.9)
// 2833.2-2839.9: (class anchor.sink.Return:29.22)
// 2841.1-3363.2: (Method:45.5)
// 2858.1-2858.24: (45.5): Bad tid
// 2859.1-2859.39: (45.5): this is not global
// 3135.2-3139.14: (class anchor.sink.While:48.9)
// 3141.1-3141.27: (45.5): Bad tid
// 3142.1-3142.42: (45.5): this is not global
// 3144.233-3145.18: (48.9): invariant NextSpecStep(0) may not hold
// 3146.1-3146.374: (48.9): Loop does not preserve yields_as annotation for field item
// 3147.1-3147.374: (48.9): Loop does not preserve yields_as annotation for field next
// 3148.1-3148.377: (48.9): Loop does not preserve yields_as annotation for field head
// 3149.1-3149.398: (48.9): Loop does not preserve yields_as annotation for field head
// 3150.1-3150.33: (48.9): Phase must be invariant at loop head
// 3151.1-3151.30: (48.9): Potentially infinite loop cannot be in post-commit phase.
// 3153.3-3155.3: (class anchor.sink.VarDeclStmt:48.16)
// 3156.3-3159.16: (class anchor.sink.Assign:48.16)
// 3161.4-3164.10: (class anchor.sink.Break:48.9)
// 3170.1-3170.30: (51.13): Cannot have potential null deference in left-mover part.
// 3174.1-3174.28: (51.13): Reduction failure
// 3176.3-3178.3: (class anchor.sink.VarDeclStmt:52.13)
// 3179.3-3181.3: (class anchor.sink.VarDeclStmt:52.13)
// 3182.3-3199.28: (class anchor.sink.Read:52.13)
// 3194.1-3194.30: (52.13): Cannot have potential null deference in left-mover part.
// 3198.1-3198.28: (52.13): Reduction failure
// 3200.3-3203.29: (class anchor.sink.Assign:52.13)
// 3205.4-3208.10: (class anchor.sink.Break:52.38)
// 3214.1-3214.30: (53.13): Cannot have potential null deference in left-mover part.
// 3216.1-3216.35: (53.13): lock not held
// 3218.1-3218.28: (53.13): Reduction failure
// 3220.3-3228.43: (class anchor.sink.Yield:54.13)
// 3231.1-3231.30: (48.9): Phase must be invariant at loop head
// 3233.2-3235.2: (class anchor.sink.VarDeclStmt:56.9)
// 3236.2-3238.2: (class anchor.sink.VarDeclStmt:56.9)
// 3239.2-3256.28: (class anchor.sink.Read:56.9)
// 3251.1-3251.29: (56.9): Cannot have potential null deference in left-mover part.
// 3255.1-3255.27: (56.9): Reduction failure
// 3257.2-3274.28: (class anchor.sink.Read:56.9)
// 3269.1-3269.29: (56.9): Cannot have potential null deference in left-mover part.
// 3273.1-3273.27: (56.9): Reduction failure
// 3275.2-3277.2: (class anchor.sink.VarDeclStmt:57.9)
// 3278.2-3280.2: (class anchor.sink.VarDeclStmt:57.9)
// 3281.2-3298.28: (class anchor.sink.Read:57.9)
// 3293.1-3293.29: (57.9): Cannot have potential null deference in left-mover part.
// 3297.1-3297.27: (57.9): Reduction failure
// 3299.2-3316.28: (class anchor.sink.Read:57.9)
// 3311.1-3311.29: (57.9): Cannot have potential null deference in left-mover part.
// 3315.1-3315.27: (57.9): Reduction failure
// 3318.2-3339.2: (class anchor.sink.Write:57.9)
// 3330.1-3330.29: (57.9): Cannot have potential null deference in left-mover part.
// 3333.1-3333.27: (57.9): Reduction failure
// 3337.1-3337.60: (57.9): tmp11 became shared, but tmp11.next may not be shared.
// 3343.1-3343.29: (58.9): Cannot have potential null deference in left-mover part.
// 3345.1-3345.34: (58.9): lock not held
// 3347.1-3347.27: (58.9): Reduction failure
// 3349.2-3355.9: (class anchor.sink.Return:59.9)
// 3356.2-3362.9: (class anchor.sink.Return:47.23)
// 3537.1-4544.2: (Method:68.2)
// 3553.1-3553.24: (68.2): Bad tid
// 3554.1-3554.46: (68.2): this is not global
// 4043.2-4047.14: (class anchor.sink.While:69.9)
// 4049.1-4049.27: (68.2): Bad tid
// 4050.1-4050.49: (68.2): this is not global
// 4053.1-4053.374: (69.9): Loop does not preserve yields_as annotation for field item
// 4054.1-4054.374: (69.9): Loop does not preserve yields_as annotation for field next
// 4055.1-4055.377: (69.9): Loop does not preserve yields_as annotation for field head
// 4056.1-4056.398: (69.9): Loop does not preserve yields_as annotation for field head
// 4057.1-4057.33: (69.9): Phase must be invariant at loop head
// 4058.1-4058.30: (69.9): Potentially infinite loop cannot be in post-commit phase.
// 4060.3-4062.3: (class anchor.sink.VarDeclStmt:69.16)
// 4063.3-4066.17: (class anchor.sink.Assign:69.16)
// 4068.4-4071.10: (class anchor.sink.Break:69.9)
// 4074.3-4076.3: (class anchor.sink.VarDeclStmt:70.13)
// 4078.3-4080.3: (class anchor.sink.VarDeclStmt:70.13)
// 4081.3-4098.46: (class anchor.sink.Read:70.13)
// 4093.1-4093.37: (70.13): Cannot have potential null deference in left-mover part.
// 4097.1-4097.28: (70.13): Reduction failure
// 4099.3-4101.3: (class anchor.sink.VarDeclStmt:70.13)
// 4102.3-4119.45: (class anchor.sink.Read:70.13)
// 4114.1-4114.37: (70.13): Cannot have potential null deference in left-mover part.
// 4118.1-4118.28: (70.13): Reduction failure
// 4120.3-4122.3: (class anchor.sink.VarDeclStmt:70.13)
// 4123.3-4140.44: (class anchor.sink.Read:70.13)
// 4135.1-4135.37: (70.13): Cannot have potential null deference in left-mover part.
// 4139.1-4139.28: (70.13): Reduction failure
// 4141.3-4143.3: (class anchor.sink.VarDeclStmt:70.13)
// 4144.3-4147.273: (class anchor.sink.Assign:70.13)
// 4148.3-4150.3: (class anchor.sink.VarDeclStmt:70.13)
// 4151.3-4154.75: (class anchor.sink.Assign:70.13)
// 4157.4-4174.36: (class anchor.sink.Read:70.13)
// 4169.1-4169.38: (70.13): Cannot have potential null deference in left-mover part.
// 4173.1-4173.29: (70.13): Reduction failure
// 4177.4-4194.36: (class anchor.sink.Read:70.13)
// 4189.1-4189.38: (70.13): Cannot have potential null deference in left-mover part.
// 4193.1-4193.29: (70.13): Reduction failure
// 4196.3-4198.3: (class anchor.sink.VarDeclStmt:71.13)
// 4199.3-4207.38: (class anchor.sink.Alloc:71.13)
// 4210.3-4212.3: (class anchor.sink.VarDeclStmt:71.13)
// 4213.3-4215.3: (class anchor.sink.VarDeclStmt:71.13)
// 4216.3-4218.3: (class anchor.sink.VarDeclStmt:71.13)
// 4219.3-4222.17: (class anchor.sink.Assign:71.13)
// 4223.3-4226.20: (class anchor.sink.Assign:71.13)
// 4227.3-4230.18: (class anchor.sink.Assign:71.13)
// 4231.3-4234.35: (class anchor.sink.Assume:7.3)
// 4235.3-4238.43: (class anchor.sink.Assume:7.3)
// 4240.3-4256.35: (class anchor.sink.Write:8.5)
// 4252.1-4252.33: (8.5): Cannot have potential null deference in left-mover part.
// 4255.1-4255.28: (8.5): Reduction failure
// 4258.3-4279.3: (class anchor.sink.Write:9.5)
// 4270.1-4270.33: (9.5): Cannot have potential null deference in left-mover part.
// 4273.1-4273.28: (9.5): Reduction failure
// 4277.1-4277.64: (9.5): next$254 became shared, but next$254.next may not be shared.
// 4280.3-4283.24: (class anchor.sink.Break:7.29)
// 4285.3-4293.43: (class anchor.sink.Yield:72.13)
// 4294.3-4296.3: (class anchor.sink.VarDeclStmt:73.13)
// 4298.3-4300.3: (class anchor.sink.VarDeclStmt:73.13)
// 4301.3-4304.21: (class anchor.sink.Assign:73.13)
// 4307.4-4310.19: (class anchor.sink.Assign:73.13)
// 4312.4-4315.22: (class anchor.sink.Assign:73.13)
// 4317.5-4319.5: (class anchor.sink.VarDeclStmt:73.13)
// 4320.5-4322.5: (class anchor.sink.VarDeclStmt:73.13)
// 4323.5-4325.5: (class anchor.sink.VarDeclStmt:73.13)
// 4326.5-4329.283: (class anchor.sink.Assign:73.13)
// 4330.5-4333.44: (class anchor.sink.Assume:73.13)
// 4334.5-4337.49: (class anchor.sink.Assume:73.13)
// 4338.5-4341.54: (class anchor.sink.Assume:73.13)
// 4342.5-4345.54: (class anchor.sink.Assume:73.13)
// 4347.5-4363.50: (class anchor.sink.Write:73.13)
// 4359.1-4359.39: (73.13): Cannot have potential null deference in left-mover part.
// 4362.1-4362.30: (73.13): Reduction failure
// 4365.5-4381.51: (class anchor.sink.Write:73.13)
// 4377.1-4377.39: (73.13): Cannot have potential null deference in left-mover part.
// 4380.1-4380.30: (73.13): Reduction failure
// 4384.5-4405.5: (class anchor.sink.Write:73.13)
// 4396.1-4396.39: (73.13): Cannot have potential null deference in left-mover part.
// 4399.1-4399.30: (73.13): Reduction failure
// 4403.1-4403.60: (73.13): nu became shared, but nu.next may not be shared.
// 4406.5-4409.19: (class anchor.sink.Assign:73.13)
// 4411.5-4414.54: (class anchor.sink.Assume:73.13)
// 4415.5-4418.54: (class anchor.sink.Assume:73.13)
// 4419.5-4421.5: (class anchor.sink.VarDeclStmt:73.13)
// 4422.5-4439.46: (class anchor.sink.Read:73.13)
// 4434.1-4434.39: (73.13): Cannot have potential null deference in left-mover part.
// 4438.1-4438.30: (73.13): Reduction failure
// 4441.5-4462.5: (class anchor.sink.Write:73.13)
// 4453.1-4453.39: (73.13): Cannot have potential null deference in left-mover part.
// 4456.1-4456.30: (73.13): Reduction failure
// 4460.1-4460.62: (73.13): next became shared, but next.next may not be shared.
// 4463.5-4465.5: (class anchor.sink.VarDeclStmt:73.13)
// 4466.5-4469.283: (class anchor.sink.Assign:73.13)
// 4471.5-4492.5: (class anchor.sink.Write:73.13)
// 4483.1-4483.39: (73.13): Cannot have potential null deference in left-mover part.
// 4486.1-4486.30: (73.13): Reduction failure
// 4490.1-4490.71: (73.13): _currentValue became shared, but _currentValue.next may not be shared.
// 4493.5-4496.46: (class anchor.sink.Assume:73.13)
// 4499.5-4520.5: (class anchor.sink.Write:73.13)
// 4511.1-4511.39: (73.13): Cannot have potential null deference in left-mover part.
// 4514.1-4514.30: (73.13): Reduction failure
// 4518.1-4518.60: (73.13): nu became shared, but nu.next may not be shared.
// 4521.5-4524.20: (class anchor.sink.Assign:73.13)
// 4528.4-4531.10: (class anchor.sink.Break:74.15)
// 4536.1-4536.30: (69.9): Phase must be invariant at loop head
// 4538.2-4543.9: (class anchor.sink.Return:68.26)
// 4545.1-5594.2: (Method:79.2)
// 4562.1-4562.24: (79.2): Bad tid
// 4563.1-4563.46: (79.2): this is not global
// 5117.2-5121.14: (class anchor.sink.While:82.6)
// 5123.1-5123.27: (79.2): Bad tid
// 5124.1-5124.49: (79.2): this is not global
// 5127.1-5127.374: (82.6): Loop does not preserve yields_as annotation for field item
// 5128.1-5128.374: (82.6): Loop does not preserve yields_as annotation for field next
// 5129.1-5129.377: (82.6): Loop does not preserve yields_as annotation for field head
// 5130.1-5130.398: (82.6): Loop does not preserve yields_as annotation for field head
// 5131.1-5131.33: (82.6): Phase must be invariant at loop head
// 5132.1-5132.30: (82.6): Potentially infinite loop cannot be in post-commit phase.
// 5134.3-5136.3: (class anchor.sink.VarDeclStmt:82.13)
// 5137.3-5140.17: (class anchor.sink.Assign:82.13)
// 5142.4-5145.10: (class anchor.sink.Break:82.6)
// 5148.3-5150.3: (class anchor.sink.VarDeclStmt:84.8)
// 5152.3-5154.3: (class anchor.sink.VarDeclStmt:84.8)
// 5155.3-5172.46: (class anchor.sink.Read:84.8)
// 5167.1-5167.37: (84.8): Cannot have potential null deference in left-mover part.
// 5171.1-5171.28: (84.8): Reduction failure
// 5173.3-5175.3: (class anchor.sink.VarDeclStmt:84.8)
// 5176.3-5193.45: (class anchor.sink.Read:84.8)
// 5188.1-5188.37: (84.8): Cannot have potential null deference in left-mover part.
// 5192.1-5192.28: (84.8): Reduction failure
// 5194.3-5196.3: (class anchor.sink.VarDeclStmt:84.8)
// 5197.3-5214.44: (class anchor.sink.Read:84.8)
// 5209.1-5209.37: (84.8): Cannot have potential null deference in left-mover part.
// 5213.1-5213.28: (84.8): Reduction failure
// 5215.3-5217.3: (class anchor.sink.VarDeclStmt:84.8)
// 5218.3-5221.273: (class anchor.sink.Assign:84.8)
// 5222.3-5224.3: (class anchor.sink.VarDeclStmt:84.8)
// 5225.3-5228.75: (class anchor.sink.Assign:84.8)
// 5231.4-5248.35: (class anchor.sink.Read:84.8)
// 5243.1-5243.38: (84.8): Cannot have potential null deference in left-mover part.
// 5247.1-5247.29: (84.8): Reduction failure
// 5251.4-5268.35: (class anchor.sink.Read:84.8)
// 5263.1-5263.38: (84.8): Cannot have potential null deference in left-mover part.
// 5267.1-5267.29: (84.8): Reduction failure
// 5270.3-5278.43: (class anchor.sink.Yield:85.11)
// 5279.3-5281.3: (class anchor.sink.VarDeclStmt:86.10)
// 5282.3-5285.29: (class anchor.sink.Assign:86.10)
// 5287.4-5289.4: (class anchor.sink.VarDeclStmt:87.10)
// 5290.4-5307.27: (class anchor.sink.Read:87.10)
// 5302.1-5302.29: (87.10): Cannot have potential null deference in left-mover part.
// 5306.1-5306.29: (87.10): Reduction failure
// 5308.4-5310.4: (class anchor.sink.VarDeclStmt:88.13)
// 5312.4-5314.4: (class anchor.sink.VarDeclStmt:88.13)
// 5315.4-5318.22: (class anchor.sink.Assign:88.13)
// 5321.5-5324.20: (class anchor.sink.Assign:88.13)
// 5326.5-5329.23: (class anchor.sink.Assign:88.13)
// 5331.6-5333.6: (class anchor.sink.VarDeclStmt:88.13)
// 5334.6-5336.6: (class anchor.sink.VarDeclStmt:88.13)
// 5337.6-5339.6: (class anchor.sink.VarDeclStmt:88.13)
// 5340.6-5343.286: (class anchor.sink.Assign:88.13)
// 5344.6-5347.44: (class anchor.sink.Assume:88.13)
// 5348.6-5351.50: (class anchor.sink.Assume:88.13)
// 5352.6-5355.55: (class anchor.sink.Assume:88.13)
// 5356.6-5359.54: (class anchor.sink.Assume:88.13)
// 5361.6-5377.51: (class anchor.sink.Write:88.13)
// 5373.1-5373.40: (88.13): Cannot have potential null deference in left-mover part.
// 5376.1-5376.31: (88.13): Reduction failure
// 5379.6-5395.52: (class anchor.sink.Write:88.13)
// 5391.1-5391.40: (88.13): Cannot have potential null deference in left-mover part.
// 5394.1-5394.31: (88.13): Reduction failure
// 5398.6-5419.6: (class anchor.sink.Write:88.13)
// 5410.1-5410.40: (88.13): Cannot have potential null deference in left-mover part.
// 5413.1-5413.31: (88.13): Reduction failure
// 5417.1-5417.63: (88.13): next became shared, but next.next may not be shared.
// 5420.6-5423.20: (class anchor.sink.Assign:88.13)
// 5425.6-5428.55: (class anchor.sink.Assume:88.13)
// 5429.6-5432.54: (class anchor.sink.Assume:88.13)
// 5433.6-5435.6: (class anchor.sink.VarDeclStmt:88.13)
// 5436.6-5453.47: (class anchor.sink.Read:88.13)
// 5448.1-5448.40: (88.13): Cannot have potential null deference in left-mover part.
// 5452.1-5452.31: (88.13): Reduction failure
// 5455.6-5476.6: (class anchor.sink.Write:88.13)
// 5467.1-5467.40: (88.13): Cannot have potential null deference in left-mover part.
// 5470.1-5470.31: (88.13): Reduction failure
// 5474.1-5474.62: (88.13): top became shared, but top.next may not be shared.
// 5477.6-5479.6: (class anchor.sink.VarDeclStmt:88.13)
// 5480.6-5483.286: (class anchor.sink.Assign:88.13)
// 5485.6-5506.6: (class anchor.sink.Write:88.13)
// 5497.1-5497.40: (88.13): Cannot have potential null deference in left-mover part.
// 5500.1-5500.31: (88.13): Reduction failure
// 5504.1-5504.72: (88.13): _currentValue became shared, but _currentValue.next may not be shared.
// 5507.6-5510.47: (class anchor.sink.Assume:88.13)
// 5513.6-5534.6: (class anchor.sink.Write:88.13)
// 5525.1-5525.40: (88.13): Cannot have potential null deference in left-mover part.
// 5528.1-5528.31: (88.13): Reduction failure
// 5532.1-5532.63: (88.13): next became shared, but next.next may not be shared.
// 5535.6-5538.21: (class anchor.sink.Assign:88.13)
// 5542.5-5544.5: (class anchor.sink.VarDeclStmt:89.14)
// 5545.5-5562.29: (class anchor.sink.Read:89.14)
// 5557.1-5557.30: (89.14): Cannot have potential null deference in left-mover part.
// 5561.1-5561.30: (89.14): Reduction failure
// 5563.5-5569.12: (class anchor.sink.Return:89.14)
// 5574.3-5582.43: (class anchor.sink.Yield:92.10)
// 5585.1-5585.30: (82.6): Phase must be invariant at loop head
// 5587.2-5593.9: (class anchor.sink.Return:81.22)
// 5694.1-5694.34: (2.3): Node.item failed Write-Write Right-Mover Check
// 5769.1-5769.30: (2.3): Node.item failed Write-Read Right-Mover Check
// 5848.1-5848.34: (2.3): Node.item failed Write-Write Left-Mover Check
// 5924.1-5924.30: (2.3): Node.item failed Write-Read Left-Mover Check
// 5997.1-5997.34: (2.3): Node.item failed Read-Write Right-Mover Check
// 6073.1-6073.34: (2.3): Node.item failed Read-Write Left-Mover Check
// 6148.1-6148.34: (3.3): Node.next failed Write-Write Right-Mover Check
// 6223.1-6223.30: (3.3): Node.next failed Write-Read Right-Mover Check
// 6302.1-6302.34: (3.3): Node.next failed Write-Write Left-Mover Check
// 6378.1-6378.30: (3.3): Node.next failed Write-Read Left-Mover Check
// 6451.1-6451.34: (3.3): Node.next failed Read-Write Right-Mover Check
// 6527.1-6527.34: (3.3): Node.next failed Read-Write Left-Mover Check
// 6602.1-6602.34: (16.3): Stack.head failed Write-Write Right-Mover Check
// 6677.1-6677.30: (16.3): Stack.head failed Write-Read Right-Mover Check
// 6756.1-6756.34: (16.3): Stack.head failed Write-Write Left-Mover Check
// 6832.1-6832.30: (16.3): Stack.head failed Write-Read Left-Mover Check
// 6905.1-6905.34: (16.3): Stack.head failed Read-Write Right-Mover Check
// 6981.1-6981.34: (16.3): Stack.head failed Read-Write Left-Mover Check
// 7056.1-7056.34: (66.2): StackWithCAS.head failed Write-Write Right-Mover Check
// 7131.1-7131.30: (66.2): StackWithCAS.head failed Write-Read Right-Mover Check
// 7210.1-7210.34: (66.2): StackWithCAS.head failed Write-Write Left-Mover Check
// 7286.1-7286.30: (66.2): StackWithCAS.head failed Write-Read Left-Mover Check
// 7359.1-7359.34: (66.2): StackWithCAS.head failed Read-Write Right-Mover Check
// 7435.1-7435.34: (66.2): StackWithCAS.head failed Read-Write Left-Mover Check
// 7522.1-7522.140: (2.3): Node.item is not Write-Write Stable with respect to Node.item (case A.1)
// 7523.1-7523.101: (2.3): Node.item is not Write-Write Stable with respect to Node.item (case A.2)
// 7524.1-7524.158: (2.3): Node.item is not Write-Write Stable with respect to Node.item (case A.3)
// 7644.1-7644.140: (2.3): Node.item is not Write-Write Stable with respect to Node.item (case C)
// 7769.1-7769.144: (2.3): Node.item is not Write-Write Stable with respect to Node.item (case D)
// 7770.1-7770.144: (2.3): Node.item is not Write-Write Stable with respect to Node.item (case R)
// 7857.1-7857.136: (2.3): Node.item is not Read-Write Stable with respect to Node.item (case F)
// 7858.1-7858.136: (2.3): Node.item is not Read-Write Stable with respect to Node.item (case H)
// 7859.1-7859.146: (2.3): Node.item is not Read-Write Stable with respect to Node.item (case I)
// 7945.1-7945.136: (2.3): Node.item is not Write-Read Stable with respect to Node.item (case J)
// 7946.1-7946.136: (2.3): Node.item is not Write-Read Stable with respect to Node.item (case K)
// 7947.1-7947.99: (2.3): Node.item is not Write-Read Stable with respect to Node.item (case L)
// 8035.1-8035.140: (3.3): Node.next is not Write-Write Stable with respect to Node.item (case A.1)
// 8036.1-8036.101: (3.3): Node.next is not Write-Write Stable with respect to Node.item (case A.2)
// 8037.1-8037.158: (3.3): Node.next is not Write-Write Stable with respect to Node.item (case A.3)
// 8157.1-8157.140: (2.3): Node.item is not Write-Write Stable with respect to Node.next (case C)
// 8282.1-8282.144: (2.3): Node.item is not Write-Write Stable with respect to Node.next (case D)
// 8283.1-8283.144: (2.3): Node.item is not Write-Write Stable with respect to Node.next (case R)
// 8370.1-8370.136: (2.3): Node.item is not Read-Write Stable with respect to Node.next (case F)
// 8371.1-8371.136: (2.3): Node.item is not Read-Write Stable with respect to Node.next (case H)
// 8372.1-8372.146: (2.3): Node.item is not Read-Write Stable with respect to Node.next (case I)
// 8458.1-8458.136: (3.3): Node.next is not Write-Read Stable with respect to Node.item (case J)
// 8459.1-8459.136: (3.3): Node.next is not Write-Read Stable with respect to Node.item (case K)
// 8460.1-8460.99: (3.3): Node.next is not Write-Read Stable with respect to Node.item (case L)
// 8548.1-8548.140: (16.3): Stack.head is not Write-Write Stable with respect to Node.item (case A.1)
// 8549.1-8549.101: (16.3): Stack.head is not Write-Write Stable with respect to Node.item (case A.2)
// 8550.1-8550.156: (16.3): Stack.head is not Write-Write Stable with respect to Node.item (case A.3)
// 8670.1-8670.140: (2.3): Node.item is not Write-Write Stable with respect to Stack.head (case C)
// 8795.1-8795.144: (2.3): Node.item is not Write-Write Stable with respect to Stack.head (case D)
// 8796.1-8796.144: (2.3): Node.item is not Write-Write Stable with respect to Stack.head (case R)
// 8883.1-8883.136: (2.3): Node.item is not Read-Write Stable with respect to Stack.head (case F)
// 8884.1-8884.136: (2.3): Node.item is not Read-Write Stable with respect to Stack.head (case H)
// 8885.1-8885.144: (2.3): Node.item is not Read-Write Stable with respect to Stack.head (case I)
// 8971.1-8971.136: (16.3): Stack.head is not Write-Read Stable with respect to Node.item (case J)
// 8972.1-8972.136: (16.3): Stack.head is not Write-Read Stable with respect to Node.item (case K)
// 8973.1-8973.99: (16.3): Stack.head is not Write-Read Stable with respect to Node.item (case L)
// 9061.1-9061.140: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.item (case A.1)
// 9062.1-9062.101: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.item (case A.2)
// 9063.1-9063.156: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.item (case A.3)
// 9183.1-9183.140: (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case C)
// 9308.1-9308.144: (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case D)
// 9309.1-9309.144: (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case R)
// 9396.1-9396.136: (2.3): Node.item is not Read-Write Stable with respect to StackWithCAS.head (case F)
// 9397.1-9397.136: (2.3): Node.item is not Read-Write Stable with respect to StackWithCAS.head (case H)
// 9398.1-9398.144: (2.3): Node.item is not Read-Write Stable with respect to StackWithCAS.head (case I)
// 9484.1-9484.136: (66.2): StackWithCAS.head is not Write-Read Stable with respect to Node.item (case J)
// 9485.1-9485.136: (66.2): StackWithCAS.head is not Write-Read Stable with respect to Node.item (case K)
// 9486.1-9486.99: (66.2): StackWithCAS.head is not Write-Read Stable with respect to Node.item (case L)
// 9574.1-9574.140: (2.3): Node.item is not Write-Write Stable with respect to Node.next (case A.1)
// 9575.1-9575.101: (2.3): Node.item is not Write-Write Stable with respect to Node.next (case A.2)
// 9576.1-9576.158: (2.3): Node.item is not Write-Write Stable with respect to Node.next (case A.3)
// 9696.1-9696.140: (3.3): Node.next is not Write-Write Stable with respect to Node.item (case C)
// 9821.1-9821.144: (3.3): Node.next is not Write-Write Stable with respect to Node.item (case D)
// 9822.1-9822.144: (3.3): Node.next is not Write-Write Stable with respect to Node.item (case R)
// 9909.1-9909.136: (3.3): Node.next is not Read-Write Stable with respect to Node.item (case F)
// 9910.1-9910.136: (3.3): Node.next is not Read-Write Stable with respect to Node.item (case H)
// 9911.1-9911.146: (3.3): Node.next is not Read-Write Stable with respect to Node.item (case I)
// 9997.1-9997.136: (2.3): Node.item is not Write-Read Stable with respect to Node.next (case J)
// 9998.1-9998.136: (2.3): Node.item is not Write-Read Stable with respect to Node.next (case K)
// 9999.1-9999.99: (2.3): Node.item is not Write-Read Stable with respect to Node.next (case L)
// 10087.1-10087.140: (3.3): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
// 10088.1-10088.101: (3.3): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
// 10089.1-10089.158: (3.3): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
// 10209.1-10209.140: (3.3): Node.next is not Write-Write Stable with respect to Node.next (case C)
// 10334.1-10334.144: (3.3): Node.next is not Write-Write Stable with respect to Node.next (case D)
// 10335.1-10335.144: (3.3): Node.next is not Write-Write Stable with respect to Node.next (case R)
// 10422.1-10422.136: (3.3): Node.next is not Read-Write Stable with respect to Node.next (case F)
// 10423.1-10423.136: (3.3): Node.next is not Read-Write Stable with respect to Node.next (case H)
// 10424.1-10424.146: (3.3): Node.next is not Read-Write Stable with respect to Node.next (case I)
// 10510.1-10510.136: (3.3): Node.next is not Write-Read Stable with respect to Node.next (case J)
// 10511.1-10511.136: (3.3): Node.next is not Write-Read Stable with respect to Node.next (case K)
// 10512.1-10512.99: (3.3): Node.next is not Write-Read Stable with respect to Node.next (case L)
// 10600.1-10600.140: (16.3): Stack.head is not Write-Write Stable with respect to Node.next (case A.1)
// 10601.1-10601.101: (16.3): Stack.head is not Write-Write Stable with respect to Node.next (case A.2)
// 10602.1-10602.156: (16.3): Stack.head is not Write-Write Stable with respect to Node.next (case A.3)
// 10722.1-10722.140: (3.3): Node.next is not Write-Write Stable with respect to Stack.head (case C)
// 10847.1-10847.144: (3.3): Node.next is not Write-Write Stable with respect to Stack.head (case D)
// 10848.1-10848.144: (3.3): Node.next is not Write-Write Stable with respect to Stack.head (case R)
// 10935.1-10935.136: (3.3): Node.next is not Read-Write Stable with respect to Stack.head (case F)
// 10936.1-10936.136: (3.3): Node.next is not Read-Write Stable with respect to Stack.head (case H)
// 10937.1-10937.144: (3.3): Node.next is not Read-Write Stable with respect to Stack.head (case I)
// 11023.1-11023.136: (16.3): Stack.head is not Write-Read Stable with respect to Node.next (case J)
// 11024.1-11024.136: (16.3): Stack.head is not Write-Read Stable with respect to Node.next (case K)
// 11025.1-11025.99: (16.3): Stack.head is not Write-Read Stable with respect to Node.next (case L)
// 11113.1-11113.140: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.next (case A.1)
// 11114.1-11114.101: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.next (case A.2)
// 11115.1-11115.156: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.next (case A.3)
// 11235.1-11235.140: (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case C)
// 11360.1-11360.144: (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case D)
// 11361.1-11361.144: (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case R)
// 11448.1-11448.136: (3.3): Node.next is not Read-Write Stable with respect to StackWithCAS.head (case F)
// 11449.1-11449.136: (3.3): Node.next is not Read-Write Stable with respect to StackWithCAS.head (case H)
// 11450.1-11450.144: (3.3): Node.next is not Read-Write Stable with respect to StackWithCAS.head (case I)
// 11536.1-11536.136: (66.2): StackWithCAS.head is not Write-Read Stable with respect to Node.next (case J)
// 11537.1-11537.136: (66.2): StackWithCAS.head is not Write-Read Stable with respect to Node.next (case K)
// 11538.1-11538.99: (66.2): StackWithCAS.head is not Write-Read Stable with respect to Node.next (case L)
// 11626.1-11626.140: (2.3): Node.item is not Write-Write Stable with respect to Stack.head (case A.1)
// 11627.1-11627.101: (2.3): Node.item is not Write-Write Stable with respect to Stack.head (case A.2)
// 11628.1-11628.156: (2.3): Node.item is not Write-Write Stable with respect to Stack.head (case A.3)
// 11748.1-11748.140: (16.3): Stack.head is not Write-Write Stable with respect to Node.item (case C)
// 11873.1-11873.144: (16.3): Stack.head is not Write-Write Stable with respect to Node.item (case D)
// 11874.1-11874.144: (16.3): Stack.head is not Write-Write Stable with respect to Node.item (case R)
// 11961.1-11961.136: (16.3): Stack.head is not Read-Write Stable with respect to Node.item (case F)
// 11962.1-11962.136: (16.3): Stack.head is not Read-Write Stable with respect to Node.item (case H)
// 11963.1-11963.144: (16.3): Stack.head is not Read-Write Stable with respect to Node.item (case I)
// 12049.1-12049.136: (2.3): Node.item is not Write-Read Stable with respect to Stack.head (case J)
// 12050.1-12050.136: (2.3): Node.item is not Write-Read Stable with respect to Stack.head (case K)
// 12051.1-12051.99: (2.3): Node.item is not Write-Read Stable with respect to Stack.head (case L)
// 12139.1-12139.140: (3.3): Node.next is not Write-Write Stable with respect to Stack.head (case A.1)
// 12140.1-12140.101: (3.3): Node.next is not Write-Write Stable with respect to Stack.head (case A.2)
// 12141.1-12141.156: (3.3): Node.next is not Write-Write Stable with respect to Stack.head (case A.3)
// 12261.1-12261.140: (16.3): Stack.head is not Write-Write Stable with respect to Node.next (case C)
// 12386.1-12386.144: (16.3): Stack.head is not Write-Write Stable with respect to Node.next (case D)
// 12387.1-12387.144: (16.3): Stack.head is not Write-Write Stable with respect to Node.next (case R)
// 12474.1-12474.136: (16.3): Stack.head is not Read-Write Stable with respect to Node.next (case F)
// 12475.1-12475.136: (16.3): Stack.head is not Read-Write Stable with respect to Node.next (case H)
// 12476.1-12476.144: (16.3): Stack.head is not Read-Write Stable with respect to Node.next (case I)
// 12562.1-12562.136: (3.3): Node.next is not Write-Read Stable with respect to Stack.head (case J)
// 12563.1-12563.136: (3.3): Node.next is not Write-Read Stable with respect to Stack.head (case K)
// 12564.1-12564.99: (3.3): Node.next is not Write-Read Stable with respect to Stack.head (case L)
// 12652.1-12652.140: (16.3): Stack.head is not Write-Write Stable with respect to Stack.head (case A.1)
// 12653.1-12653.101: (16.3): Stack.head is not Write-Write Stable with respect to Stack.head (case A.2)
// 12654.1-12654.158: (16.3): Stack.head is not Write-Write Stable with respect to Stack.head (case A.3)
// 12774.1-12774.140: (16.3): Stack.head is not Write-Write Stable with respect to Stack.head (case C)
// 12899.1-12899.144: (16.3): Stack.head is not Write-Write Stable with respect to Stack.head (case D)
// 12900.1-12900.144: (16.3): Stack.head is not Write-Write Stable with respect to Stack.head (case R)
// 12987.1-12987.136: (16.3): Stack.head is not Read-Write Stable with respect to Stack.head (case F)
// 12988.1-12988.136: (16.3): Stack.head is not Read-Write Stable with respect to Stack.head (case H)
// 12989.1-12989.146: (16.3): Stack.head is not Read-Write Stable with respect to Stack.head (case I)
// 13075.1-13075.136: (16.3): Stack.head is not Write-Read Stable with respect to Stack.head (case J)
// 13076.1-13076.136: (16.3): Stack.head is not Write-Read Stable with respect to Stack.head (case K)
// 13077.1-13077.99: (16.3): Stack.head is not Write-Read Stable with respect to Stack.head (case L)
// 13165.1-13165.140: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Stack.head (case A.1)
// 13166.1-13166.101: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Stack.head (case A.2)
// 13167.1-13167.156: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Stack.head (case A.3)
// 13287.1-13287.140: (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case C)
// 13412.1-13412.144: (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case D)
// 13413.1-13413.144: (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case R)
// 13500.1-13500.136: (16.3): Stack.head is not Read-Write Stable with respect to StackWithCAS.head (case F)
// 13501.1-13501.136: (16.3): Stack.head is not Read-Write Stable with respect to StackWithCAS.head (case H)
// 13502.1-13502.144: (16.3): Stack.head is not Read-Write Stable with respect to StackWithCAS.head (case I)
// 13588.1-13588.136: (66.2): StackWithCAS.head is not Write-Read Stable with respect to Stack.head (case J)
// 13589.1-13589.136: (66.2): StackWithCAS.head is not Write-Read Stable with respect to Stack.head (case K)
// 13590.1-13590.99: (66.2): StackWithCAS.head is not Write-Read Stable with respect to Stack.head (case L)
// 13678.1-13678.140: (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case A.1)
// 13679.1-13679.101: (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case A.2)
// 13680.1-13680.156: (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case A.3)
// 13800.1-13800.140: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.item (case C)
// 13925.1-13925.144: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.item (case D)
// 13926.1-13926.144: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.item (case R)
// 14013.1-14013.136: (66.2): StackWithCAS.head is not Read-Write Stable with respect to Node.item (case F)
// 14014.1-14014.136: (66.2): StackWithCAS.head is not Read-Write Stable with respect to Node.item (case H)
// 14015.1-14015.144: (66.2): StackWithCAS.head is not Read-Write Stable with respect to Node.item (case I)
// 14101.1-14101.136: (2.3): Node.item is not Write-Read Stable with respect to StackWithCAS.head (case J)
// 14102.1-14102.136: (2.3): Node.item is not Write-Read Stable with respect to StackWithCAS.head (case K)
// 14103.1-14103.99: (2.3): Node.item is not Write-Read Stable with respect to StackWithCAS.head (case L)
// 14233.1-14233.142: (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case M)
// 14361.1-14361.130: (2.3): Node.item is not Write-Write Stable with respect to StackWithCAS.head (case N)
// 14450.1-14450.140: (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case A.1)
// 14451.1-14451.101: (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case A.2)
// 14452.1-14452.156: (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case A.3)
// 14572.1-14572.140: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.next (case C)
// 14697.1-14697.144: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.next (case D)
// 14698.1-14698.144: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Node.next (case R)
// 14785.1-14785.136: (66.2): StackWithCAS.head is not Read-Write Stable with respect to Node.next (case F)
// 14786.1-14786.136: (66.2): StackWithCAS.head is not Read-Write Stable with respect to Node.next (case H)
// 14787.1-14787.144: (66.2): StackWithCAS.head is not Read-Write Stable with respect to Node.next (case I)
// 14873.1-14873.136: (3.3): Node.next is not Write-Read Stable with respect to StackWithCAS.head (case J)
// 14874.1-14874.136: (3.3): Node.next is not Write-Read Stable with respect to StackWithCAS.head (case K)
// 14875.1-14875.99: (3.3): Node.next is not Write-Read Stable with respect to StackWithCAS.head (case L)
// 15005.1-15005.142: (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case M)
// 15133.1-15133.130: (3.3): Node.next is not Write-Write Stable with respect to StackWithCAS.head (case N)
// 15222.1-15222.140: (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case A.1)
// 15223.1-15223.101: (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case A.2)
// 15224.1-15224.156: (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case A.3)
// 15344.1-15344.140: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Stack.head (case C)
// 15469.1-15469.144: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Stack.head (case D)
// 15470.1-15470.144: (66.2): StackWithCAS.head is not Write-Write Stable with respect to Stack.head (case R)
// 15557.1-15557.136: (66.2): StackWithCAS.head is not Read-Write Stable with respect to Stack.head (case F)
// 15558.1-15558.136: (66.2): StackWithCAS.head is not Read-Write Stable with respect to Stack.head (case H)
// 15559.1-15559.144: (66.2): StackWithCAS.head is not Read-Write Stable with respect to Stack.head (case I)
// 15645.1-15645.136: (16.3): Stack.head is not Write-Read Stable with respect to StackWithCAS.head (case J)
// 15646.1-15646.136: (16.3): Stack.head is not Write-Read Stable with respect to StackWithCAS.head (case K)
// 15647.1-15647.99: (16.3): Stack.head is not Write-Read Stable with respect to StackWithCAS.head (case L)
// 15777.1-15777.142: (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case M)
// 15905.1-15905.130: (16.3): Stack.head is not Write-Write Stable with respect to StackWithCAS.head (case N)
// 15994.1-15994.140: (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case A.1)
// 15995.1-15995.101: (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case A.2)
// 15996.1-15996.158: (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case A.3)
// 16116.1-16116.140: (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case C)
// 16241.1-16241.144: (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case D)
// 16242.1-16242.144: (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case R)
// 16329.1-16329.136: (66.2): StackWithCAS.head is not Read-Write Stable with respect to StackWithCAS.head (case F)
// 16330.1-16330.136: (66.2): StackWithCAS.head is not Read-Write Stable with respect to StackWithCAS.head (case H)
// 16331.1-16331.146: (66.2): StackWithCAS.head is not Read-Write Stable with respect to StackWithCAS.head (case I)
// 16417.1-16417.136: (66.2): StackWithCAS.head is not Write-Read Stable with respect to StackWithCAS.head (case J)
// 16418.1-16418.136: (66.2): StackWithCAS.head is not Write-Read Stable with respect to StackWithCAS.head (case K)
// 16419.1-16419.99: (66.2): StackWithCAS.head is not Write-Read Stable with respect to StackWithCAS.head (case L)
// 16549.1-16549.142: (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case M)
// 16677.1-16677.130: (66.2): StackWithCAS.head is not Write-Write Stable with respect to StackWithCAS.head (case N)
// 16718.1-16746.2: (2.3): yields_as clause for Node.item is not valid
// 16751.1-16774.2: (2.3): yields_as clause for Node.item is not reflexive
// 16780.1-16826.2: (2.3): yields_as clause for Node.item is not transitive
// 16845.1-16873.2: (3.3): yields_as clause for Node.next is not valid
// 16878.1-16901.2: (3.3): yields_as clause for Node.next is not reflexive
// 16907.1-16953.2: (3.3): yields_as clause for Node.next is not transitive
// 16973.1-17001.2: (7.32): yields_as clause for Node._lock is not valid
// 17006.1-17029.2: (7.32): yields_as clause for Node._lock is not reflexive
// 17035.1-17081.2: (7.32): yields_as clause for Node._lock is not transitive
// 17100.1-17128.2: (16.3): yields_as clause for Stack.head is not valid
// 17133.1-17156.2: (16.3): yields_as clause for Stack.head is not reflexive
// 17162.1-17208.2: (16.3): yields_as clause for Stack.head is not transitive
// 17228.1-17256.2: (7.32): yields_as clause for Stack._lock is not valid
// 17261.1-17284.2: (7.32): yields_as clause for Stack._lock is not reflexive
// 17290.1-17336.2: (7.32): yields_as clause for Stack._lock is not transitive
// 17355.1-17383.2: (66.2): yields_as clause for StackWithCAS.head is not valid
// 17388.1-17411.2: (66.2): yields_as clause for StackWithCAS.head is not reflexive
// 17417.1-17463.2: (66.2): yields_as clause for StackWithCAS.head is not transitive
// 17483.1-17511.2: (7.32): yields_as clause for StackWithCAS._lock is not valid
// 17516.1-17539.2: (7.32): yields_as clause for StackWithCAS._lock is not reflexive
// 17545.1-17591.2: (7.32): yields_as clause for StackWithCAS._lock is not transitive
