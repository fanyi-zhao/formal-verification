                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/queue-aba.anchor:                       
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int value isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      noABA volatile Node next isLocal(this, tid)                                                   
       ? isRead                                                                                     
         ? B                                                                                        
         : isLocal(newValue, tid) || newValue == Node.null ? B : E                                  
       : isRead                                                                                     
         ? this.next != Node.null ? R : N                                                           
         : isLocal(newValue, tid) && this.next == Node.null && newValue != Node.null ? N : E        
        yields_as newValue == this.next || !isLocal(newValue, tid) && !isShared(newValue) && newValue != Node.null;
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int value,Node next) {                                                              
        assume this.value == 0;                                                                     
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.value := value;                                                                      
          this.next := next;                                                                        
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Queue {                                                                                   
      volatile Node head isLocal(this, tid)                                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
      volatile Node tail isLocal(this, tid)                                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
      invariant  this.head != Node.null;                                                            
      invariant  this.tail != Node.null;                                                            
                                                                                                    
      requires this.head == Node.null;                                                              
      requires this.tail == Node.null;                                                              
                                                                                                    
      public void init() {                                                                          
        assume this.head == Node.null;                                                              
        assume this.tail == Node.null;                                                              
        {                                                                                           
          Node sentinel;                                                                            
          sentinel = new Node();                                                                    
          sentinel.init(0,Node.null)                                                                
          this.head := sentinel;                                                                    
          this.tail := sentinel;                                                                    
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void enqueue(int value) {                                                              
        Node n;                                                                                     
        n = new Node();                                                                             
        n.init(value,Node.null)                                                                     
        Node last;                                                                                  
        last := this.tail;                                                                          
        yield;                                                                                      
        while (true)                                                                                
          invariant isLocal(n, tid);                                                                
          invariant isShared(last);                                                                 
          invariant n.next == Node.null;                                                            
          {                                                                                         
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) break; else {                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node next;                                                                              
            next := last.next;                                                                      
            boolean tmp2;                                                                           
            tmp2 = next == Node.null;                                                               
            if (tmp2 /* == next == Node.null */) {                                                  
              boolean tmp3;                                                                         
              tmp3 = last.next@next :~ n;                                                           
              if (tmp3) {                                                                           
                yield;                                                                              
                boolean tmp4;                                                                       
                tmp4 = this.tail@last :~ n;                                                         
                 return;                                                                            
              } else {                                                                              
                                                                                                    
              }                                                                                     
            } else {                                                                                
              boolean tmp5;                                                                         
              tmp5 = this.tail@last :~ next;                                                        
              if (tmp5) {                                                                           
                last = next;                                                                        
              } else {                                                                              
                                                                                                    
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        // return;                                                                                  
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int value isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      hasCASOperation noABA volatile Node next isLocal(this, tid)                                   
       ? isRead                                                                                     
         ? B                                                                                        
         : isLocal(newValue, tid) || newValue == Node.null ? B : E                                  
       : isRead                                                                                     
         ? this.next != Node.null ? R : N                                                           
         : isLocal(newValue, tid) && this.next == Node.null && newValue != Node.null ? N : E        
        yields_as newValue == this.next || !isLocal(newValue, tid) && !isShared(newValue) && newValue != Node.null;
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid next_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.next_nextThread == tid ? N : E                                                        
        yields_as this.next_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node next_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.next_nextThread == tid ? N : E                                                        
        yields_as this.next_nextThread == tid ==> newValue == this.next_nextValue;                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int value,Node next) {                                                              
        assume this.value == 0;                                                                     
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.value := value;                                                                      
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.next_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.next := next;                                                                      
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Queue {                                                                                   
      volatile Node head isLocal(this, tid)                                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
      hasCASOperation volatile Node tail isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid tail_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.tail_nextThread == tid ? N : E                                                        
        yields_as this.tail_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node tail_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.tail_nextThread == tid ? N : E                                                        
        yields_as this.tail_nextThread == tid ==> newValue == this.tail_nextValue;                  
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null;                                                            
      invariant  this.tail != Node.null;                                                            
                                                                                                    
      requires this.head == Node.null;                                                              
      requires this.tail == Node.null;                                                              
                                                                                                    
      public void init() {                                                                          
        assume this.head == Node.null;                                                              
        assume this.tail == Node.null;                                                              
        {                                                                                           
          Node sentinel;                                                                            
          sentinel = new Node();                                                                    
          sentinel.init(0,Node.null)                                                                
          this.head := sentinel;                                                                    
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.tail_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.tail := sentinel;                                                                  
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void enqueue(int value) {                                                              
        Node n;                                                                                     
        n = new Node();                                                                             
        n.init(value,Node.null)                                                                     
        Node last;                                                                                  
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.tail_nextThread  as B;                                                       
          Node _C_v;                                                                                
          _C_v := this.tail_nextValue  as B;                                                        
          Node _currentValue;                                                                       
          _currentValue := this.tail  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.tail);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                    
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            last := this.tail  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            last := this.tail;                                                                      
          }                                                                                         
        }                                                                                           
        yield;                                                                                      
        while (true)                                                                                
          invariant isLocal(n, tid);                                                                
          invariant isShared(last);                                                                 
          invariant n.next == Node.null;                                                            
          {                                                                                         
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node next;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := last.next_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := last.next_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := last.next  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(last.next);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                 
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                next := last.next  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                next := last.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp2;                                                                           
            tmp2 = next == Node.null;                                                               
            if (tmp2 /* == next == Node.null */) {                                                  
              boolean tmp3;                                                                         
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp3361109;                                                                
                ctmp3361109 = *;                                                                    
                if (ctmp3361109) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp3 = false;                                                                     
                } else {                                                                            
                  ctmp3361109 = *;                                                                  
                  if (ctmp3361109) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(last.next, n);                                             
                    assume last.next == next;                                                       
                    assume !goesWrong(_m);                                                          
                    assume last.next_nextThread == tid;                                             
                    assume last.next_nextValue == next;                                             
                    last.next_nextThread := tmpTid as B;                                            
                    last.next_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    last.next := n;                                                                 
                    tmp3 = true;                                                                    
                  } else {                                                                          
                    assume last.next_nextThread == tid;                                             
                    assume last.next_nextValue == next;                                             
                    Node _currentValue;                                                             
                    _currentValue := last.next  as B;                                               
                    last.next := next as B;                                                         
                    Mover _m;                                                                       
                    _m = writePermission(last.next, n);                                             
                    last.next := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    last.next := n;                                                                 
                    tmp3 = false;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              if (tmp3) {                                                                           
                yield;                                                                              
                boolean tmp4;                                                                       
                {                                                                                   
                  noop(TraceOff);                                                                   
                  boolean ctmp3361119;                                                              
                  ctmp3361119 = *;                                                                  
                  if (ctmp3361119) {                                                                
                    noop(TraceOn);                                                                  
                    tmp4 = false;                                                                   
                  } else {                                                                          
                    ctmp3361119 = *;                                                                
                    if (ctmp3361119) {                                                              
                      Tid tmpTid;                                                                   
                      Node tmpValue;                                                                
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, n);                                           
                      assume this.tail == last;                                                     
                      assume !goesWrong(_m);                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      this.tail_nextThread := tmpTid as B;                                          
                      this.tail_nextValue := tmpValue as B;                                         
                      noop(TraceOn);                                                                
                      this.tail := n;                                                               
                      tmp4 = true;                                                                  
                    } else {                                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      Node _currentValue;                                                           
                      _currentValue := this.tail  as B;                                             
                      this.tail := last as B;                                                       
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, n);                                           
                      this.tail := _currentValue as B;                                              
                      assume goesWrong(_m);                                                         
                      noop(TraceOn);                                                                
                      this.tail := n;                                                               
                      tmp4 = false;                                                                 
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                {                                                                                   
                   return;                                                                          
                }                                                                                   
              } else {                                                                              
                                                                                                    
              }                                                                                     
            } else {                                                                                
              boolean tmp5;                                                                         
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp3361133;                                                                
                ctmp3361133 = *;                                                                    
                if (ctmp3361133) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp5 = false;                                                                     
                } else {                                                                            
                  ctmp3361133 = *;                                                                  
                  if (ctmp3361133) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(this.tail, next);                                          
                    assume this.tail == last;                                                       
                    assume !goesWrong(_m);                                                          
                    assume this.tail_nextThread == tid;                                             
                    assume this.tail_nextValue == last;                                             
                    this.tail_nextThread := tmpTid as B;                                            
                    this.tail_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    this.tail := next;                                                              
                    tmp5 = true;                                                                    
                  } else {                                                                          
                    assume this.tail_nextThread == tid;                                             
                    assume this.tail_nextValue == last;                                             
                    Node _currentValue;                                                             
                    _currentValue := this.tail  as B;                                               
                    this.tail := last as B;                                                         
                    Mover _m;                                                                       
                    _m = writePermission(this.tail, next);                                          
                    this.tail := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    this.tail := next;                                                              
                    tmp5 = false;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              if (tmp5) {                                                                           
                last = next;                                                                        
              } else {                                                                              
                                                                                                    
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int value isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      hasCASOperation noABA volatile Node next isLocal(this, tid)                                   
       ? isRead                                                                                     
         ? B                                                                                        
         : isLocal(newValue, tid) || newValue == Node.null ? B : E                                  
       : isRead                                                                                     
         ? this.next != Node.null ? R : N                                                           
         : isLocal(newValue, tid) && this.next == Node.null && newValue != Node.null ? N : E        
        yields_as newValue == this.next || !isLocal(newValue, tid) && !isShared(newValue) && newValue != Node.null;
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid next_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.next_nextThread == tid ? N : E                                                        
        yields_as this.next_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node next_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.next_nextThread == tid ? N : E                                                        
        yields_as this.next_nextThread == tid ==> newValue == this.next_nextValue;                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int value,Node next) {                                                              
        assume this.value == 0;                                                                     
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.value := value;                                                                      
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.next_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.next := next;                                                                      
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Queue {                                                                                   
      volatile Node head isLocal(this, tid)                                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
      hasCASOperation volatile Node tail isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid tail_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.tail_nextThread == tid ? N : E                                                        
        yields_as this.tail_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node tail_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.tail_nextThread == tid ? N : E                                                        
        yields_as this.tail_nextThread == tid ==> newValue == this.tail_nextValue;                  
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null;                                                            
      invariant  this.tail != Node.null;                                                            
                                                                                                    
      requires this.head == Node.null;                                                              
      requires this.tail == Node.null;                                                              
                                                                                                    
      public void init() {                                                                          
        assume this.head == Node.null;                                                              
        assume this.tail == Node.null;                                                              
        {                                                                                           
          Node sentinel;                                                                            
          sentinel = new Node();                                                                    
          {                                                                                         
            inlined sentinel.init(0,Node.null);                                                     
            exit$226: {                                                                             
              int value$226;                                                                        
              Node next$226;                                                                        
              Node this$226;                                                                        
              value$226 = 0;                                                                        
              next$226 = Node.null;                                                                 
              this$226 = sentinel;                                                                  
              {                                                                                     
                assume this$226.value == 0;                                                         
                assume this$226.next == Node.null;                                                  
                {                                                                                   
                  this$226.value := value$226;                                                      
                  {                                                                                 
                    noop(TraceOff);                                                                 
                    assume this$226.next_nextThread == tid;                                         
                    noop(TraceOn);                                                                  
                    this$226.next := next$226;                                                      
                  }                                                                                 
                  {                                                                                 
                    break exit$226;                                                                 
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            }                                                                                       
            inlined return;                                                                         
          }                                                                                         
          this.head := sentinel;                                                                    
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.tail_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.tail := sentinel;                                                                  
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void enqueue(int value) {                                                              
        Node n;                                                                                     
        n = new Node();                                                                             
        {                                                                                           
          inlined n.init(value,Node.null);                                                          
          exit$227: {                                                                               
            int value$227;                                                                          
            Node next$227;                                                                          
            Node this$227;                                                                          
            value$227 = value;                                                                      
            next$227 = Node.null;                                                                   
            this$227 = n;                                                                           
            {                                                                                       
              assume this$227.value == 0;                                                           
              assume this$227.next == Node.null;                                                    
              {                                                                                     
                this$227.value := value$227;                                                        
                {                                                                                   
                  noop(TraceOff);                                                                   
                  assume this$227.next_nextThread == tid;                                           
                  noop(TraceOn);                                                                    
                  this$227.next := next$227;                                                        
                }                                                                                   
                {                                                                                   
                  break exit$227;                                                                   
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        Node last;                                                                                  
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.tail_nextThread  as B;                                                       
          Node _C_v;                                                                                
          _C_v := this.tail_nextValue  as B;                                                        
          Node _currentValue;                                                                       
          _currentValue := this.tail  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.tail);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                    
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            last := this.tail  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            last := this.tail;                                                                      
          }                                                                                         
        }                                                                                           
        yield;                                                                                      
        while (true)                                                                                
          invariant isLocal(n, tid);                                                                
          invariant isShared(last);                                                                 
          invariant n.next == Node.null;                                                            
          {                                                                                         
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node next;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := last.next_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := last.next_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := last.next  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(last.next);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                 
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                next := last.next  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                next := last.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp2;                                                                           
            tmp2 = next == Node.null;                                                               
            if (tmp2 /* == next == Node.null */) {                                                  
              boolean tmp3;                                                                         
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp3361109;                                                                
                ctmp3361109 = *;                                                                    
                if (ctmp3361109) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp3 = false;                                                                     
                } else {                                                                            
                  ctmp3361109 = *;                                                                  
                  if (ctmp3361109) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(last.next, n);                                             
                    assume last.next == next;                                                       
                    assume !goesWrong(_m);                                                          
                    assume last.next_nextThread == tid;                                             
                    assume last.next_nextValue == next;                                             
                    last.next_nextThread := tmpTid as B;                                            
                    last.next_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    last.next := n;                                                                 
                    tmp3 = true;                                                                    
                  } else {                                                                          
                    assume last.next_nextThread == tid;                                             
                    assume last.next_nextValue == next;                                             
                    Node _currentValue;                                                             
                    _currentValue := last.next  as B;                                               
                    last.next := next as B;                                                         
                    Mover _m;                                                                       
                    _m = writePermission(last.next, n);                                             
                    last.next := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    last.next := n;                                                                 
                    tmp3 = false;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              if (tmp3) {                                                                           
                yield;                                                                              
                boolean tmp4;                                                                       
                {                                                                                   
                  noop(TraceOff);                                                                   
                  boolean ctmp3361119;                                                              
                  ctmp3361119 = *;                                                                  
                  if (ctmp3361119) {                                                                
                    noop(TraceOn);                                                                  
                    tmp4 = false;                                                                   
                  } else {                                                                          
                    ctmp3361119 = *;                                                                
                    if (ctmp3361119) {                                                              
                      Tid tmpTid;                                                                   
                      Node tmpValue;                                                                
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, n);                                           
                      assume this.tail == last;                                                     
                      assume !goesWrong(_m);                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      this.tail_nextThread := tmpTid as B;                                          
                      this.tail_nextValue := tmpValue as B;                                         
                      noop(TraceOn);                                                                
                      this.tail := n;                                                               
                      tmp4 = true;                                                                  
                    } else {                                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      Node _currentValue;                                                           
                      _currentValue := this.tail  as B;                                             
                      this.tail := last as B;                                                       
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, n);                                           
                      this.tail := _currentValue as B;                                              
                      assume goesWrong(_m);                                                         
                      noop(TraceOn);                                                                
                      this.tail := n;                                                               
                      tmp4 = false;                                                                 
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                {                                                                                   
                   return;                                                                          
                }                                                                                   
              } else {                                                                              
                                                                                                    
              }                                                                                     
            } else {                                                                                
              boolean tmp5;                                                                         
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp3361133;                                                                
                ctmp3361133 = *;                                                                    
                if (ctmp3361133) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp5 = false;                                                                     
                } else {                                                                            
                  ctmp3361133 = *;                                                                  
                  if (ctmp3361133) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(this.tail, next);                                          
                    assume this.tail == last;                                                       
                    assume !goesWrong(_m);                                                          
                    assume this.tail_nextThread == tid;                                             
                    assume this.tail_nextValue == last;                                             
                    this.tail_nextThread := tmpTid as B;                                            
                    this.tail_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    this.tail := next;                                                              
                    tmp5 = true;                                                                    
                  } else {                                                                          
                    assume this.tail_nextThread == tid;                                             
                    assume this.tail_nextValue == last;                                             
                    Node _currentValue;                                                             
                    _currentValue := this.tail  as B;                                               
                    this.tail := last as B;                                                         
                    Mover _m;                                                                       
                    _m = writePermission(this.tail, next);                                          
                    this.tail := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    this.tail := next;                                                              
                    tmp5 = false;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              if (tmp5) {                                                                           
                last = next;                                                                        
              } else {                                                                              
                                                                                                    
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int value isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      hasCASOperation noABA volatile Node next isLocal(this, tid)                                   
       ? isRead                                                                                     
         ? B                                                                                        
         : isLocal(newValue, tid) || newValue == Node.null ? B : E                                  
       : isRead                                                                                     
         ? this.next != Node.null ? R : N                                                           
         : isLocal(newValue, tid) && this.next == Node.null && newValue != Node.null ? N : E        
        yields_as newValue == this.next || !isLocal(newValue, tid) && !isShared(newValue) && newValue != Node.null;
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid next_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.next_nextThread == tid ? N : E                                                        
        yields_as this.next_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node next_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.next_nextThread == tid ? N : E                                                        
        yields_as this.next_nextThread == tid ==> newValue == this.next_nextValue;                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int value,Node next) {                                                              
        assume this.value == 0;                                                                     
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.value := value;                                                                      
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.next_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.next := next;                                                                      
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Queue {                                                                                   
      volatile Node head isLocal(this, tid)                                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
      hasCASOperation volatile Node tail isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid tail_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.tail_nextThread == tid ? N : E                                                        
        yields_as this.tail_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node tail_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.tail_nextThread == tid ? N : E                                                        
        yields_as this.tail_nextThread == tid ==> newValue == this.tail_nextValue;                  
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null;                                                            
      invariant  this.tail != Node.null;                                                            
                                                                                                    
      requires this.head == Node.null;                                                              
      requires this.tail == Node.null;                                                              
                                                                                                    
      public void init() {                                                                          
        assume this.head == Node.null;                                                              
        assume this.tail == Node.null;                                                              
        {                                                                                           
          Node sentinel;                                                                            
          sentinel = new Node();                                                                    
          {                                                                                         
            inlined sentinel.init(0,Node.null);                                                     
            exit$226: {                                                                             
              int value$226;                                                                        
              Node next$226;                                                                        
              Node this$226;                                                                        
              value$226 = 0;                                                                        
              next$226 = Node.null;                                                                 
              this$226 = sentinel;                                                                  
              {                                                                                     
                assume this$226.value == 0;                                                         
                assume this$226.next == Node.null;                                                  
                {                                                                                   
                  this$226.value := value$226;                                                      
                  {                                                                                 
                    noop(TraceOff);                                                                 
                    assume this$226.next_nextThread == tid;                                         
                    noop(TraceOn);                                                                  
                    this$226.next := next$226;                                                      
                  }                                                                                 
                  {                                                                                 
                    break exit$226;                                                                 
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            }                                                                                       
            inlined return;                                                                         
          }                                                                                         
          this.head := sentinel;                                                                    
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.tail_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.tail := sentinel;                                                                  
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void enqueue(int value) {                                                              
        Node n;                                                                                     
        n = new Node();                                                                             
        {                                                                                           
          inlined n.init(value,Node.null);                                                          
          exit$227: {                                                                               
            int value$227;                                                                          
            Node next$227;                                                                          
            Node this$227;                                                                          
            value$227 = value;                                                                      
            next$227 = Node.null;                                                                   
            this$227 = n;                                                                           
            {                                                                                       
              assume this$227.value == 0;                                                           
              assume this$227.next == Node.null;                                                    
              {                                                                                     
                this$227.value := value$227;                                                        
                {                                                                                   
                  noop(TraceOff);                                                                   
                  assume this$227.next_nextThread == tid;                                           
                  noop(TraceOn);                                                                    
                  this$227.next := next$227;                                                        
                }                                                                                   
                {                                                                                   
                  break exit$227;                                                                   
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        Node last;                                                                                  
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.tail_nextThread  as B;                                                       
          Node _C_v;                                                                                
          _C_v := this.tail_nextValue  as B;                                                        
          Node _currentValue;                                                                       
          _currentValue := this.tail  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.tail);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                    
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            last := this.tail  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            last := this.tail;                                                                      
          }                                                                                         
        }                                                                                           
        yield;                                                                                      
        while (true)                                                                                
          invariant isLocal(n, tid);                                                                
          invariant isShared(last);                                                                 
          invariant n.next == Node.null;                                                            
          {                                                                                         
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node next;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := last.next_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := last.next_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := last.next  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(last.next);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                 
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                next := last.next  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                next := last.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp2;                                                                           
            tmp2 = next == Node.null;                                                               
            if (tmp2 /* == next == Node.null */) {                                                  
              boolean tmp3;                                                                         
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp3361109;                                                                
                ctmp3361109 = *;                                                                    
                if (ctmp3361109) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp3 = false;                                                                     
                } else {                                                                            
                  ctmp3361109 = *;                                                                  
                  if (ctmp3361109) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(last.next, n);                                             
                    assume last.next == next;                                                       
                    assume !goesWrong(_m);                                                          
                    assume last.next_nextThread == tid;                                             
                    assume last.next_nextValue == next;                                             
                    last.next_nextThread := tmpTid as B;                                            
                    last.next_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    last.next := n;                                                                 
                    tmp3 = true;                                                                    
                  } else {                                                                          
                    assume last.next_nextThread == tid;                                             
                    assume last.next_nextValue == next;                                             
                    Node _currentValue;                                                             
                    _currentValue := last.next  as B;                                               
                    last.next := next as B;                                                         
                    Mover _m;                                                                       
                    _m = writePermission(last.next, n);                                             
                    last.next := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    last.next := n;                                                                 
                    tmp3 = false;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              if (tmp3) {                                                                           
                yield;                                                                              
                boolean tmp4;                                                                       
                {                                                                                   
                  noop(TraceOff);                                                                   
                  boolean ctmp3361119;                                                              
                  ctmp3361119 = *;                                                                  
                  if (ctmp3361119) {                                                                
                    noop(TraceOn);                                                                  
                    tmp4 = false;                                                                   
                  } else {                                                                          
                    ctmp3361119 = *;                                                                
                    if (ctmp3361119) {                                                              
                      Tid tmpTid;                                                                   
                      Node tmpValue;                                                                
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, n);                                           
                      assume this.tail == last;                                                     
                      assume !goesWrong(_m);                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      this.tail_nextThread := tmpTid as B;                                          
                      this.tail_nextValue := tmpValue as B;                                         
                      noop(TraceOn);                                                                
                      this.tail := n;                                                               
                      tmp4 = true;                                                                  
                    } else {                                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      Node _currentValue;                                                           
                      _currentValue := this.tail  as B;                                             
                      this.tail := last as B;                                                       
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, n);                                           
                      this.tail := _currentValue as B;                                              
                      assume goesWrong(_m);                                                         
                      noop(TraceOn);                                                                
                      this.tail := n;                                                               
                      tmp4 = false;                                                                 
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                {                                                                                   
                   return;                                                                          
                }                                                                                   
              } else {                                                                              
                                                                                                    
              }                                                                                     
            } else {                                                                                
              boolean tmp5;                                                                         
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp3361133;                                                                
                ctmp3361133 = *;                                                                    
                if (ctmp3361133) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp5 = false;                                                                     
                } else {                                                                            
                  ctmp3361133 = *;                                                                  
                  if (ctmp3361133) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(this.tail, next);                                          
                    assume this.tail == last;                                                       
                    assume !goesWrong(_m);                                                          
                    assume this.tail_nextThread == tid;                                             
                    assume this.tail_nextValue == last;                                             
                    this.tail_nextThread := tmpTid as B;                                            
                    this.tail_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    this.tail := next;                                                              
                    tmp5 = true;                                                                    
                  } else {                                                                          
                    assume this.tail_nextThread == tid;                                             
                    assume this.tail_nextValue == last;                                             
                    Node _currentValue;                                                             
                    _currentValue := this.tail  as B;                                               
                    this.tail := last as B;                                                         
                    Mover _m;                                                                       
                    _m = writePermission(this.tail, next);                                          
                    this.tail := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    this.tail := next;                                                              
                    tmp5 = false;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              if (tmp5) {                                                                           
                last = next;                                                                        
              } else {                                                                              
                                                                                                    
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Node ***/                                                                           
                                                                                                    
type Node;                                                                                          
const unique Node.null: Node;                                                                       
var Node._state: [Node]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.value: [Node]int;                                                                          
                                                                                                    
function {:inline} ReadEval.Node.value(tid: Tid,this : Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.value(tid: Tid,this : Node,newValue: int,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.next: [Node]Node;                                                                          
                                                                                                    
function {:inline} ReadEval.Node.next(tid: Tid,this : Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if ((isLocal(Node._state[newValue], tid)||(newValue==Node.null))) then                           
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node.next[this]!=Node.null)) then                                                           
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_N, 2)                                                                                
  else                                                                                              
   if (((isLocal(Node._state[newValue], tid)&&(Node.next[this]==Node.null))&&(newValue!=Node.null))) then
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.next(tid: Tid,this : Node,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if ((isLocal(Node._state[newValue], tid)||(newValue==Node.null))) then                           
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node.next[this]!=Node.null)) then                                                           
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_N, 2)                                                                                
  else                                                                                              
   if (((isLocal(Node._state[newValue], tid)&&(Node.next[this]==Node.null))&&(newValue!=Node.null))) then
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node._lock: [Node]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Node._lock(tid: Tid,this : Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node._lock(tid: Tid,this : Node,newValue: Tid,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.next_nextThread: [Node]Tid;                                                                
                                                                                                    
function {:inline} ReadEval.Node.next_nextThread(tid: Tid,this : Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Node._state[this], tid)) then                                                          
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Node.next_nextThread[this]==tid)) then                                                       
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.next_nextThread(tid: Tid,this : Node,newValue: Tid,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Node.next_nextThread[this]==tid)) then                                                       
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.next_nextValue: [Node]Node;                                                                
                                                                                                    
function {:inline} ReadEval.Node.next_nextValue(tid: Tid,this : Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Node._state[this], tid)) then                                                          
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Node.next_nextThread[this]==tid)) then                                                       
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.next_nextValue(tid: Tid,this : Node,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Node.next_nextThread[this]==tid)) then                                                       
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Queue ***/                                                                          
                                                                                                    
type Queue;                                                                                         
const unique Queue.null: Queue;                                                                     
var Queue._state: [Queue]State;                                                                     
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.head: [Queue]Node;                                                                        
                                                                                                    
function {:inline} ReadEval.Queue.head(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.head(tid: Tid,this : Queue,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.tail: [Queue]Node;                                                                        
                                                                                                    
function {:inline} ReadEval.Queue.tail(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.tail(tid: Tid,this : Queue,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue._lock: [Queue]Tid;                                                                        
                                                                                                    
function {:inline} ReadEval.Queue._lock(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Queue._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Queue._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Queue._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue._lock(tid: Tid,this : Queue,newValue: Tid,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Queue._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Queue._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Queue._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.tail_nextThread: [Queue]Tid;                                                              
                                                                                                    
function {:inline} ReadEval.Queue.tail_nextThread(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Queue._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Queue.tail_nextThread[this]==tid)) then                                                      
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.tail_nextThread(tid: Tid,this : Queue,newValue: Tid,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Queue.tail_nextThread[this]==tid)) then                                                      
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.tail_nextValue: [Queue]Node;                                                              
                                                                                                    
function {:inline} ReadEval.Queue.tail_nextValue(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Queue._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Queue.tail_nextThread[this]==tid)) then                                                      
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.tail_nextValue(tid: Tid,this : Queue,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Queue.tail_nextThread[this]==tid)) then                                                      
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.Queue.3374805(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (bool) {
 (Queue.head[this]!=Node.null)                                                                      
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Queue.3374813(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (bool) {
 (Queue.tail[this]!=Node.null)                                                                      
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Queue.init(tid:Tid, this : Queue)                                                        
modifies Node._state;                                                                               
modifies Node.value;                                                                                
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Node.next_nextThread;                                                                      
modifies Node.next_nextValue;                                                                       
modifies Queue._state;                                                                              
modifies Queue.head;                                                                                
modifies Queue.tail;                                                                                
modifies Queue._lock;                                                                               
modifies Queue.tail_nextThread;                                                                     
modifies Queue.tail_nextValue;                                                                      
                                                                                                    
requires ValidTid(tid);                                                                                    // (27.5): Bad tid
requires isLocal(Queue._state[this], tid);                                                          
requires (forall _x : Queue :: this != _x ==> !isLocal(Queue._state[_x], tid));                     
                                                                                                    
requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
requires (Queue.head[this]==Node.null);                                                             
                                                                                                    
requires (Queue.tail[this]==Node.null);                                                             
                                                                                                    
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && _this != this ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (27.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && _this != this ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (27.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (27.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (27.5): Object invariant may not hold.
{                                                                                                   
 var mover3381444: Mover;                                                                           
 var Queue.tail_nextThread3381463: [Queue]Tid;                                                      
 var Queue.tail3381463: [Queue]Node;                                                                
 var Node.next_nextValue3381463: [Node]Node;                                                        
 var mover3381433: Mover;                                                                           
 var path3381463: int;                                                                              
 var Node.next_nextValue3381474: [Node]Node;                                                        
 var tid3381476: Tid;                                                                               
 var value$226: int;                                                                                
 var $recorded.state3381444: int;                                                                   
 var Queue._lock3381444: [Queue]Tid;                                                                
 var Queue.tail3381474: [Queue]Node;                                                                
 var Queue._lock3381476: [Queue]Tid;                                                                
 var tid3381463: Tid;                                                                               
 var Queue.head3381463: [Queue]Node;                                                                
 var Queue.head3381444: [Queue]Node;                                                                
 var Queue.tail_nextThread3381444: [Queue]Tid;                                                      
 var Queue.head3381474: [Queue]Node;                                                                
 var Node._lock3381444: [Node]Tid;                                                                  
 var Node.next_nextThread3381474: [Node]Tid;                                                        
 var Node.next_nextValue3381444: [Node]Node;                                                        
 var Queue._state3381463: [Queue]State;                                                             
 var Node._lock3381433: [Node]Tid;                                                                  
 var Queue._state3381476: [Queue]State;                                                             
 var sentinel3381474: Node;                                                                         
 var Queue.tail3381433: [Queue]Node;                                                                
 var Node.value3381463: [Node]int;                                                                  
 var Queue._lock3381463: [Queue]Tid;                                                                
 var $recorded.state3381476: int;                                                                   
 var Node._lock3381474: [Node]Tid;                                                                  
 var Node._state3381444: [Node]State;                                                               
 var Node.next_nextThread3381463: [Node]Tid;                                                        
 var this3381463: Queue;                                                                            
 var Queue.tail_nextValue3381474: [Queue]Node;                                                      
 var Node._state3381463: [Node]State;                                                               
 var Node._lock3381463: [Node]Tid;                                                                  
 var moverPath3381433: MoverPath;                                                                   
 var this3381476: Queue;                                                                            
 var value$2263381433: int;                                                                         
 var $recorded.state3381433: int;                                                                   
 var Queue._lock3381474: [Queue]Tid;                                                                
 var Queue.tail_nextValue3381476: [Queue]Node;                                                      
 var Queue.head3381433: [Queue]Node;                                                                
 var Node.next3381476: [Node]Node;                                                                  
 var mover3381463: Mover;                                                                           
 var Node.next3381463: [Node]Node;                                                                  
 var Node.next_nextValue3381433: [Node]Node;                                                        
 var $recorded.state3381474: int;                                                                   
 var Node.value3381474: [Node]int;                                                                  
 var moverPath3381444: MoverPath;                                                                   
 var this3381474: Queue;                                                                            
 var this3381444: Queue;                                                                            
 var Node._state3381433: [Node]State;                                                               
 var this3381433: Queue;                                                                            
 var Queue.tail_nextValue3381444: [Queue]Node;                                                      
 var tid3381444: Tid;                                                                               
 var Node.next3381433: [Node]Node;                                                                  
 var Node.value3381476: [Node]int;                                                                  
 var path3381444: int;                                                                              
 var next$2263381444: Node;                                                                         
 var sentinel3381444: Node;                                                                         
 var next$2263381433: Node;                                                                         
 var Queue.tail_nextThread3381476: [Queue]Tid;                                                      
 var this$2263381433: Node;                                                                         
 var Node.next_nextValue3381476: [Node]Node;                                                        
 var moverPath3381463: MoverPath;                                                                   
 var Queue.tail_nextValue3381433: [Queue]Node;                                                      
 var sentinel3381433: Node;                                                                         
 var Node.next_nextThread3381444: [Node]Tid;                                                        
 var sentinel3381463: Node;                                                                         
 var $pc3381476: Phase;                                                                             
 var moverPath3381474: MoverPath;                                                                   
 var Queue.tail3381444: [Queue]Node;                                                                
 var tid3381433: Tid;                                                                               
 var $pc3381463: Phase;                                                                             
 var Queue.tail_nextThread3381474: [Queue]Tid;                                                      
 var $recorded.state3381463: int;                                                                   
 var Queue.head3381476: [Queue]Node;                                                                
 var $pc3381444: Phase;                                                                             
 var Queue.tail_nextThread3381433: [Queue]Tid;                                                      
 var Queue.tail3381476: [Queue]Node;                                                                
 var Node.next3381444: [Node]Node;                                                                  
 var Queue._state3381433: [Queue]State;                                                             
 var Node.value3381444: [Node]int;                                                                  
 var this$2263381444: Node;                                                                         
 var Queue._state3381474: [Queue]State;                                                             
 var $pc3381433: Phase;                                                                             
 var Node._state3381474: [Node]State;                                                               
 var mover3381474: Mover;                                                                           
 var path3381433: int;                                                                              
 var sentinel3381476: Node;                                                                         
 var Queue._lock3381433: [Queue]Tid;                                                                
 var Node._state3381476: [Node]State;                                                               
 var value$2263381444: int;                                                                         
 var Node.next_nextThread3381476: [Node]Tid;                                                        
 var this$226: Node;                                                                                
 var Node.value3381433: [Node]int;                                                                  
 var Node._lock3381476: [Node]Tid;                                                                  
 var Node.next3381474: [Node]Node;                                                                  
 var $pc3381474: Phase;                                                                             
 var sentinel: Node;                                                                                
 var Queue._state3381444: [Queue]State;                                                             
 var Node.next_nextThread3381433: [Node]Tid;                                                        
 var path3381474: int;                                                                              
 var Queue.tail_nextValue3381463: [Queue]Node;                                                      
 var next$226: Node;                                                                                
 var tid3381474: Tid;                                                                               
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true && leq(m#moverPath(ReadEval.Queue.head(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)),_R);       // (27.5): Can only have right-mover memory accesses in requires clause
 assert true && leq(m#moverPath(ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)),_R);       // (27.5): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 27.5: assume this.head == Node.null;                                                            
                                                                                                    
 assume (Queue.head[this]==Node.null);                                                              
                                                                                                    
 // 27.5: assume this.tail == Node.null;                                                            
                                                                                                    
 assume (Queue.tail[this]==Node.null);                                                              
                                                                                                    
 // 28.9: Node sentinel;                                                                            
                                                                                                    
                                                                                                    
 // 28.9: sentinel = new Node();                                                                    
                                                                                                    
 havoc sentinel;                                                                                    
 assume sentinel != Node.null && isFresh(Node._state[sentinel]);                                    
 Node._state[sentinel] := LOCAL(tid);                                                               
 assume Node.value[sentinel]  == 0;                                                                 
 assume Node.next[sentinel]  == Node.null;                                                          
 assume Node._lock[sentinel]  == Tid.null;                                                          
 // inlined: sentinel.init(0,Node.null)}                                                            
 exit$226_top:                                                                                      
                                                                                                    
 // 28.9: int value$226;                                                                            
                                                                                                    
                                                                                                    
 // 28.9: Node next$226;                                                                            
                                                                                                    
                                                                                                    
 // 28.9: Node this$226;                                                                            
                                                                                                    
                                                                                                    
 // 28.9: value$226 = 0;                                                                            
                                                                                                    
 value$226 := 0;                                                                                    
                                                                                                    
 // 28.9: next$226 = Node.null;                                                                     
                                                                                                    
 next$226 := Node.null;                                                                             
                                                                                                    
 // 28.9: this$226 = sentinel;                                                                      
                                                                                                    
 this$226 := sentinel;                                                                              
                                                                                                    
 // 12.5: assume this$226.value == 0;                                                               
                                                                                                    
 assume (Node.value[this$226]==0);                                                                  
                                                                                                    
 // 12.5: assume this$226.next == Node.null;                                                        
                                                                                                    
 assume (Node.next[this$226]==Node.null);                                                           
                                                                                                    
                                                                                                    
 // 13.9: this$226.value := value$226;                                                              
                                                                                                    
                                                                                                    
 moverPath3381433 := WriteEval.Node.value(tid: Tid,this$226: Node,value$226: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 mover3381433 := m#moverPath(moverPath3381433);                                                     
 path3381433 := p#moverPath(moverPath3381433);                                                      
 assume Node._state3381433 == Node._state && Node.value3381433 == Node.value && Node.next3381433 == Node.next && Node._lock3381433 == Node._lock && Node.next_nextThread3381433 == Node.next_nextThread && Node.next_nextValue3381433 == Node.next_nextValue && Queue._state3381433 == Queue._state && Queue.head3381433 == Queue.head && Queue.tail3381433 == Queue.tail && Queue._lock3381433 == Queue._lock && Queue.tail_nextThread3381433 == Queue.tail_nextThread && Queue.tail_nextValue3381433 == Queue.tail_nextValue && this$2263381433 == this$226 && next$2263381433 == next$226 && value$2263381433 == value$226 && sentinel3381433 == sentinel && this3381433 == this && tid3381433 == tid && $pc3381433 == $pc;
 assume $recorded.state3381433 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$226 != Node.null;                                                                     
 } else {                                                                                           
  assert this$226 != Node.null;                                                                            // (13.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3381433);                                                              
 assert $pc != PhaseError;                                                                                 // (13.9): Reduction failure
 Node.value[this$226] := value$226;                                                                 
 // NoOp: 'TraceOff'                                                                                
                                                                                                    
 // 14.9: assume this$226.next_nextThread == tid;                                                   
                                                                                                    
 assume (Node.next_nextThread[this$226]==tid);                                                      
 // NoOp: 'TraceOn'                                                                                 
                                                                                                    
                                                                                                    
 // 14.9: this$226.next := next$226;                                                                
                                                                                                    
                                                                                                    
 moverPath3381444 := WriteEval.Node.next(tid: Tid,this$226: Node,next$226: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 mover3381444 := m#moverPath(moverPath3381444);                                                     
 path3381444 := p#moverPath(moverPath3381444);                                                      
 assume Node._state3381444 == Node._state && Node.value3381444 == Node.value && Node.next3381444 == Node.next && Node._lock3381444 == Node._lock && Node.next_nextThread3381444 == Node.next_nextThread && Node.next_nextValue3381444 == Node.next_nextValue && Queue._state3381444 == Queue._state && Queue.head3381444 == Queue.head && Queue.tail3381444 == Queue.tail && Queue._lock3381444 == Queue._lock && Queue.tail_nextThread3381444 == Queue.tail_nextThread && Queue.tail_nextValue3381444 == Queue.tail_nextValue && this$2263381444 == this$226 && next$2263381444 == next$226 && value$2263381444 == value$226 && sentinel3381444 == sentinel && this3381444 == this && tid3381444 == tid && $pc3381444 == $pc;
 assume $recorded.state3381444 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$226 != Node.null;                                                                     
 } else {                                                                                           
  assert this$226 != Node.null;                                                                            // (14.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3381444);                                                              
 assert $pc != PhaseError;                                                                                 // (14.9): Reduction failure
 Node.next[this$226] := next$226;                                                                   
 if (isLocal(Node._state[next$226], tid)) {                                                         
  Node._state[next$226] := SHARED();                                                                
  assert isSharedAssignable(Node._state[Node.next[next$226]]);                                             // (14.9): next$226 became shared, but next$226.next may not be shared.
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 12.32: break exit$226;                                                                          
                                                                                                    
 goto exit$226_bottom;                                                                              
 exit$226_bottom:                                                                                   
                                                                                                    
                                                                                                    
 // 29.9: this.head := sentinel;                                                                    
                                                                                                    
                                                                                                    
 moverPath3381463 := WriteEval.Queue.head(tid: Tid,this: Queue,sentinel: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 mover3381463 := m#moverPath(moverPath3381463);                                                     
 path3381463 := p#moverPath(moverPath3381463);                                                      
 assume Node._state3381463 == Node._state && Node.value3381463 == Node.value && Node.next3381463 == Node.next && Node._lock3381463 == Node._lock && Node.next_nextThread3381463 == Node.next_nextThread && Node.next_nextValue3381463 == Node.next_nextValue && Queue._state3381463 == Queue._state && Queue.head3381463 == Queue.head && Queue.tail3381463 == Queue.tail && Queue._lock3381463 == Queue._lock && Queue.tail_nextThread3381463 == Queue.tail_nextThread && Queue.tail_nextValue3381463 == Queue.tail_nextValue && sentinel3381463 == sentinel && this3381463 == this && tid3381463 == tid && $pc3381463 == $pc;
 assume $recorded.state3381463 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (29.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3381463);                                                              
 assert $pc != PhaseError;                                                                                 // (29.9): Reduction failure
 Queue.head[this] := sentinel;                                                                      
 if (isLocal(Node._state[sentinel], tid)) {                                                         
  Node._state[sentinel] := SHARED();                                                                
  assert isSharedAssignable(Node._state[Node.next[sentinel]]);                                             // (29.9): sentinel became shared, but sentinel.next may not be shared.
 }                                                                                                  
                                                                                                    
 // NoOp: 'TraceOff'                                                                                
                                                                                                    
 // 30.9: assume this.tail_nextThread == tid;                                                       
                                                                                                    
 assume (Queue.tail_nextThread[this]==tid);                                                         
 // NoOp: 'TraceOn'                                                                                 
                                                                                                    
                                                                                                    
 // 30.9: this.tail := sentinel;                                                                    
                                                                                                    
                                                                                                    
 moverPath3381474 := WriteEval.Queue.tail(tid: Tid,this: Queue,sentinel: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 mover3381474 := m#moverPath(moverPath3381474);                                                     
 path3381474 := p#moverPath(moverPath3381474);                                                      
 assume Node._state3381474 == Node._state && Node.value3381474 == Node.value && Node.next3381474 == Node.next && Node._lock3381474 == Node._lock && Node.next_nextThread3381474 == Node.next_nextThread && Node.next_nextValue3381474 == Node.next_nextValue && Queue._state3381474 == Queue._state && Queue.head3381474 == Queue.head && Queue.tail3381474 == Queue.tail && Queue._lock3381474 == Queue._lock && Queue.tail_nextThread3381474 == Queue.tail_nextThread && Queue.tail_nextValue3381474 == Queue.tail_nextValue && sentinel3381474 == sentinel && this3381474 == this && tid3381474 == tid && $pc3381474 == $pc;
 assume $recorded.state3381474 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (30.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3381474);                                                              
 assert $pc != PhaseError;                                                                                 // (30.9): Reduction failure
 Queue.tail[this] := sentinel;                                                                      
 if (isLocal(Node._state[sentinel], tid)) {                                                         
  Node._state[sentinel] := SHARED();                                                                
  assert isSharedAssignable(Node._state[Node.next[sentinel]]);                                             // (30.9): sentinel became shared, but sentinel.next may not be shared.
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 27.20: // return;                                                                               
                                                                                                    
 assume Node._state3381476 == Node._state && Node.value3381476 == Node.value && Node.next3381476 == Node.next && Node._lock3381476 == Node._lock && Node.next_nextThread3381476 == Node.next_nextThread && Node.next_nextValue3381476 == Node.next_nextValue && Queue._state3381476 == Queue._state && Queue.head3381476 == Queue.head && Queue.tail3381476 == Queue.tail && Queue._lock3381476 == Queue._lock && Queue.tail_nextThread3381476 == Queue.tail_nextThread && Queue.tail_nextValue3381476 == Queue.tail_nextValue && sentinel3381476 == sentinel && this3381476 == this && tid3381476 == tid;
 assume $recorded.state3381476 == 1;                                                                
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (27.20): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (27.20): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  Queue.enqueue(tid:Tid, this : Queue, value : int)                                        
modifies Node._state;                                                                               
modifies Node.value;                                                                                
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Node.next_nextThread;                                                                      
modifies Node.next_nextValue;                                                                       
modifies Queue._state;                                                                              
modifies Queue.head;                                                                                
modifies Queue.tail;                                                                                
modifies Queue._lock;                                                                               
modifies Queue.tail_nextThread;                                                                     
modifies Queue.tail_nextValue;                                                                      
                                                                                                    
requires ValidTid(tid);                                                                                    // (33.5): Bad tid
requires isShared(Queue._state[this]);                                                                     // (33.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (33.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (33.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (33.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (33.5): Object invariant may not hold.
{                                                                                                   
 var this3381615_post: Queue;                                                                       
 var moverPath3381648: MoverPath;                                                                   
 var Queue.tail3381568: [Queue]Node;                                                                
 var Queue.tail3382017: [Queue]Node;                                                                
 var Node.next3381648: [Node]Node;                                                                  
 var Node.next3381810: [Node]Node;                                                                  
 var _m3381894: Mover;                                                                              
 var tmp33381810: bool;                                                                             
 var next3382021: Node;                                                                             
 var Node.next_nextValue3381894: [Node]Node;                                                        
 var n3381531: Node;                                                                                
 var Queue.head3382066: [Queue]Node;                                                                
 var Queue.tail3382021: [Queue]Node;                                                                
 var Queue.tail_nextThread3381611: [Queue]Tid;                                                      
 var Node.next_nextThread3382087: [Node]Tid;                                                        
 var n3381949: Node;                                                                                
 var tmp23381795: bool;                                                                             
 var $recorded.state3381686: int;                                                                   
 var tmp33381827_post: bool;                                                                        
 var Node.value3381615_post: [Node]int;                                                             
 var tmp13382014: bool;                                                                             
 var Queue.tail_nextThread3381636: [Queue]Tid;                                                      
 var tid3381939: Tid;                                                                               
 var Node.value3381691: [Node]int;                                                                  
 var Queue.tail_nextValue3381615: [Queue]Node;                                                      
 var next$2273381531: Node;                                                                         
 var tid3381615_post: Tid;                                                                          
 var Queue._lock3381648: [Queue]Tid;                                                                
 var ctmp33611093381810: bool;                                                                      
 var Node.next3381827_post: [Node]Node;                                                             
 var $recorded.state3381817: int;                                                                   
 var Node._state3382059: [Node]State;                                                               
 var mover3382047: Mover;                                                                           
 var Queue.tail_nextThread3382017: [Queue]Tid;                                                      
 var _C_t3381606: Tid;                                                                              
 var this3381636: Queue;                                                                            
 var tmpTid3382014: Tid;                                                                            
 var path3381636: int;                                                                              
 var Queue._lock3381949: [Queue]Tid;                                                                
 var this3381686: Queue;                                                                            
 var Queue.head3381556: [Queue]Node;                                                                
 var tmp23382084: bool;                                                                             
 var Queue.head3381531: [Queue]Node;                                                                
 var Queue._state3382088: [Queue]State;                                                             
 var Node.value3381606: [Node]int;                                                                  
 var Node._lock3381606: [Node]Tid;                                                                  
 var Queue._state3381556: [Queue]State;                                                             
 var tmp33381817: bool;                                                                             
 var tmpValue3381772: Node;                                                                         
 var Node.next_nextValue3381920: [Node]Node;                                                        
 var Node.next_nextValue3381606: [Node]Node;                                                        
 var this$2273381520: Node;                                                                         
 var Node.next3382088: [Node]Node;                                                                  
 var n3381636: Node;                                                                                
 var this3382084: Queue;                                                                            
 var Node.next3381556: [Node]Node;                                                                  
 var Node.next_nextThread3382084_post: [Node]Tid;                                                   
 var tmp23382044: bool;                                                                             
 var Queue.head3381810: [Queue]Node;                                                                
 var Queue._state3382014: [Queue]State;                                                             
 var Node.next_nextThread3381568: [Node]Tid;                                                        
 var this3381568: Queue;                                                                            
 var Queue.head3381772: [Queue]Node;                                                                
 var Queue._lock3381606: [Queue]Tid;                                                                
 var this3382021: Queue;                                                                            
 var mover3381817: Mover;                                                                           
 var Queue.tail_nextThread3382014: [Queue]Tid;                                                      
 var _R_t3381611: Mover;                                                                            
 var value3382021: int;                                                                             
 var Node.next_nextThread3381765: [Node]Tid;                                                        
 var Node._lock3382066: [Node]Tid;                                                                  
 var Queue.tail_nextValue3382087: [Queue]Node;                                                      
 var tmp33381894: bool;                                                                             
 var next: Node;                                                                                    
 var ctmp33611333382014: bool;                                                                      
 var Queue._state3381795: [Queue]State;                                                             
 var Node.next3381686: [Node]Node;                                                                  
 var _C_t: Tid;                                                                                     
 var tmp53382044: bool;                                                                             
 var next3381887: Node;                                                                             
 var $recorded.state3381642: int;                                                                   
 var tmp13381798: bool;                                                                             
 var Queue.head3381615_post: [Queue]Node;                                                           
 var n3381917: Node;                                                                                
 var Node.next_nextThread3381531: [Node]Tid;                                                        
 var mover3382021: Mover;                                                                           
 var Node.next3381795: [Node]Node;                                                                  
 var Node.next_nextValue3381827: [Node]Node;                                                        
 var Node.next_nextThread3381798: [Node]Tid;                                                        
 var $recorded.state3381611: int;                                                                   
 var _C_t3381562: Tid;                                                                              
 var path3381556: int;                                                                              
 var Queue._lock3381562: [Queue]Tid;                                                                
 var path3381765: int;                                                                              
 var Queue.head3381798: [Queue]Node;                                                                
 var tmp23381810: bool;                                                                             
 var Node._state3381827_post: [Node]State;                                                          
 var value3381949: int;                                                                             
 var this3381827_post: Queue;                                                                       
 var path3381795: int;                                                                              
 var path3381686: int;                                                                              
 var Node.value3382087_bottom: [Node]int;                                                           
 var path3381810: int;                                                                              
 var Queue._lock3382087_bottom: [Queue]Tid;                                                         
 var tid3382047: Tid;                                                                               
 var Queue._state3382047: [Queue]State;                                                             
 var tid3382021: Tid;                                                                               
 var mover3381939: Mover;                                                                           
 var Queue.tail3381817: [Queue]Node;                                                                
 var Queue.head3382014: [Queue]Node;                                                                
 var Node._lock3381827: [Node]Tid;                                                                  
 var _C_t3381611: Tid;                                                                              
 var Queue.head3381949: [Queue]Node;                                                                
 var $recorded.state3382014: int;                                                                   
 var tmp23381887: bool;                                                                             
 var last3381798: Node;                                                                             
 var Queue._lock3381772: [Queue]Tid;                                                                
 var Queue.head3381562: [Queue]Node;                                                                
 var Node.next3381615_post: [Node]Node;                                                             
 var n3382087_bottom: Node;                                                                         
 var n3381611: Node;                                                                                
 var tmp13382021: bool;                                                                             
 var path3381887: int;                                                                              
 var _m3382066: Mover;                                                                              
 var tmp53382014: bool;                                                                             
 var last3382087: Node;                                                                             
 var Queue._state3381686: [Queue]State;                                                             
 var moverPath3381917: MoverPath;                                                                   
 var _currentValue3381686: Node;                                                                    
 var $recorded.state3381568: int;                                                                   
 var Queue.head3382017: [Queue]Node;                                                                
 var $pc3381691: Phase;                                                                             
 var path3381642: int;                                                                              
 var Node.next_nextThread3381795: [Node]Tid;                                                        
 var next3381917: Node;                                                                             
 var moverPath3381772: MoverPath;                                                                   
 var value3382084: int;                                                                             
 var path3381531: int;                                                                              
 var Node.next_nextThread3382017: [Node]Tid;                                                        
 var tid3381642: Tid;                                                                               
 var Queue.head3381827: [Queue]Node;                                                                
 var Node.next_nextValue3381768: [Node]Node;                                                        
 var Queue.tail3382059: [Queue]Node;                                                                
 var _C_t3381686: Tid;                                                                              
 var Node.value3382014: [Node]int;                                                                  
 var tmp23382066: bool;                                                                             
 var tmpValue: Node;                                                                                
 var tmp5: bool;                                                                                    
 var next3381932: Node;                                                                             
 var _casable: bool;                                                                                
 var Node._state3381615: [Node]State;                                                               
 var Queue.tail_nextThread3381890: [Queue]Tid;                                                      
 var Node.next3381887: [Node]Node;                                                                  
 var Queue.tail_nextValue3382087_bottom: [Queue]Node;                                               
 var mover3381556: Mover;                                                                           
 var Node._state3381887: [Node]State;                                                               
 var Node.next3381562: [Node]Node;                                                                  
 var next3381920: Node;                                                                             
 var Queue.tail_nextValue3381795: [Queue]Node;                                                      
 var $recorded.state3381772: int;                                                                   
 var Queue.head3381520: [Queue]Node;                                                                
 var tmp23382021: bool;                                                                             
 var Node.next3381894: [Node]Node;                                                                  
 var Node.next_nextThread3381890: [Node]Tid;                                                        
 var mover3381768: Mover;                                                                           
 var $pc3381827: Phase;                                                                             
 var Node._lock3382059: [Node]Tid;                                                                  
 var mover3381887: Mover;                                                                           
 var Node.next3382047: [Node]Node;                                                                  
 var Node._lock3381932: [Node]Tid;                                                                  
 var ctmp33611333382017: bool;                                                                      
 var Node._lock3382021: [Node]Tid;                                                                  
 var last3382017: Node;                                                                             
 var tmp33381798: bool;                                                                             
 var Queue.tail3381648: [Queue]Node;                                                                
 var tmp13382066: bool;                                                                             
 var Queue.head3381648: [Queue]Node;                                                                
 var Queue._state3381932: [Queue]State;                                                             
 var Node._lock3381890: [Node]Tid;                                                                  
 var $recorded.state3382087: int;                                                                   
 var Queue._lock3382084: [Queue]Tid;                                                                
 var Node._lock3382088: [Node]Tid;                                                                  
 var value3381810: int;                                                                             
 var $recorded.state3381932: int;                                                                   
 var Node.next_nextThread3381827_post: [Node]Tid;                                                   
 var Queue.tail_nextThread3382021: [Queue]Tid;                                                      
 var Node.value3382017: [Node]int;                                                                  
 var path3381691: int;                                                                              
 var mover3381920: Mover;                                                                           
 var Node.next3381642: [Node]Node;                                                                  
 var Queue.tail3382087_bottom: [Queue]Node;                                                         
 var Node.value3381827_post: [Node]int;                                                             
 var tmp13381795: bool;                                                                             
 var Node._lock3381768: [Node]Tid;                                                                  
 var $recorded.state3381691: int;                                                                   
 var Queue.tail_nextValue3381768: [Queue]Node;                                                      
 var Node.next_nextValue3382087: [Node]Node;                                                        
 var _m3381890: Mover;                                                                              
 var moverPath3381890: MoverPath;                                                                   
 var tmp33381890: bool;                                                                             
 var Node._lock3381817: [Node]Tid;                                                                  
 var tid3382044: Tid;                                                                               
 var Queue._lock3381615_post: [Queue]Tid;                                                           
 var ctmp33611093381817: bool;                                                                      
 var Queue.head3381890: [Queue]Node;                                                                
 var Queue._lock3382066: [Queue]Tid;                                                                
 var tmpTid3381765: Tid;                                                                            
 var Queue.tail_nextValue3381810: [Queue]Node;                                                      
 var mover3382059: Mover;                                                                           
 var Queue.tail_nextValue3381887: [Queue]Node;                                                      
 var Node.next3381615: [Node]Node;                                                                  
 var Queue._lock3381642: [Queue]Tid;                                                                
 var Node._lock3381798: [Node]Tid;                                                                  
 var n: Node;                                                                                       
 var this3381520: Queue;                                                                            
 var $pc3382084: Phase;                                                                             
 var Queue.tail_nextValue3381606: [Queue]Node;                                                      
 var tmp13381890: bool;                                                                             
 var moverPath3381691: MoverPath;                                                                   
 var this3382047: Queue;                                                                            
 var tmp53382021: bool;                                                                             
 var ctmp33611333382044: bool;                                                                      
 var Queue.tail_nextThread3381615_post: [Queue]Tid;                                                 
 var this3382059: Queue;                                                                            
 var tid3381887: Tid;                                                                               
 var $pc3381939: Phase;                                                                             
 var Queue._lock3382059: [Queue]Tid;                                                                
 var mover3381686: Mover;                                                                           
 var value3381768: int;                                                                             
 var Node.next_nextValue3381568: [Node]Node;                                                        
 var Node.next_nextThread3381887: [Node]Tid;                                                        
 var tmp13381686: bool;                                                                             
 var Node._state3381606: [Node]State;                                                               
 var Queue.tail_nextValue3381520: [Queue]Node;                                                      
 var Queue.tail_nextValue3382066: [Queue]Node;                                                      
 var Queue.tail_nextThread3381939: [Queue]Tid;                                                      
 var path3381606: int;                                                                              
 var Node.next_nextThread3381606: [Node]Tid;                                                        
 var $recorded.state3381917: int;                                                                   
 var Queue.tail3381890: [Queue]Node;                                                                
 var tid3381615: Tid;                                                                               
 var Queue.tail3381615_post: [Queue]Node;                                                           
 var tid3381772: Tid;                                                                               
 var Queue._lock3381939: [Queue]Tid;                                                                
 var mover3382014: Mover;                                                                           
 var Node.value3381772: [Node]int;                                                                  
 var next3381648: Node;                                                                             
 var last3381556: Node;                                                                             
 var this3381798: Queue;                                                                            
 var Queue.head3382084_post: [Queue]Node;                                                           
 var _m3381932: Mover;                                                                              
 var $pc3381556: Phase;                                                                             
 var Node.next_nextValue3381556: [Node]Node;                                                        
 var Node.next_nextValue3381531: [Node]Node;                                                        
 var $pc3381817: Phase;                                                                             
 var tmp1: bool;                                                                                    
 var phase3382087: Phase;                                                                           
 var n3382066: Node;                                                                                
 var tmp43381920: bool;                                                                             
 var $pc3381920: Phase;                                                                             
 var Queue.tail3381615: [Queue]Node;                                                                
 var path3381772: int;                                                                              
 var $pc3382084_post: Phase;                                                                        
 var Queue.head3381920: [Queue]Node;                                                                
 var Node.value3381562: [Node]int;                                                                  
 var value3381772: int;                                                                             
 var Queue._lock3381810: [Queue]Tid;                                                                
 var n3381827: Node;                                                                                
 var tid3381827_post: Tid;                                                                          
 var _C_t3381636: Tid;                                                                              
 var Node._lock3381939: [Node]Tid;                                                                  
 var Queue.tail_nextValue3381691: [Queue]Node;                                                      
 var Queue.head3381691: [Queue]Node;                                                                
 var Queue.tail_nextThread3381568: [Queue]Tid;                                                      
 var Node.value3381765: [Node]int;                                                                  
 var Node.value3382047: [Node]int;                                                                  
 var tmp23381817: bool;                                                                             
 var Node._state3381686: [Node]State;                                                               
 var Node.value3382044: [Node]int;                                                                  
 var Node.next_nextValue3381887: [Node]Node;                                                        
 var Queue.head3381795: [Queue]Node;                                                                
 var tmpValue3382017: Node;                                                                         
 var Node._lock3381648: [Node]Tid;                                                                  
 var _m3381939: Mover;                                                                              
 var $pc3381642: Phase;                                                                             
 var next3381795: Node;                                                                             
 var Queue._lock3381765: [Queue]Tid;                                                                
 var last3382084_post: Node;                                                                        
 var mover3381894: Mover;                                                                           
 var tmp13381932: bool;                                                                             
 var Queue.head3381636: [Queue]Node;                                                                
 var tmp23381920: bool;                                                                             
 var Queue.tail3381520: [Queue]Node;                                                                
 var value3381827: int;                                                                             
 var next3381949: Node;                                                                             
 var $recorded.state3382021: int;                                                                   
 var moverPath3381568: MoverPath;                                                                   
 var this3381765: Queue;                                                                            
 var tmp43381949: bool;                                                                             
 var Node.next_nextValue3381562: [Node]Node;                                                        
 var Queue.tail_nextValue3381568: [Queue]Node;                                                      
 var last3381772: Node;                                                                             
 var tmpValue3381765: Node;                                                                         
 var Node.value3381939: [Node]int;                                                                  
 var _currentValue3381810: Node;                                                                    
 var Node.value3381611: [Node]int;                                                                  
 var Node.next_nextThread3381768: [Node]Tid;                                                        
 var Queue.tail3381636: [Queue]Node;                                                                
 var tid3381648: Tid;                                                                               
 var Queue.tail_nextValue3382017: [Queue]Node;                                                      
 var Node.value3381887: [Node]int;                                                                  
 var tid3382087: Tid;                                                                               
 var next3381890: Node;                                                                             
 var Queue.tail_nextThread3381648: [Queue]Tid;                                                      
 var tmp33381768: bool;                                                                             
 var n3382014: Node;                                                                                
 var Node.next3381765: [Node]Node;                                                                  
 var Queue.tail_nextValue3381636: [Queue]Node;                                                      
 var ctmp33611093381768: bool;                                                                      
 var tmp2: bool;                                                                                    
 var Node.value3381932: [Node]int;                                                                  
 var Queue.tail_nextThread3382084: [Queue]Tid;                                                      
 var Node._state3381798: [Node]State;                                                               
 var _currentValue3381648: Node;                                                                    
 var tid3381932: Tid;                                                                               
 var ctmp33611333382059: bool;                                                                      
 var next$227: Node;                                                                                
 var tmp13381817: bool;                                                                             
 var tmp23381949: bool;                                                                             
 var Node.next3381691: [Node]Node;                                                                  
 var $pc3381765: Phase;                                                                             
 var mover3381520: Mover;                                                                           
 var Node.next_nextValue3381939: [Node]Node;                                                        
 var Node.next_nextThread3381691: [Node]Tid;                                                        
 var _currentValue3381939: Node;                                                                    
 var Node.next_nextThread3381932: [Node]Tid;                                                        
 var Node._lock3381772: [Node]Tid;                                                                  
 var last3382059: Node;                                                                             
 var Node.next_nextValue3381691: [Node]Node;                                                        
 var Queue.tail_nextValue3381949: [Queue]Node;                                                      
 var Queue.tail_nextThread3381917: [Queue]Tid;                                                      
 var Node.next_nextValue3382044: [Node]Node;                                                        
 var moverPath3381642: MoverPath;                                                                   
 var Node.next3381917: [Node]Node;                                                                  
 var Node._lock3381562: [Node]Tid;                                                                  
 var Queue.tail_nextThread3382047: [Queue]Tid;                                                      
 var Node.value3381817: [Node]int;                                                                  
 var value3381636: int;                                                                             
 var Queue.head3382059: [Queue]Node;                                                                
 var next3382084_post: Node;                                                                        
 var Queue._state3381817: [Queue]State;                                                             
 var $pc3381768: Phase;                                                                             
 var $pc3381932: Phase;                                                                             
 var _R_t3381686: Mover;                                                                            
 var Queue.tail3381887: [Queue]Node;                                                                
 var n3382044: Node;                                                                                
 var Node.next3382066: [Node]Node;                                                                  
 var Node.value3382087: [Node]int;                                                                  
 var tmpValue3381894: Node;                                                                         
 var Node.next3381568: [Node]Node;                                                                  
 var Queue.tail_nextValue3382088: [Queue]Node;                                                      
 var _currentValue3381798: Node;                                                                    
 var moverPath3382017: MoverPath;                                                                   
 var value3381615_post: int;                                                                        
 var mover3381932: Mover;                                                                           
 var Node.next3382014: [Node]Node;                                                                  
 var path3382059: int;                                                                              
 var _currentValue3381917: Node;                                                                    
 var Queue.tail_nextValue3381920: [Queue]Node;                                                      
 var Queue.tail_nextThread3381798: [Queue]Tid;                                                      
 var mover3381636: Mover;                                                                           
 var $pc3382044: Phase;                                                                             
 var Queue._state3381615_post: [Queue]State;                                                        
 var $pc3381520: Phase;                                                                             
 var moverPath3381795: MoverPath;                                                                   
 var $pc3381562: Phase;                                                                             
 var path3381939: int;                                                                              
 var Queue._lock3381827_post: [Queue]Tid;                                                           
 var moverPath3381562: MoverPath;                                                                   
 var moverPath3381531: MoverPath;                                                                   
 var Queue._state3382021: [Queue]State;                                                             
 var Node.next3381817: [Node]Node;                                                                  
 var Queue.tail3381939: [Queue]Node;                                                                
 var Queue.tail_nextValue3381648: [Queue]Node;                                                      
 var Node.value3381949: [Node]int;                                                                  
 var tid3381636: Tid;                                                                               
 var tid3381531: Tid;                                                                               
 var value$2273381520: int;                                                                         
 var Node.next_nextValue3381615_post: [Node]Node;                                                   
 var Queue.tail3382084: [Queue]Node;                                                                
 var Node.value3381890: [Node]int;                                                                  
 var $recorded.state3381531: int;                                                                   
 var Node._lock3381795: [Node]Tid;                                                                  
 var Node.next3381520: [Node]Node;                                                                  
 var Queue.tail3381768: [Queue]Node;                                                                
 var Node.next_nextThread3381648: [Node]Tid;                                                        
 var Node._state3382017: [Node]State;                                                               
 var Node.value3381531: [Node]int;                                                                  
 var this3381795: Queue;                                                                            
 var Node._state3381827: [Node]State;                                                               
 var Queue._lock3382047: [Queue]Tid;                                                                
 var tmp13381887: bool;                                                                             
 var Queue.head3381606: [Queue]Node;                                                                
 var Node.next_nextValue3382084_post: [Node]Node;                                                   
 var _currentValue3382059: Node;                                                                    
 var tmp43381890: bool;                                                                             
 var Node.next_nextThread3381817: [Node]Tid;                                                        
 var _currentValue3381932: Node;                                                                    
 var Queue._state3381615: [Queue]State;                                                             
 var Node.next_nextThread3381949: [Node]Tid;                                                        
 var Node.value3382084: [Node]int;                                                                  
 var Node._lock3381642: [Node]Tid;                                                                  
 var Queue.tail3381765: [Queue]Node;                                                                
 var next3382017: Node;                                                                             
 var value3381648: int;                                                                             
 var path3381648: int;                                                                              
 var this3382084_post: Queue;                                                                       
 var Node.value3382021: [Node]int;                                                                  
 var tmp23381765: bool;                                                                             
 var Queue._lock3381520: [Queue]Tid;                                                                
 var tmp13382084_post: bool;                                                                        
 var Queue._state3381531: [Queue]State;                                                             
 var Queue._lock3381932: [Queue]Tid;                                                                
 var n3381890: Node;                                                                                
 var $pc3382087: Phase;                                                                             
 var ctmp3361109: bool;                                                                             
 var value3381920: int;                                                                             
 var this3381606: Queue;                                                                            
 var last3381810: Node;                                                                             
 var Queue.tail_nextValue3382044: [Queue]Node;                                                      
 var $pc3381810: Phase;                                                                             
 var Node._state3381917: [Node]State;                                                               
 var Node.value3381920: [Node]int;                                                                  
 var Node.value3381686: [Node]int;                                                                  
 var this3382044: Queue;                                                                            
 var Node.next3381636: [Node]Node;                                                                  
 var Node.next_nextThread3381615: [Node]Tid;                                                        
 var Queue.tail_nextValue3381894: [Queue]Node;                                                      
 var Node.next_nextThread3381615_post: [Node]Tid;                                                   
 var tmp13381917: bool;                                                                             
 var _C_v3381691: Node;                                                                             
 var Queue._lock3381768: [Queue]Tid;                                                                
 var ctmp33611093381772: bool;                                                                      
 var Node.next_nextThread3381611: [Node]Tid;                                                        
 var this$2273381531: Node;                                                                         
 var tmp13381827_post: bool;                                                                        
 var mover3381765: Mover;                                                                           
 var $pc3381648: Phase;                                                                             
 var $pc3382066: Phase;                                                                             
 var Queue.tail3381686: [Queue]Node;                                                                
 var Queue.tail_nextValue3381932: [Queue]Node;                                                      
 var Queue._lock3381615: [Queue]Tid;                                                                
 var Queue._lock3381556: [Queue]Tid;                                                                
 var path3381520: int;                                                                              
 var this3381920: Queue;                                                                            
 var Queue._state3381920: [Queue]State;                                                             
 var moverPath3381556: MoverPath;                                                                   
 var Queue.head3382021: [Queue]Node;                                                                
 var tmpValue3382021: Node;                                                                         
 var _C_v: Node;                                                                                    
 var Node._state3381642: [Node]State;                                                               
 var Queue.tail_nextValue3381917: [Queue]Node;                                                      
 var Queue._lock3381568: [Queue]Tid;                                                                
 var n3381615: Node;                                                                                
 var Queue.tail_nextThread3381894: [Queue]Tid;                                                      
 var moverPath3381606: MoverPath;                                                                   
 var tmp43381894: bool;                                                                             
 var tmp13382017: bool;                                                                             
 var Node.value3381556: [Node]int;                                                                  
 var tmpTid3381768: Tid;                                                                            
 var Node.value3382088: [Node]int;                                                                  
 var Queue._lock3381691: [Queue]Tid;                                                                
 var tmp53382017: bool;                                                                             
 var Queue.head3381611: [Queue]Node;                                                                
 var this3382014: Queue;                                                                            
 var $recorded.state3381606: int;                                                                   
 var next3381827_post: Node;                                                                        
 var tmp13381636: bool;                                                                             
 var this3381939: Queue;                                                                            
 var $recorded.state3382044: int;                                                                   
 var Queue.tail_nextThread3382084_post: [Queue]Tid;                                                 
 var $pc3381949: Phase;                                                                             
 var moverPath3381810: MoverPath;                                                                   
 var this3381768: Queue;                                                                            
 var Node._state3381894: [Node]State;                                                               
 var n3382088: Node;                                                                                
 var Node._lock3381556: [Node]Tid;                                                                  
 var this3381894: Queue;                                                                            
 var Queue.tail_nextValue3381827: [Queue]Node;                                                      
 var this$227: Node;                                                                                
 var Node._state3381817: [Node]State;                                                               
 var last3381686: Node;                                                                             
 var tid3381691: Tid;                                                                               
 var Node.next_nextThread3381520: [Node]Tid;                                                        
 var tmp33381765: bool;                                                                             
 var Node.next_nextThread3382044: [Node]Tid;                                                        
 var this3381817: Queue;                                                                            
 var Node.next_nextValue3382066: [Node]Node;                                                        
 var Queue._lock3381686: [Queue]Tid;                                                                
 var Node.next3382087_bottom: [Node]Node;                                                           
 var Queue.head3381887: [Queue]Node;                                                                
 var tmp23381917: bool;                                                                             
 var tid3381949: Tid;                                                                               
 var Queue.tail3382066: [Queue]Node;                                                                
 var last3381636: Node;                                                                             
 var Node._lock3381827_post: [Node]Tid;                                                             
 var mover3381691: Mover;                                                                           
 var Node.next_nextValue3381615: [Node]Node;                                                        
 var next3382066: Node;                                                                             
 var Queue.head3382087_bottom: [Queue]Node;                                                         
 var path3382021: int;                                                                              
 var moverPath3381520: MoverPath;                                                                   
 var tmp13382044: bool;                                                                             
 var mover3381606: Mover;                                                                           
 var value3381894: int;                                                                             
 var _C_t3381568: Tid;                                                                              
 var tmp13381648: bool;                                                                             
 var Queue._lock3382088: [Queue]Tid;                                                                
 var value3381606: int;                                                                             
 var Node._lock3382014: [Node]Tid;                                                                  
 var Queue.head3381568: [Queue]Node;                                                                
 var Queue.tail_nextThread3381772: [Queue]Tid;                                                      
 var last3381568: Node;                                                                             
 var Queue.head3381765: [Queue]Node;                                                                
 var Queue.tail_nextValue3381642: [Queue]Node;                                                      
 var next3382059: Node;                                                                             
 var Queue.tail_nextValue3381611: [Queue]Node;                                                      
 var Node.next3381772: [Node]Node;                                                                  
 var tmp13381894: bool;                                                                             
 var this3382087_bottom: Queue;                                                                     
 var Queue.tail_nextValue3382047: [Queue]Node;                                                      
 var tid3381686: Tid;                                                                               
 var moverPath3381636: MoverPath;                                                                   
 var Node.next_nextValue3381798: [Node]Node;                                                        
 var tid3381817: Tid;                                                                               
 var Queue.tail_nextValue3381827_post: [Queue]Node;                                                 
 var Node.value3381648: [Node]int;                                                                  
 var mover3381568: Mover;                                                                           
 var _m3381817: Mover;                                                                              
 var next3381798: Node;                                                                             
 var ctmp33611193381890: bool;                                                                      
 var tmp43381917: bool;                                                                             
 var Node._lock3381917: [Node]Tid;                                                                  
 var tmp53382066: bool;                                                                             
 var Node._state3382014: [Node]State;                                                               
 var $recorded.state3381636: int;                                                                   
 var moverPath3382044: MoverPath;                                                                   
 var Queue.tail_nextValue3381765: [Queue]Node;                                                      
 var moverPath3382021: MoverPath;                                                                   
 var Queue._lock3381827: [Queue]Tid;                                                                
 var Node.next_nextValue3382084: [Node]Node;                                                        
 var last3381768: Node;                                                                             
 var tmp13381772: bool;                                                                             
 var tmp23381932: bool;                                                                             
 var Node._lock3382017: [Node]Tid;                                                                  
 var _casable3381606: bool;                                                                         
 var Node._lock3381920: [Node]Tid;                                                                  
 var _C_t3381642: Tid;                                                                              
 var value3382044: int;                                                                             
 var Queue.tail_nextValue3382084: [Queue]Node;                                                      
 var tmpTid3382021: Tid;                                                                            
 var Queue.tail_nextThread3381949: [Queue]Tid;                                                      
 var path3382047: int;                                                                              
 var Queue._state3381642: [Queue]State;                                                             
 var last3381890: Node;                                                                             
 var _currentValue3381691: Node;                                                                    
 var Queue._state3381648: [Queue]State;                                                             
 var Node.next_nextThread3381917: [Node]Tid;                                                        
 var moverPath3381887: MoverPath;                                                                   
 var this3381949: Queue;                                                                            
 var Queue.head3381686: [Queue]Node;                                                                
 var Node.next3381949: [Node]Node;                                                                  
 var Node._lock3381691: [Node]Tid;                                                                  
 var Node._lock3382087_bottom: [Node]Tid;                                                           
 var Queue.tail3381920: [Queue]Node;                                                                
 var last3381894: Node;                                                                             
 var moverPath3381798: MoverPath;                                                                   
 var next3382014: Node;                                                                             
 var tmp33381917: bool;                                                                             
 var path3381568: int;                                                                              
 var Queue.tail_nextThread3381686: [Queue]Tid;                                                      
 var Queue._state3382087: [Queue]State;                                                             
 var $recorded.state3381795: int;                                                                   
 var _m3381810: Mover;                                                                              
 var Queue.head3381642: [Queue]Node;                                                                
 var tmp53382047: bool;                                                                             
 var n3381686: Node;                                                                                
 var value3381562: int;                                                                             
 var Queue.tail3382047: [Queue]Node;                                                                
 var Queue._state3381887: [Queue]State;                                                             
 var path3381562: int;                                                                              
 var last: Node;                                                                                    
 var n3382087: Node;                                                                                
 var tmp23381939: bool;                                                                             
 var last3381949: Node;                                                                             
 var tmp23382014: bool;                                                                             
 var Node._state3381568: [Node]State;                                                               
 var Queue.tail3381611: [Queue]Node;                                                                
 var value3382087_bottom: int;                                                                      
 var $pc3381795: Phase;                                                                             
 var next3381939: Node;                                                                             
 var Queue.tail_nextValue3381817: [Queue]Node;                                                      
 var value3382059: int;                                                                             
 var Queue.tail_nextThread3381817: [Queue]Tid;                                                      
 var Node.next_nextThread3381642: [Node]Tid;                                                        
 var Node.next3382059: [Node]Node;                                                                  
 var Node._state3381920: [Node]State;                                                               
 var Node.value3381798: [Node]int;                                                                  
 var Node._state3382088: [Node]State;                                                               
 var this3381642: Queue;                                                                            
 var last3381827: Node;                                                                             
 var Node.next_nextThread3381920: [Node]Tid;                                                        
 var Queue.tail_nextThread3381932: [Queue]Tid;                                                      
 var ctmp33611193381939: bool;                                                                      
 var Node.next_nextValue3381611: [Node]Node;                                                        
 var Queue.tail_nextThread3382044: [Queue]Tid;                                                      
 var _currentValue3381606: Node;                                                                    
 var value$2273381531: int;                                                                         
 var Queue._state3382084_post: [Queue]State;                                                        
 var tid3381917: Tid;                                                                               
 var value3381611: int;                                                                             
 var ctmp33611333382047: bool;                                                                      
 var this3382087: Queue;                                                                            
 var _currentValue3382047: Node;                                                                    
 var _C_v3381642: Node;                                                                             
 var tmp33381772: bool;                                                                             
 var Node.next_nextValue3382088: [Node]Node;                                                        
 var Node._state3382087: [Node]State;                                                               
 var Queue._state3382084: [Queue]State;                                                             
 var next3381772: Node;                                                                             
 var Queue._state3381939: [Queue]State;                                                             
 var n3381772: Node;                                                                                
 var n3381798: Node;                                                                                
 var value3382047: int;                                                                             
 var Queue.tail3381894: [Queue]Node;                                                                
 var next3381768: Node;                                                                             
 var Queue._lock3381636: [Queue]Tid;                                                                
 var tmpTid3382017: Tid;                                                                            
 var $pc3382021: Phase;                                                                             
 var tmp33381887: bool;                                                                             
 var value3382088: int;                                                                             
 var Queue.tail_nextValue3381615_post: [Queue]Node;                                                 
 var Queue.tail_nextThread3381810: [Queue]Tid;                                                      
 var Queue.tail_nextThread3381920: [Queue]Tid;                                                      
 var $pc3381686: Phase;                                                                             
 var Queue._state3381827_post: [Queue]State;                                                        
 var tid3382066: Tid;                                                                               
 var $recorded.state3381648: int;                                                                   
 var ctmp33611193381932: bool;                                                                      
 var tmp33381932: bool;                                                                             
 var Node._lock3381520: [Node]Tid;                                                                  
 var Queue.tail_nextThread3382087: [Queue]Tid;                                                      
 var $recorded.state3382017: int;                                                                   
 var Node.next_nextThread3381939: [Node]Tid;                                                        
 var Queue.tail_nextValue3382084_post: [Queue]Node;                                                 
 var $recorded.state3381798: int;                                                                   
 var Queue._lock3381887: [Queue]Tid;                                                                
 var tmpTid3381887: Tid;                                                                            
 var Queue.tail3381606: [Queue]Node;                                                                
 var Queue.tail_nextThread3381768: [Queue]Tid;                                                      
 var n3381520: Node;                                                                                
 var Node.next_nextThread3382014: [Node]Tid;                                                        
 var tid3381795: Tid;                                                                               
 var tmp23382017: bool;                                                                             
 var Queue._state3381917: [Queue]State;                                                             
 var Queue.tail3381772: [Queue]Node;                                                                
 var $recorded.state3382088: int;                                                                   
 var tid3382087_bottom: Tid;                                                                        
 var n3382047: Node;                                                                                
 var ctmp33611093381798: bool;                                                                      
 var tmp23382047: bool;                                                                             
 var Node._state3381648: [Node]State;                                                               
 var value3381615: int;                                                                             
 var Node._state3382044: [Node]State;                                                               
 var Node.next3382021: [Node]Node;                                                                  
 var Queue._lock3381798: [Queue]Tid;                                                                
 var value3381932: int;                                                                             
 var tmp33381939: bool;                                                                             
 var Node.next_nextThread3381772: [Node]Tid;                                                        
 var Queue.head3382087: [Queue]Node;                                                                
 var Queue._lock3382014: [Queue]Tid;                                                                
 var Queue.tail_nextValue3381890: [Queue]Node;                                                      
 var Queue.tail_nextThread3381691: [Queue]Tid;                                                      
 var $recorded.state3381765: int;                                                                   
 var Queue.head3381917: [Queue]Node;                                                                
 var Node._state3381611: [Node]State;                                                               
 var n3382084_post: Node;                                                                           
 var n3382021: Node;                                                                                
 var last3381932: Node;                                                                             
 var tmp53382059: bool;                                                                             
 var mover3381917: Mover;                                                                           
 var this3381556: Queue;                                                                            
 var _m3381772: Mover;                                                                              
 var Node.next_nextValue3382047: [Node]Node;                                                        
 var Queue.head3381939: [Queue]Node;                                                                
 var Node.value3381768: [Node]int;                                                                  
 var next3381894: Node;                                                                             
 var _currentValue: Node;                                                                           
 var tid3381568: Tid;                                                                               
 var next3381765: Node;                                                                             
 var tmp13381949: bool;                                                                             
 var tid3382084: Tid;                                                                               
 var next3381827: Node;                                                                             
 var $recorded.state3381894: int;                                                                   
 var Node.value3381810: [Node]int;                                                                  
 var Node.next_nextThread3382021: [Node]Tid;                                                        
 var $recorded.state3382084: int;                                                                   
 var n3381810: Node;                                                                                
 var tmp33381827: bool;                                                                             
 var $recorded.state3382047: int;                                                                   
 var $pc3382047: Phase;                                                                             
 var Node.value3381568: [Node]int;                                                                  
 var Node.next_nextValue3382059: [Node]Node;                                                        
 var Node.next3382017: [Node]Node;                                                                  
 var $pc3381798: Phase;                                                                             
 var n3381795: Node;                                                                                
 var Queue.tail_nextThread3381827: [Queue]Tid;                                                      
 var tmp43381939: bool;                                                                             
 var mover3381772: Mover;                                                                           
 var _casable3381691: bool;                                                                         
 var $pc3381615: Phase;                                                                             
 var Node.next3381611: [Node]Node;                                                                  
 var moverPath3382047: MoverPath;                                                                   
 var $pc3381894: Phase;                                                                             
 var Node._lock3381887: [Node]Tid;                                                                  
 var _m3382021: Mover;                                                                              
 var tmp33381949: bool;                                                                             
 var Node.next_nextThread3381894: [Node]Tid;                                                        
 var Queue._state3381562: [Queue]State;                                                             
 var tid3382059: Tid;                                                                               
 var $recorded.state3381562: int;                                                                   
 var $recorded.state3381810: int;                                                                   
 var _R_t: Mover;                                                                                   
 var Queue._state3382044: [Queue]State;                                                             
 var mover3381562: Mover;                                                                           
 var tmp13381691: bool;                                                                             
 var n3382017: Node;                                                                                
 var Node.value3381894: [Node]int;                                                                  
 var mover3382017: Mover;                                                                           
 var Queue.tail_nextValue3381531: [Queue]Node;                                                      
 var n3381642: Node;                                                                                
 var last3381887: Node;                                                                             
 var moverPath3381765: MoverPath;                                                                   
 var Node.value3381615: [Node]int;                                                                  
 var _currentValue3381611: Node;                                                                    
 var $recorded.state3381615: int;                                                                   
 var last3381795: Node;                                                                             
 var Node._state3382066: [Node]State;                                                               
 var Node._state3381949: [Node]State;                                                               
 var _currentValue3381795: Node;                                                                    
 var last3382014: Node;                                                                             
 var $pc3381772: Phase;                                                                             
 var Node.next3382084_post: [Node]Node;                                                             
 var tmp13381827: bool;                                                                             
 var tmp23381890: bool;                                                                             
 var $pc3381827_post: Phase;                                                                        
 var Node._lock3381949: [Node]Tid;                                                                  
 var _currentValue3381817: Node;                                                                    
 var tid3382084_post: Tid;                                                                          
 var Queue.tail_nextValue3381772: [Queue]Node;                                                      
 var moverPath3381894: MoverPath;                                                                   
 var Queue._state3381636: [Queue]State;                                                             
 var next3382047: Node;                                                                             
 var Node._state3382084: [Node]State;                                                               
 var Queue._lock3382044: [Queue]Tid;                                                                
 var Queue.tail3381691: [Queue]Node;                                                                
 var Queue.tail3381949: [Queue]Node;                                                                
 var _m: Mover;                                                                                     
 var last3381615: Node;                                                                             
 var this3381691: Queue;                                                                            
 var Node._lock3382084: [Node]Tid;                                                                  
 var _m3381765: Mover;                                                                              
 var next3381642: Node;                                                                             
 var $recorded.state3381827: int;                                                                   
 var Queue.tail3382088: [Queue]Node;                                                                
 var Node._lock3381611: [Node]Tid;                                                                  
 var tmp23381827: bool;                                                                             
 var Queue.head3381768: [Queue]Node;                                                                
 var value3382066: int;                                                                             
 var Node._lock3381765: [Node]Tid;                                                                  
 var Queue._lock3381817: [Queue]Tid;                                                                
 var last3381920: Node;                                                                             
 var Node.next3381798: [Node]Node;                                                                  
 var moverPath3381920: MoverPath;                                                                   
 var tmp13382047: bool;                                                                             
 var value3381917: int;                                                                             
 var Node._state3381768: [Node]State;                                                               
 var Queue.head3381615: [Queue]Node;                                                                
 var _C_v3381606: Node;                                                                             
 var Queue._lock3381531: [Queue]Tid;                                                                
 var Queue._lock3381917: [Queue]Tid;                                                                
 var n3381691: Node;                                                                                
 var next3382084: Node;                                                                             
 var Node._lock3381568: [Node]Tid;                                                                  
 var Queue.tail3381827: [Queue]Node;                                                                
 var Queue.tail_nextValue3381798: [Queue]Node;                                                      
 var Queue.head3381932: [Queue]Node;                                                                
 var Queue.tail_nextThread3381531: [Queue]Tid;                                                      
 var _currentValue3382044: Node;                                                                    
 var Queue.tail_nextThread3382066: [Queue]Tid;                                                      
 var Node.value3382084_post: [Node]int;                                                             
 var Node.next_nextValue3381817: [Node]Node;                                                        
 var path3381817: int;                                                                              
 var path3382017: int;                                                                              
 var Queue.tail_nextThread3381606: [Queue]Tid;                                                      
 var last3381611: Node;                                                                             
 var $pc3381531: Phase;                                                                             
 var Queue._lock3381894: [Queue]Tid;                                                                
 var n3381894: Node;                                                                                
 var Queue._state3382087_bottom: [Queue]State;                                                      
 var _C_v3381562: Node;                                                                             
 var Node._lock3381686: [Node]Tid;                                                                  
 var Node.next_nextValue3381827_post: [Node]Node;                                                   
 var $pc3381611: Phase;                                                                             
 var tmp13381939: bool;                                                                             
 var Queue.tail_nextThread3381765: [Queue]Tid;                                                      
 var Queue.tail3381917: [Queue]Node;                                                                
 var $pc3381606: Phase;                                                                             
 var Queue.head3381817: [Queue]Node;                                                                
 var next3381686: Node;                                                                             
 var Node.value3382059: [Node]int;                                                                  
 var _C_v3381568: Node;                                                                             
 var _currentValue3381920: Node;                                                                    
 var Queue.tail3382087: [Queue]Node;                                                                
 var last3381648: Node;                                                                             
 var tid3381606: Tid;                                                                               
 var ctmp33611193381920: bool;                                                                      
 var tmp23382084_post: bool;                                                                        
 var ctmp33611193381917: bool;                                                                      
 var $pc3382014: Phase;                                                                             
 var last3381827_post: Node;                                                                        
 var path3382044: int;                                                                              
 var Queue._lock3382021: [Queue]Tid;                                                                
 var last3382088: Node;                                                                             
 var tid3381890: Tid;                                                                               
 var Node.next3381939: [Node]Node;                                                                  
 var n3381939: Node;                                                                                
 var $recorded.state3381887: int;                                                                   
 var Node._state3381939: [Node]State;                                                               
 var tid3381920: Tid;                                                                               
 var Node._state3381772: [Node]State;                                                               
 var Node.next_nextThread3382047: [Node]Tid;                                                        
 var Node.next_nextValue3382021: [Node]Node;                                                        
 var Node.next3381920: [Node]Node;                                                                  
 var this3381611: Queue;                                                                            
 var _casable3381686: bool;                                                                         
 var $pc3382087_bottom: Phase;                                                                      
 var Node._state3381615_post: [Node]State;                                                          
 var path3381768: int;                                                                              
 var Node.next_nextThread3381686: [Node]Tid;                                                        
 var value3381817: int;                                                                             
 var next3381817: Node;                                                                             
 var Queue._lock3382017: [Queue]Tid;                                                                
 var tmp43381932: bool;                                                                             
 var _C_v3381686: Node;                                                                             
 var tmp13381765: bool;                                                                             
 var this3382017: Queue;                                                                            
 var tmp13381768: bool;                                                                             
 var value3381939: int;                                                                             
 var Queue._state3381827: [Queue]State;                                                             
 var tmp13381810: bool;                                                                             
 var tmp23381768: bool;                                                                             
 var ctmp33611093381765: bool;                                                                      
 var Node._lock3381615_post: [Node]Tid;                                                             
 var Node.next_nextValue3381686: [Node]Node;                                                        
 var Queue._state3382017: [Queue]State;                                                             
 var value3381795: int;                                                                             
 var path3381611: int;                                                                              
 var Node.next_nextValue3381949: [Node]Node;                                                        
 var ctmp33611333382066: bool;                                                                      
 var Queue._state3381611: [Queue]State;                                                             
 var Node._state3381531: [Node]State;                                                               
 var n3381562: Node;                                                                                
 var $recorded.state3381890: int;                                                                   
 var Queue._state3381949: [Queue]State;                                                             
 var value3381798: int;                                                                             
 var Queue.tail3381556: [Queue]Node;                                                                
 var last3381642: Node;                                                                             
 var Queue.tail_nextValue3381686: [Queue]Node;                                                      
 var value3381520: int;                                                                             
 var Node.next_nextThread3381827: [Node]Tid;                                                        
 var Queue._lock3382084_post: [Queue]Tid;                                                           
 var Queue.tail3382084_post: [Queue]Node;                                                           
 var moverPath3381939: MoverPath;                                                                   
 var n3381887: Node;                                                                                
 var n3382084: Node;                                                                                
 var Queue.tail3382044: [Queue]Node;                                                                
 var tmp33381920: bool;                                                                             
 var last3381917: Node;                                                                             
 var Node.next3381827: [Node]Node;                                                                  
 var value3381691: int;                                                                             
 var value3381765: int;                                                                             
 var Node.next_nextValue3382014: [Node]Node;                                                        
 var value3382014: int;                                                                             
 var Queue.head3381827_post: [Queue]Node;                                                           
 var $pc3381890: Phase;                                                                             
 var $pc3381636: Phase;                                                                             
 var $pc3381615_post: Phase;                                                                        
 var Node._lock3381531: [Node]Tid;                                                                  
 var Queue.tail3381827_post: [Queue]Node;                                                           
 var Queue.tail_nextThread3382087_bottom: [Queue]Tid;                                               
 var mover3381810: Mover;                                                                           
 var Node.next3382044: [Node]Node;                                                                  
 var Node._state3381932: [Node]State;                                                               
 var tid3381611: Tid;                                                                               
 var tid3381562: Tid;                                                                               
 var next3381810: Node;                                                                             
 var _m3381768: Mover;                                                                              
 var tmpTid3381890: Tid;                                                                            
 var Node.next_nextThread3381556: [Node]Tid;                                                        
 var tmp3: bool;                                                                                    
 var Node._state3381765: [Node]State;                                                               
 var Queue.tail3382014: [Queue]Node;                                                                
 var Node.next_nextThread3381810: [Node]Tid;                                                        
 var n3382059: Node;                                                                                
 var Queue._state3382059: [Queue]State;                                                             
 var tmpTid: Tid;                                                                                   
 var Node._lock3382044: [Node]Tid;                                                                  
 var value3381887: int;                                                                             
 var $pc3382088: Phase;                                                                             
 var Queue.tail3381795: [Queue]Node;                                                                
 var Queue._lock3381795: [Queue]Tid;                                                                
 var moverPath3382014: MoverPath;                                                                   
 var tid3382014: Tid;                                                                               
 var this3381648: Queue;                                                                            
 var Node.next_nextThread3382059: [Node]Tid;                                                        
 var Node._lock3382084_post: [Node]Tid;                                                             
 var Node.next_nextValue3381772: [Node]Node;                                                        
 var $pc3382017: Phase;                                                                             
 var Node.next3381531: [Node]Node;                                                                  
 var Node._lock3381615: [Node]Tid;                                                                  
 var tmpTid3381894: Tid;                                                                            
 var Node._state3381562: [Node]State;                                                               
 var this3381615: Queue;                                                                            
 var tmp4: bool;                                                                                    
 var Queue.tail_nextValue3382014: [Queue]Node;                                                      
 var n3381920: Node;                                                                                
 var Queue._lock3381611: [Queue]Tid;                                                                
 var path3381932: int;                                                                              
 var tmpValue3381890: Node;                                                                         
 var tid3381810: Tid;                                                                               
 var Queue.tail_nextThread3381520: [Queue]Tid;                                                      
 var Queue._state3382066: [Queue]State;                                                             
 var $recorded.state3382084_post: int;                                                              
 var Node._state3381810: [Node]State;                                                               
 var Node.next_nextThread3382066: [Node]Tid;                                                        
 var Node.next_nextThread3382087_bottom: [Node]Tid;                                                 
 var Queue.tail_nextThread3381615: [Queue]Tid;                                                      
 var Queue.tail_nextValue3382021: [Queue]Node;                                                      
 var Node.next_nextThread3381636: [Node]Tid;                                                        
 var Node._state3382021: [Node]State;                                                               
 var $recorded.state3381949: int;                                                                   
 var this3382088: Queue;                                                                            
 var _casable3381611: bool;                                                                         
 var tid3382088: Tid;                                                                               
 var _R_t3381691: Mover;                                                                            
 var Node._lock3381636: [Node]Tid;                                                                  
 var $recorded.state3381556: int;                                                                   
 var last3381939: Node;                                                                             
 var Node._state3381520: [Node]State;                                                               
 var n3381648: Node;                                                                                
 var Node.next3382087: [Node]Node;                                                                  
 var Node._lock3382047: [Node]Tid;                                                                  
 var this3381772: Queue;                                                                            
 var value$227: int;                                                                                
 var last3382044: Node;                                                                             
 var last3381817: Node;                                                                             
 var next3382044: Node;                                                                             
 var ctmp33611093381795: bool;                                                                      
 var path3381890: int;                                                                              
 var Node.next_nextThread3382088: [Node]Tid;                                                        
 var n3381932: Node;                                                                                
 var n3381827_post: Node;                                                                           
 var $recorded.state3381920: int;                                                                   
 var tmp33381795: bool;                                                                             
 var this3381562: Queue;                                                                            
 var ctmp3361133: bool;                                                                             
 var last3382021: Node;                                                                             
 var last3382087_bottom: Node;                                                                      
 var moverPath3381686: MoverPath;                                                                   
 var Queue.tail3381932: [Queue]Node;                                                                
 var this3381887: Queue;                                                                            
 var last3381615_post: Node;                                                                        
 var Queue._lock3381920: [Queue]Tid;                                                                
 var Node.next_nextValue3381795: [Node]Node;                                                        
 var n3381556: Node;                                                                                
 var _m3382059: Mover;                                                                              
 var Node.value3381642: [Node]int;                                                                  
 var tmpValue3381768: Node;                                                                         
 var Node.next_nextValue3381642: [Node]Node;                                                        
 var tmp23381894: bool;                                                                             
 var tmp13382084: bool;                                                                             
 var mover3382066: Mover;                                                                           
 var Queue._state3381568: [Queue]State;                                                             
 var path3381917: int;                                                                              
 var mover3381531: Mover;                                                                           
 var Node._state3382087_bottom: [Node]State;                                                        
 var _m3382017: Mover;                                                                              
 var moverPath3382059: MoverPath;                                                                   
 var mover3381795: Mover;                                                                           
 var Queue._lock3381890: [Queue]Tid;                                                                
 var value3381642: int;                                                                             
 var $recorded.state3381827_post: int;                                                              
 var tmp13381920: bool;                                                                             
 var tid3382017: Tid;                                                                               
 var last3382084: Node;                                                                             
 var path3382066: int;                                                                              
 var _C_t3381556: Tid;                                                                              
 var Queue.tail_nextThread3381795: [Queue]Tid;                                                      
 var Queue._state3381798: [Queue]State;                                                             
 var Queue.tail3381642: [Queue]Node;                                                                
 var Node.next_nextValue3382017: [Node]Node;                                                        
 var $pc3381917: Phase;                                                                             
 var _currentValue3381568: Node;                                                                    
 var next3381691: Node;                                                                             
 var Queue.tail3381810: [Queue]Node;                                                                
 var $recorded.state3382066: int;                                                                   
 var Queue.tail3381798: [Queue]Node;                                                                
 var Queue._state3381890: [Queue]State;                                                             
 var moverPath3381817: MoverPath;                                                                   
 var value3382017: int;                                                                             
 var Queue.tail_nextThread3382059: [Queue]Tid;                                                      
 var _C_t3381648: Tid;                                                                              
 var Node.next_nextValue3381765: [Node]Node;                                                        
 var ctmp33611333382021: bool;                                                                      
 var _C_v3381611: Node;                                                                             
 var _m3381887: Mover;                                                                              
 var this3381827: Queue;                                                                            
 var Node._state3381556: [Node]State;                                                               
 var Node.next_nextThread3381562: [Node]Tid;                                                        
 var Node.next3381890: [Node]Node;                                                                  
 var Queue._lock3382087: [Queue]Tid;                                                                
 var Node._state3381636: [Node]State;                                                               
 var Queue.head3382084: [Queue]Node;                                                                
 var Node._lock3381810: [Node]Tid;                                                                  
 var Queue.tail_nextThread3381887: [Queue]Tid;                                                      
 var Queue.tail_nextValue3381556: [Queue]Node;                                                      
 var Node.next3381932: [Node]Node;                                                                  
 var moverPath3381932: MoverPath;                                                                   
 var Node.next_nextValue3381520: [Node]Node;                                                        
 var Queue.tail3381531: [Queue]Node;                                                                
 var n3381568: Node;                                                                                
 var $recorded.state3381520: int;                                                                   
 var this3382066: Queue;                                                                            
 var Node.value3381795: [Node]int;                                                                  
 var Node._state3381890: [Node]State;                                                               
 var Node._state3382047: [Node]State;                                                               
 var _currentValue3382066: Node;                                                                    
 var moverPath3381768: MoverPath;                                                                   
 var Node._lock3382087: [Node]Tid;                                                                  
 var Node.next_nextValue3381890: [Node]Node;                                                        
 var $pc3381568: Phase;                                                                             
 var tid3381798: Tid;                                                                               
 var Queue.tail_nextValue3382059: [Queue]Node;                                                      
 var $pc3382059: Phase;                                                                             
 var Queue._state3381606: [Queue]State;                                                             
 var _R_t3381606: Mover;                                                                            
 var _C_v3381648: Node;                                                                             
 var next3381636: Node;                                                                             
 var Queue.tail_nextThread3381556: [Queue]Tid;                                                      
 var Queue.tail_nextThread3381827_post: [Queue]Tid;                                                 
 var Queue.tail_nextThread3382088: [Queue]Tid;                                                      
 var Queue._state3381765: [Queue]State;                                                             
 var mover3381890: Mover;                                                                           
 var Node.next3381768: [Node]Node;                                                                  
 var value3381827_post: int;                                                                        
 var Queue.head3381894: [Queue]Node;                                                                
 var this3381810: Queue;                                                                            
 var Node.next3382084: [Node]Node;                                                                  
 var next$2273381520: Node;                                                                         
 var ctmp33611193381894: bool;                                                                      
 var tmp43381887: bool;                                                                             
 var mover3381648: Mover;                                                                           
 var tid3381827: Tid;                                                                               
 var path3381798: int;                                                                              
 var $recorded.state3382059: int;                                                                   
 var Queue.head3382088: [Queue]Node;                                                                
 var Node._state3382084_post: [Node]State;                                                          
 var Node.next_nextThread3382084: [Node]Tid;                                                        
 var tid3381520: Tid;                                                                               
 var Node.value3381520: [Node]int;                                                                  
 var tmpValue3381887: Node;                                                                         
 var Queue._state3381768: [Queue]State;                                                             
 var last3381765: Node;                                                                             
 var Node._lock3381894: [Node]Tid;                                                                  
 var tmp23381798: bool;                                                                             
 var this3381531: Queue;                                                                            
 var $recorded.state3381615_post: int;                                                              
 var Queue._state3381810: [Queue]State;                                                             
 var Node._state3381691: [Node]State;                                                               
 var last3381691: Node;                                                                             
 var ctmp3361119: bool;                                                                             
 var moverPath3382066: MoverPath;                                                                   
 var Queue.tail_nextValue3381939: [Queue]Node;                                                      
 var tmp23382059: bool;                                                                             
 var Queue.tail_nextThread3381642: [Queue]Tid;                                                      
 var tmpValue3382014: Node;                                                                         
 var this3381890: Queue;                                                                            
 var mover3382044: Mover;                                                                           
 var Node.next_nextValue3381917: [Node]Node;                                                        
 var Node.value3381827: [Node]int;                                                                  
 var Node.next_nextValue3382087_bottom: [Node]Node;                                                 
 var Node.value3382066: [Node]int;                                                                  
 var Queue._state3381772: [Queue]State;                                                             
 var this3381917: Queue;                                                                            
 var n3381765: Node;                                                                                
 var tmpTid3381772: Tid;                                                                            
 var last3382066: Node;                                                                             
 var value3381568: int;                                                                             
 var Node.next_nextValue3381636: [Node]Node;                                                        
 var $recorded.state3381939: int;                                                                   
 var tid3381768: Tid;                                                                               
 var $recorded.state3381768: int;                                                                   
 var n3381768: Node;                                                                                
 var mover3381611: Mover;                                                                           
 var Queue.tail3381562: [Queue]Node;                                                                
 var Queue.head3382044: [Queue]Node;                                                                
 var Node.next_nextValue3381932: [Node]Node;                                                        
 var value3381556: int;                                                                             
 var Node.next_nextValue3381810: [Node]Node;                                                        
 var $recorded.state3382087_bottom: int;                                                            
 var Node._state3381795: [Node]State;                                                               
 var Node.value3381917: [Node]int;                                                                  
 var tid3381556: Tid;                                                                               
 var last3382047: Node;                                                                             
 var Node.next_nextValue3381648: [Node]Node;                                                        
 var tmp23381772: bool;                                                                             
 var value3381686: int;                                                                             
 var tmp13382059: bool;                                                                             
 var Node.value3381636: [Node]int;                                                                  
 var n3381615_post: Node;                                                                           
 var Queue.tail_nextValue3381562: [Queue]Node;                                                      
 var value3381890: int;                                                                             
 var this3381932: Queue;                                                                            
 var tid3381894: Tid;                                                                               
 var _C_t3381691: Tid;                                                                              
 var last3381562: Node;                                                                             
 var moverPath3381611: MoverPath;                                                                   
 var path3381894: int;                                                                              
 var value3382087: int;                                                                             
 var last3381606: Node;                                                                             
 var Queue.tail_nextThread3381562: [Queue]Tid;                                                      
 var ctmp33611193381887: bool;                                                                      
 var path3382014: int;                                                                              
 var tmp13381642: bool;                                                                             
 var n3381606: Node;                                                                                
 var tid3381765: Tid;                                                                               
 var Queue._state3381894: [Queue]State;                                                             
 var Queue._state3381691: [Queue]State;                                                             
 var value3381531: int;                                                                             
 var value3382084_post: int;                                                                        
 var tmp23381827_post: bool;                                                                        
 var Queue._state3381520: [Queue]State;                                                             
 var mover3381642: Mover;                                                                           
 var Node.next3381606: [Node]Node;                                                                  
 var _m3382014: Mover;                                                                              
 var $pc3381887: Phase;                                                                             
 var path3381920: int;                                                                              
 var Queue.head3382047: [Queue]Node;                                                                
 var n3381817: Node;                                                                                
 var mover3381798: Mover;                                                                           
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 // 34.9: Node n;                                                                                   
                                                                                                    
                                                                                                    
 // 34.9: n = new Node();                                                                           
                                                                                                    
 havoc n;                                                                                           
 assume n != Node.null && isFresh(Node._state[n]);                                                  
 Node._state[n] := LOCAL(tid);                                                                      
 assume Node.value[n]  == 0;                                                                        
 assume Node.next[n]  == Node.null;                                                                 
 assume Node._lock[n]  == Tid.null;                                                                 
 // inlined: n.init(value,Node.null)}                                                               
 exit$227_top:                                                                                      
                                                                                                    
 // 34.9: int value$227;                                                                            
                                                                                                    
                                                                                                    
 // 34.9: Node next$227;                                                                            
                                                                                                    
                                                                                                    
 // 34.9: Node this$227;                                                                            
                                                                                                    
                                                                                                    
 // 34.9: value$227 = value;                                                                        
                                                                                                    
 value$227 := value;                                                                                
                                                                                                    
 // 34.9: next$227 = Node.null;                                                                     
                                                                                                    
 next$227 := Node.null;                                                                             
                                                                                                    
 // 34.9: this$227 = n;                                                                             
                                                                                                    
 this$227 := n;                                                                                     
                                                                                                    
 // 12.5: assume this$227.value == 0;                                                               
                                                                                                    
 assume (Node.value[this$227]==0);                                                                  
                                                                                                    
 // 12.5: assume this$227.next == Node.null;                                                        
                                                                                                    
 assume (Node.next[this$227]==Node.null);                                                           
                                                                                                    
                                                                                                    
 // 13.9: this$227.value := value$227;                                                              
                                                                                                    
                                                                                                    
 moverPath3381520 := WriteEval.Node.value(tid: Tid,this$227: Node,value$227: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 mover3381520 := m#moverPath(moverPath3381520);                                                     
 path3381520 := p#moverPath(moverPath3381520);                                                      
 assume Node._state3381520 == Node._state && Node.value3381520 == Node.value && Node.next3381520 == Node.next && Node._lock3381520 == Node._lock && Node.next_nextThread3381520 == Node.next_nextThread && Node.next_nextValue3381520 == Node.next_nextValue && Queue._state3381520 == Queue._state && Queue.head3381520 == Queue.head && Queue.tail3381520 == Queue.tail && Queue._lock3381520 == Queue._lock && Queue.tail_nextThread3381520 == Queue.tail_nextThread && Queue.tail_nextValue3381520 == Queue.tail_nextValue && this$2273381520 == this$227 && next$2273381520 == next$227 && value$2273381520 == value$227 && n3381520 == n && value3381520 == value && this3381520 == this && tid3381520 == tid && $pc3381520 == $pc;
 assume $recorded.state3381520 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$227 != Node.null;                                                                     
 } else {                                                                                           
  assert this$227 != Node.null;                                                                            // (13.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3381520);                                                              
 assert $pc != PhaseError;                                                                                 // (13.9): Reduction failure
 Node.value[this$227] := value$227;                                                                 
 // NoOp: 'TraceOff'                                                                                
                                                                                                    
 // 14.9: assume this$227.next_nextThread == tid;                                                   
                                                                                                    
 assume (Node.next_nextThread[this$227]==tid);                                                      
 // NoOp: 'TraceOn'                                                                                 
                                                                                                    
                                                                                                    
 // 14.9: this$227.next := next$227;                                                                
                                                                                                    
                                                                                                    
 moverPath3381531 := WriteEval.Node.next(tid: Tid,this$227: Node,next$227: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 mover3381531 := m#moverPath(moverPath3381531);                                                     
 path3381531 := p#moverPath(moverPath3381531);                                                      
 assume Node._state3381531 == Node._state && Node.value3381531 == Node.value && Node.next3381531 == Node.next && Node._lock3381531 == Node._lock && Node.next_nextThread3381531 == Node.next_nextThread && Node.next_nextValue3381531 == Node.next_nextValue && Queue._state3381531 == Queue._state && Queue.head3381531 == Queue.head && Queue.tail3381531 == Queue.tail && Queue._lock3381531 == Queue._lock && Queue.tail_nextThread3381531 == Queue.tail_nextThread && Queue.tail_nextValue3381531 == Queue.tail_nextValue && this$2273381531 == this$227 && next$2273381531 == next$227 && value$2273381531 == value$227 && n3381531 == n && value3381531 == value && this3381531 == this && tid3381531 == tid && $pc3381531 == $pc;
 assume $recorded.state3381531 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$227 != Node.null;                                                                     
 } else {                                                                                           
  assert this$227 != Node.null;                                                                            // (14.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3381531);                                                              
 assert $pc != PhaseError;                                                                                 // (14.9): Reduction failure
 Node.next[this$227] := next$227;                                                                   
 if (isLocal(Node._state[next$227], tid)) {                                                         
  Node._state[next$227] := SHARED();                                                                
  assert isSharedAssignable(Node._state[Node.next[next$227]]);                                             // (14.9): next$227 became shared, but next$227.next may not be shared.
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 12.32: break exit$227;                                                                          
                                                                                                    
 goto exit$227_bottom;                                                                              
 exit$227_bottom:                                                                                   
                                                                                                    
 // 35.9: Node last;                                                                                
                                                                                                    
 // NoOp: 'TraceOff'                                                                                
                                                                                                    
 // 35.9: Tid _C_t;                                                                                 
                                                                                                    
                                                                                                    
 // 35.9: _C_t := this.tail_nextThread  as B;                                                       
                                                                                                    
                                                                                                    
 moverPath3381556 := ReadEval.Queue.tail_nextThread(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 mover3381556 := m#moverPath(moverPath3381556);                                                     
 path3381556 := p#moverPath(moverPath3381556);                                                      
 assume Node._state3381556 == Node._state && Node.value3381556 == Node.value && Node.next3381556 == Node.next && Node._lock3381556 == Node._lock && Node.next_nextThread3381556 == Node.next_nextThread && Node.next_nextValue3381556 == Node.next_nextValue && Queue._state3381556 == Queue._state && Queue.head3381556 == Queue.head && Queue.tail3381556 == Queue.tail && Queue._lock3381556 == Queue._lock && Queue.tail_nextThread3381556 == Queue.tail_nextThread && Queue.tail_nextValue3381556 == Queue.tail_nextValue && _C_t3381556 == _C_t && last3381556 == last && n3381556 == n && value3381556 == value && this3381556 == this && tid3381556 == tid && $pc3381556 == $pc;
 assume $recorded.state3381556 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (35.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (35.9): Reduction failure
 _C_t := Queue.tail_nextThread[this];                                                               
                                                                                                    
 // 35.9: Node _C_v;                                                                                
                                                                                                    
                                                                                                    
 // 35.9: _C_v := this.tail_nextValue  as B;                                                        
                                                                                                    
                                                                                                    
 moverPath3381562 := ReadEval.Queue.tail_nextValue(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 mover3381562 := m#moverPath(moverPath3381562);                                                     
 path3381562 := p#moverPath(moverPath3381562);                                                      
 assume Node._state3381562 == Node._state && Node.value3381562 == Node.value && Node.next3381562 == Node.next && Node._lock3381562 == Node._lock && Node.next_nextThread3381562 == Node.next_nextThread && Node.next_nextValue3381562 == Node.next_nextValue && Queue._state3381562 == Queue._state && Queue.head3381562 == Queue.head && Queue.tail3381562 == Queue.tail && Queue._lock3381562 == Queue._lock && Queue.tail_nextThread3381562 == Queue.tail_nextThread && Queue.tail_nextValue3381562 == Queue.tail_nextValue && _C_v3381562 == _C_v && _C_t3381562 == _C_t && last3381562 == last && n3381562 == n && value3381562 == value && this3381562 == this && tid3381562 == tid && $pc3381562 == $pc;
 assume $recorded.state3381562 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (35.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (35.9): Reduction failure
 _C_v := Queue.tail_nextValue[this];                                                                
                                                                                                    
 // 35.9: Node _currentValue;                                                                       
                                                                                                    
                                                                                                    
 // 35.9: _currentValue := this.tail  as B;                                                         
                                                                                                    
                                                                                                    
 moverPath3381568 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 mover3381568 := m#moverPath(moverPath3381568);                                                     
 path3381568 := p#moverPath(moverPath3381568);                                                      
 assume Node._state3381568 == Node._state && Node.value3381568 == Node.value && Node.next3381568 == Node.next && Node._lock3381568 == Node._lock && Node.next_nextThread3381568 == Node.next_nextThread && Node.next_nextValue3381568 == Node.next_nextValue && Queue._state3381568 == Queue._state && Queue.head3381568 == Queue.head && Queue.tail3381568 == Queue.tail && Queue._lock3381568 == Queue._lock && Queue.tail_nextThread3381568 == Queue.tail_nextThread && Queue.tail_nextValue3381568 == Queue.tail_nextValue && _currentValue3381568 == _currentValue && _C_v3381568 == _C_v && _C_t3381568 == _C_t && last3381568 == last && n3381568 == n && value3381568 == value && this3381568 == this && tid3381568 == tid && $pc3381568 == $pc;
 assume $recorded.state3381568 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (35.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (35.9): Reduction failure
 _currentValue := Queue.tail[this];                                                                 
                                                                                                    
 // 35.9: Mover _R_t;                                                                               
                                                                                                    
                                                                                                    
 // 35.9: _R_t = readPermission(this.tail);                                                         
                                                                                                    
 _R_t := m#moverPath(ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
 // 35.9: boolean _casable;                                                                         
                                                                                                    
                                                                                                    
 // 35.9: _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                    
                                                                                                    
 _casable := ((((_R_t!=_E)&&false)&&(_C_t==tid))&&(_C_v==_currentValue));                           
 if (_casable) {                                                                                    
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 35.9: last := this.tail  as R;                                                                 
                                                                                                    
                                                                                                    
  moverPath3381606 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3381606 := m#moverPath(moverPath3381606);                                                    
  path3381606 := p#moverPath(moverPath3381606);                                                     
  assume Node._state3381606 == Node._state && Node.value3381606 == Node.value && Node.next3381606 == Node.next && Node._lock3381606 == Node._lock && Node.next_nextThread3381606 == Node.next_nextThread && Node.next_nextValue3381606 == Node.next_nextValue && Queue._state3381606 == Queue._state && Queue.head3381606 == Queue.head && Queue.tail3381606 == Queue.tail && Queue._lock3381606 == Queue._lock && Queue.tail_nextThread3381606 == Queue.tail_nextThread && Queue.tail_nextValue3381606 == Queue.tail_nextValue && _casable3381606 == _casable && _R_t3381606 == _R_t && _currentValue3381606 == _currentValue && _C_v3381606 == _C_v && _C_t3381606 == _C_t && last3381606 == last && n3381606 == n && value3381606 == value && this3381606 == this && tid3381606 == tid && $pc3381606 == $pc;
  assume $recorded.state3381606 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (35.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _R);                                                                       
  assert $pc != PhaseError;                                                                                // (35.9): Reduction failure
  last := Queue.tail[this];                                                                         
 } else {                                                                                           
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 35.9: last := this.tail;                                                                       
                                                                                                    
                                                                                                    
  moverPath3381611 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3381611 := m#moverPath(moverPath3381611);                                                    
  path3381611 := p#moverPath(moverPath3381611);                                                     
  assume Node._state3381611 == Node._state && Node.value3381611 == Node.value && Node.next3381611 == Node.next && Node._lock3381611 == Node._lock && Node.next_nextThread3381611 == Node.next_nextThread && Node.next_nextValue3381611 == Node.next_nextValue && Queue._state3381611 == Queue._state && Queue.head3381611 == Queue.head && Queue.tail3381611 == Queue.tail && Queue._lock3381611 == Queue._lock && Queue.tail_nextThread3381611 == Queue.tail_nextThread && Queue.tail_nextValue3381611 == Queue.tail_nextValue && _casable3381611 == _casable && _R_t3381611 == _R_t && _currentValue3381611 == _currentValue && _C_v3381611 == _C_v && _C_t3381611 == _C_t && last3381611 == last && n3381611 == n && value3381611 == value && this3381611 == this && tid3381611 == tid && $pc3381611 == $pc;
  assume $recorded.state3381611 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (35.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover3381611);                                                             
  assert $pc != PhaseError;                                                                                // (35.9): Reduction failure
  last := Queue.tail[this];                                                                         
 }                                                                                                  
                                                                                                    
 // 36.9: yield;                                                                                    
                                                                                                    
 assume Node._state3381615 == Node._state && Node.value3381615 == Node.value && Node.next3381615 == Node.next && Node._lock3381615 == Node._lock && Node.next_nextThread3381615 == Node.next_nextThread && Node.next_nextValue3381615 == Node.next_nextValue && Queue._state3381615 == Queue._state && Queue.head3381615 == Queue.head && Queue.tail3381615 == Queue.tail && Queue._lock3381615 == Queue._lock && Queue.tail_nextThread3381615 == Queue.tail_nextThread && Queue.tail_nextValue3381615 == Queue.tail_nextValue && last3381615 == last && n3381615 == n && value3381615 == value && this3381615 == this && tid3381615 == tid;
 assume $recorded.state3381615 == 1;                                                                
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (36.9): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (36.9): Object invariant may not hold.
 call Yield(tid);                                                                                   
 assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (36.9): Object invariant may not hold.
 assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (36.9): Object invariant may not hold.
 $pc := PreCommit;                                                                                  
 assume Node._state3381615_post == Node._state && Node.value3381615_post == Node.value && Node.next3381615_post == Node.next && Node._lock3381615_post == Node._lock && Node.next_nextThread3381615_post == Node.next_nextThread && Node.next_nextValue3381615_post == Node.next_nextValue && Queue._state3381615_post == Queue._state && Queue.head3381615_post == Queue.head && Queue.tail3381615_post == Queue.tail && Queue._lock3381615_post == Queue._lock && Queue.tail_nextThread3381615_post == Queue.tail_nextThread && Queue.tail_nextValue3381615_post == Queue.tail_nextValue && last3381615_post == last && n3381615_post == n && value3381615_post == value && this3381615_post == this && tid3381615_post == tid;
 assume $recorded.state3381615_post == 1;                                                           
 assume Node._state3382087 == Node._state && Node.value3382087 == Node.value && Node.next3382087 == Node.next && Node._lock3382087 == Node._lock && Node.next_nextThread3382087 == Node.next_nextThread && Node.next_nextValue3382087 == Node.next_nextValue && Queue._state3382087 == Queue._state && Queue.head3382087 == Queue.head && Queue.tail3382087 == Queue.tail && Queue._lock3382087 == Queue._lock && Queue.tail_nextThread3382087 == Queue.tail_nextThread && Queue.tail_nextValue3382087 == Queue.tail_nextValue && last3382087 == last && n3382087 == n && value3382087 == value && this3382087 == this && tid3382087 == tid;
 assume $recorded.state3382087 == 1;                                                                
                                                                                                    
 // 37.9: while (true)                                                                              
                                                                                                    
 phase3382087 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (33.5): Bad tid
  invariant isShared(Queue._state[this]);                                                                  // (33.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
  invariant  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (37.9): Object invariant may not hold.
  invariant  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (37.9): Object invariant may not hold.
  invariant isLocal(Node._state[n], tid);                                                           
  invariant isShared(Node._state[last]);                                                            
  invariant (Node.next[n]==Node.null);                                                              
  invariant (forall _this : Node :: Invariant.Y_Node.value(tid : Tid, _this, Node.value[_this] ,Node._state3382087,Node.value3382087,Node.next3382087,Node._lock3382087,Node.next_nextThread3382087,Node.next_nextValue3382087,Queue._state3382087,Queue.head3382087,Queue.tail3382087,Queue._lock3382087,Queue.tail_nextThread3382087,Queue.tail_nextValue3382087));       // (37.9): Loop does not preserve yields_as annotation for field value
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state3382087,Node.value3382087,Node.next3382087,Node._lock3382087,Node.next_nextThread3382087,Node.next_nextValue3382087,Queue._state3382087,Queue.head3382087,Queue.tail3382087,Queue._lock3382087,Queue.tail_nextThread3382087,Queue.tail_nextValue3382087));       // (37.9): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Queue :: Invariant.Y_Queue.head(tid : Tid, _this, Queue.head[_this] ,Node._state3382087,Node.value3382087,Node.next3382087,Node._lock3382087,Node.next_nextThread3382087,Node.next_nextValue3382087,Queue._state3382087,Queue.head3382087,Queue.tail3382087,Queue._lock3382087,Queue.tail_nextThread3382087,Queue.tail_nextValue3382087));       // (37.9): Loop does not preserve yields_as annotation for field head
  invariant (forall _this : Queue :: Invariant.Y_Queue.tail(tid : Tid, _this, Queue.tail[_this] ,Node._state3382087,Node.value3382087,Node.next3382087,Node._lock3382087,Node.next_nextThread3382087,Node.next_nextValue3382087,Queue._state3382087,Queue.head3382087,Queue.tail3382087,Queue._lock3382087,Queue.tail_nextThread3382087,Queue.tail_nextValue3382087));       // (37.9): Loop does not preserve yields_as annotation for field tail
  invariant phase3382087 == $pc;                                                                           // (37.9): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (37.9): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 37.15: boolean tmp1;                                                                           
                                                                                                    
                                                                                                    
  // 37.15: tmp1 = true;                                                                            
                                                                                                    
  tmp1 := true;                                                                                     
  if (!(tmp1)) {                                                                                    
                                                                                                    
   // 37.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 42.13: Node next;                                                                              
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 42.13: Tid _C_t;                                                                               
                                                                                                    
                                                                                                    
  // 42.13: _C_t := last.next_nextThread  as B;                                                     
                                                                                                    
                                                                                                    
  moverPath3381636 := ReadEval.Node.next_nextThread(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3381636 := m#moverPath(moverPath3381636);                                                    
  path3381636 := p#moverPath(moverPath3381636);                                                     
  assume Node._state3381636 == Node._state && Node.value3381636 == Node.value && Node.next3381636 == Node.next && Node._lock3381636 == Node._lock && Node.next_nextThread3381636 == Node.next_nextThread && Node.next_nextValue3381636 == Node.next_nextValue && Queue._state3381636 == Queue._state && Queue.head3381636 == Queue.head && Queue.tail3381636 == Queue.tail && Queue._lock3381636 == Queue._lock && Queue.tail_nextThread3381636 == Queue.tail_nextThread && Queue.tail_nextValue3381636 == Queue.tail_nextValue && _C_t3381636 == _C_t && next3381636 == next && tmp13381636 == tmp1 && last3381636 == last && n3381636 == n && value3381636 == value && this3381636 == this && tid3381636 == tid && $pc3381636 == $pc;
  assume $recorded.state3381636 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume last != Node.null;                                                                        
  } else {                                                                                          
   assert last != Node.null;                                                                               // (42.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (42.13): Reduction failure
  _C_t := Node.next_nextThread[last];                                                               
                                                                                                    
  // 42.13: Node _C_v;                                                                              
                                                                                                    
                                                                                                    
  // 42.13: _C_v := last.next_nextValue  as B;                                                      
                                                                                                    
                                                                                                    
  moverPath3381642 := ReadEval.Node.next_nextValue(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3381642 := m#moverPath(moverPath3381642);                                                    
  path3381642 := p#moverPath(moverPath3381642);                                                     
  assume Node._state3381642 == Node._state && Node.value3381642 == Node.value && Node.next3381642 == Node.next && Node._lock3381642 == Node._lock && Node.next_nextThread3381642 == Node.next_nextThread && Node.next_nextValue3381642 == Node.next_nextValue && Queue._state3381642 == Queue._state && Queue.head3381642 == Queue.head && Queue.tail3381642 == Queue.tail && Queue._lock3381642 == Queue._lock && Queue.tail_nextThread3381642 == Queue.tail_nextThread && Queue.tail_nextValue3381642 == Queue.tail_nextValue && _C_v3381642 == _C_v && _C_t3381642 == _C_t && next3381642 == next && tmp13381642 == tmp1 && last3381642 == last && n3381642 == n && value3381642 == value && this3381642 == this && tid3381642 == tid && $pc3381642 == $pc;
  assume $recorded.state3381642 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume last != Node.null;                                                                        
  } else {                                                                                          
   assert last != Node.null;                                                                               // (42.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (42.13): Reduction failure
  _C_v := Node.next_nextValue[last];                                                                
                                                                                                    
  // 42.13: Node _currentValue;                                                                     
                                                                                                    
                                                                                                    
  // 42.13: _currentValue := last.next  as B;                                                       
                                                                                                    
                                                                                                    
  moverPath3381648 := ReadEval.Node.next(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3381648 := m#moverPath(moverPath3381648);                                                    
  path3381648 := p#moverPath(moverPath3381648);                                                     
  assume Node._state3381648 == Node._state && Node.value3381648 == Node.value && Node.next3381648 == Node.next && Node._lock3381648 == Node._lock && Node.next_nextThread3381648 == Node.next_nextThread && Node.next_nextValue3381648 == Node.next_nextValue && Queue._state3381648 == Queue._state && Queue.head3381648 == Queue.head && Queue.tail3381648 == Queue.tail && Queue._lock3381648 == Queue._lock && Queue.tail_nextThread3381648 == Queue.tail_nextThread && Queue.tail_nextValue3381648 == Queue.tail_nextValue && _currentValue3381648 == _currentValue && _C_v3381648 == _C_v && _C_t3381648 == _C_t && next3381648 == next && tmp13381648 == tmp1 && last3381648 == last && n3381648 == n && value3381648 == value && this3381648 == this && tid3381648 == tid && $pc3381648 == $pc;
  assume $recorded.state3381648 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume last != Node.null;                                                                        
  } else {                                                                                          
   assert last != Node.null;                                                                               // (42.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (42.13): Reduction failure
  _currentValue := Node.next[last];                                                                 
                                                                                                    
  // 42.13: Mover _R_t;                                                                             
                                                                                                    
                                                                                                    
  // 42.13: _R_t = readPermission(last.next);                                                       
                                                                                                    
  _R_t := m#moverPath(ReadEval.Node.next(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
  // 42.13: boolean _casable;                                                                       
                                                                                                    
                                                                                                    
  // 42.13: _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                   
                                                                                                    
  _casable := ((((_R_t!=_E)&&true)&&(_C_t==tid))&&(_C_v==_currentValue));                           
  if (_casable) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 42.13: next := last.next  as R;                                                               
                                                                                                    
                                                                                                    
   moverPath3381686 := ReadEval.Node.next(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
   mover3381686 := m#moverPath(moverPath3381686);                                                   
   path3381686 := p#moverPath(moverPath3381686);                                                    
   assume Node._state3381686 == Node._state && Node.value3381686 == Node.value && Node.next3381686 == Node.next && Node._lock3381686 == Node._lock && Node.next_nextThread3381686 == Node.next_nextThread && Node.next_nextValue3381686 == Node.next_nextValue && Queue._state3381686 == Queue._state && Queue.head3381686 == Queue.head && Queue.tail3381686 == Queue.tail && Queue._lock3381686 == Queue._lock && Queue.tail_nextThread3381686 == Queue.tail_nextThread && Queue.tail_nextValue3381686 == Queue.tail_nextValue && _casable3381686 == _casable && _R_t3381686 == _R_t && _currentValue3381686 == _currentValue && _C_v3381686 == _C_v && _C_t3381686 == _C_t && next3381686 == next && tmp13381686 == tmp1 && last3381686 == last && n3381686 == n && value3381686 == value && this3381686 == this && tid3381686 == tid && $pc3381686 == $pc;
   assume $recorded.state3381686 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume last != Node.null;                                                                       
   } else {                                                                                         
    assert last != Node.null;                                                                              // (42.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, _R);                                                                      
   assert $pc != PhaseError;                                                                               // (42.13): Reduction failure
   next := Node.next[last];                                                                         
  } else {                                                                                          
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 42.13: next := last.next;                                                                     
                                                                                                    
                                                                                                    
   moverPath3381691 := ReadEval.Node.next(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
   mover3381691 := m#moverPath(moverPath3381691);                                                   
   path3381691 := p#moverPath(moverPath3381691);                                                    
   assume Node._state3381691 == Node._state && Node.value3381691 == Node.value && Node.next3381691 == Node.next && Node._lock3381691 == Node._lock && Node.next_nextThread3381691 == Node.next_nextThread && Node.next_nextValue3381691 == Node.next_nextValue && Queue._state3381691 == Queue._state && Queue.head3381691 == Queue.head && Queue.tail3381691 == Queue.tail && Queue._lock3381691 == Queue._lock && Queue.tail_nextThread3381691 == Queue.tail_nextThread && Queue.tail_nextValue3381691 == Queue.tail_nextValue && _casable3381691 == _casable && _R_t3381691 == _R_t && _currentValue3381691 == _currentValue && _C_v3381691 == _C_v && _C_t3381691 == _C_t && next3381691 == next && tmp13381691 == tmp1 && last3381691 == last && n3381691 == n && value3381691 == value && this3381691 == this && tid3381691 == tid && $pc3381691 == $pc;
   assume $recorded.state3381691 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume last != Node.null;                                                                       
   } else {                                                                                         
    assert last != Node.null;                                                                              // (42.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover3381691);                                                            
   assert $pc != PhaseError;                                                                               // (42.13): Reduction failure
   next := Node.next[last];                                                                         
  }                                                                                                 
                                                                                                    
  // 43.13: boolean tmp2;                                                                           
                                                                                                    
                                                                                                    
  // 43.13: tmp2 = next == Node.null;                                                               
                                                                                                    
  tmp2 := (next==Node.null);                                                                        
  if (tmp2 /* lowered (next==Node.null) */) {                                                       
                                                                                                    
   // 44.17: boolean tmp3;                                                                          
                                                                                                    
   // NoOp: 'TraceOff'                                                                              
                                                                                                    
   // 44.17: boolean ctmp3361109;                                                                   
                                                                                                    
                                                                                                    
   // 44.17: ctmp3361109 = *;                                                                       
                                                                                                    
   havoc ctmp3361109;                                                                               
   if (ctmp3361109) {                                                                               
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
    // 44.17: tmp3 = false;                                                                         
                                                                                                    
    tmp3 := false;                                                                                  
   } else {                                                                                         
                                                                                                    
    // 44.17: ctmp3361109 = *;                                                                      
                                                                                                    
    havoc ctmp3361109;                                                                              
    if (ctmp3361109) {                                                                              
                                                                                                    
     // 44.17: Tid tmpTid;                                                                          
                                                                                                    
                                                                                                    
     // 44.17: Node tmpValue;                                                                       
                                                                                                    
                                                                                                    
     // 44.17: Mover _m;                                                                            
                                                                                                    
                                                                                                    
     // 44.17: _m = writePermission(last.next, n);                                                  
                                                                                                    
     _m := m#moverPath(WriteEval.Node.next(tid: Tid,last: Node,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
     // 44.17: assume last.next == next;                                                            
                                                                                                    
     assume (Node.next[last]==next);                                                                
                                                                                                    
     // 44.17: assume !goesWrong(_m);                                                               
                                                                                                    
     assume !(transition($pc, _m) == PhaseError);                                                   
                                                                                                    
     // 44.17: assume last.next_nextThread == tid;                                                  
                                                                                                    
     assume (Node.next_nextThread[last]==tid);                                                      
                                                                                                    
     // 44.17: assume last.next_nextValue == next;                                                  
                                                                                                    
     assume (Node.next_nextValue[last]==next);                                                      
                                                                                                    
                                                                                                    
     // 44.17: last.next_nextThread := tmpTid as B;                                                 
                                                                                                    
                                                                                                    
     moverPath3381765 := WriteEval.Node.next_nextThread(tid: Tid,last: Node,tmpTid: Tid,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3381765 := m#moverPath(moverPath3381765);                                                 
     path3381765 := p#moverPath(moverPath3381765);                                                  
     assume Node._state3381765 == Node._state && Node.value3381765 == Node.value && Node.next3381765 == Node.next && Node._lock3381765 == Node._lock && Node.next_nextThread3381765 == Node.next_nextThread && Node.next_nextValue3381765 == Node.next_nextValue && Queue._state3381765 == Queue._state && Queue.head3381765 == Queue.head && Queue.tail3381765 == Queue.tail && Queue._lock3381765 == Queue._lock && Queue.tail_nextThread3381765 == Queue.tail_nextThread && Queue.tail_nextValue3381765 == Queue.tail_nextValue && _m3381765 == _m && tmpValue3381765 == tmpValue && tmpTid3381765 == tmpTid && ctmp33611093381765 == ctmp3361109 && tmp33381765 == tmp3 && tmp23381765 == tmp2 && next3381765 == next && tmp13381765 == tmp1 && last3381765 == last && n3381765 == n && value3381765 == value && this3381765 == this && tid3381765 == tid && $pc3381765 == $pc;
     assume $recorded.state3381765 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (44.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (44.17): Reduction failure
     Node.next_nextThread[last] := tmpTid;                                                          
                                                                                                    
                                                                                                    
     // 44.17: last.next_nextValue := tmpValue as B;                                                
                                                                                                    
                                                                                                    
     moverPath3381768 := WriteEval.Node.next_nextValue(tid: Tid,last: Node,tmpValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3381768 := m#moverPath(moverPath3381768);                                                 
     path3381768 := p#moverPath(moverPath3381768);                                                  
     assume Node._state3381768 == Node._state && Node.value3381768 == Node.value && Node.next3381768 == Node.next && Node._lock3381768 == Node._lock && Node.next_nextThread3381768 == Node.next_nextThread && Node.next_nextValue3381768 == Node.next_nextValue && Queue._state3381768 == Queue._state && Queue.head3381768 == Queue.head && Queue.tail3381768 == Queue.tail && Queue._lock3381768 == Queue._lock && Queue.tail_nextThread3381768 == Queue.tail_nextThread && Queue.tail_nextValue3381768 == Queue.tail_nextValue && _m3381768 == _m && tmpValue3381768 == tmpValue && tmpTid3381768 == tmpTid && ctmp33611093381768 == ctmp3361109 && tmp33381768 == tmp3 && tmp23381768 == tmp2 && next3381768 == next && tmp13381768 == tmp1 && last3381768 == last && n3381768 == n && value3381768 == value && this3381768 == this && tid3381768 == tid && $pc3381768 == $pc;
     assume $recorded.state3381768 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (44.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (44.17): Reduction failure
     Node.next_nextValue[last] := tmpValue;                                                         
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
                                                                                                    
     // 44.17: last.next := n;                                                                      
                                                                                                    
                                                                                                    
     moverPath3381772 := WriteEval.Node.next(tid: Tid,last: Node,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3381772 := m#moverPath(moverPath3381772);                                                 
     path3381772 := p#moverPath(moverPath3381772);                                                  
     assume Node._state3381772 == Node._state && Node.value3381772 == Node.value && Node.next3381772 == Node.next && Node._lock3381772 == Node._lock && Node.next_nextThread3381772 == Node.next_nextThread && Node.next_nextValue3381772 == Node.next_nextValue && Queue._state3381772 == Queue._state && Queue.head3381772 == Queue.head && Queue.tail3381772 == Queue.tail && Queue._lock3381772 == Queue._lock && Queue.tail_nextThread3381772 == Queue.tail_nextThread && Queue.tail_nextValue3381772 == Queue.tail_nextValue && _m3381772 == _m && tmpValue3381772 == tmpValue && tmpTid3381772 == tmpTid && ctmp33611093381772 == ctmp3361109 && tmp33381772 == tmp3 && tmp23381772 == tmp2 && next3381772 == next && tmp13381772 == tmp1 && last3381772 == last && n3381772 == n && value3381772 == value && this3381772 == this && tid3381772 == tid && $pc3381772 == $pc;
     assume $recorded.state3381772 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (44.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, mover3381772);                                                          
     assert $pc != PhaseError;                                                                             // (44.17): Reduction failure
     Node.next[last] := n;                                                                          
     if (isLocal(Node._state[n], tid)) {                                                            
      Node._state[n] := SHARED();                                                                   
      assert isSharedAssignable(Node._state[Node.next[n]]);                                                // (44.17): n became shared, but n.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 44.17: tmp3 = true;                                                                         
                                                                                                    
     tmp3 := true;                                                                                  
    } else {                                                                                        
                                                                                                    
     // 44.17: assume last.next_nextThread == tid;                                                  
                                                                                                    
     assume (Node.next_nextThread[last]==tid);                                                      
                                                                                                    
     // 44.17: assume last.next_nextValue == next;                                                  
                                                                                                    
     assume (Node.next_nextValue[last]==next);                                                      
                                                                                                    
     // 44.17: Node _currentValue;                                                                  
                                                                                                    
                                                                                                    
     // 44.17: _currentValue := last.next  as B;                                                    
                                                                                                    
                                                                                                    
     moverPath3381795 := ReadEval.Node.next(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3381795 := m#moverPath(moverPath3381795);                                                 
     path3381795 := p#moverPath(moverPath3381795);                                                  
     assume Node._state3381795 == Node._state && Node.value3381795 == Node.value && Node.next3381795 == Node.next && Node._lock3381795 == Node._lock && Node.next_nextThread3381795 == Node.next_nextThread && Node.next_nextValue3381795 == Node.next_nextValue && Queue._state3381795 == Queue._state && Queue.head3381795 == Queue.head && Queue.tail3381795 == Queue.tail && Queue._lock3381795 == Queue._lock && Queue.tail_nextThread3381795 == Queue.tail_nextThread && Queue.tail_nextValue3381795 == Queue.tail_nextValue && _currentValue3381795 == _currentValue && ctmp33611093381795 == ctmp3361109 && tmp33381795 == tmp3 && tmp23381795 == tmp2 && next3381795 == next && tmp13381795 == tmp1 && last3381795 == last && n3381795 == n && value3381795 == value && this3381795 == this && tid3381795 == tid && $pc3381795 == $pc;
     assume $recorded.state3381795 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (44.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
                                                                                                    
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (44.17): Reduction failure
     _currentValue := Node.next[last];                                                              
                                                                                                    
                                                                                                    
     // 44.17: last.next := next as B;                                                              
                                                                                                    
                                                                                                    
     moverPath3381798 := WriteEval.Node.next(tid: Tid,last: Node,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3381798 := m#moverPath(moverPath3381798);                                                 
     path3381798 := p#moverPath(moverPath3381798);                                                  
     assume Node._state3381798 == Node._state && Node.value3381798 == Node.value && Node.next3381798 == Node.next && Node._lock3381798 == Node._lock && Node.next_nextThread3381798 == Node.next_nextThread && Node.next_nextValue3381798 == Node.next_nextValue && Queue._state3381798 == Queue._state && Queue.head3381798 == Queue.head && Queue.tail3381798 == Queue.tail && Queue._lock3381798 == Queue._lock && Queue.tail_nextThread3381798 == Queue.tail_nextThread && Queue.tail_nextValue3381798 == Queue.tail_nextValue && _currentValue3381798 == _currentValue && ctmp33611093381798 == ctmp3361109 && tmp33381798 == tmp3 && tmp23381798 == tmp2 && next3381798 == next && tmp13381798 == tmp1 && last3381798 == last && n3381798 == n && value3381798 == value && this3381798 == this && tid3381798 == tid && $pc3381798 == $pc;
     assume $recorded.state3381798 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (44.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (44.17): Reduction failure
     Node.next[last] := next;                                                                       
     if (isLocal(Node._state[next], tid)) {                                                         
      Node._state[next] := SHARED();                                                                
      assert isSharedAssignable(Node._state[Node.next[next]]);                                             // (44.17): next became shared, but next.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 44.17: Mover _m;                                                                            
                                                                                                    
                                                                                                    
     // 44.17: _m = writePermission(last.next, n);                                                  
                                                                                                    
     _m := m#moverPath(WriteEval.Node.next(tid: Tid,last: Node,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
                                                                                                    
     // 44.17: last.next := _currentValue as B;                                                     
                                                                                                    
                                                                                                    
     moverPath3381810 := WriteEval.Node.next(tid: Tid,last: Node,_currentValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3381810 := m#moverPath(moverPath3381810);                                                 
     path3381810 := p#moverPath(moverPath3381810);                                                  
     assume Node._state3381810 == Node._state && Node.value3381810 == Node.value && Node.next3381810 == Node.next && Node._lock3381810 == Node._lock && Node.next_nextThread3381810 == Node.next_nextThread && Node.next_nextValue3381810 == Node.next_nextValue && Queue._state3381810 == Queue._state && Queue.head3381810 == Queue.head && Queue.tail3381810 == Queue.tail && Queue._lock3381810 == Queue._lock && Queue.tail_nextThread3381810 == Queue.tail_nextThread && Queue.tail_nextValue3381810 == Queue.tail_nextValue && _m3381810 == _m && _currentValue3381810 == _currentValue && ctmp33611093381810 == ctmp3361109 && tmp33381810 == tmp3 && tmp23381810 == tmp2 && next3381810 == next && tmp13381810 == tmp1 && last3381810 == last && n3381810 == n && value3381810 == value && this3381810 == this && tid3381810 == tid && $pc3381810 == $pc;
     assume $recorded.state3381810 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (44.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (44.17): Reduction failure
     Node.next[last] := _currentValue;                                                              
     if (isLocal(Node._state[_currentValue], tid)) {                                                
      Node._state[_currentValue] := SHARED();                                                       
      assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                    // (44.17): _currentValue became shared, but _currentValue.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 44.17: assume goesWrong(_m);                                                                
                                                                                                    
     assume transition($pc, _m) == PhaseError;                                                      
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
                                                                                                    
     // 44.17: last.next := n;                                                                      
                                                                                                    
                                                                                                    
     moverPath3381817 := WriteEval.Node.next(tid: Tid,last: Node,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3381817 := m#moverPath(moverPath3381817);                                                 
     path3381817 := p#moverPath(moverPath3381817);                                                  
     assume Node._state3381817 == Node._state && Node.value3381817 == Node.value && Node.next3381817 == Node.next && Node._lock3381817 == Node._lock && Node.next_nextThread3381817 == Node.next_nextThread && Node.next_nextValue3381817 == Node.next_nextValue && Queue._state3381817 == Queue._state && Queue.head3381817 == Queue.head && Queue.tail3381817 == Queue.tail && Queue._lock3381817 == Queue._lock && Queue.tail_nextThread3381817 == Queue.tail_nextThread && Queue.tail_nextValue3381817 == Queue.tail_nextValue && _m3381817 == _m && _currentValue3381817 == _currentValue && ctmp33611093381817 == ctmp3361109 && tmp33381817 == tmp3 && tmp23381817 == tmp2 && next3381817 == next && tmp13381817 == tmp1 && last3381817 == last && n3381817 == n && value3381817 == value && this3381817 == this && tid3381817 == tid && $pc3381817 == $pc;
     assume $recorded.state3381817 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (44.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, mover3381817);                                                          
     assert $pc != PhaseError;                                                                             // (44.17): Reduction failure
     Node.next[last] := n;                                                                          
     if (isLocal(Node._state[n], tid)) {                                                            
      Node._state[n] := SHARED();                                                                   
      assert isSharedAssignable(Node._state[Node.next[n]]);                                                // (44.17): n became shared, but n.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 44.17: tmp3 = false;                                                                        
                                                                                                    
     tmp3 := false;                                                                                 
    }                                                                                               
   }                                                                                                
   if (tmp3) {                                                                                      
                                                                                                    
    // 45.21: yield;                                                                                
                                                                                                    
    assume Node._state3381827 == Node._state && Node.value3381827 == Node.value && Node.next3381827 == Node.next && Node._lock3381827 == Node._lock && Node.next_nextThread3381827 == Node.next_nextThread && Node.next_nextValue3381827 == Node.next_nextValue && Queue._state3381827 == Queue._state && Queue.head3381827 == Queue.head && Queue.tail3381827 == Queue.tail && Queue._lock3381827 == Queue._lock && Queue.tail_nextThread3381827 == Queue.tail_nextThread && Queue.tail_nextValue3381827 == Queue.tail_nextValue && tmp33381827 == tmp3 && tmp23381827 == tmp2 && next3381827 == next && tmp13381827 == tmp1 && last3381827 == last && n3381827 == n && value3381827 == value && this3381827 == this && tid3381827 == tid;
    assume $recorded.state3381827 == 1;                                                             
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (45.21): Object invariant may not hold.
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (45.21): Object invariant may not hold.
    call Yield(tid);                                                                                
    assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (45.21): Object invariant may not hold.
    assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (45.21): Object invariant may not hold.
    $pc := PreCommit;                                                                               
    assume Node._state3381827_post == Node._state && Node.value3381827_post == Node.value && Node.next3381827_post == Node.next && Node._lock3381827_post == Node._lock && Node.next_nextThread3381827_post == Node.next_nextThread && Node.next_nextValue3381827_post == Node.next_nextValue && Queue._state3381827_post == Queue._state && Queue.head3381827_post == Queue.head && Queue.tail3381827_post == Queue.tail && Queue._lock3381827_post == Queue._lock && Queue.tail_nextThread3381827_post == Queue.tail_nextThread && Queue.tail_nextValue3381827_post == Queue.tail_nextValue && tmp33381827_post == tmp3 && tmp23381827_post == tmp2 && next3381827_post == next && tmp13381827_post == tmp1 && last3381827_post == last && n3381827_post == n && value3381827_post == value && this3381827_post == this && tid3381827_post == tid;
    assume $recorded.state3381827_post == 1;                                                        
                                                                                                    
    // 46.21: boolean tmp4;                                                                         
                                                                                                    
    // NoOp: 'TraceOff'                                                                             
                                                                                                    
    // 46.21: boolean ctmp3361119;                                                                  
                                                                                                    
                                                                                                    
    // 46.21: ctmp3361119 = *;                                                                      
                                                                                                    
    havoc ctmp3361119;                                                                              
    if (ctmp3361119) {                                                                              
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
     // 46.21: tmp4 = false;                                                                        
                                                                                                    
     tmp4 := false;                                                                                 
    } else {                                                                                        
                                                                                                    
     // 46.21: ctmp3361119 = *;                                                                     
                                                                                                    
     havoc ctmp3361119;                                                                             
     if (ctmp3361119) {                                                                             
                                                                                                    
      // 46.21: Tid tmpTid;                                                                         
                                                                                                    
                                                                                                    
      // 46.21: Node tmpValue;                                                                      
                                                                                                    
                                                                                                    
      // 46.21: Mover _m;                                                                           
                                                                                                    
                                                                                                    
      // 46.21: _m = writePermission(this.tail, n);                                                 
                                                                                                    
      _m := m#moverPath(WriteEval.Queue.tail(tid: Tid,this: Queue,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
      // 46.21: assume this.tail == last;                                                           
                                                                                                    
      assume (Queue.tail[this]==last);                                                              
                                                                                                    
      // 46.21: assume !goesWrong(_m);                                                              
                                                                                                    
      assume !(transition($pc, _m) == PhaseError);                                                  
                                                                                                    
      // 46.21: assume this.tail_nextThread == tid;                                                 
                                                                                                    
      assume (Queue.tail_nextThread[this]==tid);                                                    
                                                                                                    
      // 46.21: assume this.tail_nextValue == last;                                                 
                                                                                                    
      assume (Queue.tail_nextValue[this]==last);                                                    
                                                                                                    
                                                                                                    
      // 46.21: this.tail_nextThread := tmpTid as B;                                                
                                                                                                    
                                                                                                    
      moverPath3381887 := WriteEval.Queue.tail_nextThread(tid: Tid,this: Queue,tmpTid: Tid,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3381887 := m#moverPath(moverPath3381887);                                                
      path3381887 := p#moverPath(moverPath3381887);                                                 
      assume Node._state3381887 == Node._state && Node.value3381887 == Node.value && Node.next3381887 == Node.next && Node._lock3381887 == Node._lock && Node.next_nextThread3381887 == Node.next_nextThread && Node.next_nextValue3381887 == Node.next_nextValue && Queue._state3381887 == Queue._state && Queue.head3381887 == Queue.head && Queue.tail3381887 == Queue.tail && Queue._lock3381887 == Queue._lock && Queue.tail_nextThread3381887 == Queue.tail_nextThread && Queue.tail_nextValue3381887 == Queue.tail_nextValue && _m3381887 == _m && tmpValue3381887 == tmpValue && tmpTid3381887 == tmpTid && ctmp33611193381887 == ctmp3361119 && tmp43381887 == tmp4 && tmp33381887 == tmp3 && tmp23381887 == tmp2 && next3381887 == next && tmp13381887 == tmp1 && last3381887 == last && n3381887 == n && value3381887 == value && this3381887 == this && tid3381887 == tid && $pc3381887 == $pc;
      assume $recorded.state3381887 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (46.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (46.21): Reduction failure
      Queue.tail_nextThread[this] := tmpTid;                                                        
                                                                                                    
                                                                                                    
      // 46.21: this.tail_nextValue := tmpValue as B;                                               
                                                                                                    
                                                                                                    
      moverPath3381890 := WriteEval.Queue.tail_nextValue(tid: Tid,this: Queue,tmpValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3381890 := m#moverPath(moverPath3381890);                                                
      path3381890 := p#moverPath(moverPath3381890);                                                 
      assume Node._state3381890 == Node._state && Node.value3381890 == Node.value && Node.next3381890 == Node.next && Node._lock3381890 == Node._lock && Node.next_nextThread3381890 == Node.next_nextThread && Node.next_nextValue3381890 == Node.next_nextValue && Queue._state3381890 == Queue._state && Queue.head3381890 == Queue.head && Queue.tail3381890 == Queue.tail && Queue._lock3381890 == Queue._lock && Queue.tail_nextThread3381890 == Queue.tail_nextThread && Queue.tail_nextValue3381890 == Queue.tail_nextValue && _m3381890 == _m && tmpValue3381890 == tmpValue && tmpTid3381890 == tmpTid && ctmp33611193381890 == ctmp3361119 && tmp43381890 == tmp4 && tmp33381890 == tmp3 && tmp23381890 == tmp2 && next3381890 == next && tmp13381890 == tmp1 && last3381890 == last && n3381890 == n && value3381890 == value && this3381890 == this && tid3381890 == tid && $pc3381890 == $pc;
      assume $recorded.state3381890 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (46.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (46.21): Reduction failure
      Queue.tail_nextValue[this] := tmpValue;                                                       
      // NoOp: 'TraceOn'                                                                            
                                                                                                    
                                                                                                    
      // 46.21: this.tail := n;                                                                     
                                                                                                    
                                                                                                    
      moverPath3381894 := WriteEval.Queue.tail(tid: Tid,this: Queue,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3381894 := m#moverPath(moverPath3381894);                                                
      path3381894 := p#moverPath(moverPath3381894);                                                 
      assume Node._state3381894 == Node._state && Node.value3381894 == Node.value && Node.next3381894 == Node.next && Node._lock3381894 == Node._lock && Node.next_nextThread3381894 == Node.next_nextThread && Node.next_nextValue3381894 == Node.next_nextValue && Queue._state3381894 == Queue._state && Queue.head3381894 == Queue.head && Queue.tail3381894 == Queue.tail && Queue._lock3381894 == Queue._lock && Queue.tail_nextThread3381894 == Queue.tail_nextThread && Queue.tail_nextValue3381894 == Queue.tail_nextValue && _m3381894 == _m && tmpValue3381894 == tmpValue && tmpTid3381894 == tmpTid && ctmp33611193381894 == ctmp3361119 && tmp43381894 == tmp4 && tmp33381894 == tmp3 && tmp23381894 == tmp2 && next3381894 == next && tmp13381894 == tmp1 && last3381894 == last && n3381894 == n && value3381894 == value && this3381894 == this && tid3381894 == tid && $pc3381894 == $pc;
      assume $recorded.state3381894 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (46.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, mover3381894);                                                         
      assert $pc != PhaseError;                                                                            // (46.21): Reduction failure
      Queue.tail[this] := n;                                                                        
      if (isLocal(Node._state[n], tid)) {                                                           
       Node._state[n] := SHARED();                                                                  
       assert isSharedAssignable(Node._state[Node.next[n]]);                                               // (46.21): n became shared, but n.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 46.21: tmp4 = true;                                                                        
                                                                                                    
      tmp4 := true;                                                                                 
     } else {                                                                                       
                                                                                                    
      // 46.21: assume this.tail_nextThread == tid;                                                 
                                                                                                    
      assume (Queue.tail_nextThread[this]==tid);                                                    
                                                                                                    
      // 46.21: assume this.tail_nextValue == last;                                                 
                                                                                                    
      assume (Queue.tail_nextValue[this]==last);                                                    
                                                                                                    
      // 46.21: Node _currentValue;                                                                 
                                                                                                    
                                                                                                    
      // 46.21: _currentValue := this.tail  as B;                                                   
                                                                                                    
                                                                                                    
      moverPath3381917 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3381917 := m#moverPath(moverPath3381917);                                                
      path3381917 := p#moverPath(moverPath3381917);                                                 
      assume Node._state3381917 == Node._state && Node.value3381917 == Node.value && Node.next3381917 == Node.next && Node._lock3381917 == Node._lock && Node.next_nextThread3381917 == Node.next_nextThread && Node.next_nextValue3381917 == Node.next_nextValue && Queue._state3381917 == Queue._state && Queue.head3381917 == Queue.head && Queue.tail3381917 == Queue.tail && Queue._lock3381917 == Queue._lock && Queue.tail_nextThread3381917 == Queue.tail_nextThread && Queue.tail_nextValue3381917 == Queue.tail_nextValue && _currentValue3381917 == _currentValue && ctmp33611193381917 == ctmp3361119 && tmp43381917 == tmp4 && tmp33381917 == tmp3 && tmp23381917 == tmp2 && next3381917 == next && tmp13381917 == tmp1 && last3381917 == last && n3381917 == n && value3381917 == value && this3381917 == this && tid3381917 == tid && $pc3381917 == $pc;
      assume $recorded.state3381917 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (46.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
                                                                                                    
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (46.21): Reduction failure
      _currentValue := Queue.tail[this];                                                            
                                                                                                    
                                                                                                    
      // 46.21: this.tail := last as B;                                                             
                                                                                                    
                                                                                                    
      moverPath3381920 := WriteEval.Queue.tail(tid: Tid,this: Queue,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3381920 := m#moverPath(moverPath3381920);                                                
      path3381920 := p#moverPath(moverPath3381920);                                                 
      assume Node._state3381920 == Node._state && Node.value3381920 == Node.value && Node.next3381920 == Node.next && Node._lock3381920 == Node._lock && Node.next_nextThread3381920 == Node.next_nextThread && Node.next_nextValue3381920 == Node.next_nextValue && Queue._state3381920 == Queue._state && Queue.head3381920 == Queue.head && Queue.tail3381920 == Queue.tail && Queue._lock3381920 == Queue._lock && Queue.tail_nextThread3381920 == Queue.tail_nextThread && Queue.tail_nextValue3381920 == Queue.tail_nextValue && _currentValue3381920 == _currentValue && ctmp33611193381920 == ctmp3361119 && tmp43381920 == tmp4 && tmp33381920 == tmp3 && tmp23381920 == tmp2 && next3381920 == next && tmp13381920 == tmp1 && last3381920 == last && n3381920 == n && value3381920 == value && this3381920 == this && tid3381920 == tid && $pc3381920 == $pc;
      assume $recorded.state3381920 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (46.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (46.21): Reduction failure
      Queue.tail[this] := last;                                                                     
      if (isLocal(Node._state[last], tid)) {                                                        
       Node._state[last] := SHARED();                                                               
       assert isSharedAssignable(Node._state[Node.next[last]]);                                            // (46.21): last became shared, but last.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 46.21: Mover _m;                                                                           
                                                                                                    
                                                                                                    
      // 46.21: _m = writePermission(this.tail, n);                                                 
                                                                                                    
      _m := m#moverPath(WriteEval.Queue.tail(tid: Tid,this: Queue,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
                                                                                                    
      // 46.21: this.tail := _currentValue as B;                                                    
                                                                                                    
                                                                                                    
      moverPath3381932 := WriteEval.Queue.tail(tid: Tid,this: Queue,_currentValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3381932 := m#moverPath(moverPath3381932);                                                
      path3381932 := p#moverPath(moverPath3381932);                                                 
      assume Node._state3381932 == Node._state && Node.value3381932 == Node.value && Node.next3381932 == Node.next && Node._lock3381932 == Node._lock && Node.next_nextThread3381932 == Node.next_nextThread && Node.next_nextValue3381932 == Node.next_nextValue && Queue._state3381932 == Queue._state && Queue.head3381932 == Queue.head && Queue.tail3381932 == Queue.tail && Queue._lock3381932 == Queue._lock && Queue.tail_nextThread3381932 == Queue.tail_nextThread && Queue.tail_nextValue3381932 == Queue.tail_nextValue && _m3381932 == _m && _currentValue3381932 == _currentValue && ctmp33611193381932 == ctmp3361119 && tmp43381932 == tmp4 && tmp33381932 == tmp3 && tmp23381932 == tmp2 && next3381932 == next && tmp13381932 == tmp1 && last3381932 == last && n3381932 == n && value3381932 == value && this3381932 == this && tid3381932 == tid && $pc3381932 == $pc;
      assume $recorded.state3381932 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (46.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (46.21): Reduction failure
      Queue.tail[this] := _currentValue;                                                            
      if (isLocal(Node._state[_currentValue], tid)) {                                               
       Node._state[_currentValue] := SHARED();                                                      
       assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                   // (46.21): _currentValue became shared, but _currentValue.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 46.21: assume goesWrong(_m);                                                               
                                                                                                    
      assume transition($pc, _m) == PhaseError;                                                     
      // NoOp: 'TraceOn'                                                                            
                                                                                                    
                                                                                                    
      // 46.21: this.tail := n;                                                                     
                                                                                                    
                                                                                                    
      moverPath3381939 := WriteEval.Queue.tail(tid: Tid,this: Queue,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3381939 := m#moverPath(moverPath3381939);                                                
      path3381939 := p#moverPath(moverPath3381939);                                                 
      assume Node._state3381939 == Node._state && Node.value3381939 == Node.value && Node.next3381939 == Node.next && Node._lock3381939 == Node._lock && Node.next_nextThread3381939 == Node.next_nextThread && Node.next_nextValue3381939 == Node.next_nextValue && Queue._state3381939 == Queue._state && Queue.head3381939 == Queue.head && Queue.tail3381939 == Queue.tail && Queue._lock3381939 == Queue._lock && Queue.tail_nextThread3381939 == Queue.tail_nextThread && Queue.tail_nextValue3381939 == Queue.tail_nextValue && _m3381939 == _m && _currentValue3381939 == _currentValue && ctmp33611193381939 == ctmp3361119 && tmp43381939 == tmp4 && tmp33381939 == tmp3 && tmp23381939 == tmp2 && next3381939 == next && tmp13381939 == tmp1 && last3381939 == last && n3381939 == n && value3381939 == value && this3381939 == this && tid3381939 == tid && $pc3381939 == $pc;
      assume $recorded.state3381939 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (46.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, mover3381939);                                                         
      assert $pc != PhaseError;                                                                            // (46.21): Reduction failure
      Queue.tail[this] := n;                                                                        
      if (isLocal(Node._state[n], tid)) {                                                           
       Node._state[n] := SHARED();                                                                  
       assert isSharedAssignable(Node._state[Node.next[n]]);                                               // (46.21): n became shared, but n.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 46.21: tmp4 = false;                                                                       
                                                                                                    
      tmp4 := false;                                                                                
     }                                                                                              
    }                                                                                               
                                                                                                    
    // 47.21:  return;                                                                              
                                                                                                    
    assume Node._state3381949 == Node._state && Node.value3381949 == Node.value && Node.next3381949 == Node.next && Node._lock3381949 == Node._lock && Node.next_nextThread3381949 == Node.next_nextThread && Node.next_nextValue3381949 == Node.next_nextValue && Queue._state3381949 == Queue._state && Queue.head3381949 == Queue.head && Queue.tail3381949 == Queue.tail && Queue._lock3381949 == Queue._lock && Queue.tail_nextThread3381949 == Queue.tail_nextThread && Queue.tail_nextValue3381949 == Queue.tail_nextValue && tmp43381949 == tmp4 && tmp33381949 == tmp3 && tmp23381949 == tmp2 && next3381949 == next && tmp13381949 == tmp1 && last3381949 == last && n3381949 == n && value3381949 == value && this3381949 == this && tid3381949 == tid;
    assume $recorded.state3381949 == 1;                                                             
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (47.21): Object invariant may not hold.
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (47.21): Object invariant may not hold.
    return;                                                                                         
   } else {                                                                                         
   }                                                                                                
  } else {                                                                                          
                                                                                                    
   // 50.17: boolean tmp5;                                                                          
                                                                                                    
   // NoOp: 'TraceOff'                                                                              
                                                                                                    
   // 50.17: boolean ctmp3361133;                                                                   
                                                                                                    
                                                                                                    
   // 50.17: ctmp3361133 = *;                                                                       
                                                                                                    
   havoc ctmp3361133;                                                                               
   if (ctmp3361133) {                                                                               
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
    // 50.17: tmp5 = false;                                                                         
                                                                                                    
    tmp5 := false;                                                                                  
   } else {                                                                                         
                                                                                                    
    // 50.17: ctmp3361133 = *;                                                                      
                                                                                                    
    havoc ctmp3361133;                                                                              
    if (ctmp3361133) {                                                                              
                                                                                                    
     // 50.17: Tid tmpTid;                                                                          
                                                                                                    
                                                                                                    
     // 50.17: Node tmpValue;                                                                       
                                                                                                    
                                                                                                    
     // 50.17: Mover _m;                                                                            
                                                                                                    
                                                                                                    
     // 50.17: _m = writePermission(this.tail, next);                                               
                                                                                                    
     _m := m#moverPath(WriteEval.Queue.tail(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
     // 50.17: assume this.tail == last;                                                            
                                                                                                    
     assume (Queue.tail[this]==last);                                                               
                                                                                                    
     // 50.17: assume !goesWrong(_m);                                                               
                                                                                                    
     assume !(transition($pc, _m) == PhaseError);                                                   
                                                                                                    
     // 50.17: assume this.tail_nextThread == tid;                                                  
                                                                                                    
     assume (Queue.tail_nextThread[this]==tid);                                                     
                                                                                                    
     // 50.17: assume this.tail_nextValue == last;                                                  
                                                                                                    
     assume (Queue.tail_nextValue[this]==last);                                                     
                                                                                                    
                                                                                                    
     // 50.17: this.tail_nextThread := tmpTid as B;                                                 
                                                                                                    
                                                                                                    
     moverPath3382014 := WriteEval.Queue.tail_nextThread(tid: Tid,this: Queue,tmpTid: Tid,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3382014 := m#moverPath(moverPath3382014);                                                 
     path3382014 := p#moverPath(moverPath3382014);                                                  
     assume Node._state3382014 == Node._state && Node.value3382014 == Node.value && Node.next3382014 == Node.next && Node._lock3382014 == Node._lock && Node.next_nextThread3382014 == Node.next_nextThread && Node.next_nextValue3382014 == Node.next_nextValue && Queue._state3382014 == Queue._state && Queue.head3382014 == Queue.head && Queue.tail3382014 == Queue.tail && Queue._lock3382014 == Queue._lock && Queue.tail_nextThread3382014 == Queue.tail_nextThread && Queue.tail_nextValue3382014 == Queue.tail_nextValue && _m3382014 == _m && tmpValue3382014 == tmpValue && tmpTid3382014 == tmpTid && ctmp33611333382014 == ctmp3361133 && tmp53382014 == tmp5 && tmp23382014 == tmp2 && next3382014 == next && tmp13382014 == tmp1 && last3382014 == last && n3382014 == n && value3382014 == value && this3382014 == this && tid3382014 == tid && $pc3382014 == $pc;
     assume $recorded.state3382014 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (50.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (50.17): Reduction failure
     Queue.tail_nextThread[this] := tmpTid;                                                         
                                                                                                    
                                                                                                    
     // 50.17: this.tail_nextValue := tmpValue as B;                                                
                                                                                                    
                                                                                                    
     moverPath3382017 := WriteEval.Queue.tail_nextValue(tid: Tid,this: Queue,tmpValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3382017 := m#moverPath(moverPath3382017);                                                 
     path3382017 := p#moverPath(moverPath3382017);                                                  
     assume Node._state3382017 == Node._state && Node.value3382017 == Node.value && Node.next3382017 == Node.next && Node._lock3382017 == Node._lock && Node.next_nextThread3382017 == Node.next_nextThread && Node.next_nextValue3382017 == Node.next_nextValue && Queue._state3382017 == Queue._state && Queue.head3382017 == Queue.head && Queue.tail3382017 == Queue.tail && Queue._lock3382017 == Queue._lock && Queue.tail_nextThread3382017 == Queue.tail_nextThread && Queue.tail_nextValue3382017 == Queue.tail_nextValue && _m3382017 == _m && tmpValue3382017 == tmpValue && tmpTid3382017 == tmpTid && ctmp33611333382017 == ctmp3361133 && tmp53382017 == tmp5 && tmp23382017 == tmp2 && next3382017 == next && tmp13382017 == tmp1 && last3382017 == last && n3382017 == n && value3382017 == value && this3382017 == this && tid3382017 == tid && $pc3382017 == $pc;
     assume $recorded.state3382017 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (50.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (50.17): Reduction failure
     Queue.tail_nextValue[this] := tmpValue;                                                        
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
                                                                                                    
     // 50.17: this.tail := next;                                                                   
                                                                                                    
                                                                                                    
     moverPath3382021 := WriteEval.Queue.tail(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3382021 := m#moverPath(moverPath3382021);                                                 
     path3382021 := p#moverPath(moverPath3382021);                                                  
     assume Node._state3382021 == Node._state && Node.value3382021 == Node.value && Node.next3382021 == Node.next && Node._lock3382021 == Node._lock && Node.next_nextThread3382021 == Node.next_nextThread && Node.next_nextValue3382021 == Node.next_nextValue && Queue._state3382021 == Queue._state && Queue.head3382021 == Queue.head && Queue.tail3382021 == Queue.tail && Queue._lock3382021 == Queue._lock && Queue.tail_nextThread3382021 == Queue.tail_nextThread && Queue.tail_nextValue3382021 == Queue.tail_nextValue && _m3382021 == _m && tmpValue3382021 == tmpValue && tmpTid3382021 == tmpTid && ctmp33611333382021 == ctmp3361133 && tmp53382021 == tmp5 && tmp23382021 == tmp2 && next3382021 == next && tmp13382021 == tmp1 && last3382021 == last && n3382021 == n && value3382021 == value && this3382021 == this && tid3382021 == tid && $pc3382021 == $pc;
     assume $recorded.state3382021 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (50.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, mover3382021);                                                          
     assert $pc != PhaseError;                                                                             // (50.17): Reduction failure
     Queue.tail[this] := next;                                                                      
     if (isLocal(Node._state[next], tid)) {                                                         
      Node._state[next] := SHARED();                                                                
      assert isSharedAssignable(Node._state[Node.next[next]]);                                             // (50.17): next became shared, but next.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 50.17: tmp5 = true;                                                                         
                                                                                                    
     tmp5 := true;                                                                                  
    } else {                                                                                        
                                                                                                    
     // 50.17: assume this.tail_nextThread == tid;                                                  
                                                                                                    
     assume (Queue.tail_nextThread[this]==tid);                                                     
                                                                                                    
     // 50.17: assume this.tail_nextValue == last;                                                  
                                                                                                    
     assume (Queue.tail_nextValue[this]==last);                                                     
                                                                                                    
     // 50.17: Node _currentValue;                                                                  
                                                                                                    
                                                                                                    
     // 50.17: _currentValue := this.tail  as B;                                                    
                                                                                                    
                                                                                                    
     moverPath3382044 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3382044 := m#moverPath(moverPath3382044);                                                 
     path3382044 := p#moverPath(moverPath3382044);                                                  
     assume Node._state3382044 == Node._state && Node.value3382044 == Node.value && Node.next3382044 == Node.next && Node._lock3382044 == Node._lock && Node.next_nextThread3382044 == Node.next_nextThread && Node.next_nextValue3382044 == Node.next_nextValue && Queue._state3382044 == Queue._state && Queue.head3382044 == Queue.head && Queue.tail3382044 == Queue.tail && Queue._lock3382044 == Queue._lock && Queue.tail_nextThread3382044 == Queue.tail_nextThread && Queue.tail_nextValue3382044 == Queue.tail_nextValue && _currentValue3382044 == _currentValue && ctmp33611333382044 == ctmp3361133 && tmp53382044 == tmp5 && tmp23382044 == tmp2 && next3382044 == next && tmp13382044 == tmp1 && last3382044 == last && n3382044 == n && value3382044 == value && this3382044 == this && tid3382044 == tid && $pc3382044 == $pc;
     assume $recorded.state3382044 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (50.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
                                                                                                    
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (50.17): Reduction failure
     _currentValue := Queue.tail[this];                                                             
                                                                                                    
                                                                                                    
     // 50.17: this.tail := last as B;                                                              
                                                                                                    
                                                                                                    
     moverPath3382047 := WriteEval.Queue.tail(tid: Tid,this: Queue,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3382047 := m#moverPath(moverPath3382047);                                                 
     path3382047 := p#moverPath(moverPath3382047);                                                  
     assume Node._state3382047 == Node._state && Node.value3382047 == Node.value && Node.next3382047 == Node.next && Node._lock3382047 == Node._lock && Node.next_nextThread3382047 == Node.next_nextThread && Node.next_nextValue3382047 == Node.next_nextValue && Queue._state3382047 == Queue._state && Queue.head3382047 == Queue.head && Queue.tail3382047 == Queue.tail && Queue._lock3382047 == Queue._lock && Queue.tail_nextThread3382047 == Queue.tail_nextThread && Queue.tail_nextValue3382047 == Queue.tail_nextValue && _currentValue3382047 == _currentValue && ctmp33611333382047 == ctmp3361133 && tmp53382047 == tmp5 && tmp23382047 == tmp2 && next3382047 == next && tmp13382047 == tmp1 && last3382047 == last && n3382047 == n && value3382047 == value && this3382047 == this && tid3382047 == tid && $pc3382047 == $pc;
     assume $recorded.state3382047 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (50.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (50.17): Reduction failure
     Queue.tail[this] := last;                                                                      
     if (isLocal(Node._state[last], tid)) {                                                         
      Node._state[last] := SHARED();                                                                
      assert isSharedAssignable(Node._state[Node.next[last]]);                                             // (50.17): last became shared, but last.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 50.17: Mover _m;                                                                            
                                                                                                    
                                                                                                    
     // 50.17: _m = writePermission(this.tail, next);                                               
                                                                                                    
     _m := m#moverPath(WriteEval.Queue.tail(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
                                                                                                    
     // 50.17: this.tail := _currentValue as B;                                                     
                                                                                                    
                                                                                                    
     moverPath3382059 := WriteEval.Queue.tail(tid: Tid,this: Queue,_currentValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3382059 := m#moverPath(moverPath3382059);                                                 
     path3382059 := p#moverPath(moverPath3382059);                                                  
     assume Node._state3382059 == Node._state && Node.value3382059 == Node.value && Node.next3382059 == Node.next && Node._lock3382059 == Node._lock && Node.next_nextThread3382059 == Node.next_nextThread && Node.next_nextValue3382059 == Node.next_nextValue && Queue._state3382059 == Queue._state && Queue.head3382059 == Queue.head && Queue.tail3382059 == Queue.tail && Queue._lock3382059 == Queue._lock && Queue.tail_nextThread3382059 == Queue.tail_nextThread && Queue.tail_nextValue3382059 == Queue.tail_nextValue && _m3382059 == _m && _currentValue3382059 == _currentValue && ctmp33611333382059 == ctmp3361133 && tmp53382059 == tmp5 && tmp23382059 == tmp2 && next3382059 == next && tmp13382059 == tmp1 && last3382059 == last && n3382059 == n && value3382059 == value && this3382059 == this && tid3382059 == tid && $pc3382059 == $pc;
     assume $recorded.state3382059 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (50.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (50.17): Reduction failure
     Queue.tail[this] := _currentValue;                                                             
     if (isLocal(Node._state[_currentValue], tid)) {                                                
      Node._state[_currentValue] := SHARED();                                                       
      assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                    // (50.17): _currentValue became shared, but _currentValue.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 50.17: assume goesWrong(_m);                                                                
                                                                                                    
     assume transition($pc, _m) == PhaseError;                                                      
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
                                                                                                    
     // 50.17: this.tail := next;                                                                   
                                                                                                    
                                                                                                    
     moverPath3382066 := WriteEval.Queue.tail(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3382066 := m#moverPath(moverPath3382066);                                                 
     path3382066 := p#moverPath(moverPath3382066);                                                  
     assume Node._state3382066 == Node._state && Node.value3382066 == Node.value && Node.next3382066 == Node.next && Node._lock3382066 == Node._lock && Node.next_nextThread3382066 == Node.next_nextThread && Node.next_nextValue3382066 == Node.next_nextValue && Queue._state3382066 == Queue._state && Queue.head3382066 == Queue.head && Queue.tail3382066 == Queue.tail && Queue._lock3382066 == Queue._lock && Queue.tail_nextThread3382066 == Queue.tail_nextThread && Queue.tail_nextValue3382066 == Queue.tail_nextValue && _m3382066 == _m && _currentValue3382066 == _currentValue && ctmp33611333382066 == ctmp3361133 && tmp53382066 == tmp5 && tmp23382066 == tmp2 && next3382066 == next && tmp13382066 == tmp1 && last3382066 == last && n3382066 == n && value3382066 == value && this3382066 == this && tid3382066 == tid && $pc3382066 == $pc;
     assume $recorded.state3382066 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (50.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, mover3382066);                                                          
     assert $pc != PhaseError;                                                                             // (50.17): Reduction failure
     Queue.tail[this] := next;                                                                      
     if (isLocal(Node._state[next], tid)) {                                                         
      Node._state[next] := SHARED();                                                                
      assert isSharedAssignable(Node._state[Node.next[next]]);                                             // (50.17): next became shared, but next.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 50.17: tmp5 = false;                                                                        
                                                                                                    
     tmp5 := false;                                                                                 
    }                                                                                               
   }                                                                                                
   if (tmp5) {                                                                                      
                                                                                                    
    // 51.21: last = next;                                                                          
                                                                                                    
    last := next;                                                                                   
   } else {                                                                                         
   }                                                                                                
  }                                                                                                 
                                                                                                    
  // 54.13: yield;                                                                                  
                                                                                                    
  assume Node._state3382084 == Node._state && Node.value3382084 == Node.value && Node.next3382084 == Node.next && Node._lock3382084 == Node._lock && Node.next_nextThread3382084 == Node.next_nextThread && Node.next_nextValue3382084 == Node.next_nextValue && Queue._state3382084 == Queue._state && Queue.head3382084 == Queue.head && Queue.tail3382084 == Queue.tail && Queue._lock3382084 == Queue._lock && Queue.tail_nextThread3382084 == Queue.tail_nextThread && Queue.tail_nextValue3382084 == Queue.tail_nextValue && tmp23382084 == tmp2 && next3382084 == next && tmp13382084 == tmp1 && last3382084 == last && n3382084 == n && value3382084 == value && this3382084 == this && tid3382084 == tid;
  assume $recorded.state3382084 == 1;                                                               
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (54.13): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (54.13): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (54.13): Object invariant may not hold.
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (54.13): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Node._state3382084_post == Node._state && Node.value3382084_post == Node.value && Node.next3382084_post == Node.next && Node._lock3382084_post == Node._lock && Node.next_nextThread3382084_post == Node.next_nextThread && Node.next_nextValue3382084_post == Node.next_nextValue && Queue._state3382084_post == Queue._state && Queue.head3382084_post == Queue.head && Queue.tail3382084_post == Queue.tail && Queue._lock3382084_post == Queue._lock && Queue.tail_nextThread3382084_post == Queue.tail_nextThread && Queue.tail_nextValue3382084_post == Queue.tail_nextValue && tmp23382084_post == tmp2 && next3382084_post == next && tmp13382084_post == tmp1 && last3382084_post == last && n3382084_post == n && value3382084_post == value && this3382084_post == this && tid3382084_post == tid;
  assume $recorded.state3382084_post == 1;                                                          
  assume Node._state3382087_bottom == Node._state && Node.value3382087_bottom == Node.value && Node.next3382087_bottom == Node.next && Node._lock3382087_bottom == Node._lock && Node.next_nextThread3382087_bottom == Node.next_nextThread && Node.next_nextValue3382087_bottom == Node.next_nextValue && Queue._state3382087_bottom == Queue._state && Queue.head3382087_bottom == Queue.head && Queue.tail3382087_bottom == Queue.tail && Queue._lock3382087_bottom == Queue._lock && Queue.tail_nextThread3382087_bottom == Queue.tail_nextThread && Queue.tail_nextValue3382087_bottom == Queue.tail_nextValue && last3382087_bottom == last && n3382087_bottom == n && value3382087_bottom == value && this3382087_bottom == this && tid3382087_bottom == tid;
  assume $recorded.state3382087_bottom == 1;                                                        
  assert phase3382087 == $pc;                                                                              // (37.9): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 33.36: // return;                                                                               
                                                                                                    
 assume Node._state3382088 == Node._state && Node.value3382088 == Node.value && Node.next3382088 == Node.next && Node._lock3382088 == Node._lock && Node.next_nextThread3382088 == Node.next_nextThread && Node.next_nextValue3382088 == Node.next_nextValue && Queue._state3382088 == Queue._state && Queue.head3382088 == Queue.head && Queue.tail3382088 == Queue.tail && Queue._lock3382088 == Queue._lock && Queue.tail_nextThread3382088 == Queue.tail_nextThread && Queue.tail_nextValue3382088 == Queue.tail_nextValue && last3382088 == last && n3382088 == n && value3382088 == value && this3382088 == this && tid3382088 == tid;
 assume $recorded.state3382088 == 1;                                                                
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (33.36): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (33.36): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (bool) {
  true &&                                                                                           
  (forall _i: Node  :: _i == Node.null <==> isNull(Node._state[_i])) &&                             
  (forall _i: Queue  :: _i == Queue.null <==> isNull(Queue._state[_i])) &&                          
  (forall _i: Node ::  (isShared(Node._state[_i]) ==> isSharedAssignable(Node._state[Node.next[_i]]))) &&
  (forall _i: Node ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Node._state[_i],_t) ==> isLocalAssignable(Node._state[Node.next[_i]], _t)))) &&
  (forall _i: Queue ::  (isShared(Queue._state[_i]) ==> isSharedAssignable(Node._state[Queue.head[_i]]))) &&
  (forall _i: Queue ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Queue._state[_i],_t) ==> isLocalAssignable(Node._state[Queue.head[_i]], _t)))) &&
  (forall _i: Queue ::  (isShared(Queue._state[_i]) ==> isSharedAssignable(Node._state[Queue.tail[_i]]))) &&
  (forall _i: Queue ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Queue._state[_i],_t) ==> isLocalAssignable(Node._state[Queue.tail[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)          
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.value(u: Tid,x: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (3.5): Node.value failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)           
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.value(u: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (3.5): Node.value failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)           
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.value[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.value[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.value(u: Tid,x: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (3.5): Node.value failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.value[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.value(u: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (3.5): Node.value failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)                
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.value(u: Tid,x: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (3.5): Node.value failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)                 
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Node.value[x];                                                                         
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.value[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.value(u: Tid,x: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (3.5): Node.value failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)         
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.5): Node.next failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (5.5): Node.next failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.5): Node.next failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)           
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (5.5): Node.next failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)               
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.5): Node.next failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)                
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Node.next[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.5): Node.next failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Queue.head(t: Tid, u: Tid, v: Node, w: Node, x: Queue)       
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (20.5): Queue.head failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Queue.head(t: Tid, u: Tid, v: Node, w: Node, x: Queue)        
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Queue.head(u: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (20.5): Queue.head failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Queue.head(t: Tid, u: Tid, v: Node, w: Node, x: Queue)        
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Queue.head[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Queue.head[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (20.5): Queue.head failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Queue.head(t: Tid, u: Tid, v: Node, w: Node, x: Queue)         
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Queue.head[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Queue.head(u: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (20.5): Queue.head failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Queue.head(t: Tid, u: Tid, v: Node, w: Node, x: Queue)             
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (20.5): Queue.head failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Queue.head(t: Tid, u: Tid, v: Node, w: Node, x: Queue)              
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Queue.head[x];                                                                         
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Queue.head[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (20.5): Queue.head failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, x: Queue)       
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (21.5): Queue.tail failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, x: Queue)        
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Queue.tail(u: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (21.5): Queue.tail failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, x: Queue)        
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Queue.tail[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Queue.tail[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (21.5): Queue.tail failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, x: Queue)         
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Queue.tail[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Queue.tail(u: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (21.5): Queue.tail failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, x: Queue)             
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (21.5): Queue.tail failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, x: Queue)              
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Queue.tail[x];                                                                         
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Queue.tail[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (21.5): Queue.tail failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.value (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.5): Node.value is not Write-Write Stable with respect to Node.value (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.value (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.value (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.value (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.value (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Node.value (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Node.value (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Node.value (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Node.value (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Node.value (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.5): Node.value is not Write-Read Stable with respect to Node.value (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Node.value (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Node.next is not Write-Write Stable with respect to Node.value (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Node.value (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.next is not Write-Read Stable with respect to Node.value (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.next is not Write-Read Stable with respect to Node.value (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Node.next is not Write-Read Stable with respect to Node.value (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.value.Queue.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.value (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.value (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.value (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.value.Queue.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.value.Queue.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.value.Queue.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Queue.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.value.Queue.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.5): Queue.head is not Write-Read Stable with respect to Node.value (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.5): Queue.head is not Write-Read Stable with respect to Node.value (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (20.5): Queue.head is not Write-Read Stable with respect to Node.value (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.value.Queue.tail(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.value (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.value (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.value (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.value.Queue.tail(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.value.Queue.tail(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.value.Queue.tail(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Queue.tail (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.value.Queue.tail(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (21.5): Queue.tail is not Write-Read Stable with respect to Node.value (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (21.5): Queue.tail is not Write-Read Stable with respect to Node.value (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (21.5): Queue.tail is not Write-Read Stable with respect to Node.value (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Node.value (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Node.value (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Node.value (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.next is not Read-Write Stable with respect to Node.value (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.next is not Read-Write Stable with respect to Node.value (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.next is not Read-Write Stable with respect to Node.value (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.5): Node.value is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Node.next.Node.value(t: Tid, u: Tid, v: Node, w1: int, w2: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: int;                                                                                     
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var w2_pre: int;                                                                                   
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w1_pre: int;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var w2_mid: int;                                                                                   
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var w1_mid: int;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var w2_post: int;                                                                                  
 var w1_post: int;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w1: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.value[y];                                                                             
 Node.value[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.value(u: Tid,y: Node,w2: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.value[y] := tmpW;                                                                             
                                                                                                    
 Node.next[x] := v;                                                                                 
 Node.value[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.value(u: Tid,y: Node,w2: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Node.next.Node.value(t: Tid, u: Tid, v1: Node, v2: Node, w: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v1;                                                                                
 _writeByTAfterT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Node.next[x] := tmpV;                                                                              
                                                                                                    
 Node.value[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Node.next[x] := v1;                                                                                
 _writeByTAfterUAndT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Node.next.Node.next(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.next[y];                                                                              
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.next[y] := tmpW;                                                                              
                                                                                                    
 Node.next[x] := v;                                                                                 
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Node.next (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Node.next.Node.next(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v1;                                                                                
 _writeByTAfterT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Node.next[x] := tmpV;                                                                              
                                                                                                    
 Node.next[y] := w;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Node.next[x] := v1;                                                                                
 _writeByTAfterUAndT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Node.next (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.next is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.next is not Read-Write Stable with respect to Queue.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.next is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.5): Queue.head is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.5): Queue.head is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (20.5): Queue.head is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Node.next.Queue.head(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Queue.head[y];                                                                             
 Queue.head[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Queue.head(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Queue.head[y] := tmpW;                                                                             
                                                                                                    
 Node.next[x] := v;                                                                                 
 Queue.head[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Queue.head(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Node.next.Queue.head(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v1;                                                                                
 _writeByTAfterT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Node.next[x] := tmpV;                                                                              
                                                                                                    
 Queue.head[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Node.next[x] := v1;                                                                                
 _writeByTAfterUAndT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.next is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.next is not Read-Write Stable with respect to Queue.tail (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.next is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (21.5): Queue.tail is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (21.5): Queue.tail is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (21.5): Queue.tail is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Node.next.Queue.tail(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Queue.tail[y];                                                                             
 Queue.tail[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Queue.tail(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Queue.tail[y] := tmpW;                                                                             
                                                                                                    
 Node.next[x] := v;                                                                                 
 Queue.tail[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Queue.tail(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Node.next.Queue.tail(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v1;                                                                                
 _writeByTAfterT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Node.next[x] := tmpV;                                                                              
                                                                                                    
 Queue.tail[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Node.next[x] := v1;                                                                                
 _writeByTAfterUAndT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.value (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.value (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.value (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.5): Queue.head is not Read-Write Stable with respect to Node.value (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.5): Queue.head is not Read-Write Stable with respect to Node.value (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.5): Queue.head is not Read-Write Stable with respect to Node.value (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.5): Node.value is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.5): Queue.head is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.5): Queue.head is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.5): Queue.head is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.next is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.next is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Node.next is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.5): Queue.head is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.5): Queue.head is not Read-Write Stable with respect to Queue.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.5): Queue.head is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.5): Queue.head is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.5): Queue.head is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (20.5): Queue.head is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (21.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (21.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (21.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.value (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.value (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.value (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (21.5): Queue.tail is not Read-Write Stable with respect to Node.value (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (21.5): Queue.tail is not Read-Write Stable with respect to Node.value (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (21.5): Queue.tail is not Read-Write Stable with respect to Node.value (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.5): Node.value is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Queue.tail.Node.value(t: Tid, u: Tid, v: Node, w1: int, w2: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: int;                                                                                     
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var w2_pre: int;                                                                                   
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w1_pre: int;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var w2_mid: int;                                                                                   
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var w1_mid: int;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var w2_post: int;                                                                                  
 var w1_post: int;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w1: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.value[y];                                                                             
 Node.value[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.value(u: Tid,y: Node,w2: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.value[y] := tmpW;                                                                             
                                                                                                    
 Queue.tail[x] := v;                                                                                
 Node.value[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.value(u: Tid,y: Node,w2: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Queue.tail.Node.value(t: Tid, u: Tid, v1: Node, v2: Node, w: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Queue.tail[x] := tmpV;                                                                             
                                                                                                    
 Node.value[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterUAndT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (21.5): Queue.tail is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (21.5): Queue.tail is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (21.5): Queue.tail is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.next is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.next is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Node.next is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Queue.tail.Node.next(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.next[y];                                                                              
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.next[y] := tmpW;                                                                              
                                                                                                    
 Queue.tail[x] := v;                                                                                
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Queue.tail.Node.next(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Queue.tail[x] := tmpV;                                                                             
                                                                                                    
 Node.next[y] := w;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterUAndT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (21.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (21.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (21.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (20.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Queue.tail.Queue.head(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Queue.head[y];                                                                             
 Queue.head[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Queue.head(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Queue.head[y] := tmpW;                                                                             
                                                                                                    
 Queue.tail[x] := v;                                                                                
 Queue.head[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Queue.head(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Queue.tail.Queue.head(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Queue.tail[x] := tmpV;                                                                             
                                                                                                    
 Queue.head[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterUAndT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (21.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (21.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (21.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (21.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (21.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (21.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Queue.tail.Queue.tail(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Queue.tail[y];                                                                             
 Queue.tail[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Queue.tail(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Queue.tail[y] := tmpW;                                                                             
                                                                                                    
 Queue.tail[x] := v;                                                                                
 Queue.tail[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Queue.tail(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Queue.tail.Queue.tail(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Queue.tail[x] := tmpV;                                                                             
                                                                                                    
 Queue.tail[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterUAndT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
requires ValidTid(tid);                                                                             
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (<undefined position>): Object invariant may not hold.
modifies Node._state;                                                                               
modifies Node.value;                                                                                
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Node.next_nextThread;                                                                      
modifies Node.next_nextValue;                                                                       
modifies Queue._state;                                                                              
modifies Queue.head;                                                                                
modifies Queue.tail;                                                                                
modifies Queue._lock;                                                                               
modifies Queue.tail_nextThread;                                                                     
modifies Queue.tail_nextValue;                                                                      
ensures StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
ensures Y(tid , old(Node._state), old(Node.value), old(Node.next), old(Node._lock), old(Node.next_nextThread), old(Node.next_nextValue), old(Queue._state), old(Queue.head), old(Queue.tail), old(Queue._lock), old(Queue.tail_nextThread), old(Queue.tail_nextValue) , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// Node.value:                                                                                      
                                                                                                    
function {:inline} Y_Node.value(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.value(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Node.value[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.value(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.value.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var newValue_yield: int;                                                                            
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.value(u: Tid,this: Node,newValue: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.value(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.value.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.value(tid, this, Node.value[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.value.Transitive(tid : Tid, this: Node, newValue : int , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (3.25): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (3.25): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Queue.head_pre: [Queue]Node;                                                                    
var Queue.tail_nextThread_pre: [Queue]Tid;                                                          
var Node.next_nextValue_pre: [Node]Node;                                                            
var Node.next_nextThread_pre: [Node]Tid;                                                            
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var newValue_pre: int;                                                                              
var Queue.tail_nextValue_pre: [Queue]Node;                                                          
var Queue._lock_pre: [Queue]Tid;                                                                    
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Queue.tail_pre: [Queue]Node;                                                                    
var Queue._state_pre: [Queue]State;                                                                 
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.next_nextThread_post: [Node]Tid;                                                           
var Node.value_post: [Node]int;                                                                     
var newValue_post: int;                                                                             
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Queue.tail_post: [Queue]Node;                                                                   
var Node.next_nextValue_post: [Node]Node;                                                           
var tid_post: Tid;                                                                                  
var Queue.head_post: [Queue]Node;                                                                   
var Queue.tail_nextThread_post: [Queue]Tid;                                                         
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Queue.tail_nextValue_post: [Queue]Node;                                                         
var Queue._state_post: [Queue]State;                                                                
var this_post: Node;                                                                                
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 assume Y_Node.value(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Node.next_nextThread_post == Node.next_nextThread_p && Node.next_nextValue_post == Node.next_nextValue_p && Queue._state_post == Queue._state_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue._lock_post == Queue._lock_p && Queue.tail_nextThread_post == Queue.tail_nextThread_p && Queue.tail_nextValue_post == Queue.tail_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.value(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
// Node.next:                                                                                       
                                                                                                    
function {:inline} Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.next(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Node.next[this] == newValue))
 &&(((newValue==Node.next[this])||((!(isLocal(Node._state[newValue], tid))&&!(isShared(Node._state[newValue])))&&(newValue!=Node.null))))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var newValue_yield: Node;                                                                           
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.next(u: Tid,this: Node,newValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, Node.next[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Transitive(tid : Tid, this: Node, newValue : Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (5.40): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (5.40): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Queue.head_pre: [Queue]Node;                                                                    
var Queue.tail_nextThread_pre: [Queue]Tid;                                                          
var Node.next_nextValue_pre: [Node]Node;                                                            
var Node.next_nextThread_pre: [Node]Tid;                                                            
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var Queue.tail_nextValue_pre: [Queue]Node;                                                          
var Queue._lock_pre: [Queue]Tid;                                                                    
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Queue.tail_pre: [Queue]Node;                                                                    
var Queue._state_pre: [Queue]State;                                                                 
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
                                                                                                    
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.next_nextThread_post: [Node]Tid;                                                           
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Queue.tail_post: [Queue]Node;                                                                   
var Node.next_nextValue_post: [Node]Node;                                                           
var tid_post: Tid;                                                                                  
var Queue.head_post: [Queue]Node;                                                                   
var Queue.tail_nextThread_post: [Queue]Tid;                                                         
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Queue.tail_nextValue_post: [Queue]Node;                                                         
var Queue._state_post: [Queue]State;                                                                
var this_post: Node;                                                                                
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 assume Y_Node.next(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Node.next_nextThread_post == Node.next_nextThread_p && Node.next_nextValue_post == Node.next_nextValue_p && Queue._state_post == Queue._state_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue._lock_post == Queue._lock_p && Queue.tail_nextThread_post == Queue.tail_nextThread_p && Queue.tail_nextValue_post == Queue.tail_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.next(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Check_Node.next.ABAFree(tid : Tid, this: Node, A : Node, B : Node)                        
 modifies Node.next;                                                                                
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires Node.next[this] == A;                                                                     
 requires isAccessible(Node._state[this], tid);                                                     
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (5.40): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (5.40): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Queue.head_pre: [Queue]Node;                                                                    
var Queue.tail_nextThread_pre: [Queue]Tid;                                                          
var Node.next_nextValue_pre: [Node]Node;                                                            
var Node.next_nextThread_pre: [Node]Tid;                                                            
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var Queue.tail_nextValue_pre: [Queue]Node;                                                          
var Queue._lock_pre: [Queue]Tid;                                                                    
var Node._state_pre: [Node]State;                                                                   
var B_pre: Node;                                                                                    
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Queue.tail_pre: [Queue]Node;                                                                    
var Queue._state_pre: [Queue]State;                                                                 
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var A_pre: Node;                                                                                    
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.next_nextThread_post: [Node]Tid;                                                           
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Queue.tail_post: [Queue]Node;                                                                   
var Node.next_nextValue_post: [Node]Node;                                                           
var tid_post: Tid;                                                                                  
var Queue.head_post: [Queue]Node;                                                                   
var Queue.tail_nextThread_post: [Queue]Tid;                                                         
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Queue.tail_nextValue_post: [Queue]Node;                                                         
var B_post: Node;                                                                                   
var Queue._state_post: [Queue]State;                                                                
var A_post: Node;                                                                                   
var this_post: Node;                                                                                
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && B_pre == B && A_pre == A && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume Y_Node.next(tid, this, B , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 assume A != B;                                                                                     
Node.next[this] := B;                                                                               
assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && B_post == B && A_post == A && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert !(Y_Node.next(tid, this, A , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue));
}                                                                                                   
// Node._lock:                                                                                      
                                                                                                    
function {:inline} Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Node._lock[this] == newValue))
 &&(((Node._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var newValue_yield: Tid;                                                                            
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node._lock(u: Tid,this: Node,newValue: Tid,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)));
 assume leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)), _N);
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, Node._lock[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Transitive(tid : Tid, this: Node, newValue : Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (2.1): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (2.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Queue.head_pre: [Queue]Node;                                                                    
var Queue.tail_nextThread_pre: [Queue]Tid;                                                          
var Node.next_nextValue_pre: [Node]Node;                                                            
var Node.next_nextThread_pre: [Node]Tid;                                                            
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var Queue.tail_nextValue_pre: [Queue]Node;                                                          
var Queue._lock_pre: [Queue]Tid;                                                                    
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Queue.tail_pre: [Queue]Node;                                                                    
var Queue._state_pre: [Queue]State;                                                                 
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var newValue_pre: Tid;                                                                              
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.next_nextThread_post: [Node]Tid;                                                           
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Queue.tail_post: [Queue]Node;                                                                   
var Node.next_nextValue_post: [Node]Node;                                                           
var tid_post: Tid;                                                                                  
var Queue.head_post: [Queue]Node;                                                                   
var Queue.tail_nextThread_post: [Queue]Tid;                                                         
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Queue.tail_nextValue_post: [Queue]Node;                                                         
var Queue._state_post: [Queue]State;                                                                
var this_post: Node;                                                                                
var newValue_post: Tid;                                                                             
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 assume Y_Node._lock(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Node.next_nextThread_post == Node.next_nextThread_p && Node.next_nextValue_post == Node.next_nextValue_p && Queue._state_post == Queue._state_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue._lock_post == Queue._lock_p && Queue.tail_nextThread_post == Queue.tail_nextThread_p && Queue.tail_nextValue_post == Queue.tail_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
// Node.next_nextThread:                                                                            
                                                                                                    
function {:inline} Y_Node.next_nextThread(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.next_nextThread(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Node.next_nextThread[this] == newValue))
 &&(((Node.next_nextThread[this]==tid)==>(newValue==tid)))                                          
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.next_nextThread(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// Node.next_nextValue:                                                                             
                                                                                                    
function {:inline} Y_Node.next_nextValue(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.next_nextValue(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Node.next_nextValue[this] == newValue))
 &&(((Node.next_nextThread[this]==tid)==>(newValue==Node.next_nextValue[this])))                    
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.next_nextValue(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// Queue.head:                                                                                      
                                                                                                    
function {:inline} Y_Queue.head(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.head(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Queue.head[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Queue.head(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue.head.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var newValue_yield: Node;                                                                           
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue.head(u: Tid,this: Queue,newValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.head(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Queue.head.Reflexive(tid : Tid, this: Queue , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.head(tid, this, Queue.head[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Queue.head.Transitive(tid : Tid, this: Queue, newValue : Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (20.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (20.33): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Queue.head_pre: [Queue]Node;                                                                    
var Queue.tail_nextThread_pre: [Queue]Tid;                                                          
var Node.next_nextValue_pre: [Node]Node;                                                            
var Node.next_nextThread_pre: [Node]Tid;                                                            
var $recorded.state_pre: int;                                                                       
var Queue.tail_nextValue_pre: [Queue]Node;                                                          
var Queue._lock_pre: [Queue]Tid;                                                                    
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Queue.tail_pre: [Queue]Node;                                                                    
var Queue._state_pre: [Queue]State;                                                                 
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var this_pre: Queue;                                                                                
                                                                                                    
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.next_nextThread_post: [Node]Tid;                                                           
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Queue.tail_post: [Queue]Node;                                                                   
var Node.next_nextValue_post: [Node]Node;                                                           
var tid_post: Tid;                                                                                  
var this_post: Queue;                                                                               
var Queue.head_post: [Queue]Node;                                                                   
var Queue.tail_nextThread_post: [Queue]Tid;                                                         
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Queue.tail_nextValue_post: [Queue]Node;                                                         
var Queue._state_post: [Queue]State;                                                                
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 assume Y_Queue.head(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Node.next_nextThread_post == Node.next_nextThread_p && Node.next_nextValue_post == Node.next_nextValue_p && Queue._state_post == Queue._state_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue._lock_post == Queue._lock_p && Queue.tail_nextThread_post == Queue.tail_nextThread_p && Queue.tail_nextValue_post == Queue.tail_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue.head(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
// Queue.tail:                                                                                      
                                                                                                    
function {:inline} Y_Queue.tail(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Queue.tail[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Queue.tail(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue.tail.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var newValue_yield: Node;                                                                           
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue.tail(u: Tid,this: Queue,newValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.tail(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Queue.tail.Reflexive(tid : Tid, this: Queue , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.tail(tid, this, Queue.tail[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Queue.tail.Transitive(tid : Tid, this: Queue, newValue : Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (21.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (21.33): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Queue.head_pre: [Queue]Node;                                                                    
var Queue.tail_nextThread_pre: [Queue]Tid;                                                          
var Node.next_nextValue_pre: [Node]Node;                                                            
var Node.next_nextThread_pre: [Node]Tid;                                                            
var $recorded.state_pre: int;                                                                       
var Queue.tail_nextValue_pre: [Queue]Node;                                                          
var Queue._lock_pre: [Queue]Tid;                                                                    
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Queue.tail_pre: [Queue]Node;                                                                    
var Queue._state_pre: [Queue]State;                                                                 
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var this_pre: Queue;                                                                                
                                                                                                    
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.next_nextThread_post: [Node]Tid;                                                           
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Queue.tail_post: [Queue]Node;                                                                   
var Node.next_nextValue_post: [Node]Node;                                                           
var tid_post: Tid;                                                                                  
var this_post: Queue;                                                                               
var Queue.head_post: [Queue]Node;                                                                   
var Queue.tail_nextThread_post: [Queue]Tid;                                                         
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Queue.tail_nextValue_post: [Queue]Node;                                                         
var Queue._state_post: [Queue]State;                                                                
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 assume Y_Queue.tail(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Node.next_nextThread_post == Node.next_nextThread_p && Node.next_nextValue_post == Node.next_nextValue_p && Queue._state_post == Queue._state_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue._lock_post == Queue._lock_p && Queue.tail_nextThread_post == Queue.tail_nextThread_p && Queue.tail_nextValue_post == Queue.tail_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue.tail(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
// Queue._lock:                                                                                     
                                                                                                    
function {:inline} Y_Queue._lock(tid : Tid, this: Queue, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue._lock(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Queue._lock[this] == newValue))
 &&(((Queue._lock[this]==tid)==(newValue==tid)))                                                    
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Queue._lock(tid : Tid, this: Queue, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue._lock.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var Node.value_yield: [Node]int;                                                                    
var newValue_yield: Tid;                                                                            
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue._lock(u: Tid,this: Queue,newValue: Tid,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)));
 assume leq(m#moverPath(ReadEval.Queue._lock(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)), _N);
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue._lock(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Queue._lock.Reflexive(tid : Tid, this: Queue , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue._lock(tid, this, Queue._lock[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Queue._lock.Transitive(tid : Tid, this: Queue, newValue : Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374805(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (18.1): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3374813(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue));       // (18.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Queue.head_pre: [Queue]Node;                                                                    
var Queue.tail_nextThread_pre: [Queue]Tid;                                                          
var Node.next_nextValue_pre: [Node]Node;                                                            
var Node.next_nextThread_pre: [Node]Tid;                                                            
var $recorded.state_pre: int;                                                                       
var Queue.tail_nextValue_pre: [Queue]Node;                                                          
var Queue._lock_pre: [Queue]Tid;                                                                    
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Queue.tail_pre: [Queue]Node;                                                                    
var Queue._state_pre: [Queue]State;                                                                 
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var newValue_pre: Tid;                                                                              
var this_pre: Queue;                                                                                
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.next_nextThread_post: [Node]Tid;                                                           
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Queue.tail_post: [Queue]Node;                                                                   
var Node.next_nextValue_post: [Node]Node;                                                           
var tid_post: Tid;                                                                                  
var this_post: Queue;                                                                               
var Queue.head_post: [Queue]Node;                                                                   
var Queue.tail_nextThread_post: [Queue]Tid;                                                         
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Queue.tail_nextValue_post: [Queue]Node;                                                         
var Queue._state_post: [Queue]State;                                                                
var newValue_post: Tid;                                                                             
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 assume Y_Queue._lock(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Node.next_nextThread_post == Node.next_nextThread_p && Node.next_nextValue_post == Node.next_nextValue_p && Queue._state_post == Queue._state_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue._lock_post == Queue._lock_p && Queue.tail_nextThread_post == Queue.tail_nextThread_p && Queue.tail_nextValue_post == Queue.tail_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue._lock(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
// Queue.tail_nextThread:                                                                           
                                                                                                    
function {:inline} Y_Queue.tail_nextThread(tid : Tid, this: Queue, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.tail_nextThread(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Queue.tail_nextThread[this] == newValue))
 &&(((Queue.tail_nextThread[this]==tid)==>(newValue==tid)))                                         
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Queue.tail_nextThread(tid : Tid, this: Queue, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// Queue.tail_nextValue:                                                                            
                                                                                                    
function {:inline} Y_Queue.tail_nextValue(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.tail_nextValue(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Queue.tail_nextValue[this] == newValue))
 &&(((Queue.tail_nextThread[this]==tid)==>(newValue==Queue.tail_nextValue[this])))                  
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Queue.tail_nextValue(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node): bool
{                                                                                                   
 (forall this: Node :: Y_Node.value(tid : Tid, this, Node.value_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Node :: Y_Node.next(tid : Tid, this, Node.next_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Node :: Y_Node._lock(tid : Tid, this, Node._lock_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Node :: Y_Node.next_nextThread(tid : Tid, this, Node.next_nextThread_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Node :: Y_Node.next_nextValue(tid : Tid, this, Node.next_nextValue_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Queue :: Y_Queue.head(tid : Tid, this, Queue.head_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Queue :: Y_Queue.tail(tid : Tid, this, Queue.tail_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Queue :: Y_Queue._lock(tid : Tid, this, Queue._lock_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Queue :: Y_Queue.tail_nextThread(tid : Tid, this, Queue.tail_nextThread_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Queue :: Y_Queue.tail_nextValue(tid : Tid, this, Queue.tail_nextValue_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall _i : Node :: isShared(Node._state[_i]) ==> isShared(Node._state_p[_i]))                 
 && (forall _i : Node :: isLocal(Node._state[_i], tid) <==> isLocal(Node._state_p[_i], tid))        
 && (forall _i : Queue :: isShared(Queue._state[_i]) ==> isShared(Queue._state_p[_i]))              
 && (forall _i : Queue :: isLocal(Queue._state[_i], tid) <==> isLocal(Queue._state_p[_i], tid))     
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 1823.1-2132.2: (Method:27.5)
// 1839.1-1839.24: (27.5): Bad tid
// 1848.1-1848.345: (27.5): Object invariant may not hold.
// 1849.1-1849.345: (27.5): Object invariant may not hold.
// 1852.1-1852.335: (27.5): Object invariant may not hold.
// 1853.1-1853.335: (27.5): Object invariant may not hold.
// 1966.1-1966.255: (27.5): Can only have right-mover memory accesses in requires clause
// 1967.1-1967.255: (27.5): Can only have right-mover memory accesses in requires clause
// 1969.2-1972.39: (class anchor.sink.Assume:27.5)
// 1973.2-1976.39: (class anchor.sink.Assume:27.5)
// 1977.2-1979.2: (class anchor.sink.VarDeclStmt:28.9)
// 1980.2-1988.43: (class anchor.sink.Alloc:28.9)
// 1991.2-1993.2: (class anchor.sink.VarDeclStmt:28.9)
// 1994.2-1996.2: (class anchor.sink.VarDeclStmt:28.9)
// 1997.2-1999.2: (class anchor.sink.VarDeclStmt:28.9)
// 2000.2-2003.17: (class anchor.sink.Assign:28.9)
// 2004.2-2007.24: (class anchor.sink.Assign:28.9)
// 2008.2-2011.23: (class anchor.sink.Assign:28.9)
// 2012.2-2015.35: (class anchor.sink.Assume:12.5)
// 2016.2-2019.42: (class anchor.sink.Assume:12.5)
// 2021.2-2037.36: (class anchor.sink.Write:13.9)
// 2033.1-2033.32: (13.9): Cannot have potential null deference in left-mover part.
// 2036.1-2036.27: (13.9): Reduction failure
// 2039.2-2042.47: (class anchor.sink.Assume:14.9)
// 2045.2-2066.2: (class anchor.sink.Write:14.9)
// 2057.1-2057.32: (14.9): Cannot have potential null deference in left-mover part.
// 2060.1-2060.27: (14.9): Reduction failure
// 2064.1-2064.63: (14.9): next$226 became shared, but next$226.next may not be shared.
// 2067.2-2070.23: (class anchor.sink.Break:12.32)
// 2073.2-2094.2: (class anchor.sink.Write:29.9)
// 2085.1-2085.29: (29.9): Cannot have potential null deference in left-mover part.
// 2088.1-2088.27: (29.9): Reduction failure
// 2092.1-2092.63: (29.9): sentinel became shared, but sentinel.next may not be shared.
// 2096.2-2099.44: (class anchor.sink.Assume:30.9)
// 2102.2-2123.2: (class anchor.sink.Write:30.9)
// 2114.1-2114.29: (30.9): Cannot have potential null deference in left-mover part.
// 2117.1-2117.27: (30.9): Reduction failure
// 2121.1-2121.63: (30.9): sentinel became shared, but sentinel.next may not be shared.
// 2124.2-2131.9: (class anchor.sink.Return:27.20)
// 2129.1-2129.335: (27.20): Object invariant may not hold.
// 2130.1-2130.335: (27.20): Object invariant may not hold.
// 2133.1-4481.2: (Method:33.5)
// 2149.1-2149.24: (33.5): Bad tid
// 2150.1-2150.39: (33.5): this is not global
// 2153.1-2153.336: (33.5): Object invariant may not hold.
// 2154.1-2154.336: (33.5): Object invariant may not hold.
// 2157.1-2157.335: (33.5): Object invariant may not hold.
// 2158.1-2158.335: (33.5): Object invariant may not hold.
// 3326.2-3328.2: (class anchor.sink.VarDeclStmt:34.9)
// 3329.2-3337.36: (class anchor.sink.Alloc:34.9)
// 3340.2-3342.2: (class anchor.sink.VarDeclStmt:34.9)
// 3343.2-3345.2: (class anchor.sink.VarDeclStmt:34.9)
// 3346.2-3348.2: (class anchor.sink.VarDeclStmt:34.9)
// 3349.2-3352.21: (class anchor.sink.Assign:34.9)
// 3353.2-3356.24: (class anchor.sink.Assign:34.9)
// 3357.2-3360.16: (class anchor.sink.Assign:34.9)
// 3361.2-3364.35: (class anchor.sink.Assume:12.5)
// 3365.2-3368.42: (class anchor.sink.Assume:12.5)
// 3370.2-3386.36: (class anchor.sink.Write:13.9)
// 3382.1-3382.32: (13.9): Cannot have potential null deference in left-mover part.
// 3385.1-3385.27: (13.9): Reduction failure
// 3388.2-3391.47: (class anchor.sink.Assume:14.9)
// 3394.2-3415.2: (class anchor.sink.Write:14.9)
// 3406.1-3406.32: (14.9): Cannot have potential null deference in left-mover part.
// 3409.1-3409.27: (14.9): Reduction failure
// 3413.1-3413.63: (14.9): next$227 became shared, but next$227.next may not be shared.
// 3416.2-3419.23: (class anchor.sink.Break:12.32)
// 3421.2-3423.2: (class anchor.sink.VarDeclStmt:35.9)
// 3425.2-3427.2: (class anchor.sink.VarDeclStmt:35.9)
// 3428.2-3445.38: (class anchor.sink.Read:35.9)
// 3440.1-3440.29: (35.9): Cannot have potential null deference in left-mover part.
// 3444.1-3444.27: (35.9): Reduction failure
// 3446.2-3448.2: (class anchor.sink.VarDeclStmt:35.9)
// 3449.2-3466.37: (class anchor.sink.Read:35.9)
// 3461.1-3461.29: (35.9): Cannot have potential null deference in left-mover part.
// 3465.1-3465.27: (35.9): Reduction failure
// 3467.2-3469.2: (class anchor.sink.VarDeclStmt:35.9)
// 3470.2-3487.36: (class anchor.sink.Read:35.9)
// 3482.1-3482.29: (35.9): Cannot have potential null deference in left-mover part.
// 3486.1-3486.27: (35.9): Reduction failure
// 3488.2-3490.2: (class anchor.sink.VarDeclStmt:35.9)
// 3491.2-3494.240: (class anchor.sink.Assign:35.9)
// 3495.2-3497.2: (class anchor.sink.VarDeclStmt:35.9)
// 3498.2-3501.74: (class anchor.sink.Assign:35.9)
// 3504.3-3521.28: (class anchor.sink.Read:35.9)
// 3516.1-3516.30: (35.9): Cannot have potential null deference in left-mover part.
// 3520.1-3520.28: (35.9): Reduction failure
// 3524.3-3541.28: (class anchor.sink.Read:35.9)
// 3536.1-3536.30: (35.9): Cannot have potential null deference in left-mover part.
// 3540.1-3540.28: (35.9): Reduction failure
// 3543.2-3555.42: (class anchor.sink.Yield:36.9)
// 3548.1-3548.335: (36.9): Object invariant may not hold.
// 3549.1-3549.335: (36.9): Object invariant may not hold.
// 3551.1-3551.335: (36.9): Object invariant may not hold.
// 3552.1-3552.335: (36.9): Object invariant may not hold.
// 3558.2-3562.14: (class anchor.sink.While:37.9)
// 3564.1-3564.27: (33.5): Bad tid
// 3565.1-3565.42: (33.5): this is not global
// 3568.1-3568.339: (37.9): Object invariant may not hold.
// 3569.1-3569.339: (37.9): Object invariant may not hold.
// 3569.339-3570.42: (37.9): invariant isLocal(n, tid) may not hold
// 3570.42-3571.41: (37.9): invariant isShared(last) may not hold
// 3571.41-3572.39: (37.9): invariant n.next == Node.null may not hold
// 3573.1-3573.358: (37.9): Loop does not preserve yields_as annotation for field value
// 3574.1-3574.356: (37.9): Loop does not preserve yields_as annotation for field next
// 3575.1-3575.359: (37.9): Loop does not preserve yields_as annotation for field head
// 3576.1-3576.359: (37.9): Loop does not preserve yields_as annotation for field tail
// 3577.1-3577.33: (37.9): Phase must be invariant at loop head
// 3578.1-3578.30: (37.9): Potentially infinite loop cannot be in post-commit phase.
// 3580.3-3582.3: (class anchor.sink.VarDeclStmt:37.15)
// 3583.3-3586.16: (class anchor.sink.Assign:37.15)
// 3588.4-3591.10: (class anchor.sink.Break:37.9)
// 3594.3-3596.3: (class anchor.sink.VarDeclStmt:42.13)
// 3598.3-3600.3: (class anchor.sink.VarDeclStmt:42.13)
// 3601.3-3618.38: (class anchor.sink.Read:42.13)
// 3613.1-3613.29: (42.13): Cannot have potential null deference in left-mover part.
// 3617.1-3617.28: (42.13): Reduction failure
// 3619.3-3621.3: (class anchor.sink.VarDeclStmt:42.13)
// 3622.3-3639.37: (class anchor.sink.Read:42.13)
// 3634.1-3634.29: (42.13): Cannot have potential null deference in left-mover part.
// 3638.1-3638.28: (42.13): Reduction failure
// 3640.3-3642.3: (class anchor.sink.VarDeclStmt:42.13)
// 3643.3-3660.36: (class anchor.sink.Read:42.13)
// 3655.1-3655.29: (42.13): Cannot have potential null deference in left-mover part.
// 3659.1-3659.28: (42.13): Reduction failure
// 3661.3-3663.3: (class anchor.sink.VarDeclStmt:42.13)
// 3664.3-3667.239: (class anchor.sink.Assign:42.13)
// 3668.3-3670.3: (class anchor.sink.VarDeclStmt:42.13)
// 3671.3-3674.74: (class anchor.sink.Assign:42.13)
// 3677.4-3694.28: (class anchor.sink.Read:42.13)
// 3689.1-3689.30: (42.13): Cannot have potential null deference in left-mover part.
// 3693.1-3693.29: (42.13): Reduction failure
// 3697.4-3714.28: (class anchor.sink.Read:42.13)
// 3709.1-3709.30: (42.13): Cannot have potential null deference in left-mover part.
// 3713.1-3713.29: (42.13): Reduction failure
// 3716.3-3718.3: (class anchor.sink.VarDeclStmt:43.13)
// 3719.3-3722.29: (class anchor.sink.Assign:43.13)
// 3724.4-3726.4: (class anchor.sink.VarDeclStmt:44.17)
// 3728.4-3730.4: (class anchor.sink.VarDeclStmt:44.17)
// 3731.4-3734.22: (class anchor.sink.Assign:44.17)
// 3737.5-3740.19: (class anchor.sink.Assign:44.17)
// 3742.5-3745.23: (class anchor.sink.Assign:44.17)
// 3747.6-3749.6: (class anchor.sink.VarDeclStmt:44.17)
// 3750.6-3752.6: (class anchor.sink.VarDeclStmt:44.17)
// 3753.6-3755.6: (class anchor.sink.VarDeclStmt:44.17)
// 3756.6-3759.249: (class anchor.sink.Assign:44.17)
// 3760.6-3763.37: (class anchor.sink.Assume:44.17)
// 3764.6-3767.50: (class anchor.sink.Assume:44.17)
// 3768.6-3771.47: (class anchor.sink.Assume:44.17)
// 3772.6-3775.47: (class anchor.sink.Assume:44.17)
// 3777.6-3793.43: (class anchor.sink.Write:44.17)
// 3789.1-3789.32: (44.17): Cannot have potential null deference in left-mover part.
// 3792.1-3792.31: (44.17): Reduction failure
// 3795.6-3811.44: (class anchor.sink.Write:44.17)
// 3807.1-3807.32: (44.17): Cannot have potential null deference in left-mover part.
// 3810.1-3810.31: (44.17): Reduction failure
// 3814.6-3835.6: (class anchor.sink.Write:44.17)
// 3826.1-3826.32: (44.17): Cannot have potential null deference in left-mover part.
// 3829.1-3829.31: (44.17): Reduction failure
// 3833.1-3833.60: (44.17): n became shared, but n.next may not be shared.
// 3836.6-3839.19: (class anchor.sink.Assign:44.17)
// 3841.6-3844.47: (class anchor.sink.Assume:44.17)
// 3845.6-3848.47: (class anchor.sink.Assume:44.17)
// 3849.6-3851.6: (class anchor.sink.VarDeclStmt:44.17)
// 3852.6-3869.39: (class anchor.sink.Read:44.17)
// 3864.1-3864.32: (44.17): Cannot have potential null deference in left-mover part.
// 3868.1-3868.31: (44.17): Reduction failure
// 3871.6-3892.6: (class anchor.sink.Write:44.17)
// 3883.1-3883.32: (44.17): Cannot have potential null deference in left-mover part.
// 3886.1-3886.31: (44.17): Reduction failure
// 3890.1-3890.63: (44.17): next became shared, but next.next may not be shared.
// 3893.6-3895.6: (class anchor.sink.VarDeclStmt:44.17)
// 3896.6-3899.249: (class anchor.sink.Assign:44.17)
// 3901.6-3922.6: (class anchor.sink.Write:44.17)
// 3913.1-3913.32: (44.17): Cannot have potential null deference in left-mover part.
// 3916.1-3916.31: (44.17): Reduction failure
// 3920.1-3920.72: (44.17): _currentValue became shared, but _currentValue.next may not be shared.
// 3923.6-3926.47: (class anchor.sink.Assume:44.17)
// 3929.6-3950.6: (class anchor.sink.Write:44.17)
// 3941.1-3941.32: (44.17): Cannot have potential null deference in left-mover part.
// 3944.1-3944.31: (44.17): Reduction failure
// 3948.1-3948.60: (44.17): n became shared, but n.next may not be shared.
// 3951.6-3954.20: (class anchor.sink.Assign:44.17)
// 3958.5-3970.45: (class anchor.sink.Yield:45.21)
// 3963.1-3963.338: (45.21): Object invariant may not hold.
// 3964.1-3964.338: (45.21): Object invariant may not hold.
// 3966.1-3966.338: (45.21): Object invariant may not hold.
// 3967.1-3967.338: (45.21): Object invariant may not hold.
// 3971.5-3973.5: (class anchor.sink.VarDeclStmt:46.21)
// 3975.5-3977.5: (class anchor.sink.VarDeclStmt:46.21)
// 3978.5-3981.23: (class anchor.sink.Assign:46.21)
// 3984.6-3987.20: (class anchor.sink.Assign:46.21)
// 3989.6-3992.24: (class anchor.sink.Assign:46.21)
// 3994.7-3996.7: (class anchor.sink.VarDeclStmt:46.21)
// 3997.7-3999.7: (class anchor.sink.VarDeclStmt:46.21)
// 4000.7-4002.7: (class anchor.sink.VarDeclStmt:46.21)
// 4003.7-4006.252: (class anchor.sink.Assign:46.21)
// 4007.7-4010.39: (class anchor.sink.Assume:46.21)
// 4011.7-4014.51: (class anchor.sink.Assume:46.21)
// 4015.7-4018.49: (class anchor.sink.Assume:46.21)
// 4019.7-4022.49: (class anchor.sink.Assume:46.21)
// 4024.7-4040.45: (class anchor.sink.Write:46.21)
// 4036.1-4036.34: (46.21): Cannot have potential null deference in left-mover part.
// 4039.1-4039.32: (46.21): Reduction failure
// 4042.7-4058.46: (class anchor.sink.Write:46.21)
// 4054.1-4054.34: (46.21): Cannot have potential null deference in left-mover part.
// 4057.1-4057.32: (46.21): Reduction failure
// 4061.7-4082.7: (class anchor.sink.Write:46.21)
// 4073.1-4073.34: (46.21): Cannot have potential null deference in left-mover part.
// 4076.1-4076.32: (46.21): Reduction failure
// 4080.1-4080.61: (46.21): n became shared, but n.next may not be shared.
// 4083.7-4086.20: (class anchor.sink.Assign:46.21)
// 4088.7-4091.49: (class anchor.sink.Assume:46.21)
// 4092.7-4095.49: (class anchor.sink.Assume:46.21)
// 4096.7-4098.7: (class anchor.sink.VarDeclStmt:46.21)
// 4099.7-4116.41: (class anchor.sink.Read:46.21)
// 4111.1-4111.34: (46.21): Cannot have potential null deference in left-mover part.
// 4115.1-4115.32: (46.21): Reduction failure
// 4118.7-4139.7: (class anchor.sink.Write:46.21)
// 4130.1-4130.34: (46.21): Cannot have potential null deference in left-mover part.
// 4133.1-4133.32: (46.21): Reduction failure
// 4137.1-4137.64: (46.21): last became shared, but last.next may not be shared.
// 4140.7-4142.7: (class anchor.sink.VarDeclStmt:46.21)
// 4143.7-4146.252: (class anchor.sink.Assign:46.21)
// 4148.7-4169.7: (class anchor.sink.Write:46.21)
// 4160.1-4160.34: (46.21): Cannot have potential null deference in left-mover part.
// 4163.1-4163.32: (46.21): Reduction failure
// 4167.1-4167.73: (46.21): _currentValue became shared, but _currentValue.next may not be shared.
// 4170.7-4173.48: (class anchor.sink.Assume:46.21)
// 4176.7-4197.7: (class anchor.sink.Write:46.21)
// 4188.1-4188.34: (46.21): Cannot have potential null deference in left-mover part.
// 4191.1-4191.32: (46.21): Reduction failure
// 4195.1-4195.61: (46.21): n became shared, but n.next may not be shared.
// 4198.7-4201.21: (class anchor.sink.Assign:46.21)
// 4204.5-4211.12: (class anchor.sink.Return:47.21)
// 4209.1-4209.338: (47.21): Object invariant may not hold.
// 4210.1-4210.338: (47.21): Object invariant may not hold.
// 4215.4-4217.4: (class anchor.sink.VarDeclStmt:50.17)
// 4219.4-4221.4: (class anchor.sink.VarDeclStmt:50.17)
// 4222.4-4225.22: (class anchor.sink.Assign:50.17)
// 4228.5-4231.19: (class anchor.sink.Assign:50.17)
// 4233.5-4236.23: (class anchor.sink.Assign:50.17)
// 4238.6-4240.6: (class anchor.sink.VarDeclStmt:50.17)
// 4241.6-4243.6: (class anchor.sink.VarDeclStmt:50.17)
// 4244.6-4246.6: (class anchor.sink.VarDeclStmt:50.17)
// 4247.6-4250.254: (class anchor.sink.Assign:50.17)
// 4251.6-4254.38: (class anchor.sink.Assume:50.17)
// 4255.6-4258.50: (class anchor.sink.Assume:50.17)
// 4259.6-4262.48: (class anchor.sink.Assume:50.17)
// 4263.6-4266.48: (class anchor.sink.Assume:50.17)
// 4268.6-4284.44: (class anchor.sink.Write:50.17)
// 4280.1-4280.33: (50.17): Cannot have potential null deference in left-mover part.
// 4283.1-4283.31: (50.17): Reduction failure
// 4286.6-4302.45: (class anchor.sink.Write:50.17)
// 4298.1-4298.33: (50.17): Cannot have potential null deference in left-mover part.
// 4301.1-4301.31: (50.17): Reduction failure
// 4305.6-4326.6: (class anchor.sink.Write:50.17)
// 4317.1-4317.33: (50.17): Cannot have potential null deference in left-mover part.
// 4320.1-4320.31: (50.17): Reduction failure
// 4324.1-4324.63: (50.17): next became shared, but next.next may not be shared.
// 4327.6-4330.19: (class anchor.sink.Assign:50.17)
// 4332.6-4335.48: (class anchor.sink.Assume:50.17)
// 4336.6-4339.48: (class anchor.sink.Assume:50.17)
// 4340.6-4342.6: (class anchor.sink.VarDeclStmt:50.17)
// 4343.6-4360.40: (class anchor.sink.Read:50.17)
// 4355.1-4355.33: (50.17): Cannot have potential null deference in left-mover part.
// 4359.1-4359.31: (50.17): Reduction failure
// 4362.6-4383.6: (class anchor.sink.Write:50.17)
// 4374.1-4374.33: (50.17): Cannot have potential null deference in left-mover part.
// 4377.1-4377.31: (50.17): Reduction failure
// 4381.1-4381.63: (50.17): last became shared, but last.next may not be shared.
// 4384.6-4386.6: (class anchor.sink.VarDeclStmt:50.17)
// 4387.6-4390.254: (class anchor.sink.Assign:50.17)
// 4392.6-4413.6: (class anchor.sink.Write:50.17)
// 4404.1-4404.33: (50.17): Cannot have potential null deference in left-mover part.
// 4407.1-4407.31: (50.17): Reduction failure
// 4411.1-4411.72: (50.17): _currentValue became shared, but _currentValue.next may not be shared.
// 4414.6-4417.47: (class anchor.sink.Assume:50.17)
// 4420.6-4441.6: (class anchor.sink.Write:50.17)
// 4432.1-4432.33: (50.17): Cannot have potential null deference in left-mover part.
// 4435.1-4435.31: (50.17): Reduction failure
// 4439.1-4439.63: (50.17): next became shared, but next.next may not be shared.
// 4442.6-4445.20: (class anchor.sink.Assign:50.17)
// 4449.5-4452.18: (class anchor.sink.Assign:51.21)
// 4456.3-4468.43: (class anchor.sink.Yield:54.13)
// 4461.1-4461.336: (54.13): Object invariant may not hold.
// 4462.1-4462.336: (54.13): Object invariant may not hold.
// 4464.1-4464.336: (54.13): Object invariant may not hold.
// 4465.1-4465.336: (54.13): Object invariant may not hold.
// 4471.1-4471.30: (37.9): Phase must be invariant at loop head
// 4473.2-4480.9: (class anchor.sink.Return:33.36)
// 4478.1-4478.335: (33.36): Object invariant may not hold.
// 4479.1-4479.335: (33.36): Object invariant may not hold.
// 4580.1-4580.34: (3.5): Node.value failed Write-Write Right-Mover Check
// 4655.1-4655.30: (3.5): Node.value failed Write-Read Right-Mover Check
// 4734.1-4734.34: (3.5): Node.value failed Write-Write Left-Mover Check
// 4810.1-4810.30: (3.5): Node.value failed Write-Read Left-Mover Check
// 4883.1-4883.34: (3.5): Node.value failed Read-Write Right-Mover Check
// 4959.1-4959.34: (3.5): Node.value failed Read-Write Left-Mover Check
// 5034.1-5034.34: (5.5): Node.next failed Write-Write Right-Mover Check
// 5109.1-5109.30: (5.5): Node.next failed Write-Read Right-Mover Check
// 5188.1-5188.34: (5.5): Node.next failed Write-Write Left-Mover Check
// 5264.1-5264.30: (5.5): Node.next failed Write-Read Left-Mover Check
// 5337.1-5337.34: (5.5): Node.next failed Read-Write Right-Mover Check
// 5413.1-5413.34: (5.5): Node.next failed Read-Write Left-Mover Check
// 5488.1-5488.34: (20.5): Queue.head failed Write-Write Right-Mover Check
// 5563.1-5563.30: (20.5): Queue.head failed Write-Read Right-Mover Check
// 5642.1-5642.34: (20.5): Queue.head failed Write-Write Left-Mover Check
// 5718.1-5718.30: (20.5): Queue.head failed Write-Read Left-Mover Check
// 5791.1-5791.34: (20.5): Queue.head failed Read-Write Right-Mover Check
// 5867.1-5867.34: (20.5): Queue.head failed Read-Write Left-Mover Check
// 5942.1-5942.34: (21.5): Queue.tail failed Write-Write Right-Mover Check
// 6017.1-6017.30: (21.5): Queue.tail failed Write-Read Right-Mover Check
// 6096.1-6096.34: (21.5): Queue.tail failed Write-Write Left-Mover Check
// 6172.1-6172.30: (21.5): Queue.tail failed Write-Read Left-Mover Check
// 6245.1-6245.34: (21.5): Queue.tail failed Read-Write Right-Mover Check
// 6321.1-6321.34: (21.5): Queue.tail failed Read-Write Left-Mover Check
// 6408.1-6408.140: (3.5): Node.value is not Write-Write Stable with respect to Node.value (case A.1)
// 6409.1-6409.101: (3.5): Node.value is not Write-Write Stable with respect to Node.value (case A.2)
// 6410.1-6410.158: (3.5): Node.value is not Write-Write Stable with respect to Node.value (case A.3)
// 6530.1-6530.140: (3.5): Node.value is not Write-Write Stable with respect to Node.value (case C)
// 6655.1-6655.144: (3.5): Node.value is not Write-Write Stable with respect to Node.value (case D)
// 6656.1-6656.144: (3.5): Node.value is not Write-Write Stable with respect to Node.value (case R)
// 6743.1-6743.136: (3.5): Node.value is not Read-Write Stable with respect to Node.value (case F)
// 6744.1-6744.136: (3.5): Node.value is not Read-Write Stable with respect to Node.value (case H)
// 6745.1-6745.146: (3.5): Node.value is not Read-Write Stable with respect to Node.value (case I)
// 6831.1-6831.136: (3.5): Node.value is not Write-Read Stable with respect to Node.value (case J)
// 6832.1-6832.136: (3.5): Node.value is not Write-Read Stable with respect to Node.value (case K)
// 6833.1-6833.99: (3.5): Node.value is not Write-Read Stable with respect to Node.value (case L)
// 6921.1-6921.140: (5.5): Node.next is not Write-Write Stable with respect to Node.value (case A.1)
// 6922.1-6922.101: (5.5): Node.next is not Write-Write Stable with respect to Node.value (case A.2)
// 6923.1-6923.158: (5.5): Node.next is not Write-Write Stable with respect to Node.value (case A.3)
// 7043.1-7043.140: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case C)
// 7168.1-7168.144: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case D)
// 7169.1-7169.144: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case R)
// 7256.1-7256.136: (3.5): Node.value is not Read-Write Stable with respect to Node.next (case F)
// 7257.1-7257.136: (3.5): Node.value is not Read-Write Stable with respect to Node.next (case H)
// 7258.1-7258.146: (3.5): Node.value is not Read-Write Stable with respect to Node.next (case I)
// 7344.1-7344.136: (5.5): Node.next is not Write-Read Stable with respect to Node.value (case J)
// 7345.1-7345.136: (5.5): Node.next is not Write-Read Stable with respect to Node.value (case K)
// 7346.1-7346.99: (5.5): Node.next is not Write-Read Stable with respect to Node.value (case L)
// 7434.1-7434.140: (20.5): Queue.head is not Write-Write Stable with respect to Node.value (case A.1)
// 7435.1-7435.101: (20.5): Queue.head is not Write-Write Stable with respect to Node.value (case A.2)
// 7436.1-7436.156: (20.5): Queue.head is not Write-Write Stable with respect to Node.value (case A.3)
// 7556.1-7556.140: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case C)
// 7681.1-7681.144: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case D)
// 7682.1-7682.144: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case R)
// 7769.1-7769.136: (3.5): Node.value is not Read-Write Stable with respect to Queue.head (case F)
// 7770.1-7770.136: (3.5): Node.value is not Read-Write Stable with respect to Queue.head (case H)
// 7771.1-7771.144: (3.5): Node.value is not Read-Write Stable with respect to Queue.head (case I)
// 7857.1-7857.136: (20.5): Queue.head is not Write-Read Stable with respect to Node.value (case J)
// 7858.1-7858.136: (20.5): Queue.head is not Write-Read Stable with respect to Node.value (case K)
// 7859.1-7859.99: (20.5): Queue.head is not Write-Read Stable with respect to Node.value (case L)
// 7947.1-7947.140: (21.5): Queue.tail is not Write-Write Stable with respect to Node.value (case A.1)
// 7948.1-7948.101: (21.5): Queue.tail is not Write-Write Stable with respect to Node.value (case A.2)
// 7949.1-7949.156: (21.5): Queue.tail is not Write-Write Stable with respect to Node.value (case A.3)
// 8069.1-8069.140: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case C)
// 8194.1-8194.144: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case D)
// 8195.1-8195.144: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case R)
// 8282.1-8282.136: (3.5): Node.value is not Read-Write Stable with respect to Queue.tail (case F)
// 8283.1-8283.136: (3.5): Node.value is not Read-Write Stable with respect to Queue.tail (case H)
// 8284.1-8284.144: (3.5): Node.value is not Read-Write Stable with respect to Queue.tail (case I)
// 8370.1-8370.136: (21.5): Queue.tail is not Write-Read Stable with respect to Node.value (case J)
// 8371.1-8371.136: (21.5): Queue.tail is not Write-Read Stable with respect to Node.value (case K)
// 8372.1-8372.99: (21.5): Queue.tail is not Write-Read Stable with respect to Node.value (case L)
// 8460.1-8460.140: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case A.1)
// 8461.1-8461.101: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case A.2)
// 8462.1-8462.158: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case A.3)
// 8582.1-8582.140: (5.5): Node.next is not Write-Write Stable with respect to Node.value (case C)
// 8707.1-8707.144: (5.5): Node.next is not Write-Write Stable with respect to Node.value (case D)
// 8708.1-8708.144: (5.5): Node.next is not Write-Write Stable with respect to Node.value (case R)
// 8795.1-8795.136: (5.5): Node.next is not Read-Write Stable with respect to Node.value (case F)
// 8796.1-8796.136: (5.5): Node.next is not Read-Write Stable with respect to Node.value (case H)
// 8797.1-8797.146: (5.5): Node.next is not Read-Write Stable with respect to Node.value (case I)
// 8883.1-8883.136: (3.5): Node.value is not Write-Read Stable with respect to Node.next (case J)
// 8884.1-8884.136: (3.5): Node.value is not Write-Read Stable with respect to Node.next (case K)
// 8885.1-8885.99: (3.5): Node.value is not Write-Read Stable with respect to Node.next (case L)
// 9015.1-9015.142: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case M)
// 9143.1-9143.130: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case N)
// 9232.1-9232.140: (5.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
// 9233.1-9233.101: (5.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
// 9234.1-9234.158: (5.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
// 9354.1-9354.140: (5.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
// 9479.1-9479.144: (5.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
// 9480.1-9480.144: (5.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
// 9567.1-9567.136: (5.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
// 9568.1-9568.136: (5.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
// 9569.1-9569.146: (5.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
// 9655.1-9655.136: (5.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
// 9656.1-9656.136: (5.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
// 9657.1-9657.99: (5.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
// 9787.1-9787.142: (5.5): Node.next is not Write-Write Stable with respect to Node.next (case M)
// 9915.1-9915.130: (5.5): Node.next is not Write-Write Stable with respect to Node.next (case N)
// 10004.1-10004.140: (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case A.1)
// 10005.1-10005.101: (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case A.2)
// 10006.1-10006.156: (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case A.3)
// 10126.1-10126.140: (5.5): Node.next is not Write-Write Stable with respect to Queue.head (case C)
// 10251.1-10251.144: (5.5): Node.next is not Write-Write Stable with respect to Queue.head (case D)
// 10252.1-10252.144: (5.5): Node.next is not Write-Write Stable with respect to Queue.head (case R)
// 10339.1-10339.136: (5.5): Node.next is not Read-Write Stable with respect to Queue.head (case F)
// 10340.1-10340.136: (5.5): Node.next is not Read-Write Stable with respect to Queue.head (case H)
// 10341.1-10341.144: (5.5): Node.next is not Read-Write Stable with respect to Queue.head (case I)
// 10427.1-10427.136: (20.5): Queue.head is not Write-Read Stable with respect to Node.next (case J)
// 10428.1-10428.136: (20.5): Queue.head is not Write-Read Stable with respect to Node.next (case K)
// 10429.1-10429.99: (20.5): Queue.head is not Write-Read Stable with respect to Node.next (case L)
// 10559.1-10559.142: (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case M)
// 10687.1-10687.130: (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case N)
// 10776.1-10776.140: (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case A.1)
// 10777.1-10777.101: (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case A.2)
// 10778.1-10778.156: (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case A.3)
// 10898.1-10898.140: (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case C)
// 11023.1-11023.144: (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case D)
// 11024.1-11024.144: (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case R)
// 11111.1-11111.136: (5.5): Node.next is not Read-Write Stable with respect to Queue.tail (case F)
// 11112.1-11112.136: (5.5): Node.next is not Read-Write Stable with respect to Queue.tail (case H)
// 11113.1-11113.144: (5.5): Node.next is not Read-Write Stable with respect to Queue.tail (case I)
// 11199.1-11199.136: (21.5): Queue.tail is not Write-Read Stable with respect to Node.next (case J)
// 11200.1-11200.136: (21.5): Queue.tail is not Write-Read Stable with respect to Node.next (case K)
// 11201.1-11201.99: (21.5): Queue.tail is not Write-Read Stable with respect to Node.next (case L)
// 11331.1-11331.142: (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case M)
// 11459.1-11459.130: (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case N)
// 11548.1-11548.140: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case A.1)
// 11549.1-11549.101: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case A.2)
// 11550.1-11550.156: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case A.3)
// 11670.1-11670.140: (20.5): Queue.head is not Write-Write Stable with respect to Node.value (case C)
// 11795.1-11795.144: (20.5): Queue.head is not Write-Write Stable with respect to Node.value (case D)
// 11796.1-11796.144: (20.5): Queue.head is not Write-Write Stable with respect to Node.value (case R)
// 11883.1-11883.136: (20.5): Queue.head is not Read-Write Stable with respect to Node.value (case F)
// 11884.1-11884.136: (20.5): Queue.head is not Read-Write Stable with respect to Node.value (case H)
// 11885.1-11885.144: (20.5): Queue.head is not Read-Write Stable with respect to Node.value (case I)
// 11971.1-11971.136: (3.5): Node.value is not Write-Read Stable with respect to Queue.head (case J)
// 11972.1-11972.136: (3.5): Node.value is not Write-Read Stable with respect to Queue.head (case K)
// 11973.1-11973.99: (3.5): Node.value is not Write-Read Stable with respect to Queue.head (case L)
// 12061.1-12061.140: (5.5): Node.next is not Write-Write Stable with respect to Queue.head (case A.1)
// 12062.1-12062.101: (5.5): Node.next is not Write-Write Stable with respect to Queue.head (case A.2)
// 12063.1-12063.156: (5.5): Node.next is not Write-Write Stable with respect to Queue.head (case A.3)
// 12183.1-12183.140: (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case C)
// 12308.1-12308.144: (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case D)
// 12309.1-12309.144: (20.5): Queue.head is not Write-Write Stable with respect to Node.next (case R)
// 12396.1-12396.136: (20.5): Queue.head is not Read-Write Stable with respect to Node.next (case F)
// 12397.1-12397.136: (20.5): Queue.head is not Read-Write Stable with respect to Node.next (case H)
// 12398.1-12398.144: (20.5): Queue.head is not Read-Write Stable with respect to Node.next (case I)
// 12484.1-12484.136: (5.5): Node.next is not Write-Read Stable with respect to Queue.head (case J)
// 12485.1-12485.136: (5.5): Node.next is not Write-Read Stable with respect to Queue.head (case K)
// 12486.1-12486.99: (5.5): Node.next is not Write-Read Stable with respect to Queue.head (case L)
// 12574.1-12574.140: (20.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.1)
// 12575.1-12575.101: (20.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.2)
// 12576.1-12576.158: (20.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.3)
// 12696.1-12696.140: (20.5): Queue.head is not Write-Write Stable with respect to Queue.head (case C)
// 12821.1-12821.144: (20.5): Queue.head is not Write-Write Stable with respect to Queue.head (case D)
// 12822.1-12822.144: (20.5): Queue.head is not Write-Write Stable with respect to Queue.head (case R)
// 12909.1-12909.136: (20.5): Queue.head is not Read-Write Stable with respect to Queue.head (case F)
// 12910.1-12910.136: (20.5): Queue.head is not Read-Write Stable with respect to Queue.head (case H)
// 12911.1-12911.146: (20.5): Queue.head is not Read-Write Stable with respect to Queue.head (case I)
// 12997.1-12997.136: (20.5): Queue.head is not Write-Read Stable with respect to Queue.head (case J)
// 12998.1-12998.136: (20.5): Queue.head is not Write-Read Stable with respect to Queue.head (case K)
// 12999.1-12999.99: (20.5): Queue.head is not Write-Read Stable with respect to Queue.head (case L)
// 13087.1-13087.140: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.1)
// 13088.1-13088.101: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.2)
// 13089.1-13089.158: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.3)
// 13209.1-13209.140: (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case C)
// 13334.1-13334.144: (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case D)
// 13335.1-13335.144: (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case R)
// 13422.1-13422.136: (20.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case F)
// 13423.1-13423.136: (20.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case H)
// 13424.1-13424.146: (20.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case I)
// 13510.1-13510.136: (21.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case J)
// 13511.1-13511.136: (21.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case K)
// 13512.1-13512.99: (21.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case L)
// 13600.1-13600.140: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case A.1)
// 13601.1-13601.101: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case A.2)
// 13602.1-13602.156: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case A.3)
// 13722.1-13722.140: (21.5): Queue.tail is not Write-Write Stable with respect to Node.value (case C)
// 13847.1-13847.144: (21.5): Queue.tail is not Write-Write Stable with respect to Node.value (case D)
// 13848.1-13848.144: (21.5): Queue.tail is not Write-Write Stable with respect to Node.value (case R)
// 13935.1-13935.136: (21.5): Queue.tail is not Read-Write Stable with respect to Node.value (case F)
// 13936.1-13936.136: (21.5): Queue.tail is not Read-Write Stable with respect to Node.value (case H)
// 13937.1-13937.144: (21.5): Queue.tail is not Read-Write Stable with respect to Node.value (case I)
// 14023.1-14023.136: (3.5): Node.value is not Write-Read Stable with respect to Queue.tail (case J)
// 14024.1-14024.136: (3.5): Node.value is not Write-Read Stable with respect to Queue.tail (case K)
// 14025.1-14025.99: (3.5): Node.value is not Write-Read Stable with respect to Queue.tail (case L)
// 14155.1-14155.142: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case M)
// 14283.1-14283.130: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case N)
// 14372.1-14372.140: (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case A.1)
// 14373.1-14373.101: (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case A.2)
// 14374.1-14374.156: (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case A.3)
// 14494.1-14494.140: (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case C)
// 14619.1-14619.144: (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case D)
// 14620.1-14620.144: (21.5): Queue.tail is not Write-Write Stable with respect to Node.next (case R)
// 14707.1-14707.136: (21.5): Queue.tail is not Read-Write Stable with respect to Node.next (case F)
// 14708.1-14708.136: (21.5): Queue.tail is not Read-Write Stable with respect to Node.next (case H)
// 14709.1-14709.144: (21.5): Queue.tail is not Read-Write Stable with respect to Node.next (case I)
// 14795.1-14795.136: (5.5): Node.next is not Write-Read Stable with respect to Queue.tail (case J)
// 14796.1-14796.136: (5.5): Node.next is not Write-Read Stable with respect to Queue.tail (case K)
// 14797.1-14797.99: (5.5): Node.next is not Write-Read Stable with respect to Queue.tail (case L)
// 14927.1-14927.142: (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case M)
// 15055.1-15055.130: (5.5): Node.next is not Write-Write Stable with respect to Queue.tail (case N)
// 15144.1-15144.140: (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.1)
// 15145.1-15145.101: (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.2)
// 15146.1-15146.158: (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.3)
// 15266.1-15266.140: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case C)
// 15391.1-15391.144: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case D)
// 15392.1-15392.144: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case R)
// 15479.1-15479.136: (21.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case F)
// 15480.1-15480.136: (21.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case H)
// 15481.1-15481.146: (21.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case I)
// 15567.1-15567.136: (20.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case J)
// 15568.1-15568.136: (20.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case K)
// 15569.1-15569.99: (20.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case L)
// 15699.1-15699.142: (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case M)
// 15827.1-15827.130: (20.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case N)
// 15916.1-15916.140: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.1)
// 15917.1-15917.101: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.2)
// 15918.1-15918.158: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.3)
// 16038.1-16038.140: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case C)
// 16163.1-16163.144: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case D)
// 16164.1-16164.144: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case R)
// 16251.1-16251.136: (21.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case F)
// 16252.1-16252.136: (21.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case H)
// 16253.1-16253.146: (21.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case I)
// 16339.1-16339.136: (21.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case J)
// 16340.1-16340.136: (21.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case K)
// 16341.1-16341.99: (21.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case L)
// 16471.1-16471.142: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case M)
// 16599.1-16599.130: (21.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case N)
// 16607.1-16607.336: (<undefined position>): Object invariant may not hold.
// 16608.1-16608.336: (<undefined position>): Object invariant may not hold.
// 16623.1-16623.335: (<undefined position>): Object invariant may not hold.
// 16624.1-16624.335: (<undefined position>): Object invariant may not hold.
// 16644.1-16672.2: (3.5): yields_as clause for Node.value is not valid
// 16677.1-16700.2: (3.5): yields_as clause for Node.value is not reflexive
// 16706.1-16706.336: (3.25): Object invariant may not hold.
// 16707.1-16707.336: (3.25): Object invariant may not hold.
// 16708.1-16754.2: (3.5): yields_as clause for Node.value is not transitive
// 16774.1-16802.2: (10.28): yields_as clause for Node.next is not valid
// 16807.1-16830.2: (10.28): yields_as clause for Node.next is not reflexive
// 16836.1-16836.336: (5.40): Object invariant may not hold.
// 16837.1-16837.336: (5.40): Object invariant may not hold.
// 16838.1-16884.2: (10.28): yields_as clause for Node.next is not transitive
// 16892.1-16892.336: (5.40): Object invariant may not hold.
// 16893.1-16893.336: (5.40): Object invariant may not hold.
// 16894.1-16942.2: (10.28): Node.next is not ABA-free
// 16962.1-16990.2: (7.32): yields_as clause for Node._lock is not valid
// 16995.1-17018.2: (7.32): yields_as clause for Node._lock is not reflexive
// 17024.1-17024.336: (2.1): Object invariant may not hold.
// 17025.1-17025.336: (2.1): Object invariant may not hold.
// 17026.1-17072.2: (7.32): yields_as clause for Node._lock is not transitive
// 17119.1-17147.2: (20.5): yields_as clause for Queue.head is not valid
// 17152.1-17175.2: (20.5): yields_as clause for Queue.head is not reflexive
// 17181.1-17181.336: (20.33): Object invariant may not hold.
// 17182.1-17182.336: (20.33): Object invariant may not hold.
// 17183.1-17229.2: (20.5): yields_as clause for Queue.head is not transitive
// 17248.1-17276.2: (21.5): yields_as clause for Queue.tail is not valid
// 17281.1-17304.2: (21.5): yields_as clause for Queue.tail is not reflexive
// 17310.1-17310.336: (21.33): Object invariant may not hold.
// 17311.1-17311.336: (21.33): Object invariant may not hold.
// 17312.1-17358.2: (21.5): yields_as clause for Queue.tail is not transitive
// 17378.1-17406.2: (7.32): yields_as clause for Queue._lock is not valid
// 17411.1-17434.2: (7.32): yields_as clause for Queue._lock is not reflexive
// 17440.1-17440.336: (18.1): Object invariant may not hold.
// 17441.1-17441.336: (18.1): Object invariant may not hold.
// 17442.1-17488.2: (7.32): yields_as clause for Queue._lock is not transitive
