                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/queue-no-mod-v1.anchor:                 
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Queue {                                                                                   
      array T = int[isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E]                                                                  
                                                                                                    
       [Queue.T{this}] elems isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      volatile int head isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      volatile int tail isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      volatile Seq<int> spec isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      invariant  0 <= this.head && this.head <= this.tail && this.tail <= this.elems.length;        
      invariant  this.tail - this.head == SeqLen<int>(this.spec);                                   
      invariant  forall int i ::0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i];
                                                                                                    
      requires this.elems == [Queue.T{this}].null;                                                  
      {                                                                                             
        ensures this.spec == SeqEmpty<int>();                                                       
      }                                                                                             
      public void init() {                                                                          
        assume this.elems == [Queue.T{this}].null;                                                  
        assume this.head == 0;                                                                      
        assume this.tail == 0;                                                                      
        assume this.spec == SeqEmpty;                                                               
        {                                                                                           
          Seq<int> tmp1;                                                                            
          tmp1 = SeqEmpty<int>();                                                                   
          this.spec := tmp1;                                                                        
          int tmp2;                                                                                 
          tmp2 = 0;                                                                                 
          this.head := tmp2;                                                                        
          int tmp3;                                                                                 
          tmp3 = 0;                                                                                 
          this.tail := tmp3;                                                                        
          [Queue.T{this}] tmp4;                                                                     
          tmp4 = new [Queue.T{this}](512);                                                          
          this.elems := tmp4;                                                                       
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public int dequeue() {                                                                        
        synchronized (this) {                                                                       
          bool tmp5;                                                                                
          int tmp6;                                                                                 
          int tmp7;                                                                                 
          tmp7 := this.tail;                                                                        
          int tmp8;                                                                                 
          tmp8 := this.head;                                                                        
          tmp6 = tmp7 - tmp8;                                                                       
          tmp5 = tmp6 > 0;                                                                          
          if (tmp5 /* == this.tail - this.head > 0 */) {                                            
            int result;                                                                             
            [Queue.T{this}] tmp9;                                                                   
            tmp9 := this.elems;                                                                     
            int tmp10;                                                                              
            tmp10 := this.head;                                                                     
            result := tmp9[tmp10];                                                                  
            Seq<int> o;                                                                             
            Seq<int> tmp11;                                                                         
            tmp11 := this.spec;                                                                     
            int tmp12;                                                                              
            int tmp13;                                                                              
            Seq<int> tmp14;                                                                         
            tmp14 := this.spec;                                                                     
            tmp13 = SeqLen<int>(tmp14);                                                             
            tmp12 = tmp13 - 1;                                                                      
            o = SeqExtract<int>(tmp11,1,tmp12);                                                     
            int i;                                                                                  
            bool tmp15;                                                                             
            bool tmp16;                                                                             
            bool tmp17;                                                                             
            tmp17 = 0 <= i;                                                                         
            if (tmp17) {                                                                            
              int tmp18;                                                                            
              Seq<int> tmp19;                                                                       
              tmp19 := this.spec;                                                                   
              tmp18 = SeqLen<int>(tmp19);                                                           
              tmp16 = i < tmp18;                                                                    
            } else {                                                                                
                                                                                                    
            }                                                                                       
            bool tmp20;                                                                             
            int tmp21;                                                                              
            Seq<int> tmp22;                                                                         
            tmp22 := this.spec;                                                                     
            tmp21 = SeqNth<int>(tmp22,i);                                                           
            [Queue.T{this}] tmp23;                                                                  
            tmp23 := this.elems;                                                                    
            int tmp24;                                                                              
            int tmp25;                                                                              
            tmp25 := this.head;                                                                     
            tmp24 = tmp25 + i;                                                                      
            int tmp26;                                                                              
            tmp26 := tmp23[tmp24];                                                                  
            tmp20 = tmp21 == tmp26;                                                                 
            tmp15 = tmp16 ==> tmp20;                                                                
            assert tmp15 /* == 0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i] */;
            bool tmp27;                                                                             
            bool tmp28;                                                                             
            bool tmp29;                                                                             
            tmp29 = 0 <= i;                                                                         
            if (tmp29) {                                                                            
              int tmp30;                                                                            
              tmp30 = SeqLen<int>(o);                                                               
              tmp28 = i < tmp30;                                                                    
            } else {                                                                                
                                                                                                    
            }                                                                                       
            bool tmp31;                                                                             
            int tmp32;                                                                              
            tmp32 = SeqNth<int>(o,i);                                                               
            int tmp33;                                                                              
            Seq<int> tmp34;                                                                         
            tmp34 := this.spec;                                                                     
            int tmp35;                                                                              
            tmp35 = i + 1;                                                                          
            tmp33 = SeqNth<int>(tmp34,tmp35);                                                       
            tmp31 = tmp32 == tmp33;                                                                 
            tmp27 = tmp28 ==> tmp31;                                                                
            assert tmp27 /* == 0 <= i && i < SeqLen<int>(o) ==> SeqNth<int>(o,i) == SeqNth<int>(this.spec,i + 1) */;
            bool tmp36;                                                                             
            bool tmp37;                                                                             
            bool tmp38;                                                                             
            tmp38 = 0 <= i;                                                                         
            if (tmp38) {                                                                            
              int tmp39;                                                                            
              tmp39 = SeqLen<int>(o);                                                               
              tmp37 = i < tmp39;                                                                    
            } else {                                                                                
                                                                                                    
            }                                                                                       
            bool tmp40;                                                                             
            int tmp41;                                                                              
            tmp41 = SeqNth<int>(o,i);                                                               
            [Queue.T{this}] tmp42;                                                                  
            tmp42 := this.elems;                                                                    
            int tmp43;                                                                              
            int tmp44;                                                                              
            int tmp45;                                                                              
            tmp45 := this.head;                                                                     
            tmp44 = tmp45 + 1;                                                                      
            tmp43 = tmp44 + i;                                                                      
            int tmp46;                                                                              
            tmp46 := tmp42[tmp43];                                                                  
            tmp40 = tmp41 == tmp46;                                                                 
            tmp36 = tmp37 ==> tmp40;                                                                
            assert tmp36 /* == 0 <= i && i < SeqLen<int>(o) ==> SeqNth<int>(o,i) == this.elems[this.head + 1 + i] */;
            int tmp47;                                                                              
            int tmp48;                                                                              
            tmp48 := this.head;                                                                     
            tmp47 = tmp48 + 1;                                                                      
            this.head := tmp47;                                                                     
            this.spec := o;                                                                         
            bool tmp49;                                                                             
            bool tmp50;                                                                             
            bool tmp51;                                                                             
            tmp51 = 0 <= i;                                                                         
            if (tmp51) {                                                                            
              int tmp52;                                                                            
              Seq<int> tmp53;                                                                       
              tmp53 := this.spec;                                                                   
              tmp52 = SeqLen<int>(tmp53);                                                           
              tmp50 = i < tmp52;                                                                    
            } else {                                                                                
                                                                                                    
            }                                                                                       
            bool tmp54;                                                                             
            int tmp55;                                                                              
            Seq<int> tmp56;                                                                         
            tmp56 := this.spec;                                                                     
            tmp55 = SeqNth<int>(tmp56,i);                                                           
            [Queue.T{this}] tmp57;                                                                  
            tmp57 := this.elems;                                                                    
            int tmp58;                                                                              
            int tmp59;                                                                              
            tmp59 := this.head;                                                                     
            tmp58 = tmp59 + i;                                                                      
            int tmp60;                                                                              
            tmp60 := tmp57[tmp58];                                                                  
            tmp54 = tmp55 == tmp60;                                                                 
            tmp49 = tmp50 ==> tmp54;                                                                
            assert tmp49 /* == 0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i] */;
             return result;                                                                         
          } else {                                                                                  
             return 0;                                                                              
          }                                                                                         
        }                                                                                           
        // return -1;                                                                               
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Queue {                                                                                   
      array T = int[isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E]                                                                  
                                                                                                    
       [Queue.T{this}] elems isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      volatile int head isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      volatile int tail isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      volatile Seq<int> spec isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  0 <= this.head && this.head <= this.tail && this.tail <= this.elems.length;        
      invariant  this.tail - this.head == SeqLen<int>(this.spec);                                   
      invariant  forall int i ::0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i];
                                                                                                    
      requires this.elems == [Queue.T{this}].null;                                                  
      {                                                                                             
        ensures this.spec == SeqEmpty<int>();                                                       
      }                                                                                             
      public void init() {                                                                          
        assume this.elems == [Queue.T{this}].null;                                                  
        assume this.head == 0;                                                                      
        assume this.tail == 0;                                                                      
        assume this.spec == SeqEmpty;                                                               
        {                                                                                           
          Seq<int> tmp1;                                                                            
          tmp1 = SeqEmpty<int>();                                                                   
          this.spec := tmp1;                                                                        
          int tmp2;                                                                                 
          tmp2 = 0;                                                                                 
          this.head := tmp2;                                                                        
          int tmp3;                                                                                 
          tmp3 = 0;                                                                                 
          this.tail := tmp3;                                                                        
          [Queue.T{this}] tmp4;                                                                     
          tmp4 = new [Queue.T{this}](512);                                                          
          this.elems := tmp4;                                                                       
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public int dequeue() {                                                                        
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            bool tmp5;                                                                              
            int tmp6;                                                                               
            int tmp7;                                                                               
            tmp7 := this.tail;                                                                      
            int tmp8;                                                                               
            tmp8 := this.head;                                                                      
            tmp6 = tmp7 - tmp8;                                                                     
            tmp5 = tmp6 > 0;                                                                        
            if (tmp5 /* == this.tail - this.head > 0 */) {                                          
              int result;                                                                           
              [Queue.T{this}] tmp9;                                                                 
              tmp9 := this.elems;                                                                   
              int tmp10;                                                                            
              tmp10 := this.head;                                                                   
              result := tmp9[tmp10];                                                                
              Seq<int> o;                                                                           
              Seq<int> tmp11;                                                                       
              tmp11 := this.spec;                                                                   
              int tmp12;                                                                            
              int tmp13;                                                                            
              Seq<int> tmp14;                                                                       
              tmp14 := this.spec;                                                                   
              tmp13 = SeqLen<int>(tmp14);                                                           
              tmp12 = tmp13 - 1;                                                                    
              o = SeqExtract<int>(tmp11,1,tmp12);                                                   
              int i;                                                                                
              bool tmp15;                                                                           
              bool tmp16;                                                                           
              bool tmp17;                                                                           
              tmp17 = 0 <= i;                                                                       
              if (tmp17) {                                                                          
                int tmp18;                                                                          
                Seq<int> tmp19;                                                                     
                tmp19 := this.spec;                                                                 
                tmp18 = SeqLen<int>(tmp19);                                                         
                tmp16 = i < tmp18;                                                                  
              } else {                                                                              
                                                                                                    
              }                                                                                     
              bool tmp20;                                                                           
              int tmp21;                                                                            
              Seq<int> tmp22;                                                                       
              tmp22 := this.spec;                                                                   
              tmp21 = SeqNth<int>(tmp22,i);                                                         
              [Queue.T{this}] tmp23;                                                                
              tmp23 := this.elems;                                                                  
              int tmp24;                                                                            
              int tmp25;                                                                            
              tmp25 := this.head;                                                                   
              tmp24 = tmp25 + i;                                                                    
              int tmp26;                                                                            
              tmp26 := tmp23[tmp24];                                                                
              tmp20 = tmp21 == tmp26;                                                               
              tmp15 = tmp16 ==> tmp20;                                                              
              assert tmp15 /* == 0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i] */;
              bool tmp27;                                                                           
              bool tmp28;                                                                           
              bool tmp29;                                                                           
              tmp29 = 0 <= i;                                                                       
              if (tmp29) {                                                                          
                int tmp30;                                                                          
                tmp30 = SeqLen<int>(o);                                                             
                tmp28 = i < tmp30;                                                                  
              } else {                                                                              
                                                                                                    
              }                                                                                     
              bool tmp31;                                                                           
              int tmp32;                                                                            
              tmp32 = SeqNth<int>(o,i);                                                             
              int tmp33;                                                                            
              Seq<int> tmp34;                                                                       
              tmp34 := this.spec;                                                                   
              int tmp35;                                                                            
              tmp35 = i + 1;                                                                        
              tmp33 = SeqNth<int>(tmp34,tmp35);                                                     
              tmp31 = tmp32 == tmp33;                                                               
              tmp27 = tmp28 ==> tmp31;                                                              
              assert tmp27 /* == 0 <= i && i < SeqLen<int>(o) ==> SeqNth<int>(o,i) == SeqNth<int>(this.spec,i + 1) */;
              bool tmp36;                                                                           
              bool tmp37;                                                                           
              bool tmp38;                                                                           
              tmp38 = 0 <= i;                                                                       
              if (tmp38) {                                                                          
                int tmp39;                                                                          
                tmp39 = SeqLen<int>(o);                                                             
                tmp37 = i < tmp39;                                                                  
              } else {                                                                              
                                                                                                    
              }                                                                                     
              bool tmp40;                                                                           
              int tmp41;                                                                            
              tmp41 = SeqNth<int>(o,i);                                                             
              [Queue.T{this}] tmp42;                                                                
              tmp42 := this.elems;                                                                  
              int tmp43;                                                                            
              int tmp44;                                                                            
              int tmp45;                                                                            
              tmp45 := this.head;                                                                   
              tmp44 = tmp45 + 1;                                                                    
              tmp43 = tmp44 + i;                                                                    
              int tmp46;                                                                            
              tmp46 := tmp42[tmp43];                                                                
              tmp40 = tmp41 == tmp46;                                                               
              tmp36 = tmp37 ==> tmp40;                                                              
              assert tmp36 /* == 0 <= i && i < SeqLen<int>(o) ==> SeqNth<int>(o,i) == this.elems[this.head + 1 + i] */;
              int tmp47;                                                                            
              int tmp48;                                                                            
              tmp48 := this.head;                                                                   
              tmp47 = tmp48 + 1;                                                                    
              this.head := tmp47;                                                                   
              this.spec := o;                                                                       
              bool tmp49;                                                                           
              bool tmp50;                                                                           
              bool tmp51;                                                                           
              tmp51 = 0 <= i;                                                                       
              if (tmp51) {                                                                          
                int tmp52;                                                                          
                Seq<int> tmp53;                                                                     
                tmp53 := this.spec;                                                                 
                tmp52 = SeqLen<int>(tmp53);                                                         
                tmp50 = i < tmp52;                                                                  
              } else {                                                                              
                                                                                                    
              }                                                                                     
              bool tmp54;                                                                           
              int tmp55;                                                                            
              Seq<int> tmp56;                                                                       
              tmp56 := this.spec;                                                                   
              tmp55 = SeqNth<int>(tmp56,i);                                                         
              [Queue.T{this}] tmp57;                                                                
              tmp57 := this.elems;                                                                  
              int tmp58;                                                                            
              int tmp59;                                                                            
              tmp59 := this.head;                                                                   
              tmp58 = tmp59 + i;                                                                    
              int tmp60;                                                                            
              tmp60 := tmp57[tmp58];                                                                
              tmp54 = tmp55 == tmp60;                                                               
              tmp49 = tmp50 ==> tmp54;                                                              
              assert tmp49 /* == 0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i] */;
              {                                                                                     
                release(this);                                                                      
                 return result;                                                                     
              }                                                                                     
            } else {                                                                                
              {                                                                                     
                release(this);                                                                      
                 return 0;                                                                          
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Queue {                                                                                   
      array T = int[isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E]                                                                  
                                                                                                    
       [Queue.T{this}] elems isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      volatile int head isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      volatile int tail isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      volatile Seq<int> spec isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  0 <= this.head && this.head <= this.tail && this.tail <= this.elems.length;        
      invariant  this.tail - this.head == SeqLen<int>(this.spec);                                   
      invariant  forall int i ::0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i];
                                                                                                    
      requires this.elems == [Queue.T{this}].null;                                                  
      {                                                                                             
        ensures this.spec == SeqEmpty<int>();                                                       
      }                                                                                             
      public void init() {                                                                          
        assume this.elems == [Queue.T{this}].null;                                                  
        assume this.head == 0;                                                                      
        assume this.tail == 0;                                                                      
        assume this.spec == SeqEmpty;                                                               
        {                                                                                           
          Seq<int> tmp1;                                                                            
          tmp1 = SeqEmpty<int>();                                                                   
          this.spec := tmp1;                                                                        
          int tmp2;                                                                                 
          tmp2 = 0;                                                                                 
          this.head := tmp2;                                                                        
          int tmp3;                                                                                 
          tmp3 = 0;                                                                                 
          this.tail := tmp3;                                                                        
          [Queue.T{this}] tmp4;                                                                     
          tmp4 = new [Queue.T{this}](512);                                                          
          this.elems := tmp4;                                                                       
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public int dequeue() {                                                                        
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            bool tmp5;                                                                              
            int tmp6;                                                                               
            int tmp7;                                                                               
            tmp7 := this.tail;                                                                      
            int tmp8;                                                                               
            tmp8 := this.head;                                                                      
            tmp6 = tmp7 - tmp8;                                                                     
            tmp5 = tmp6 > 0;                                                                        
            if (tmp5 /* == this.tail - this.head > 0 */) {                                          
              int result;                                                                           
              [Queue.T{this}] tmp9;                                                                 
              tmp9 := this.elems;                                                                   
              int tmp10;                                                                            
              tmp10 := this.head;                                                                   
              result := tmp9[tmp10];                                                                
              Seq<int> o;                                                                           
              Seq<int> tmp11;                                                                       
              tmp11 := this.spec;                                                                   
              int tmp12;                                                                            
              int tmp13;                                                                            
              Seq<int> tmp14;                                                                       
              tmp14 := this.spec;                                                                   
              tmp13 = SeqLen<int>(tmp14);                                                           
              tmp12 = tmp13 - 1;                                                                    
              o = SeqExtract<int>(tmp11,1,tmp12);                                                   
              int i;                                                                                
              bool tmp15;                                                                           
              bool tmp16;                                                                           
              bool tmp17;                                                                           
              tmp17 = 0 <= i;                                                                       
              if (tmp17) {                                                                          
                int tmp18;                                                                          
                Seq<int> tmp19;                                                                     
                tmp19 := this.spec;                                                                 
                tmp18 = SeqLen<int>(tmp19);                                                         
                tmp16 = i < tmp18;                                                                  
              } else {                                                                              
                                                                                                    
              }                                                                                     
              bool tmp20;                                                                           
              int tmp21;                                                                            
              Seq<int> tmp22;                                                                       
              tmp22 := this.spec;                                                                   
              tmp21 = SeqNth<int>(tmp22,i);                                                         
              [Queue.T{this}] tmp23;                                                                
              tmp23 := this.elems;                                                                  
              int tmp24;                                                                            
              int tmp25;                                                                            
              tmp25 := this.head;                                                                   
              tmp24 = tmp25 + i;                                                                    
              int tmp26;                                                                            
              tmp26 := tmp23[tmp24];                                                                
              tmp20 = tmp21 == tmp26;                                                               
              tmp15 = tmp16 ==> tmp20;                                                              
              assert tmp15 /* == 0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i] */;
              bool tmp27;                                                                           
              bool tmp28;                                                                           
              bool tmp29;                                                                           
              tmp29 = 0 <= i;                                                                       
              if (tmp29) {                                                                          
                int tmp30;                                                                          
                tmp30 = SeqLen<int>(o);                                                             
                tmp28 = i < tmp30;                                                                  
              } else {                                                                              
                                                                                                    
              }                                                                                     
              bool tmp31;                                                                           
              int tmp32;                                                                            
              tmp32 = SeqNth<int>(o,i);                                                             
              int tmp33;                                                                            
              Seq<int> tmp34;                                                                       
              tmp34 := this.spec;                                                                   
              int tmp35;                                                                            
              tmp35 = i + 1;                                                                        
              tmp33 = SeqNth<int>(tmp34,tmp35);                                                     
              tmp31 = tmp32 == tmp33;                                                               
              tmp27 = tmp28 ==> tmp31;                                                              
              assert tmp27 /* == 0 <= i && i < SeqLen<int>(o) ==> SeqNth<int>(o,i) == SeqNth<int>(this.spec,i + 1) */;
              bool tmp36;                                                                           
              bool tmp37;                                                                           
              bool tmp38;                                                                           
              tmp38 = 0 <= i;                                                                       
              if (tmp38) {                                                                          
                int tmp39;                                                                          
                tmp39 = SeqLen<int>(o);                                                             
                tmp37 = i < tmp39;                                                                  
              } else {                                                                              
                                                                                                    
              }                                                                                     
              bool tmp40;                                                                           
              int tmp41;                                                                            
              tmp41 = SeqNth<int>(o,i);                                                             
              [Queue.T{this}] tmp42;                                                                
              tmp42 := this.elems;                                                                  
              int tmp43;                                                                            
              int tmp44;                                                                            
              int tmp45;                                                                            
              tmp45 := this.head;                                                                   
              tmp44 = tmp45 + 1;                                                                    
              tmp43 = tmp44 + i;                                                                    
              int tmp46;                                                                            
              tmp46 := tmp42[tmp43];                                                                
              tmp40 = tmp41 == tmp46;                                                               
              tmp36 = tmp37 ==> tmp40;                                                              
              assert tmp36 /* == 0 <= i && i < SeqLen<int>(o) ==> SeqNth<int>(o,i) == this.elems[this.head + 1 + i] */;
              int tmp47;                                                                            
              int tmp48;                                                                            
              tmp48 := this.head;                                                                   
              tmp47 = tmp48 + 1;                                                                    
              this.head := tmp47;                                                                   
              this.spec := o;                                                                       
              bool tmp49;                                                                           
              bool tmp50;                                                                           
              bool tmp51;                                                                           
              tmp51 = 0 <= i;                                                                       
              if (tmp51) {                                                                          
                int tmp52;                                                                          
                Seq<int> tmp53;                                                                     
                tmp53 := this.spec;                                                                 
                tmp52 = SeqLen<int>(tmp53);                                                         
                tmp50 = i < tmp52;                                                                  
              } else {                                                                              
                                                                                                    
              }                                                                                     
              bool tmp54;                                                                           
              int tmp55;                                                                            
              Seq<int> tmp56;                                                                       
              tmp56 := this.spec;                                                                   
              tmp55 = SeqNth<int>(tmp56,i);                                                         
              [Queue.T{this}] tmp57;                                                                
              tmp57 := this.elems;                                                                  
              int tmp58;                                                                            
              int tmp59;                                                                            
              tmp59 := this.head;                                                                   
              tmp58 = tmp59 + i;                                                                    
              int tmp60;                                                                            
              tmp60 := tmp57[tmp58];                                                                
              tmp54 = tmp55 == tmp60;                                                               
              tmp49 = tmp50 ==> tmp54;                                                              
              assert tmp49 /* == 0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i] */;
              {                                                                                     
                release(this);                                                                      
                 return result;                                                                     
              }                                                                                     
            } else {                                                                                
              {                                                                                     
                release(this);                                                                      
                 return 0;                                                                          
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Queue {                                                                                   
      array T = int[isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E]                                                                  
                                                                                                    
       [Queue.T{this}] elems isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      volatile int head isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      volatile int tail isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      volatile Seq<int> spec isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  0 <= this.head && this.head <= this.tail && this.tail <= this.elems.length;        
      invariant  this.tail - this.head == SeqLen<int>(this.spec);                                   
      invariant  forall int i ::0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i];
                                                                                                    
      requires this.elems == [Queue.T{this}].null;                                                  
      {                                                                                             
        ensures this.spec == SeqEmpty<int>();                                                       
      }                                                                                             
      public void init() {                                                                          
        assume this.elems == [Queue.T{this}].null;                                                  
        assume this.head == 0;                                                                      
        assume this.tail == 0;                                                                      
        assume this.spec == SeqEmpty;                                                               
        {                                                                                           
          Seq<int> tmp1;                                                                            
          tmp1 = SeqEmpty<int>();                                                                   
          this.spec := tmp1;                                                                        
          int tmp2;                                                                                 
          tmp2 = 0;                                                                                 
          this.head := tmp2;                                                                        
          int tmp3;                                                                                 
          tmp3 = 0;                                                                                 
          this.tail := tmp3;                                                                        
          [Queue.T{this}] tmp4;                                                                     
          tmp4 = new [Queue.T{this}](512);                                                          
          this.elems := tmp4;                                                                       
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public int dequeue() {                                                                        
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            bool tmp5;                                                                              
            int tmp6;                                                                               
            int tmp7;                                                                               
            tmp7 := this.tail;                                                                      
            int tmp8;                                                                               
            tmp8 := this.head;                                                                      
            tmp6 = tmp7 - tmp8;                                                                     
            tmp5 = tmp6 > 0;                                                                        
            if (tmp5 /* == this.tail - this.head > 0 */) {                                          
              int result;                                                                           
              [Queue.T{this}] tmp9;                                                                 
              tmp9 := this.elems;                                                                   
              int tmp10;                                                                            
              tmp10 := this.head;                                                                   
              result := tmp9[tmp10];                                                                
              Seq<int> o;                                                                           
              Seq<int> tmp11;                                                                       
              tmp11 := this.spec;                                                                   
              int tmp12;                                                                            
              int tmp13;                                                                            
              Seq<int> tmp14;                                                                       
              tmp14 := this.spec;                                                                   
              tmp13 = SeqLen<int>(tmp14);                                                           
              tmp12 = tmp13 - 1;                                                                    
              o = SeqExtract<int>(tmp11,1,tmp12);                                                   
              int i;                                                                                
              bool tmp15;                                                                           
              bool tmp16;                                                                           
              bool tmp17;                                                                           
              tmp17 = 0 <= i;                                                                       
              if (tmp17) {                                                                          
                int tmp18;                                                                          
                Seq<int> tmp19;                                                                     
                tmp19 := this.spec;                                                                 
                tmp18 = SeqLen<int>(tmp19);                                                         
                tmp16 = i < tmp18;                                                                  
              } else {                                                                              
                                                                                                    
              }                                                                                     
              bool tmp20;                                                                           
              int tmp21;                                                                            
              Seq<int> tmp22;                                                                       
              tmp22 := this.spec;                                                                   
              tmp21 = SeqNth<int>(tmp22,i);                                                         
              [Queue.T{this}] tmp23;                                                                
              tmp23 := this.elems;                                                                  
              int tmp24;                                                                            
              int tmp25;                                                                            
              tmp25 := this.head;                                                                   
              tmp24 = tmp25 + i;                                                                    
              int tmp26;                                                                            
              tmp26 := tmp23[tmp24];                                                                
              tmp20 = tmp21 == tmp26;                                                               
              tmp15 = tmp16 ==> tmp20;                                                              
              assert tmp15 /* == 0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i] */;
              bool tmp27;                                                                           
              bool tmp28;                                                                           
              bool tmp29;                                                                           
              tmp29 = 0 <= i;                                                                       
              if (tmp29) {                                                                          
                int tmp30;                                                                          
                tmp30 = SeqLen<int>(o);                                                             
                tmp28 = i < tmp30;                                                                  
              } else {                                                                              
                                                                                                    
              }                                                                                     
              bool tmp31;                                                                           
              int tmp32;                                                                            
              tmp32 = SeqNth<int>(o,i);                                                             
              int tmp33;                                                                            
              Seq<int> tmp34;                                                                       
              tmp34 := this.spec;                                                                   
              int tmp35;                                                                            
              tmp35 = i + 1;                                                                        
              tmp33 = SeqNth<int>(tmp34,tmp35);                                                     
              tmp31 = tmp32 == tmp33;                                                               
              tmp27 = tmp28 ==> tmp31;                                                              
              assert tmp27 /* == 0 <= i && i < SeqLen<int>(o) ==> SeqNth<int>(o,i) == SeqNth<int>(this.spec,i + 1) */;
              bool tmp36;                                                                           
              bool tmp37;                                                                           
              bool tmp38;                                                                           
              tmp38 = 0 <= i;                                                                       
              if (tmp38) {                                                                          
                int tmp39;                                                                          
                tmp39 = SeqLen<int>(o);                                                             
                tmp37 = i < tmp39;                                                                  
              } else {                                                                              
                                                                                                    
              }                                                                                     
              bool tmp40;                                                                           
              int tmp41;                                                                            
              tmp41 = SeqNth<int>(o,i);                                                             
              [Queue.T{this}] tmp42;                                                                
              tmp42 := this.elems;                                                                  
              int tmp43;                                                                            
              int tmp44;                                                                            
              int tmp45;                                                                            
              tmp45 := this.head;                                                                   
              tmp44 = tmp45 + 1;                                                                    
              tmp43 = tmp44 + i;                                                                    
              int tmp46;                                                                            
              tmp46 := tmp42[tmp43];                                                                
              tmp40 = tmp41 == tmp46;                                                               
              tmp36 = tmp37 ==> tmp40;                                                              
              assert tmp36 /* == 0 <= i && i < SeqLen<int>(o) ==> SeqNth<int>(o,i) == this.elems[this.head + 1 + i] */;
              int tmp47;                                                                            
              int tmp48;                                                                            
              tmp48 := this.head;                                                                   
              tmp47 = tmp48 + 1;                                                                    
              this.head := tmp47;                                                                   
              this.spec := o;                                                                       
              bool tmp49;                                                                           
              bool tmp50;                                                                           
              bool tmp51;                                                                           
              tmp51 = 0 <= i;                                                                       
              if (tmp51) {                                                                          
                int tmp52;                                                                          
                Seq<int> tmp53;                                                                     
                tmp53 := this.spec;                                                                 
                tmp52 = SeqLen<int>(tmp53);                                                         
                tmp50 = i < tmp52;                                                                  
              } else {                                                                              
                                                                                                    
              }                                                                                     
              bool tmp54;                                                                           
              int tmp55;                                                                            
              Seq<int> tmp56;                                                                       
              tmp56 := this.spec;                                                                   
              tmp55 = SeqNth<int>(tmp56,i);                                                         
              [Queue.T{this}] tmp57;                                                                
              tmp57 := this.elems;                                                                  
              int tmp58;                                                                            
              int tmp59;                                                                            
              tmp59 := this.head;                                                                   
              tmp58 = tmp59 + i;                                                                    
              int tmp60;                                                                            
              tmp60 := tmp57[tmp58];                                                                
              tmp54 = tmp55 == tmp60;                                                               
              tmp49 = tmp50 ==> tmp54;                                                              
              assert tmp49 /* == 0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i] */;
              {                                                                                     
                release(this);                                                                      
                 return result;                                                                     
              }                                                                                     
            } else {                                                                                
              {                                                                                     
                release(this);                                                                      
                 return 0;                                                                          
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Queue ***/                                                                          
                                                                                                    
type Queue;                                                                                         
const unique Queue.null: Queue;                                                                     
var Queue._state: [Queue]State;                                                                     
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.elems: [Queue]Array.Queue.T;                                                              
                                                                                                    
function {:inline} ReadEval.Queue.elems(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Array.Queue.T.null;                                                               
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.elems(tid: Tid,this : Queue,newValue: Array.Queue.T,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.head: [Queue]int;                                                                         
                                                                                                    
function {:inline} ReadEval.Queue.head(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Queue._state[this], tid) && Queue._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.head(tid: Tid,this : Queue,newValue: int,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Queue._state[this], tid) && Queue._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.tail: [Queue]int;                                                                         
                                                                                                    
function {:inline} ReadEval.Queue.tail(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Queue._state[this], tid) && Queue._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.tail(tid: Tid,this : Queue,newValue: int,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Queue._state[this], tid) && Queue._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.spec: [Queue]Seq.int;                                                                     
                                                                                                    
function {:inline} ReadEval.Queue.spec(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := SeqEmpty.int() : Seq.int;                                                         
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Queue._state[this], tid) && Queue._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.spec(tid: Tid,this : Queue,newValue: Seq.int,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Queue._state[this], tid) && Queue._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue._lock: [Queue]Tid;                                                                        
                                                                                                    
function {:inline} ReadEval.Queue._lock(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Queue._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Queue._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Queue._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue._lock(tid: Tid,this : Queue,newValue: Tid,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Queue._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Queue._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Queue._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.Queue.3598743(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (bool) {
 (((0<=Queue.head[this])&&(Queue.head[this]<=Queue.tail[this]))&&(Queue.tail[this]<=Array.Queue.T._length[Queue.elems[this]]))
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Queue.3598756(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (bool) {
 ((Queue.tail[this]-Queue.head[this])==SeqLen.int(Queue.spec[this]))                                
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Queue.3598791(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (bool) {
 (forall i: int ::  ((((0<=i)&&(i<SeqLen.int(Queue.spec[this])))==>(SeqNth.int(Queue.spec[this],i)==Array.Queue.T._elems[Queue.elems[this]][(Queue.head[this]+i)]))))
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Queue.init(tid:Tid, this : Queue)                                                        
modifies Queue._state;                                                                              
modifies Queue.elems;                                                                               
modifies Queue.head;                                                                                
modifies Queue.tail;                                                                                
modifies Queue.spec;                                                                                
modifies Queue._lock;                                                                               
modifies Array.Queue.T._state;                                                                      
modifies Array.Queue.T._elems;                                                                      
                                                                                                    
requires ValidTid(tid);                                                                                    // (26.5): Bad tid
requires isLocal(Queue._state[this], tid);                                                          
                                                                                                    
requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
requires (Queue.elems[this]==Array.Queue.T.null);                                                   
                                                                                                    
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && _this != this ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (26.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && _this != this ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (26.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && _this != this ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (26.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (26.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (26.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (26.5): Object invariant may not hold.
{                                                                                                   
 var mover3610999: Mover;                                                                           
 var mover3610976: Mover;                                                                           
 var tmp13610986: Seq.int;                                                                          
 var Array.Queue.T._elems3610999: [Array.Queue.T]([int]int);                                        
 var Queue.tail3610976: [Queue]int;                                                                 
 var this3610986: Queue;                                                                            
 var moverPath3610976: MoverPath;                                                                   
 var tmp13611000: Seq.int;                                                                          
 var Array.Queue.T._length3610999: [Array.Queue.T]int;                                              
 var tmp33610986: int;                                                                              
 var Array.Queue.T._state3610976: [Array.Queue.T]State;                                             
 var Queue.spec3610976: [Queue]Seq.int;                                                             
 var Array.Queue.T._elems3610966: [Array.Queue.T]([int]int);                                        
 var Queue.tail3611000: [Queue]int;                                                                 
 var Queue.tail3610966: [Queue]int;                                                                 
 var this3610999: Queue;                                                                            
 var Queue.elems3611000: [Queue]Array.Queue.T;                                                      
 var path3610966: int;                                                                              
 var Array.Queue.T._length3610986: [Array.Queue.T]int;                                              
 var tmp23611000: int;                                                                              
 var Array.Queue.T._state3610966: [Array.Queue.T]State;                                             
 var _pc3610976: Phase;                                                                             
 var Array.Queue.T._elems3611000: [Array.Queue.T]([int]int);                                        
 var $recorded.state3610976: int;                                                                   
 var _pc3610999: Phase;                                                                             
 var Queue.elems3610999: [Queue]Array.Queue.T;                                                      
 var tmp13610999: Seq.int;                                                                          
 var Array.Queue.T._length3610966: [Array.Queue.T]int;                                              
 var Queue._lock3610999: [Queue]Tid;                                                                
 var mover3610986: Mover;                                                                           
 var this3610966: Queue;                                                                            
 var tmp13610966: Seq.int;                                                                          
 var Queue._state3611000: [Queue]State;                                                             
 var Queue._lock3610966: [Queue]Tid;                                                                
 var Queue.head3610999: [Queue]int;                                                                 
 var this3611000: Queue;                                                                            
 var $recorded.state3610999: int;                                                                   
 var Queue.head3611000: [Queue]int;                                                                 
 var Queue.head3610986: [Queue]int;                                                                 
 var path3610986: int;                                                                              
 var mover3610966: Mover;                                                                           
 var $recorded.state3610986: int;                                                                   
 var tid3610986: Tid;                                                                               
 var Queue.elems3610966: [Queue]Array.Queue.T;                                                      
 var moverPath3610966: MoverPath;                                                                   
 var this3610976: Queue;                                                                            
 var Queue._lock3611000: [Queue]Tid;                                                                
 var Queue.head3610976: [Queue]int;                                                                 
 var _pc3611000: Phase;                                                                             
 var Queue.elems3610986: [Queue]Array.Queue.T;                                                      
 var $recorded.state3610966: int;                                                                   
 var tid3610976: Tid;                                                                               
 var path3610976: int;                                                                              
 var Queue.tail3610999: [Queue]int;                                                                 
 var tmp23610999: int;                                                                              
 var tmp43611000: Array.Queue.T;                                                                    
 var Queue.spec3610986: [Queue]Seq.int;                                                             
 var tmp13610976: Seq.int;                                                                          
 var Array.Queue.T._length3611000: [Array.Queue.T]int;                                              
 var Queue.spec3610966: [Queue]Seq.int;                                                             
 var Array.Queue.T._elems3610976: [Array.Queue.T]([int]int);                                        
 var moverPath3610999: MoverPath;                                                                   
 var Array.Queue.T._length3610976: [Array.Queue.T]int;                                              
 var tmp4: Array.Queue.T;                                                                           
 var tmp23610976: int;                                                                              
 var tid3611000: Tid;                                                                               
 var tmp33610999: int;                                                                              
 var Queue.head3610966: [Queue]int;                                                                 
 var Queue._state3610999: [Queue]State;                                                             
 var Array.Queue.T._state3610986: [Array.Queue.T]State;                                             
 var tid3610999: Tid;                                                                               
 var Queue.spec3610999: [Queue]Seq.int;                                                             
 var Queue._state3610976: [Queue]State;                                                             
 var tid3610966: Tid;                                                                               
 var tmp3: int;                                                                                     
 var _pc3610986: Phase;                                                                             
 var Queue._state3610986: [Queue]State;                                                             
 var $recorded.state3611000: int;                                                                   
 var Array.Queue.T._elems3610986: [Array.Queue.T]([int]int);                                        
 var Queue._state3610966: [Queue]State;                                                             
 var moverPath3610986: MoverPath;                                                                   
 var tmp1: Seq.int;                                                                                 
 var tmp33611000: int;                                                                              
 var _pc3610966: Phase;                                                                             
 var tmp23610986: int;                                                                              
 var Queue.tail3610986: [Queue]int;                                                                 
 var tmp2: int;                                                                                     
 var Array.Queue.T._state3610999: [Array.Queue.T]State;                                             
 var Queue._lock3610976: [Queue]Tid;                                                                
 var Queue._lock3610986: [Queue]Tid;                                                                
 var Queue.elems3610976: [Queue]Array.Queue.T;                                                      
 var Queue.spec3611000: [Queue]Seq.int;                                                             
 var tmp43610999: Array.Queue.T;                                                                    
 var Array.Queue.T._state3611000: [Array.Queue.T]State;                                             
 var path3610999: int;                                                                              
                                                                                                    
 var _pc : Phase;                                                                                   
 _pc := PreCommit;                                                                                  
                                                                                                    
 assert true && leq(m#moverPath(ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)),_R);       // (26.5): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 26.5: assume this.elems == [Queue.T{this}].null;                                                
                                                                                                    
 assume (Queue.elems[this]==Array.Queue.T.null);                                                    
                                                                                                    
 // 26.5: assume this.head == 0;                                                                    
                                                                                                    
 assume (Queue.head[this]==0);                                                                      
                                                                                                    
 // 26.5: assume this.tail == 0;                                                                    
                                                                                                    
 assume (Queue.tail[this]==0);                                                                      
                                                                                                    
 // 26.5: assume this.spec == SeqEmpty;                                                             
                                                                                                    
 assume (Queue.spec[this]==SeqEmpty.int() : Seq.int);                                               
                                                                                                    
 // 28.9: Seq<int> tmp1;                                                                            
                                                                                                    
                                                                                                    
 // 28.9: tmp1 = SeqEmpty<int>();                                                                   
                                                                                                    
 tmp1 := SeqEmpty.int();                                                                            
                                                                                                    
                                                                                                    
 // 28.9: this.spec := tmp1;                                                                        
                                                                                                    
                                                                                                    
 moverPath3610966 := WriteEval.Queue.spec(tid: Tid,this: Queue,tmp1: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3610966 := m#moverPath(moverPath3610966);                                                     
 path3610966 := p#moverPath(moverPath3610966);                                                      
 assume Queue._state3610966 == Queue._state && Queue.elems3610966 == Queue.elems && Queue.head3610966 == Queue.head && Queue.tail3610966 == Queue.tail && Queue.spec3610966 == Queue.spec && Queue._lock3610966 == Queue._lock && Array.Queue.T._state3610966 == Array.Queue.T._state && Array.Queue.T._elems3610966 == Array.Queue.T._elems && Array.Queue.T._length3610966 == Array.Queue.T._length && tmp13610966 == tmp1 && this3610966 == this && tid3610966 == tid && _pc3610966 == _pc;
 assume $recorded.state3610966 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (28.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 _pc := transition(_pc, mover3610966);                                                              
 assert _pc != PhaseError;                                                                                 // (28.9): Reduction failure
 Queue.spec[this] := tmp1;                                                                          
                                                                                                    
 // 29.9: int tmp2;                                                                                 
                                                                                                    
                                                                                                    
 // 29.9: tmp2 = 0;                                                                                 
                                                                                                    
 tmp2 := 0;                                                                                         
                                                                                                    
                                                                                                    
 // 29.9: this.head := tmp2;                                                                        
                                                                                                    
                                                                                                    
 moverPath3610976 := WriteEval.Queue.head(tid: Tid,this: Queue,tmp2: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3610976 := m#moverPath(moverPath3610976);                                                     
 path3610976 := p#moverPath(moverPath3610976);                                                      
 assume Queue._state3610976 == Queue._state && Queue.elems3610976 == Queue.elems && Queue.head3610976 == Queue.head && Queue.tail3610976 == Queue.tail && Queue.spec3610976 == Queue.spec && Queue._lock3610976 == Queue._lock && Array.Queue.T._state3610976 == Array.Queue.T._state && Array.Queue.T._elems3610976 == Array.Queue.T._elems && Array.Queue.T._length3610976 == Array.Queue.T._length && tmp23610976 == tmp2 && tmp13610976 == tmp1 && this3610976 == this && tid3610976 == tid && _pc3610976 == _pc;
 assume $recorded.state3610976 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (29.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 _pc := transition(_pc, mover3610976);                                                              
 assert _pc != PhaseError;                                                                                 // (29.9): Reduction failure
 Queue.head[this] := tmp2;                                                                          
                                                                                                    
 // 30.9: int tmp3;                                                                                 
                                                                                                    
                                                                                                    
 // 30.9: tmp3 = 0;                                                                                 
                                                                                                    
 tmp3 := 0;                                                                                         
                                                                                                    
                                                                                                    
 // 30.9: this.tail := tmp3;                                                                        
                                                                                                    
                                                                                                    
 moverPath3610986 := WriteEval.Queue.tail(tid: Tid,this: Queue,tmp3: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3610986 := m#moverPath(moverPath3610986);                                                     
 path3610986 := p#moverPath(moverPath3610986);                                                      
 assume Queue._state3610986 == Queue._state && Queue.elems3610986 == Queue.elems && Queue.head3610986 == Queue.head && Queue.tail3610986 == Queue.tail && Queue.spec3610986 == Queue.spec && Queue._lock3610986 == Queue._lock && Array.Queue.T._state3610986 == Array.Queue.T._state && Array.Queue.T._elems3610986 == Array.Queue.T._elems && Array.Queue.T._length3610986 == Array.Queue.T._length && tmp33610986 == tmp3 && tmp23610986 == tmp2 && tmp13610986 == tmp1 && this3610986 == this && tid3610986 == tid && _pc3610986 == _pc;
 assume $recorded.state3610986 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (30.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 _pc := transition(_pc, mover3610986);                                                              
 assert _pc != PhaseError;                                                                                 // (30.9): Reduction failure
 Queue.tail[this] := tmp3;                                                                          
                                                                                                    
 // 31.9: [Queue.T{this}] tmp4;                                                                     
                                                                                                    
                                                                                                    
 // 31.9: tmp4 = new [Queue.T{this}](512);                                                          
                                                                                                    
 havoc tmp4;                                                                                        
 assume isFresh(Array.Queue.T._state[tmp4]);                                                        
 assume Array.Queue.T._length[tmp4] == 512;                                                         
 assume Array.Queue.T._this[tmp4] == this;                                                          
 Array.Queue.T._state[tmp4] := LOCAL(tid);                                                          
 assume (forall _i : int :: 0 <= _i ==> Array.Queue.T._elems[tmp4][_i] == 0);                       
                                                                                                    
                                                                                                    
 // 31.9: this.elems := tmp4;                                                                       
                                                                                                    
                                                                                                    
 moverPath3610999 := WriteEval.Queue.elems(tid: Tid,this: Queue,tmp4: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3610999 := m#moverPath(moverPath3610999);                                                     
 path3610999 := p#moverPath(moverPath3610999);                                                      
 assume Queue._state3610999 == Queue._state && Queue.elems3610999 == Queue.elems && Queue.head3610999 == Queue.head && Queue.tail3610999 == Queue.tail && Queue.spec3610999 == Queue.spec && Queue._lock3610999 == Queue._lock && Array.Queue.T._state3610999 == Array.Queue.T._state && Array.Queue.T._elems3610999 == Array.Queue.T._elems && Array.Queue.T._length3610999 == Array.Queue.T._length && tmp43610999 == tmp4 && tmp33610999 == tmp3 && tmp23610999 == tmp2 && tmp13610999 == tmp1 && this3610999 == this && tid3610999 == tid && _pc3610999 == _pc;
 assume $recorded.state3610999 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (31.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 _pc := transition(_pc, mover3610999);                                                              
 assert _pc != PhaseError;                                                                                 // (31.9): Reduction failure
 Queue.elems[this] := tmp4;                                                                         
 if (isLocal(Array.Queue.T._state[tmp4], tid)) {                                                    
  Array.Queue.T._state[tmp4] := SHARED();                                                           
  if (isLocal(Queue._state[Array.Queue.T._this[tmp4]], tid)) {                                      
   Queue._state[Array.Queue.T._this[tmp4]] := SHARED();                                             
   assert isSharedAssignable(Array.Queue.T._state[Queue.elems[Array.Queue.T._this[tmp4]]]);                // (31.9): tmp4 became shared, but Array.Queue.T._this[tmp4].elems may not be shared.
  }                                                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 27.21: // return;                                                                               
                                                                                                    
 assume Queue._state3611000 == Queue._state && Queue.elems3611000 == Queue.elems && Queue.head3611000 == Queue.head && Queue.tail3611000 == Queue.tail && Queue.spec3611000 == Queue.spec && Queue._lock3611000 == Queue._lock && Array.Queue.T._state3611000 == Array.Queue.T._state && Array.Queue.T._elems3611000 == Array.Queue.T._elems && Array.Queue.T._length3611000 == Array.Queue.T._length && tmp43611000 == tmp4 && tmp33611000 == tmp3 && tmp23611000 == tmp2 && tmp13611000 == tmp1 && this3611000 == this && tid3611000 == tid;
 assume $recorded.state3611000 == 1;                                                                
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (27.21): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (27.21): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (27.21): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  Queue.dequeue(tid:Tid, this : Queue)                                                     
returns ($result : int)                                                                             
modifies Queue._state;                                                                              
modifies Queue.elems;                                                                               
modifies Queue.head;                                                                                
modifies Queue.tail;                                                                                
modifies Queue.spec;                                                                                
modifies Queue._lock;                                                                               
modifies Array.Queue.T._state;                                                                      
modifies Array.Queue.T._elems;                                                                      
                                                                                                    
requires ValidTid(tid);                                                                                    // (34.5): Bad tid
requires isShared(Queue._state[this]);                                                                     // (34.5): this is not global
                                                                                                    
requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (34.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (34.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (34.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (34.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (34.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (34.5): Object invariant may not hold.
{                                                                                                   
 var tmp363611505: bool;                                                                            
 var Queue.head3611354: [Queue]int;                                                                 
 var tmp263611561: int;                                                                             
 var tmp383611534: bool;                                                                            
 var tmp293611646: bool;                                                                            
 var tmp423611438: Array.Queue.T;                                                                   
 var tmp583611596: int;                                                                             
 var Array.Queue.T._elems3611438: [Array.Queue.T]([int]int);                                        
 var tmp113611508: Seq.int;                                                                         
 var tmp113611192: Seq.int;                                                                         
 var tmp153611561: bool;                                                                            
 var tmp113611238: Seq.int;                                                                         
 var tmp133611438: int;                                                                             
 var Queue._lock3611130: [Queue]Tid;                                                                
 var result: int;                                                                                   
 var Queue.spec3611130: [Queue]Seq.int;                                                             
 var tmp30: int;                                                                                    
 var Queue._lock3611574: [Queue]Tid;                                                                
 var result3611157: int;                                                                            
 var Queue.head3611574: [Queue]int;                                                                 
 var tmp53611179: bool;                                                                             
 var tid3611508: Tid;                                                                               
 var tmp133611130: int;                                                                             
 var tmp473611508: int;                                                                             
 var tmp53611505: bool;                                                                             
 var tmp353611505: int;                                                                             
 var tmp93611293: Array.Queue.T;                                                                    
 var tmp153611130: bool;                                                                            
 var path3611170: int;                                                                              
 var tmp42: Array.Queue.T;                                                                          
 var tmp463611486: int;                                                                             
 var tmp313611642: bool;                                                                            
 var o3611574: Seq.int;                                                                             
 var tmp403611486: bool;                                                                            
 var mover3611418: Mover;                                                                           
 var tmp343611418: Seq.int;                                                                         
 var tmp403611406: bool;                                                                            
 var tmp143611486: Seq.int;                                                                         
 var tmp63611438: int;                                                                              
 var tmp443611642: int;                                                                             
 var tmp593611596: int;                                                                             
 var tid3611179: Tid;                                                                               
 var tmp123611170: int;                                                                             
 var result3611574: int;                                                                            
 var Queue.tail3611047: [Queue]int;                                                                 
 var Queue.head3611505: [Queue]int;                                                                 
 var Queue._lock3611505: [Queue]Tid;                                                                
 var this3611293: Queue;                                                                            
 var tmp453611596: int;                                                                             
 var tmp223611583: Seq.int;                                                                         
 var tmp423611596: Array.Queue.T;                                                                   
 var Queue.tail3611170: [Queue]int;                                                                 
 var $recorded.state3611561: int;                                                                   
 var tmp103611354: int;                                                                             
 var tmp213611596: int;                                                                             
 var tmp22: Seq.int;                                                                                
 var tmp163611418: bool;                                                                            
 var Queue._state3611192: [Queue]State;                                                             
 var tmp503611574: bool;                                                                            
 var tmp93611505: Array.Queue.T;                                                                    
 var tmp143611081: Seq.int;                                                                         
 var Queue.head3611157: [Queue]int;                                                                 
 var tmp213611157: int;                                                                             
 var tmp133611157: int;                                                                             
 var tmp23: Array.Queue.T;                                                                          
 var tmp113611438: Seq.int;                                                                         
 var tmp113611534: Seq.int;                                                                         
 var tmp463611596: int;                                                                             
 var Queue.tail3611534: [Queue]int;                                                                 
 var tmp343611505: Seq.int;                                                                         
 var i3611406: int;                                                                                 
 var tmp443611534: int;                                                                             
 var tmp263611505: int;                                                                             
 var tmp183611130: int;                                                                             
 var tmp233611583: Array.Queue.T;                                                                   
 var tmp343611406: Seq.int;                                                                         
 var tmp103611534: int;                                                                             
 var tmp83611495: int;                                                                              
 var _pc3611057: Phase;                                                                             
 var Queue.tail3611179: [Queue]int;                                                                 
 var tmp28: bool;                                                                                   
 var tmp353611418: int;                                                                             
 var tmp63611561: int;                                                                              
 var tmp63611053: int;                                                                              
 var tmp113611486: Seq.int;                                                                         
 var Queue._lock3611018: [Queue]Tid;                                                                
 var tmp63611170: int;                                                                              
 var tmp283611495: bool;                                                                            
 var Queue.elems3611663: [Queue]Array.Queue.T;                                                      
 var tmp123611574: int;                                                                             
 var tmp263611354: int;                                                                             
 var Array.Queue.T._state3611495: [Array.Queue.T]State;                                             
 var tmp583611646: int;                                                                             
 var tmp283611642: bool;                                                                            
 var tmp513611596: bool;                                                                            
 var Queue._state3611653: [Queue]State;                                                             
 var tmp553611561: int;                                                                             
 var tid3611238: Tid;                                                                               
 var tmp483611505: int;                                                                             
 var $recorded.state3611653: int;                                                                   
 var tmp36: bool;                                                                                   
 var tid3611438: Tid;                                                                               
 var tid3611486: Tid;                                                                               
 var mover3611068: Mover;                                                                           
 var tmp43: int;                                                                                    
 var result3611130: int;                                                                            
 var tmp503611646: bool;                                                                            
 var Queue.head3611081: [Queue]int;                                                                 
 var i3611574: int;                                                                                 
 var tmp143611596: Seq.int;                                                                         
 var tmp473611505: int;                                                                             
 var this3611642: Queue;                                                                            
 var Array.Queue.T._elems3611018: [Array.Queue.T]([int]int);                                        
 var Array.Queue.T._length3611192: [Array.Queue.T]int;                                              
 var tmp143611561: Seq.int;                                                                         
 var tmp483611574: int;                                                                             
 var tmp73611053: int;                                                                              
 var tmp143611583: Seq.int;                                                                         
 var Queue.spec3611653: [Queue]Seq.int;                                                             
 var tmp103611574: int;                                                                             
 var $result3611418: int;                                                                           
 var Array.Queue.T._length3611534: [Array.Queue.T]int;                                              
 var tmp373611561: bool;                                                                            
 var tmp103611596: int;                                                                             
 var Queue.tail3611354: [Queue]int;                                                                 
 var Array.Queue.T._elems3611596: [Array.Queue.T]([int]int);                                        
 var tmp263611534: int;                                                                             
 var $result3611024: int;                                                                           
 var tmp243611495: int;                                                                             
 var tmp73611642: int;                                                                              
 var tmp443611438: int;                                                                             
 var tmp373611486: bool;                                                                            
 var $recorded.state3611170: int;                                                                   
 var tmp93611561: Array.Queue.T;                                                                    
 var tmp413611583: int;                                                                             
 var tmp173611642: bool;                                                                            
 var Queue.elems3611534: [Queue]Array.Queue.T;                                                      
 var _pc3611505: Phase;                                                                             
 var tmp423611534: Array.Queue.T;                                                                   
 var tid3611663: Tid;                                                                               
 var result3611068: int;                                                                            
 var tmp443611646: int;                                                                             
 var tmp473611561: int;                                                                             
 var tmp143611646: Seq.int;                                                                         
 var tmp173611574: bool;                                                                            
 var Array.Queue.T._state3611574: [Array.Queue.T]State;                                             
 var i3611354: int;                                                                                 
 var tmp213611508: int;                                                                             
 var tmp253611418: int;                                                                             
 var Queue.tail3611438: [Queue]int;                                                                 
 var tmp593611646: int;                                                                             
 var $result3611653: int;                                                                           
 var o3611081: Seq.int;                                                                             
 var tmp93611574: Array.Queue.T;                                                                    
 var this3611024: Queue;                                                                            
 var Queue.head3611596: [Queue]int;                                                                 
 var $result3611508: int;                                                                           
 var i3611561: int;                                                                                 
 var tmp463611642: int;                                                                             
 var tmp153611486: bool;                                                                            
 var this3611081: Queue;                                                                            
 var tmp283611583: bool;                                                                            
 var tmp103611192: int;                                                                             
 var tmp123611495: int;                                                                             
 var tmp213611354: int;                                                                             
 var tmp83611024: int;                                                                              
 var tmp223611438: Seq.int;                                                                         
 var tmp443611583: int;                                                                             
 var tmp5: bool;                                                                                    
 var Queue._lock3611081: [Queue]Tid;                                                                
 var tmp73611438: int;                                                                              
 var o3611406: Seq.int;                                                                             
 var tmp53611653: bool;                                                                             
 var Queue.elems3611130: [Queue]Array.Queue.T;                                                      
 var Queue.elems3611047: [Queue]Array.Queue.T;                                                      
 var _pc3611418: Phase;                                                                             
 var tmp263611418: int;                                                                             
 var tmp423611495: Array.Queue.T;                                                                   
 var result3611047: int;                                                                            
 var tmp273611508: bool;                                                                            
 var tmp463611561: int;                                                                             
 var Queue._lock3611583: [Queue]Tid;                                                                
 var tmp453611646: int;                                                                             
 var result3611192: int;                                                                            
 var _pc3611047: Phase;                                                                             
 var $result3611170: int;                                                                           
 var tmp163611157: bool;                                                                            
 var tmp133611081: int;                                                                             
 var tmp173611170: bool;                                                                            
 var Queue._lock3611047: [Queue]Tid;                                                                
 var tmp433611561: int;                                                                             
 var result3611081: int;                                                                            
 var tmp243611293: int;                                                                             
 var Array.Queue.T._length3611495: [Array.Queue.T]int;                                              
 var tmp143611534: Seq.int;                                                                         
 var tmp143611574: Seq.int;                                                                         
 var moverPath3611018: MoverPath;                                                                   
 var result3611057: int;                                                                            
 var tmp63611057: int;                                                                              
 var this3611534: Queue;                                                                            
 var _pc3611024: Phase;                                                                             
 var tid3611192: Tid;                                                                               
 var Queue.spec3611192: [Queue]Seq.int;                                                             
 var this3611646: Queue;                                                                            
 var Queue.spec3611438: [Queue]Seq.int;                                                             
 var tmp273611596: bool;                                                                            
 var tmp263611293: int;                                                                             
 var tmp223611179: Seq.int;                                                                         
 var $recorded.state3611081: int;                                                                   
 var tmp363611583: bool;                                                                            
 var tmp473611495: int;                                                                             
 var Array.Queue.T._length3611057: [Array.Queue.T]int;                                              
 var tmp513611583: bool;                                                                            
 var Queue._state3611534: [Queue]State;                                                             
 var tmp83611508: int;                                                                              
 var Array.Queue.T._elems3611486: [Array.Queue.T]([int]int);                                        
 var tmp453611534: int;                                                                             
 var result3611583: int;                                                                            
 var tmp473611642: int;                                                                             
 var tmp293611505: bool;                                                                            
 var $result3611642: int;                                                                           
 var tmp133611561: int;                                                                             
 var mover3611583: Mover;                                                                           
 var Queue.spec3611596: [Queue]Seq.int;                                                             
 var moverPath3611192: MoverPath;                                                                   
 var tmp523611534: int;                                                                             
 var tmp283611486: bool;                                                                            
 var path3611583: int;                                                                              
 var tmp223611508: Seq.int;                                                                         
 var tmp73611495: int;                                                                              
 var tmp603611646: int;                                                                             
 var tmp73611505: int;                                                                              
 var tmp353611561: int;                                                                             
 var tmp163611646: bool;                                                                            
 var tmp50: bool;                                                                                   
 var tmp323611561: int;                                                                             
 var $result3611053: int;                                                                           
 var $result3611179: int;                                                                           
 var tmp513611642: bool;                                                                            
 var tmp113611354: Seq.int;                                                                         
 var tmp93611508: Array.Queue.T;                                                                    
 var tmp113611406: Seq.int;                                                                         
 var tmp173611192: bool;                                                                            
 var tmp123611642: int;                                                                             
 var tmp313611486: bool;                                                                            
 var tmp323611354: int;                                                                             
 var $recorded.state3611508: int;                                                                   
 var tmp253611438: int;                                                                             
 var this3611663: Queue;                                                                            
 var tmp35: int;                                                                                    
 var tmp313611438: bool;                                                                            
 var $recorded.state3611238: int;                                                                   
 var tmp243611238: int;                                                                             
 var Array.Queue.T._length3611583: [Array.Queue.T]int;                                              
 var tmp83611170: int;                                                                              
 var tmp83611053: int;                                                                              
 var Array.Queue.T._state3611486: [Array.Queue.T]State;                                             
 var tmp103611130: int;                                                                             
 var tmp293611574: bool;                                                                            
 var Queue.elems3611179: [Queue]Array.Queue.T;                                                      
 var Queue.head3611486: [Queue]int;                                                                 
 var _pc3611068: Phase;                                                                             
 var tmp143611293: Seq.int;                                                                         
 var tmp343611438: Seq.int;                                                                         
 var Array.Queue.T._length3611293: [Array.Queue.T]int;                                              
 var tmp53611642: bool;                                                                             
 var tmp423611418: Array.Queue.T;                                                                   
 var tmp333611574: int;                                                                             
 var tmp143611157: Seq.int;                                                                         
 var i3611238: int;                                                                                 
 var tmp323611293: int;                                                                             
 var this3611068: Queue;                                                                            
 var tmp583611583: int;                                                                             
 var o3611646: Seq.int;                                                                             
 var path3611130: int;                                                                              
 var tmp113611505: Seq.int;                                                                         
 var tmp63611068: int;                                                                              
 var tmp53611486: bool;                                                                             
 var tmp323611406: int;                                                                             
 var Array.Queue.T._length3611642: [Array.Queue.T]int;                                              
 var tmp213611561: int;                                                                             
 var Queue.elems3611653: [Queue]Array.Queue.T;                                                      
 var tmp333611354: int;                                                                             
 var tmp433611438: int;                                                                             
 var tmp16: bool;                                                                                   
 var tmp283611354: bool;                                                                            
 var tmp8: int;                                                                                     
 var this3611018: Queue;                                                                            
 var tmp323611508: int;                                                                             
 var Queue.head3611047: [Queue]int;                                                                 
 var tmp223611406: Seq.int;                                                                         
 var this3611486: Queue;                                                                            
 var tmp433611642: int;                                                                             
 var tmp563611574: Seq.int;                                                                         
 var tmp333611406: int;                                                                             
 var tmp323611534: int;                                                                             
 var tmp32: int;                                                                                    
 var tmp343611642: Seq.int;                                                                         
 var $result3611081: int;                                                                           
 var moverPath3611024: MoverPath;                                                                   
 var tmp203611170: bool;                                                                            
 var tmp73611354: int;                                                                              
 var Array.Queue.T._elems3611179: [Array.Queue.T]([int]int);                                        
 var tmp443611574: int;                                                                             
 var tid3611130: Tid;                                                                               
 var $recorded.state3611642: int;                                                                   
 var Array.Queue.T._length3611418: [Array.Queue.T]int;                                              
 var tmp113611081: Seq.int;                                                                         
 var moverPath3611596: MoverPath;                                                                   
 var tmp143611170: Seq.int;                                                                         
 var $result3611047: int;                                                                           
 var Queue.tail3611293: [Queue]int;                                                                 
 var tmp543611574: bool;                                                                            
 var $result3611293: int;                                                                           
 var tmp223611192: Seq.int;                                                                         
 var tmp293611438: bool;                                                                            
 var tmp493611534: bool;                                                                            
 var tmp363611486: bool;                                                                            
 var tmp283611438: bool;                                                                            
 var Queue.elems3611574: [Queue]Array.Queue.T;                                                      
 var tmp293611406: bool;                                                                            
 var tmp233611354: Array.Queue.T;                                                                   
 var this3611596: Queue;                                                                            
 var Array.Queue.T._elems3611047: [Array.Queue.T]([int]int);                                        
 var _pc3611663: Phase;                                                                             
 var tmp383611495: bool;                                                                            
 var tmp563611596: Seq.int;                                                                         
 var tmp233611170: Array.Queue.T;                                                                   
 var tmp253611583: int;                                                                             
 var mover3611053: Mover;                                                                           
 var tmp473611534: int;                                                                             
 var tid3611293: Tid;                                                                               
 var tmp413611505: int;                                                                             
 var _pc3611583: Phase;                                                                             
 var result3611495: int;                                                                            
 var tmp293611293: bool;                                                                            
 var tmp283611406: bool;                                                                            
 var Queue.tail3611653: [Queue]int;                                                                 
 var tmp63611495: int;                                                                              
 var result3611418: int;                                                                            
 var Queue.elems3611505: [Queue]Array.Queue.T;                                                      
 var tmp553611574: int;                                                                             
 var Queue._lock3611663: [Queue]Tid;                                                                
 var tmp413611418: int;                                                                             
 var Array.Queue.T._length3611561: [Array.Queue.T]int;                                              
 var tmp353611406: int;                                                                             
 var tmp93611646: Array.Queue.T;                                                                    
 var tmp73611646: int;                                                                              
 var Queue.spec3611574: [Queue]Seq.int;                                                             
 var tmp353611486: int;                                                                             
 var tmp233611486: Array.Queue.T;                                                                   
 var result3611293: int;                                                                            
 var Array.Queue.T._state3611663: [Array.Queue.T]State;                                             
 var Queue._state3611583: [Queue]State;                                                             
 var Queue.spec3611018: [Queue]Seq.int;                                                             
 var Queue._state3611561: [Queue]State;                                                             
 var tmp373611495: bool;                                                                            
 var tmp113611157: Seq.int;                                                                         
 var tmp93611406: Array.Queue.T;                                                                    
 var $recorded.state3611053: int;                                                                   
 var tmp203611646: bool;                                                                            
 var tmp53611534: bool;                                                                             
 var tmp363611596: bool;                                                                            
 var tmp263611192: int;                                                                             
 var tmp483611508: int;                                                                             
 var tmp253611495: int;                                                                             
 var tmp173611130: bool;                                                                            
 var tmp73611596: int;                                                                              
 var tmp83611418: int;                                                                              
 var tmp423611486: Array.Queue.T;                                                                   
 var Array.Queue.T._elems3611053: [Array.Queue.T]([int]int);                                        
 var tmp163611438: bool;                                                                            
 var result3611596: int;                                                                            
 var Queue.tail3611081: [Queue]int;                                                                 
 var tmp113611574: Seq.int;                                                                         
 var tmp273611646: bool;                                                                            
 var $recorded.state3611663: int;                                                                   
 var Array.Queue.T._elems3611238: [Array.Queue.T]([int]int);                                        
 var tmp173611583: bool;                                                                            
 var tmp353611646: int;                                                                             
 var tmp73611130: int;                                                                              
 var i3611418: int;                                                                                 
 var tmp313611505: bool;                                                                            
 var tmp373611596: bool;                                                                            
 var tmp73611561: int;                                                                              
 var tmp313611534: bool;                                                                            
 var path3611179: int;                                                                              
 var tmp263611596: int;                                                                             
 var tmp283611505: bool;                                                                            
 var tmp243611642: int;                                                                             
 var Queue.tail3611238: [Queue]int;                                                                 
 var tmp73611406: int;                                                                              
 var tmp293611583: bool;                                                                            
 var tmp253611646: int;                                                                             
 var tid3611583: Tid;                                                                               
 var $result3611583: int;                                                                           
 var tmp153611646: bool;                                                                            
 var tmp383611505: bool;                                                                            
 var tmp573611596: Array.Queue.T;                                                                   
 var _pc3611170: Phase;                                                                             
 var tmp153611406: bool;                                                                            
 var tmp153611534: bool;                                                                            
 var tmp113611170: Seq.int;                                                                         
 var tmp203611642: bool;                                                                            
 var tmp233611574: Array.Queue.T;                                                                   
 var i3611192: int;                                                                                 
 var tmp403611505: bool;                                                                            
 var tmp383611486: bool;                                                                            
 var tmp323611583: int;                                                                             
 var tmp253611505: int;                                                                             
 var tmp333611646: int;                                                                             
 var tmp113611596: Seq.int;                                                                         
 var tmp313611406: bool;                                                                            
 var o3611561: Seq.int;                                                                             
 var tmp443611505: int;                                                                             
 var tmp133611505: int;                                                                             
 var tmp63611406: int;                                                                              
 var tmp203611354: bool;                                                                            
 var $recorded.state3611018: int;                                                                   
 var tmp493611596: bool;                                                                            
 var o3611192: Seq.int;                                                                             
 var tmp103611238: int;                                                                             
 var tmp493611561: bool;                                                                            
 var tmp63611642: int;                                                                              
 var Queue.head3611068: [Queue]int;                                                                 
 var Array.Queue.T._length3611508: [Array.Queue.T]int;                                              
 var tmp123611561: int;                                                                             
 var moverPath3611508: MoverPath;                                                                   
 var $recorded.state3611534: int;                                                                   
 var tmp223611574: Seq.int;                                                                         
 var tmp463611574: int;                                                                             
 var Queue.spec3611646: [Queue]Seq.int;                                                             
 var tmp363611646: bool;                                                                            
 var result3611170: int;                                                                            
 var tmp453611438: int;                                                                             
 var tmp48: int;                                                                                    
 var tmp223611596: Seq.int;                                                                         
 var this3611053: Queue;                                                                            
 var tmp413611642: int;                                                                             
 var path3611018: int;                                                                              
 var tmp243611486: int;                                                                             
 var tmp313611293: bool;                                                                            
 var tmp133611508: int;                                                                             
 var tmp58: int;                                                                                    
 var _pc3611293: Phase;                                                                             
 var tmp73611574: int;                                                                              
 var Queue._state3611508: [Queue]State;                                                             
 var moverPath3611081: MoverPath;                                                                   
 var tmp553611596: int;                                                                             
 var Array.Queue.T._state3611238: [Array.Queue.T]State;                                             
 var tmp373611646: bool;                                                                            
 var tmp83611354: int;                                                                              
 var tmp93611642: Array.Queue.T;                                                                    
 var tmp163611505: bool;                                                                            
 var tmp153611157: bool;                                                                            
 var tmp113611179: Seq.int;                                                                         
 var moverPath3611406: MoverPath;                                                                   
 var Array.Queue.T._state3611053: [Array.Queue.T]State;                                             
 var this3611653: Queue;                                                                            
 var $result3611018: int;                                                                           
 var tmp203611293: bool;                                                                            
 var tmp223611561: Seq.int;                                                                         
 var Queue.elems3611192: [Queue]Array.Queue.T;                                                      
 var Array.Queue.T._elems3611354: [Array.Queue.T]([int]int);                                        
 var tmp133611495: int;                                                                             
 var tmp173611418: bool;                                                                            
 var Queue._state3611495: [Queue]State;                                                             
 var tmp11: Seq.int;                                                                                
 var tmp63611018: int;                                                                              
 var o3611354: Seq.int;                                                                             
 var tmp123611192: int;                                                                             
 var tmp403611418: bool;                                                                            
 var tid3611081: Tid;                                                                               
 var tmp463611505: int;                                                                             
 var tmp403611534: bool;                                                                            
 var tmp553611642: int;                                                                             
 var tmp133611646: int;                                                                             
 var Queue.elems3611293: [Queue]Array.Queue.T;                                                      
 var tmp363611508: bool;                                                                            
 var Queue.tail3611561: [Queue]int;                                                                 
 var tmp233611293: Array.Queue.T;                                                                   
 var this3611179: Queue;                                                                            
 var result3611179: int;                                                                            
 var tmp423611642: Array.Queue.T;                                                                   
 var tmp483611646: int;                                                                             
 var o3611130: Seq.int;                                                                             
 var tmp83611238: int;                                                                              
 var this3611157: Queue;                                                                            
 var tmp173611354: bool;                                                                            
 var Array.Queue.T._length3611047: [Array.Queue.T]int;                                              
 var tmp353611508: int;                                                                             
 var tmp253611574: int;                                                                             
 var tmp453611418: int;                                                                             
 var this3611561: Queue;                                                                            
 var tmp483611561: int;                                                                             
 var tmp63611574: int;                                                                              
 var tmp263611642: int;                                                                             
 var tmp63611354: int;                                                                              
 var tmp373611438: bool;                                                                            
 var tmp14: Seq.int;                                                                                
 var Array.Queue.T._elems3611561: [Array.Queue.T]([int]int);                                        
 var $result3611486: int;                                                                           
 var path3611053: int;                                                                              
 var _pc3611179: Phase;                                                                             
 var tmp163611170: bool;                                                                            
 var i: int;                                                                                        
 var tmp543611646: bool;                                                                            
 var tmp133611170: int;                                                                             
 var tmp83611157: int;                                                                              
 var tmp53611293: bool;                                                                             
 var tmp93611596: Array.Queue.T;                                                                    
 var Array.Queue.T._length3611130: [Array.Queue.T]int;                                              
 var Array.Queue.T._state3611561: [Array.Queue.T]State;                                             
 var tmp223611170: Seq.int;                                                                         
 var Queue.elems3611081: [Queue]Array.Queue.T;                                                      
 var tmp443611495: int;                                                                             
 var tmp21: int;                                                                                    
 var tid3611534: Tid;                                                                               
 var tmp503611561: bool;                                                                            
 var tmp313611354: bool;                                                                            
 var tmp83611505: int;                                                                              
 var tmp113611495: Seq.int;                                                                         
 var tmp453611574: int;                                                                             
 var tmp363611406: bool;                                                                            
 var tmp123611130: int;                                                                             
 var tmp133611583: int;                                                                             
 var tmp423611646: Array.Queue.T;                                                                   
 var tmp333611561: int;                                                                             
 var $recorded.state3611486: int;                                                                   
 var tmp383611583: bool;                                                                            
 var tid3611018: Tid;                                                                               
 var tmp513611561: bool;                                                                            
 var result3611505: int;                                                                            
 var tmp153611438: bool;                                                                            
 var tmp203611238: bool;                                                                            
 var tmp203611406: bool;                                                                            
 var tmp473611574: int;                                                                             
 var tmp213611418: int;                                                                             
 var tmp83611646: int;                                                                              
 var Queue.spec3611534: [Queue]Seq.int;                                                             
 var tmp173611646: bool;                                                                            
 var tmp223611495: Seq.int;                                                                         
 var path3611574: int;                                                                              
 var tmp53611646: bool;                                                                             
 var tmp373611418: bool;                                                                            
 var tmp273611505: bool;                                                                            
 var Queue._lock3611179: [Queue]Tid;                                                                
 var Queue._state3611179: [Queue]State;                                                             
 var tmp293611596: bool;                                                                            
 var tmp123611438: int;                                                                             
 var tmp153611179: bool;                                                                            
 var moverPath3611057: MoverPath;                                                                   
 var i3611596: int;                                                                                 
 var Array.Queue.T._elems3611505: [Array.Queue.T]([int]int);                                        
 var tmp213611293: int;                                                                             
 var tmp153611293: bool;                                                                            
 var Queue._lock3611293: [Queue]Tid;                                                                
 var tmp313611574: bool;                                                                            
 var Queue._state3611406: [Queue]State;                                                             
 var this3611170: Queue;                                                                            
 var _pc3611596: Phase;                                                                             
 var tmp273611583: bool;                                                                            
 var $recorded.state3611047: int;                                                                   
 var tmp173611157: bool;                                                                            
 var Queue._state3611047: [Queue]State;                                                             
 var tmp163611406: bool;                                                                            
 var Array.Queue.T._elems3611646: [Array.Queue.T]([int]int);                                        
 var tmp203611583: bool;                                                                            
 var i3611179: int;                                                                                 
 var Queue._lock3611438: [Queue]Tid;                                                                
 var Queue.head3611583: [Queue]int;                                                                 
 var mover3611192: Mover;                                                                           
 var tmp443611561: int;                                                                             
 var Queue._state3611438: [Queue]State;                                                             
 var tmp593611583: int;                                                                             
 var tmp53611238: bool;                                                                             
 var tmp163611354: bool;                                                                            
 var tmp143611354: Seq.int;                                                                         
 var Array.Queue.T._elems3611418: [Array.Queue.T]([int]int);                                        
 var tmp273611406: bool;                                                                            
 var tmp31: bool;                                                                                   
 var tmp243611534: int;                                                                             
 var tmp63611596: int;                                                                              
 var tmp263611438: int;                                                                             
 var tmp233611646: Array.Queue.T;                                                                   
 var tmp353611642: int;                                                                             
 var Queue.spec3611057: [Queue]Seq.int;                                                             
 var tmp133611642: int;                                                                             
 var Queue._state3611574: [Queue]State;                                                             
 var tmp53611596: bool;                                                                             
 var tmp253611642: int;                                                                             
 var tmp163611486: bool;                                                                            
 var tmp53611024: bool;                                                                             
 var Queue.tail3611508: [Queue]int;                                                                 
 var result3611642: int;                                                                            
 var tmp163611508: bool;                                                                            
 var tmp213611170: int;                                                                             
 var tmp533611534: Seq.int;                                                                         
 var $result3611238: int;                                                                           
 var tmp273611495: bool;                                                                            
 var tmp333611293: int;                                                                             
 var $result3611157: int;                                                                           
 var Queue.elems3611418: [Queue]Array.Queue.T;                                                      
 var tmp233611495: Array.Queue.T;                                                                   
 var Queue.spec3611508: [Queue]Seq.int;                                                             
 var Queue.elems3611157: [Queue]Array.Queue.T;                                                      
 var tmp453611505: int;                                                                             
 var _pc3611646: Phase;                                                                             
 var i3611157: int;                                                                                 
 var Array.Queue.T._state3611024: [Array.Queue.T]State;                                             
 var $result3611406: int;                                                                           
 var Queue.head3611495: [Queue]int;                                                                 
 var tmp453611642: int;                                                                             
 var tmp253611561: int;                                                                             
 var tmp433611574: int;                                                                             
 var tmp473611583: int;                                                                             
 var tmp573611583: Array.Queue.T;                                                                   
 var this3611130: Queue;                                                                            
 var tmp343611646: Seq.int;                                                                         
 var tmp103611053: int;                                                                             
 var tmp283611561: bool;                                                                            
 var tmp223611238: Seq.int;                                                                         
 var Queue._state3611596: [Queue]State;                                                             
 var tmp193611130: Seq.int;                                                                         
 var tmp83611486: int;                                                                              
 var tmp383611574: bool;                                                                            
 var Array.Queue.T._state3611081: [Array.Queue.T]State;                                             
 var Queue.head3611018: [Queue]int;                                                                 
 var tmp273611293: bool;                                                                            
 var path3611561: int;                                                                              
 var tmp20: bool;                                                                                   
 var tmp63611179: int;                                                                              
 var Queue.tail3611418: [Queue]int;                                                                 
 var tmp93611534: Array.Queue.T;                                                                    
 var tmp213611574: int;                                                                             
 var Array.Queue.T._state3611354: [Array.Queue.T]State;                                             
 var Queue._lock3611157: [Queue]Tid;                                                                
 var tmp113611646: Seq.int;                                                                         
 var Queue.elems3611018: [Queue]Array.Queue.T;                                                      
 var tmp103611418: int;                                                                             
 var tmp73611238: int;                                                                              
 var Queue.tail3611406: [Queue]int;                                                                 
 var tmp103611293: int;                                                                             
 var tmp93611438: Array.Queue.T;                                                                    
 var o3611534: Seq.int;                                                                             
 var tmp413611596: int;                                                                             
 var tmp543611642: bool;                                                                            
 var tmp123611418: int;                                                                             
 var tmp403611561: bool;                                                                            
 var tmp93611053: Array.Queue.T;                                                                    
 var Queue._state3611293: [Queue]State;                                                             
 var tmp38: bool;                                                                                   
 var tmp29: bool;                                                                                   
 var tmp343611534: Seq.int;                                                                         
 var tmp383611561: bool;                                                                            
 var tmp47: int;                                                                                    
 var tmp83611583: int;                                                                              
 var tmp293611354: bool;                                                                            
 var tmp223611534: Seq.int;                                                                         
 var tmp253611508: int;                                                                             
 var tmp233611642: Array.Queue.T;                                                                   
 var Queue.spec3611354: [Queue]Seq.int;                                                             
 var Queue._state3611081: [Queue]State;                                                             
 var tmp203611534: bool;                                                                            
 var tmp453611583: int;                                                                             
 var Array.Queue.T._length3611505: [Array.Queue.T]int;                                              
 var mover3611574: Mover;                                                                           
 var _pc3611130: Phase;                                                                             
 var tmp373611508: bool;                                                                            
 var tmp123611508: int;                                                                             
 var Array.Queue.T._length3611081: [Array.Queue.T]int;                                              
 var Queue._lock3611024: [Queue]Tid;                                                                
 var Array.Queue.T._elems3611642: [Array.Queue.T]([int]int);                                        
 var path3611505: int;                                                                              
 var Queue.head3611130: [Queue]int;                                                                 
 var tmp283611418: bool;                                                                            
 var Array.Queue.T._state3611653: [Array.Queue.T]State;                                             
 var Array.Queue.T._length3611053: [Array.Queue.T]int;                                              
 var o3611642: Seq.int;                                                                             
 var o: Seq.int;                                                                                    
 var Queue._lock3611192: [Queue]Tid;                                                                
 var tmp603611642: int;                                                                             
 var tmp423611574: Array.Queue.T;                                                                   
 var tmp293611495: bool;                                                                            
 var Array.Queue.T._elems3611068: [Array.Queue.T]([int]int);                                        
 var tmp123611583: int;                                                                             
 var tmp243611418: int;                                                                             
 var tmp113611418: Seq.int;                                                                         
 var _pc3611018: Phase;                                                                             
 var Queue.tail3611642: [Queue]int;                                                                 
 var tmp283611574: bool;                                                                            
 var Queue.tail3611486: [Queue]int;                                                                 
 var tmp53611057: bool;                                                                             
 var Queue.tail3611495: [Queue]int;                                                                 
 var tmp83611047: int;                                                                              
 var tmp153611354: bool;                                                                            
 var tmp63611130: int;                                                                              
 var moverPath3611179: MoverPath;                                                                   
 var tmp93611130: Array.Queue.T;                                                                    
 var Array.Queue.T._state3611583: [Array.Queue.T]State;                                             
 var tmp323611505: int;                                                                             
 var this3611057: Queue;                                                                            
 var tmp153611170: bool;                                                                            
 var o3611505: Seq.int;                                                                             
 var this3611418: Queue;                                                                            
 var Queue.elems3611068: [Queue]Array.Queue.T;                                                      
 var tmp363611438: bool;                                                                            
 var tmp223611646: Seq.int;                                                                         
 var tmp243611438: int;                                                                             
 var tmp73611024: int;                                                                              
 var Array.Queue.T._length3611663: [Array.Queue.T]int;                                              
 var tmp93611354: Array.Queue.T;                                                                    
 var tid3611418: Tid;                                                                               
 var tmp243611508: int;                                                                             
 var tmp53611418: bool;                                                                             
 var Queue.tail3611505: [Queue]int;                                                                 
 var Queue.spec3611418: [Queue]Seq.int;                                                             
 var tmp433611534: int;                                                                             
 var Queue.spec3611293: [Queue]Seq.int;                                                             
 var tmp37: bool;                                                                                   
 var tmp153611505: bool;                                                                            
 var tmp443611486: int;                                                                             
 var tmp333611418: int;                                                                             
 var moverPath3611053: MoverPath;                                                                   
 var tmp463611583: int;                                                                             
 var tmp433611596: int;                                                                             
 var tmp153611574: bool;                                                                            
 var tmp93611068: Array.Queue.T;                                                                    
 var tmp143611238: Seq.int;                                                                         
 var o3611179: Seq.int;                                                                             
 var tmp273611561: bool;                                                                            
 var tmp483611596: int;                                                                             
 var Queue._lock3611534: [Queue]Tid;                                                                
 var Queue.spec3611068: [Queue]Seq.int;                                                             
 var tmp143611438: Seq.int;                                                                         
 var Queue.tail3611574: [Queue]int;                                                                 
 var tmp343611495: Seq.int;                                                                         
 var tmp18: int;                                                                                    
 var tmp403611596: bool;                                                                            
 var Queue.elems3611486: [Queue]Array.Queue.T;                                                      
 var tmp103611508: int;                                                                             
 var Queue.spec3611081: [Queue]Seq.int;                                                             
 var tmp55: int;                                                                                    
 var tmp93611179: Array.Queue.T;                                                                    
 var tmp163611192: bool;                                                                            
 var tmp263611406: int;                                                                             
 var tmp73611418: int;                                                                              
 var tmp213611583: int;                                                                             
 var tmp463611646: int;                                                                             
 var Queue.tail3611068: [Queue]int;                                                                 
 var Array.Queue.T._elems3611508: [Array.Queue.T]([int]int);                                        
 var tmp253611293: int;                                                                             
 var tmp253611192: int;                                                                             
 var tmp463611534: int;                                                                             
 var tmp133611293: int;                                                                             
 var $recorded.state3611438: int;                                                                   
 var tmp103611495: int;                                                                             
 var tmp123611534: int;                                                                             
 var tmp73611192: int;                                                                              
 var tmp233611238: Array.Queue.T;                                                                   
 var tmp543611596: bool;                                                                            
 var tmp423611508: Array.Queue.T;                                                                   
 var tmp203611596: bool;                                                                            
 var $result3611505: int;                                                                           
 var tid3611068: Tid;                                                                               
 var tmp173611495: bool;                                                                            
 var tmp463611438: int;                                                                             
 var $result3611130: int;                                                                           
 var tmp353611583: int;                                                                             
 var tmp313611561: bool;                                                                            
 var tmp233611534: Array.Queue.T;                                                                   
 var tmp15: bool;                                                                                   
 var tmp163611642: bool;                                                                            
 var Queue.spec3611047: [Queue]Seq.int;                                                             
 var $result3611561: int;                                                                           
 var Array.Queue.T._elems3611583: [Array.Queue.T]([int]int);                                        
 var tmp73611081: int;                                                                              
 var $result3611495: int;                                                                           
 var tmp353611574: int;                                                                             
 var $recorded.state3611192: int;                                                                   
 var tmp73611653: int;                                                                              
 var Queue.head3611646: [Queue]int;                                                                 
 var tmp283611508: bool;                                                                            
 var tmp63611646: int;                                                                              
 var path3611047: int;                                                                              
 var tmp103611505: int;                                                                             
 var tmp103611081: int;                                                                             
 var tmp243611179: int;                                                                             
 var tmp63611508: int;                                                                              
 var tmp143611505: Seq.int;                                                                         
 var Queue.elems3611354: [Queue]Array.Queue.T;                                                      
 var result3611406: int;                                                                            
 var tmp283611596: bool;                                                                            
 var tmp403611508: bool;                                                                            
 var Queue.spec3611157: [Queue]Seq.int;                                                             
 var tmp373611534: bool;                                                                            
 var tmp223611293: Seq.int;                                                                         
 var tmp213611505: int;                                                                             
 var tmp133611486: int;                                                                             
 var tmp403611438: bool;                                                                            
 var tmp83611081: int;                                                                              
 var Queue.head3611508: [Queue]int;                                                                 
 var tmp273611574: bool;                                                                            
 var _pc3611534: Phase;                                                                             
 var tmp83611596: int;                                                                              
 var Queue._state3611057: [Queue]State;                                                             
 var moverPath3611534: MoverPath;                                                                   
 var tid3611157: Tid;                                                                               
 var tid3611354: Tid;                                                                               
 var tmp273611642: bool;                                                                            
 var result3611238: int;                                                                            
 var result3611354: int;                                                                            
 var path3611406: int;                                                                              
 var i3611508: int;                                                                                 
 var Array.Queue.T._elems3611574: [Array.Queue.T]([int]int);                                        
 var tmp73611508: int;                                                                              
 var path3611057: int;                                                                              
 var Array.Queue.T._elems3611057: [Array.Queue.T]([int]int);                                        
 var tmp293611486: bool;                                                                            
 var tmp313611508: bool;                                                                            
 var tmp163611179: bool;                                                                            
 var tmp253611406: int;                                                                             
 var tmp83611438: int;                                                                              
 var Queue._lock3611418: [Queue]Tid;                                                                
 var i3611583: int;                                                                                 
 var Queue.elems3611508: [Queue]Array.Queue.T;                                                      
 var tmp19: Seq.int;                                                                                
 var path3611495: int;                                                                              
 var Array.Queue.T._state3611018: [Array.Queue.T]State;                                             
 var tmp493611574: bool;                                                                            
 var tmp233611508: Array.Queue.T;                                                                   
 var Array.Queue.T._state3611406: [Array.Queue.T]State;                                             
 var tmp83611653: int;                                                                              
 var Queue.spec3611663: [Queue]Seq.int;                                                             
 var tmp27: bool;                                                                                   
 var Queue.head3611653: [Queue]int;                                                                 
 var tmp343611596: Seq.int;                                                                         
 var tmp463611495: int;                                                                             
 var tmp593611642: int;                                                                             
 var tmp453611495: int;                                                                             
 var tmp143611179: Seq.int;                                                                         
 var tmp93611157: Array.Queue.T;                                                                    
 var Queue._lock3611486: [Queue]Tid;                                                                
 var path3611534: int;                                                                              
 var tmp273611438: bool;                                                                            
 var tmp223611157: Seq.int;                                                                         
 var tmp203611179: bool;                                                                            
 var tmp103611157: int;                                                                             
 var Queue.spec3611561: [Queue]Seq.int;                                                             
 var tmp243611574: int;                                                                             
 var Queue.spec3611238: [Queue]Seq.int;                                                             
 var _pc3611653: Phase;                                                                             
 var Array.Queue.T._state3611047: [Array.Queue.T]State;                                             
 var tmp383611642: bool;                                                                            
 var tmp173611534: bool;                                                                            
 var this3611574: Queue;                                                                            
 var tmp323611486: int;                                                                             
 var Queue.spec3611505: [Queue]Seq.int;                                                             
 var tmp293611418: bool;                                                                            
 var Queue.head3611438: [Queue]int;                                                                 
 var tmp93611583: Array.Queue.T;                                                                    
 var i3611486: int;                                                                                 
 var tmp40: bool;                                                                                   
 var Array.Queue.T._length3611157: [Array.Queue.T]int;                                              
 var tmp383611438: bool;                                                                            
 var Array.Queue.T._state3611157: [Array.Queue.T]State;                                             
 var tmp103611406: int;                                                                             
 var tmp233611418: Array.Queue.T;                                                                   
 var tmp203611574: bool;                                                                            
 var $result3611574: int;                                                                           
 var Queue.elems3611495: [Queue]Array.Queue.T;                                                      
 var Array.Queue.T._length3611238: [Array.Queue.T]int;                                              
 var o3611418: Seq.int;                                                                             
 var Queue._state3611642: [Queue]State;                                                             
 var tmp413611534: int;                                                                             
 var Queue.elems3611583: [Queue]Array.Queue.T;                                                      
 var Queue.elems3611438: [Queue]Array.Queue.T;                                                      
 var result3611534: int;                                                                            
 var tmp123611081: int;                                                                             
 var tmp163611583: bool;                                                                            
 var tmp10: int;                                                                                    
 var $recorded.state3611293: int;                                                                   
 var tmp403611642: bool;                                                                            
 var tid3611495: Tid;                                                                               
 var tmp203611418: bool;                                                                            
 var tmp39: int;                                                                                    
 var o3611068: Seq.int;                                                                             
 var tmp573611574: Array.Queue.T;                                                                   
 var tmp483611495: int;                                                                             
 var Array.Queue.T._state3611596: [Array.Queue.T]State;                                             
 var Queue.elems3611406: [Queue]Array.Queue.T;                                                      
 var tmp83611642: int;                                                                              
 var tmp73611170: int;                                                                              
 var tmp293611508: bool;                                                                            
 var tmp93611081: Array.Queue.T;                                                                    
 var tmp153611583: bool;                                                                            
 var tmp403611574: bool;                                                                            
 var tmp433611486: int;                                                                             
 var tmp573611642: Array.Queue.T;                                                                   
 var tmp173611293: bool;                                                                            
 var tmp53611130: bool;                                                                             
 var moverPath3611068: MoverPath;                                                                   
 var tmp163611130: bool;                                                                            
 var this3611406: Queue;                                                                            
 var tmp13: int;                                                                                    
 var path3611068: int;                                                                              
 var tmp443611418: int;                                                                             
 var tmp143611418: Seq.int;                                                                         
 var tmp383611406: bool;                                                                            
 var tmp153611642: bool;                                                                            
 var tmp163611596: bool;                                                                            
 var $recorded.state3611068: int;                                                                   
 var Array.Queue.T._state3611068: [Array.Queue.T]State;                                             
 var $result3611192: int;                                                                           
 var tmp26: int;                                                                                    
 var Array.Queue.T._length3611406: [Array.Queue.T]int;                                              
 var result3611561: int;                                                                            
 var tmp473611596: int;                                                                             
 var tid3611170: Tid;                                                                               
 var Array.Queue.T._elems3611653: [Array.Queue.T]([int]int);                                        
 var i3611505: int;                                                                                 
 var Queue._lock3611354: [Queue]Tid;                                                                
 var tmp233611596: Array.Queue.T;                                                                   
 var tmp373611583: bool;                                                                            
 var Queue.head3611642: [Queue]int;                                                                 
 var tmp243611596: int;                                                                             
 var $recorded.state3611505: int;                                                                   
 var Queue.elems3611642: [Queue]Array.Queue.T;                                                      
 var tmp413611561: int;                                                                             
 var tmp373611642: bool;                                                                            
 var mover3611438: Mover;                                                                           
 var tmp93611192: Array.Queue.T;                                                                    
 var tmp93611418: Array.Queue.T;                                                                    
 var tmp433611646: int;                                                                             
 var moverPath3611047: MoverPath;                                                                   
 var tmp233611505: Array.Queue.T;                                                                   
 var tmp213611642: int;                                                                             
 var mover3611534: Mover;                                                                           
 var tmp503611642: bool;                                                                            
 var Queue.elems3611561: [Queue]Array.Queue.T;                                                      
 var tmp49: bool;                                                                                   
 var tmp353611354: int;                                                                             
 var Array.Queue.T._state3611534: [Array.Queue.T]State;                                             
 var $recorded.state3611179: int;                                                                   
 var path3611192: int;                                                                              
 var $recorded.state3611406: int;                                                                   
 var i3611642: int;                                                                                 
 var this3611508: Queue;                                                                            
 var tmp263611495: int;                                                                             
 var Queue.spec3611642: [Queue]Seq.int;                                                             
 var moverPath3611583: MoverPath;                                                                   
 var tmp203611495: bool;                                                                            
 var tmp353611438: int;                                                                             
 var Queue.tail3611663: [Queue]int;                                                                 
 var tmp123611406: int;                                                                             
 var tmp53611081: bool;                                                                             
 var tmp253611179: int;                                                                             
 var tmp173611438: bool;                                                                            
 var Array.Queue.T._elems3611406: [Array.Queue.T]([int]int);                                        
 var tmp503611596: bool;                                                                            
 var tmp363611495: bool;                                                                            
 var tmp213611238: int;                                                                             
 var _pc3611438: Phase;                                                                             
 var $result3611057: int;                                                                           
 var tmp243611583: int;                                                                             
 var tmp413611646: int;                                                                             
 var tmp163611238: bool;                                                                            
 var tmp343611561: Seq.int;                                                                         
 var tmp143611406: Seq.int;                                                                         
 var path3611081: int;                                                                              
 var Array.Queue.T._length3611179: [Array.Queue.T]int;                                              
 var o3611238: Seq.int;                                                                             
 var o3611486: Seq.int;                                                                             
 var tmp203611486: bool;                                                                            
 var Array.Queue.T._state3611646: [Array.Queue.T]State;                                             
 var tmp563611642: Seq.int;                                                                         
 var Queue._lock3611508: [Queue]Tid;                                                                
 var Queue.head3611053: [Queue]int;                                                                 
 var tmp363611418: bool;                                                                            
 var _pc3611508: Phase;                                                                             
 var tmp493611583: bool;                                                                            
 var tmp103611646: int;                                                                             
 var $result3611068: int;                                                                           
 var tmp333611642: int;                                                                             
 var tmp93611238: Array.Queue.T;                                                                    
 var mover3611293: Mover;                                                                           
 var o3611438: Seq.int;                                                                             
 var tmp363611574: bool;                                                                            
 var _pc3611192: Phase;                                                                             
 var _pc3611053: Phase;                                                                             
 var tmp483611534: int;                                                                             
 var tmp63611047: int;                                                                              
 var tmp283611646: bool;                                                                            
 var tmp103611583: int;                                                                             
 var tmp293611642: bool;                                                                            
 var Queue._lock3611238: [Queue]Tid;                                                                
 var tmp453611508: int;                                                                             
 var tmp173611508: bool;                                                                            
 var mover3611047: Mover;                                                                           
 var tmp313611418: bool;                                                                            
 var tmp143611192: Seq.int;                                                                         
 var tmp163611561: bool;                                                                            
 var _pc3611157: Phase;                                                                             
 var tmp563611561: Seq.int;                                                                         
 var tmp213611406: int;                                                                             
 var tmp133611406: int;                                                                             
 var Queue.tail3611024: [Queue]int;                                                                 
 var tmp213611534: int;                                                                             
 var tmp343611354: Seq.int;                                                                         
 var Queue.spec3611024: [Queue]Seq.int;                                                             
 var moverPath3611505: MoverPath;                                                                   
 var mover3611157: Mover;                                                                           
 var tmp73611018: int;                                                                              
 var Array.Queue.T._length3611170: [Array.Queue.T]int;                                              
 var result3611438: int;                                                                            
 var Queue.head3611534: [Queue]int;                                                                 
 var _pc3611238: Phase;                                                                             
 var $result3611534: int;                                                                           
 var tmp73611486: int;                                                                              
 var i3611130: int;                                                                                 
 var Array.Queue.T._length3611596: [Array.Queue.T]int;                                              
 var tmp153611508: bool;                                                                            
 var tmp253611354: int;                                                                             
 var tmp333611438: int;                                                                             
 var tmp34: Seq.int;                                                                                
 var Queue.head3611238: [Queue]int;                                                                 
 var o3611583: Seq.int;                                                                             
 var Queue.head3611057: [Queue]int;                                                                 
 var tmp60: int;                                                                                    
 var mover3611057: Mover;                                                                           
 var tmp233611192: Array.Queue.T;                                                                   
 var tmp173611486: bool;                                                                            
 var mover3611596: Mover;                                                                           
 var moverPath3611418: MoverPath;                                                                   
 var tmp63611486: int;                                                                              
 var tmp153611418: bool;                                                                            
 var tmp363611642: bool;                                                                            
 var tmp413611438: int;                                                                             
 var tmp153611192: bool;                                                                            
 var result3611053: int;                                                                            
 var tmp413611495: int;                                                                             
 var tmp553611646: int;                                                                             
 var tmp54: bool;                                                                                   
 var tmp143611130: Seq.int;                                                                         
 var tmp53611354: bool;                                                                             
 var _pc3611081: Phase;                                                                             
 var tmp313611646: bool;                                                                            
 var moverPath3611561: MoverPath;                                                                   
 var tmp12: int;                                                                                    
 var Array.Queue.T._length3611574: [Array.Queue.T]int;                                              
 var moverPath3611130: MoverPath;                                                                   
 var tmp163611534: bool;                                                                            
 var this3611505: Queue;                                                                            
 var Queue.tail3611157: [Queue]int;                                                                 
 var Queue.elems3611238: [Queue]Array.Queue.T;                                                      
 var tmp93611486: Array.Queue.T;                                                                    
 var tmp383611596: bool;                                                                            
 var Array.Queue.T._state3611192: [Array.Queue.T]State;                                             
 var tmp483611642: int;                                                                             
 var Queue._state3611354: [Queue]State;                                                             
 var tmp373611505: bool;                                                                            
 var i3611495: int;                                                                                 
 var tmp433611508: int;                                                                             
 var tmp163611574: bool;                                                                            
 var tmp44: int;                                                                                    
 var path3611024: int;                                                                              
 var moverPath3611170: MoverPath;                                                                   
 var tmp343611293: Seq.int;                                                                         
 var tmp313611596: bool;                                                                            
 var mover3611179: Mover;                                                                           
 var $result3611646: int;                                                                           
 var Array.Queue.T._length3611354: [Array.Queue.T]int;                                              
 var Queue._lock3611596: [Queue]Tid;                                                                
 var tmp143611495: Seq.int;                                                                         
 var Queue._state3611024: [Queue]State;                                                             
 var tmp133611238: int;                                                                             
 var this3611238: Queue;                                                                            
 var Queue.head3611179: [Queue]int;                                                                 
 var Queue._lock3611561: [Queue]Tid;                                                                
 var tmp243611406: int;                                                                             
 var tmp93611495: Array.Queue.T;                                                                    
 var tmp563611583: Seq.int;                                                                         
 var Queue._state3611157: [Queue]State;                                                             
 var tmp123611238: int;                                                                             
 var tmp53611157: bool;                                                                             
 var tmp73611157: int;                                                                              
 var Array.Queue.T._length3611646: [Array.Queue.T]int;                                              
 var tmp63611192: int;                                                                              
 var Queue._state3611053: [Queue]State;                                                             
 var Array.Queue.T._elems3611495: [Array.Queue.T]([int]int);                                        
 var result3611646: int;                                                                            
 var _pc3611486: Phase;                                                                             
 var tmp133611596: int;                                                                             
 var tmp83611406: int;                                                                              
 var $result3611438: int;                                                                           
 var tid3611596: Tid;                                                                               
 var tmp253611596: int;                                                                             
 var $recorded.state3611057: int;                                                                   
 var tmp513611574: bool;                                                                            
 var tmp383611508: bool;                                                                            
 var tmp323611642: int;                                                                             
 var o3611508: Seq.int;                                                                             
 var Queue._state3611646: [Queue]State;                                                             
 var tmp413611406: int;                                                                             
 var tmp383611418: bool;                                                                            
 var Array.Queue.T._state3611505: [Array.Queue.T]State;                                             
 var tmp123611293: int;                                                                             
 var tmp333611495: int;                                                                             
 var tmp46: int;                                                                                    
 var tmp363611561: bool;                                                                            
 var tmp433611495: int;                                                                             
 var Queue.spec3611170: [Queue]Seq.int;                                                             
 var this3611495: Queue;                                                                            
 var Queue.elems3611596: [Queue]Array.Queue.T;                                                      
 var tmp73611293: int;                                                                              
 var _pc3611574: Phase;                                                                             
 var tmp113611583: Seq.int;                                                                         
 var Queue._state3611663: [Queue]State;                                                             
 var tmp63611505: int;                                                                              
 var _pc3611561: Phase;                                                                             
 var tmp53611495: bool;                                                                             
 var tmp363611534: bool;                                                                            
 var $recorded.state3611130: int;                                                                   
 var tmp73611583: int;                                                                              
 var tmp56: Seq.int;                                                                                
 var tmp173611179: bool;                                                                            
 var tmp53611170: bool;                                                                             
 var path3611157: int;                                                                              
 var Queue._lock3611646: [Queue]Tid;                                                                
 var Queue.head3611024: [Queue]int;                                                                 
 var tmp123611646: int;                                                                             
 var tmp83611192: int;                                                                              
 var Array.Queue.T._state3611179: [Array.Queue.T]State;                                             
 var Array.Queue.T._elems3611293: [Array.Queue.T]([int]int);                                        
 var tmp93611047: Array.Queue.T;                                                                    
 var $recorded.state3611596: int;                                                                   
 var mover3611018: Mover;                                                                           
 var tmp63611024: int;                                                                              
 var Array.Queue.T._state3611438: [Array.Queue.T]State;                                             
 var tmp583611642: int;                                                                             
 var tmp513611646: bool;                                                                            
 var tmp9: Array.Queue.T;                                                                           
 var tmp503611583: bool;                                                                            
 var this3611438: Queue;                                                                            
 var tid3611505: Tid;                                                                               
 var tmp203611505: bool;                                                                            
 var i3611646: int;                                                                                 
 var tmp7: int;                                                                                     
 var Queue._lock3611495: [Queue]Tid;                                                                
 var tmp113611561: Seq.int;                                                                         
 var $recorded.state3611024: int;                                                                   
 var Queue.head3611561: [Queue]int;                                                                 
 var tmp73611057: int;                                                                              
 var tmp323611646: int;                                                                             
 var Array.Queue.T._elems3611130: [Array.Queue.T]([int]int);                                        
 var mover3611406: Mover;                                                                           
 var mover3611170: Mover;                                                                           
 var tmp243611646: int;                                                                             
 var tmp503611534: bool;                                                                            
 var tmp373611574: bool;                                                                            
 var tmp243611561: int;                                                                             
 var tmp213611179: int;                                                                             
 var tmp103611486: int;                                                                             
 var tmp213611192: int;                                                                             
 var tmp53611574: bool;                                                                             
 var tmp423611505: Array.Queue.T;                                                                   
 var tmp203611157: bool;                                                                            
 var tmp343611486: Seq.int;                                                                         
 var Array.Queue.T._length3611653: [Array.Queue.T]int;                                              
 var _pc3611406: Phase;                                                                             
 var Array.Queue.T._elems3611081: [Array.Queue.T]([int]int);                                        
 var this3611583: Queue;                                                                            
 var tmp353611495: int;                                                                             
 var Queue._state3611068: [Queue]State;                                                             
 var tmp353611596: int;                                                                             
 var tmp173611238: bool;                                                                            
 var tmp103611057: int;                                                                             
 var tmp423611583: Array.Queue.T;                                                                   
 var tid3611561: Tid;                                                                               
 var Array.Queue.T._length3611486: [Array.Queue.T]int;                                              
 var tmp313611495: bool;                                                                            
 var tmp123611486: int;                                                                             
 var tmp223611418: Seq.int;                                                                         
 var tid3611024: Tid;                                                                               
 var tmp443611596: int;                                                                             
 var Queue.head3611418: [Queue]int;                                                                 
 var tmp463611508: int;                                                                             
 var tmp133611192: int;                                                                             
 var tmp53611192: bool;                                                                             
 var tmp73611179: int;                                                                              
 var this3611192: Queue;                                                                            
 var o3611495: Seq.int;                                                                             
 var Queue.spec3611495: [Queue]Seq.int;                                                             
 var tmp63611238: int;                                                                              
 var tmp353611534: int;                                                                             
 var tmp53: Seq.int;                                                                                
 var tmp53611018: bool;                                                                             
 var tmp163611293: bool;                                                                            
 var tmp73611047: int;                                                                              
 var tmp403611583: bool;                                                                            
 var tmp59: int;                                                                                    
 var tmp153611495: bool;                                                                            
 var tmp53611583: bool;                                                                             
 var tmp63611293: int;                                                                              
 var Queue.elems3611057: [Queue]Array.Queue.T;                                                      
 var Array.Queue.T._elems3611170: [Array.Queue.T]([int]int);                                        
 var tmp403611646: bool;                                                                            
 var tmp83611561: int;                                                                              
 var tmp93611170: Array.Queue.T;                                                                    
 var tmp493611646: bool;                                                                            
 var i3611438: int;                                                                                 
 var tmp53611406: bool;                                                                             
 var tmp323611596: int;                                                                             
 var $recorded.state3611646: int;                                                                   
 var tmp543611583: bool;                                                                            
 var Queue.spec3611486: [Queue]Seq.int;                                                             
 var tmp123611157: int;                                                                             
 var Queue.head3611406: [Queue]int;                                                                 
 var path3611596: int;                                                                              
 var tmp333611508: int;                                                                             
 var tmp433611583: int;                                                                             
 var tmp453611561: int;                                                                             
 var tmp413611574: int;                                                                             
 var tmp403611495: bool;                                                                            
 var tmp233611179: Array.Queue.T;                                                                   
 var tmp603611596: int;                                                                             
 var tmp453611486: int;                                                                             
 var tmp243611354: int;                                                                             
 var Array.Queue.T._elems3611192: [Array.Queue.T]([int]int);                                        
 var tmp24: int;                                                                                    
 var tmp103611170: int;                                                                             
 var o3611170: Seq.int;                                                                             
 var tmp143611642: Seq.int;                                                                         
 var tmp17: bool;                                                                                   
 var tmp63611157: int;                                                                              
 var moverPath3611574: MoverPath;                                                                   
 var Queue._lock3611068: [Queue]Tid;                                                                
 var tmp93611057: Array.Queue.T;                                                                    
 var tmp123611179: int;                                                                             
 var tmp103611068: int;                                                                             
 var Queue._state3611238: [Queue]State;                                                             
 var tmp263611583: int;                                                                             
 var tmp213611486: int;                                                                             
 var tmp433611505: int;                                                                             
 var tmp63611418: int;                                                                              
 var tid3611057: Tid;                                                                               
 var $recorded.state3611354: int;                                                                   
 var i3611534: int;                                                                                 
 var Queue._lock3611642: [Queue]Tid;                                                                
 var moverPath3611438: MoverPath;                                                                   
 var $result3611596: int;                                                                           
 var Queue._state3611418: [Queue]State;                                                             
 var tmp323611495: int;                                                                             
 var Array.Queue.T._state3611508: [Array.Queue.T]State;                                             
 var tmp123611596: int;                                                                             
 var tmp223611642: Seq.int;                                                                         
 var Queue._state3611486: [Queue]State;                                                             
 var tmp153611238: bool;                                                                            
 var tmp33: int;                                                                                    
 var tmp283611293: bool;                                                                            
 var Array.Queue.T._state3611130: [Array.Queue.T]State;                                             
 var _pc3611642: Phase;                                                                             
 var o3611293: Seq.int;                                                                             
 var moverPath3611293: MoverPath;                                                                   
 var tmp173611406: bool;                                                                            
 var tmp83611574: int;                                                                              
 var path3611438: int;                                                                              
 var Queue.spec3611583: [Queue]Seq.int;                                                             
 var tmp203611561: bool;                                                                            
 var Queue.tail3611192: [Queue]int;                                                                 
 var Queue.head3611170: [Queue]int;                                                                 
 var tmp283611534: bool;                                                                            
 var Array.Queue.T._length3611018: [Array.Queue.T]int;                                              
 var Array.Queue.T._length3611438: [Array.Queue.T]int;                                              
 var result3611508: int;                                                                            
 var tmp483611583: int;                                                                             
 var tmp133611574: int;                                                                             
 var $recorded.state3611574: int;                                                                   
 var tmp513611534: bool;                                                                            
 var _pc3611354: Phase;                                                                             
 var tmp273611486: bool;                                                                            
 var tmp133611534: int;                                                                             
 var tmp83611293: int;                                                                              
 var Queue.tail3611646: [Queue]int;                                                                 
 var tmp153611596: bool;                                                                            
 var tmp103611642: int;                                                                             
 var tmp53611438: bool;                                                                             
 var Array.Queue.T._length3611068: [Array.Queue.T]int;                                              
 var Queue._lock3611653: [Queue]Tid;                                                                
 var Queue.spec3611179: [Queue]Seq.int;                                                             
 var tmp333611534: int;                                                                             
 var Queue._state3611018: [Queue]State;                                                             
 var i3611293: int;                                                                                 
 var tmp243611192: int;                                                                             
 var tmp293611534: bool;                                                                            
 var tid3611653: Tid;                                                                               
 var tmp233611438: Array.Queue.T;                                                                   
 var tmp373611406: bool;                                                                            
 var tmp263611574: int;                                                                             
 var tmp113611130: Seq.int;                                                                         
 var tmp123611354: int;                                                                             
 var tmp53611068: bool;                                                                             
 var tmp573611646: Array.Queue.T;                                                                   
 var o3611157: Seq.int;                                                                             
 var tmp173611596: bool;                                                                            
 var tmp383611646: bool;                                                                            
 var $result3611354: int;                                                                           
 var Array.Queue.T._elems3611024: [Array.Queue.T]([int]int);                                        
 var tmp273611354: bool;                                                                            
 var Array.Queue.T._state3611642: [Array.Queue.T]State;                                             
 var tmp53611047: bool;                                                                             
 var tid3611642: Tid;                                                                               
 var tmp52: int;                                                                                    
 var tmp263611486: int;                                                                             
 var tmp213611646: int;                                                                             
 var tmp103611179: int;                                                                             
 var mover3611024: Mover;                                                                           
 var Queue.head3611192: [Queue]int;                                                                 
 var mover3611130: Mover;                                                                           
 var tmp223611354: Seq.int;                                                                         
 var tmp543611561: bool;                                                                            
 var Queue._lock3611053: [Queue]Tid;                                                                
 var path3611293: int;                                                                              
 var tmp223611505: Seq.int;                                                                         
 var tmp323611574: int;                                                                             
 var mover3611081: Mover;                                                                           
 var tmp83611534: int;                                                                              
 var tmp53611053: bool;                                                                             
 var tmp133611179: int;                                                                             
 var tmp25: int;                                                                                    
 var tmp323611438: int;                                                                             
 var Queue.tail3611130: [Queue]int;                                                                 
 var Queue.tail3611596: [Queue]int;                                                                 
 var tmp51: bool;                                                                                   
 var tmp123611505: int;                                                                             
 var Queue._lock3611406: [Queue]Tid;                                                                
 var $result3611663: int;                                                                           
 var path3611508: int;                                                                              
 var tmp203611438: bool;                                                                            
 var this3611047: Queue;                                                                            
 var mover3611505: Mover;                                                                           
 var tmp253611238: int;                                                                             
 var path3611418: int;                                                                              
 var tmp163611495: bool;                                                                            
 var tmp173611505: bool;                                                                            
 var Queue.elems3611024: [Queue]Array.Queue.T;                                                      
 var $recorded.state3611418: int;                                                                   
 var tmp83611068: int;                                                                              
 var tmp233611561: Array.Queue.T;                                                                   
 var mover3611561: Mover;                                                                           
 var tmp423611561: Array.Queue.T;                                                                   
 var Queue._lock3611057: [Queue]Tid;                                                                
 var Queue._state3611505: [Queue]State;                                                             
 var tmp263611508: int;                                                                             
 var Queue.elems3611646: [Queue]Array.Queue.T;                                                      
 var Array.Queue.T._state3611170: [Array.Queue.T]State;                                             
 var tmp563611646: Seq.int;                                                                         
 var tmp233611406: Array.Queue.T;                                                                   
 var tmp223611486: Seq.int;                                                                         
 var tmp103611438: int;                                                                             
 var tmp203611508: bool;                                                                            
 var Array.Queue.T._state3611057: [Array.Queue.T]State;                                             
 var tmp273611534: bool;                                                                            
 var tmp333611505: int;                                                                             
 var Queue.tail3611053: [Queue]int;                                                                 
 var tmp243611505: int;                                                                             
 var mover3611508: Mover;                                                                           
 var tmp413611486: int;                                                                             
 var tid3611047: Tid;                                                                               
 var tmp41: int;                                                                                    
 var tmp83611130: int;                                                                              
 var tmp83611057: int;                                                                              
 var tmp343611574: Seq.int;                                                                         
 var tmp113611293: Seq.int;                                                                         
 var Queue.head3611663: [Queue]int;                                                                 
 var Queue.spec3611406: [Queue]Seq.int;                                                             
 var Queue.tail3611057: [Queue]int;                                                                 
 var $recorded.state3611495: int;                                                                   
 var Queue.head3611293: [Queue]int;                                                                 
 var Array.Queue.T._state3611418: [Array.Queue.T]State;                                             
 var tmp113611068: Seq.int;                                                                         
 var Array.Queue.T._elems3611157: [Array.Queue.T]([int]int);                                        
 var tmp253611486: int;                                                                             
 var tmp213611495: int;                                                                             
 var $recorded.state3611157: int;                                                                   
 var tmp333611486: int;                                                                             
 var tmp173611561: bool;                                                                            
 var Array.Queue.T._length3611024: [Array.Queue.T]int;                                              
 var Array.Queue.T._elems3611663: [Array.Queue.T]([int]int);                                        
 var tmp103611561: int;                                                                             
 var tmp213611438: int;                                                                             
 var Queue.elems3611053: [Queue]Array.Queue.T;                                                      
 var tmp53611561: bool;                                                                             
 var o3611596: Seq.int;                                                                             
 var tmp433611418: int;                                                                             
 var tmp73611534: int;                                                                              
 var tmp57: Array.Queue.T;                                                                          
 var tmp423611406: Array.Queue.T;                                                                   
 var mover3611495: Mover;                                                                           
 var moverPath3611495: MoverPath;                                                                   
 var tmp83611179: int;                                                                              
 var _pc3611495: Phase;                                                                             
 var Queue.tail3611018: [Queue]int;                                                                 
 var tmp63611081: int;                                                                              
 var tmp413611508: int;                                                                             
 var this3611354: Queue;                                                                            
 var tmp473611646: int;                                                                             
 var i3611170: int;                                                                                 
 var Queue.spec3611053: [Queue]Seq.int;                                                             
 var tmp6: int;                                                                                     
 var tmp253611534: int;                                                                             
 var tmp443611508: int;                                                                             
 var tmp553611583: int;                                                                             
 var tmp323611418: int;                                                                             
 var tmp343611583: Seq.int;                                                                         
 var Queue._lock3611170: [Queue]Tid;                                                                
 var tmp263611238: int;                                                                             
 var Queue.elems3611170: [Queue]Array.Queue.T;                                                      
 var tmp333611583: int;                                                                             
 var tmp133611418: int;                                                                             
 var tmp53611508: bool;                                                                             
 var tmp63611653: int;                                                                              
 var Queue.tail3611583: [Queue]int;                                                                 
 var $recorded.state3611583: int;                                                                   
 var tmp203611192: bool;                                                                            
 var tmp273611418: bool;                                                                            
 var tmp333611596: int;                                                                             
 var tmp63611534: int;                                                                              
 var Array.Queue.T._state3611293: [Array.Queue.T]State;                                             
 var tmp63611583: int;                                                                              
 var tmp293611561: bool;                                                                            
 var tmp313611583: bool;                                                                            
 var tmp113611642: Seq.int;                                                                         
 var moverPath3611157: MoverPath;                                                                   
 var Queue._state3611130: [Queue]State;                                                             
 var Array.Queue.T._elems3611534: [Array.Queue.T]([int]int);                                        
 var result3611486: int;                                                                            
 var tid3611053: Tid;                                                                               
 var tid3611574: Tid;                                                                               
 var tmp73611068: int;                                                                              
 var tmp45: int;                                                                                    
 var tid3611406: Tid;                                                                               
 var Queue._state3611170: [Queue]State;                                                             
 var tmp143611508: Seq.int;                                                                         
 var tid3611646: Tid;                                                                               
 var tmp493611642: bool;                                                                            
 var tmp133611354: int;                                                                             
 var tmp343611508: Seq.int;                                                                         
 var tmp263611646: int;                                                                             
                                                                                                    
 var _pc : Phase;                                                                                   
 _pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (35.23): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume Queue._lock[this] == Tid.null;                                                              
 _pc := transition(_pc, _R);                                                                        
 assert _pc != PhaseError;                                                                                 // (35.23): Reduction failure
 Queue._lock[this] := tid;                                                                          
                                                                                                    
 // 36.13: bool tmp5;                                                                               
                                                                                                    
                                                                                                    
 // 36.13: int tmp6;                                                                                
                                                                                                    
                                                                                                    
 // 36.13: int tmp7;                                                                                
                                                                                                    
                                                                                                    
 // 36.13: tmp7 := this.tail;                                                                       
                                                                                                    
                                                                                                    
 moverPath3611018 := ReadEval.Queue.tail(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3611018 := m#moverPath(moverPath3611018);                                                     
 path3611018 := p#moverPath(moverPath3611018);                                                      
 assume Queue._state3611018 == Queue._state && Queue.elems3611018 == Queue.elems && Queue.head3611018 == Queue.head && Queue.tail3611018 == Queue.tail && Queue.spec3611018 == Queue.spec && Queue._lock3611018 == Queue._lock && Array.Queue.T._state3611018 == Array.Queue.T._state && Array.Queue.T._elems3611018 == Array.Queue.T._elems && Array.Queue.T._length3611018 == Array.Queue.T._length && tmp73611018 == tmp7 && tmp63611018 == tmp6 && tmp53611018 == tmp5 && $result3611018 == $result && this3611018 == this && tid3611018 == tid && _pc3611018 == _pc;
 assume $recorded.state3611018 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (36.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 _pc := transition(_pc, mover3611018);                                                              
 assert _pc != PhaseError;                                                                                 // (36.13): Reduction failure
 tmp7 := Queue.tail[this];                                                                          
                                                                                                    
 // 36.13: int tmp8;                                                                                
                                                                                                    
                                                                                                    
 // 36.13: tmp8 := this.head;                                                                       
                                                                                                    
                                                                                                    
 moverPath3611024 := ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3611024 := m#moverPath(moverPath3611024);                                                     
 path3611024 := p#moverPath(moverPath3611024);                                                      
 assume Queue._state3611024 == Queue._state && Queue.elems3611024 == Queue.elems && Queue.head3611024 == Queue.head && Queue.tail3611024 == Queue.tail && Queue.spec3611024 == Queue.spec && Queue._lock3611024 == Queue._lock && Array.Queue.T._state3611024 == Array.Queue.T._state && Array.Queue.T._elems3611024 == Array.Queue.T._elems && Array.Queue.T._length3611024 == Array.Queue.T._length && tmp83611024 == tmp8 && tmp73611024 == tmp7 && tmp63611024 == tmp6 && tmp53611024 == tmp5 && $result3611024 == $result && this3611024 == this && tid3611024 == tid && _pc3611024 == _pc;
 assume $recorded.state3611024 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (36.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 _pc := transition(_pc, mover3611024);                                                              
 assert _pc != PhaseError;                                                                                 // (36.13): Reduction failure
 tmp8 := Queue.head[this];                                                                          
                                                                                                    
 // 36.13: tmp6 = tmp7 - tmp8;                                                                      
                                                                                                    
 tmp6 := (tmp7-tmp8);                                                                               
                                                                                                    
 // 36.13: tmp5 = tmp6 > 0;                                                                         
                                                                                                    
 tmp5 := (tmp6>0);                                                                                  
 if (tmp5 /* lowered ((Queue.tail[this]-Queue.head[this])>0) */) {                                  
                                                                                                    
  // 37.17: int result;                                                                             
                                                                                                    
                                                                                                    
  // 37.17: [Queue.T{this}] tmp9;                                                                   
                                                                                                    
                                                                                                    
  // 37.17: tmp9 := this.elems;                                                                     
                                                                                                    
                                                                                                    
  moverPath3611047 := ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611047 := m#moverPath(moverPath3611047);                                                    
  path3611047 := p#moverPath(moverPath3611047);                                                     
  assume Queue._state3611047 == Queue._state && Queue.elems3611047 == Queue.elems && Queue.head3611047 == Queue.head && Queue.tail3611047 == Queue.tail && Queue.spec3611047 == Queue.spec && Queue._lock3611047 == Queue._lock && Array.Queue.T._state3611047 == Array.Queue.T._state && Array.Queue.T._elems3611047 == Array.Queue.T._elems && Array.Queue.T._length3611047 == Array.Queue.T._length && tmp93611047 == tmp9 && result3611047 == result && tmp83611047 == tmp8 && tmp73611047 == tmp7 && tmp63611047 == tmp6 && tmp53611047 == tmp5 && $result3611047 == $result && this3611047 == this && tid3611047 == tid && _pc3611047 == _pc;
  assume $recorded.state3611047 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (37.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611047);                                                             
  assert _pc != PhaseError;                                                                                // (37.17): Reduction failure
  tmp9 := Queue.elems[this];                                                                        
                                                                                                    
  // 37.17: int tmp10;                                                                              
                                                                                                    
                                                                                                    
  // 37.17: tmp10 := this.head;                                                                     
                                                                                                    
                                                                                                    
  moverPath3611053 := ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611053 := m#moverPath(moverPath3611053);                                                    
  path3611053 := p#moverPath(moverPath3611053);                                                     
  assume Queue._state3611053 == Queue._state && Queue.elems3611053 == Queue.elems && Queue.head3611053 == Queue.head && Queue.tail3611053 == Queue.tail && Queue.spec3611053 == Queue.spec && Queue._lock3611053 == Queue._lock && Array.Queue.T._state3611053 == Array.Queue.T._state && Array.Queue.T._elems3611053 == Array.Queue.T._elems && Array.Queue.T._length3611053 == Array.Queue.T._length && tmp103611053 == tmp10 && tmp93611053 == tmp9 && result3611053 == result && tmp83611053 == tmp8 && tmp73611053 == tmp7 && tmp63611053 == tmp6 && tmp53611053 == tmp5 && $result3611053 == $result && this3611053 == this && tid3611053 == tid && _pc3611053 == _pc;
  assume $recorded.state3611053 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (37.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611053);                                                             
  assert _pc != PhaseError;                                                                                // (37.17): Reduction failure
  tmp10 := Queue.head[this];                                                                        
                                                                                                    
  // 37.17: result := tmp9[tmp10];                                                                  
                                                                                                    
                                                                                                    
  moverPath3611057 := ReadEval.Array.Queue.T(tid: Tid,this: Queue,tmp9: Array.Queue.T,tmp10: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611057 := m#moverPath(moverPath3611057);                                                    
  path3611057 := p#moverPath(moverPath3611057);                                                     
  assume Queue._state3611057 == Queue._state && Queue.elems3611057 == Queue.elems && Queue.head3611057 == Queue.head && Queue.tail3611057 == Queue.tail && Queue.spec3611057 == Queue.spec && Queue._lock3611057 == Queue._lock && Array.Queue.T._state3611057 == Array.Queue.T._state && Array.Queue.T._elems3611057 == Array.Queue.T._elems && Array.Queue.T._length3611057 == Array.Queue.T._length && tmp103611057 == tmp10 && tmp93611057 == tmp9 && result3611057 == result && tmp83611057 == tmp8 && tmp73611057 == tmp7 && tmp63611057 == tmp6 && tmp53611057 == tmp5 && $result3611057 == $result && this3611057 == this && tid3611057 == tid && _pc3611057 == _pc;
  assume $recorded.state3611057 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume tmp9 != Array.Queue.T.null;                                                               
  } else {                                                                                          
   assert tmp9 != Array.Queue.T.null;                                                                      // (37.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume 0 <= tmp10;                                                                               
  } else {                                                                                          
   assert 0 <= tmp10;                                                                                      // (37.17): index < 0.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume tmp10 < Array.Queue.T._length[tmp9];                                                      
  } else {                                                                                          
   assert tmp10 < Array.Queue.T._length[tmp9];                                                             // (37.17): index is >= length.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611057);                                                             
  assert _pc != PhaseError;                                                                                // (37.17): Reduction failure
  result := Array.Queue.T._elems[tmp9][tmp10];                                                      
                                                                                                    
  // 38.17: Seq<int> o;                                                                             
                                                                                                    
                                                                                                    
  // 38.17: Seq<int> tmp11;                                                                         
                                                                                                    
                                                                                                    
  // 38.17: tmp11 := this.spec;                                                                     
                                                                                                    
                                                                                                    
  moverPath3611068 := ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611068 := m#moverPath(moverPath3611068);                                                    
  path3611068 := p#moverPath(moverPath3611068);                                                     
  assume Queue._state3611068 == Queue._state && Queue.elems3611068 == Queue.elems && Queue.head3611068 == Queue.head && Queue.tail3611068 == Queue.tail && Queue.spec3611068 == Queue.spec && Queue._lock3611068 == Queue._lock && Array.Queue.T._state3611068 == Array.Queue.T._state && Array.Queue.T._elems3611068 == Array.Queue.T._elems && Array.Queue.T._length3611068 == Array.Queue.T._length && tmp113611068 == tmp11 && o3611068 == o && tmp103611068 == tmp10 && tmp93611068 == tmp9 && result3611068 == result && tmp83611068 == tmp8 && tmp73611068 == tmp7 && tmp63611068 == tmp6 && tmp53611068 == tmp5 && $result3611068 == $result && this3611068 == this && tid3611068 == tid && _pc3611068 == _pc;
  assume $recorded.state3611068 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (38.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611068);                                                             
  assert _pc != PhaseError;                                                                                // (38.17): Reduction failure
  tmp11 := Queue.spec[this];                                                                        
                                                                                                    
  // 38.17: int tmp12;                                                                              
                                                                                                    
                                                                                                    
  // 38.17: int tmp13;                                                                              
                                                                                                    
                                                                                                    
  // 38.17: Seq<int> tmp14;                                                                         
                                                                                                    
                                                                                                    
  // 38.17: tmp14 := this.spec;                                                                     
                                                                                                    
                                                                                                    
  moverPath3611081 := ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611081 := m#moverPath(moverPath3611081);                                                    
  path3611081 := p#moverPath(moverPath3611081);                                                     
  assume Queue._state3611081 == Queue._state && Queue.elems3611081 == Queue.elems && Queue.head3611081 == Queue.head && Queue.tail3611081 == Queue.tail && Queue.spec3611081 == Queue.spec && Queue._lock3611081 == Queue._lock && Array.Queue.T._state3611081 == Array.Queue.T._state && Array.Queue.T._elems3611081 == Array.Queue.T._elems && Array.Queue.T._length3611081 == Array.Queue.T._length && tmp143611081 == tmp14 && tmp133611081 == tmp13 && tmp123611081 == tmp12 && tmp113611081 == tmp11 && o3611081 == o && tmp103611081 == tmp10 && tmp93611081 == tmp9 && result3611081 == result && tmp83611081 == tmp8 && tmp73611081 == tmp7 && tmp63611081 == tmp6 && tmp53611081 == tmp5 && $result3611081 == $result && this3611081 == this && tid3611081 == tid && _pc3611081 == _pc;
  assume $recorded.state3611081 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (38.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611081);                                                             
  assert _pc != PhaseError;                                                                                // (38.17): Reduction failure
  tmp14 := Queue.spec[this];                                                                        
                                                                                                    
  // 38.17: tmp13 = SeqLen<int>(tmp14);                                                             
                                                                                                    
  tmp13 := SeqLen.int(tmp14);                                                                       
                                                                                                    
  // 38.17: tmp12 = tmp13 - 1;                                                                      
                                                                                                    
  tmp12 := (tmp13-1);                                                                               
                                                                                                    
  // 38.17: o = SeqExtract<int>(tmp11,1,tmp12);                                                     
                                                                                                    
  o := SeqExtract.int(tmp11,1,tmp12);                                                               
                                                                                                    
  // 39.17: int i;                                                                                  
                                                                                                    
                                                                                                    
  // 40.17: bool tmp15;                                                                             
                                                                                                    
                                                                                                    
  // 40.17: bool tmp16;                                                                             
                                                                                                    
                                                                                                    
  // 40.17: bool tmp17;                                                                             
                                                                                                    
                                                                                                    
  // 40.17: tmp17 = 0 <= i;                                                                         
                                                                                                    
  tmp17 := (0<=i);                                                                                  
  if (tmp17) {                                                                                      
                                                                                                    
   // 40.38: int tmp18;                                                                             
                                                                                                    
                                                                                                    
   // 40.45: Seq<int> tmp19;                                                                        
                                                                                                    
                                                                                                    
   // 40.45: tmp19 := this.spec;                                                                    
                                                                                                    
                                                                                                    
   moverPath3611130 := ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
   mover3611130 := m#moverPath(moverPath3611130);                                                   
   path3611130 := p#moverPath(moverPath3611130);                                                    
   assume Queue._state3611130 == Queue._state && Queue.elems3611130 == Queue.elems && Queue.head3611130 == Queue.head && Queue.tail3611130 == Queue.tail && Queue.spec3611130 == Queue.spec && Queue._lock3611130 == Queue._lock && Array.Queue.T._state3611130 == Array.Queue.T._state && Array.Queue.T._elems3611130 == Array.Queue.T._elems && Array.Queue.T._length3611130 == Array.Queue.T._length && tmp193611130 == tmp19 && tmp183611130 == tmp18 && tmp173611130 == tmp17 && tmp163611130 == tmp16 && tmp153611130 == tmp15 && i3611130 == i && tmp143611130 == tmp14 && tmp133611130 == tmp13 && tmp123611130 == tmp12 && tmp113611130 == tmp11 && o3611130 == o && tmp103611130 == tmp10 && tmp93611130 == tmp9 && result3611130 == result && tmp83611130 == tmp8 && tmp73611130 == tmp7 && tmp63611130 == tmp6 && tmp53611130 == tmp5 && $result3611130 == $result && this3611130 == this && tid3611130 == tid && _pc3611130 == _pc;
   assume $recorded.state3611130 == 1;                                                              
   if (_pc == PreCommit) {                                                                          
    assume this != Queue.null;                                                                      
   } else {                                                                                         
    assert this != Queue.null;                                                                             // (40.45): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   _pc := transition(_pc, mover3611130);                                                            
   assert _pc != PhaseError;                                                                               // (40.45): Reduction failure
   tmp19 := Queue.spec[this];                                                                       
                                                                                                    
   // 40.38: tmp18 = SeqLen<int>(tmp19);                                                            
                                                                                                    
   tmp18 := SeqLen.int(tmp19);                                                                      
                                                                                                    
   // 40.36: tmp16 = i < tmp18;                                                                     
                                                                                                    
   tmp16 := (i<tmp18);                                                                              
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 40.17: bool tmp20;                                                                             
                                                                                                    
                                                                                                    
  // 40.17: int tmp21;                                                                              
                                                                                                    
                                                                                                    
  // 40.17: Seq<int> tmp22;                                                                         
                                                                                                    
                                                                                                    
  // 40.17: tmp22 := this.spec;                                                                     
                                                                                                    
                                                                                                    
  moverPath3611157 := ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611157 := m#moverPath(moverPath3611157);                                                    
  path3611157 := p#moverPath(moverPath3611157);                                                     
  assume Queue._state3611157 == Queue._state && Queue.elems3611157 == Queue.elems && Queue.head3611157 == Queue.head && Queue.tail3611157 == Queue.tail && Queue.spec3611157 == Queue.spec && Queue._lock3611157 == Queue._lock && Array.Queue.T._state3611157 == Array.Queue.T._state && Array.Queue.T._elems3611157 == Array.Queue.T._elems && Array.Queue.T._length3611157 == Array.Queue.T._length && tmp223611157 == tmp22 && tmp213611157 == tmp21 && tmp203611157 == tmp20 && tmp173611157 == tmp17 && tmp163611157 == tmp16 && tmp153611157 == tmp15 && i3611157 == i && tmp143611157 == tmp14 && tmp133611157 == tmp13 && tmp123611157 == tmp12 && tmp113611157 == tmp11 && o3611157 == o && tmp103611157 == tmp10 && tmp93611157 == tmp9 && result3611157 == result && tmp83611157 == tmp8 && tmp73611157 == tmp7 && tmp63611157 == tmp6 && tmp53611157 == tmp5 && $result3611157 == $result && this3611157 == this && tid3611157 == tid && _pc3611157 == _pc;
  assume $recorded.state3611157 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (40.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611157);                                                             
  assert _pc != PhaseError;                                                                                // (40.17): Reduction failure
  tmp22 := Queue.spec[this];                                                                        
                                                                                                    
  // 40.17: tmp21 = SeqNth<int>(tmp22,i);                                                           
                                                                                                    
  tmp21 := SeqNth.int(tmp22,i);                                                                     
                                                                                                    
  // 40.17: [Queue.T{this}] tmp23;                                                                  
                                                                                                    
                                                                                                    
  // 40.17: tmp23 := this.elems;                                                                    
                                                                                                    
                                                                                                    
  moverPath3611170 := ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611170 := m#moverPath(moverPath3611170);                                                    
  path3611170 := p#moverPath(moverPath3611170);                                                     
  assume Queue._state3611170 == Queue._state && Queue.elems3611170 == Queue.elems && Queue.head3611170 == Queue.head && Queue.tail3611170 == Queue.tail && Queue.spec3611170 == Queue.spec && Queue._lock3611170 == Queue._lock && Array.Queue.T._state3611170 == Array.Queue.T._state && Array.Queue.T._elems3611170 == Array.Queue.T._elems && Array.Queue.T._length3611170 == Array.Queue.T._length && tmp233611170 == tmp23 && tmp223611170 == tmp22 && tmp213611170 == tmp21 && tmp203611170 == tmp20 && tmp173611170 == tmp17 && tmp163611170 == tmp16 && tmp153611170 == tmp15 && i3611170 == i && tmp143611170 == tmp14 && tmp133611170 == tmp13 && tmp123611170 == tmp12 && tmp113611170 == tmp11 && o3611170 == o && tmp103611170 == tmp10 && tmp93611170 == tmp9 && result3611170 == result && tmp83611170 == tmp8 && tmp73611170 == tmp7 && tmp63611170 == tmp6 && tmp53611170 == tmp5 && $result3611170 == $result && this3611170 == this && tid3611170 == tid && _pc3611170 == _pc;
  assume $recorded.state3611170 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (40.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611170);                                                             
  assert _pc != PhaseError;                                                                                // (40.17): Reduction failure
  tmp23 := Queue.elems[this];                                                                       
                                                                                                    
  // 40.17: int tmp24;                                                                              
                                                                                                    
                                                                                                    
  // 40.17: int tmp25;                                                                              
                                                                                                    
                                                                                                    
  // 40.17: tmp25 := this.head;                                                                     
                                                                                                    
                                                                                                    
  moverPath3611179 := ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611179 := m#moverPath(moverPath3611179);                                                    
  path3611179 := p#moverPath(moverPath3611179);                                                     
  assume Queue._state3611179 == Queue._state && Queue.elems3611179 == Queue.elems && Queue.head3611179 == Queue.head && Queue.tail3611179 == Queue.tail && Queue.spec3611179 == Queue.spec && Queue._lock3611179 == Queue._lock && Array.Queue.T._state3611179 == Array.Queue.T._state && Array.Queue.T._elems3611179 == Array.Queue.T._elems && Array.Queue.T._length3611179 == Array.Queue.T._length && tmp253611179 == tmp25 && tmp243611179 == tmp24 && tmp233611179 == tmp23 && tmp223611179 == tmp22 && tmp213611179 == tmp21 && tmp203611179 == tmp20 && tmp173611179 == tmp17 && tmp163611179 == tmp16 && tmp153611179 == tmp15 && i3611179 == i && tmp143611179 == tmp14 && tmp133611179 == tmp13 && tmp123611179 == tmp12 && tmp113611179 == tmp11 && o3611179 == o && tmp103611179 == tmp10 && tmp93611179 == tmp9 && result3611179 == result && tmp83611179 == tmp8 && tmp73611179 == tmp7 && tmp63611179 == tmp6 && tmp53611179 == tmp5 && $result3611179 == $result && this3611179 == this && tid3611179 == tid && _pc3611179 == _pc;
  assume $recorded.state3611179 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (40.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611179);                                                             
  assert _pc != PhaseError;                                                                                // (40.17): Reduction failure
  tmp25 := Queue.head[this];                                                                        
                                                                                                    
  // 40.17: tmp24 = tmp25 + i;                                                                      
                                                                                                    
  tmp24 := (tmp25+i);                                                                               
                                                                                                    
  // 40.17: int tmp26;                                                                              
                                                                                                    
                                                                                                    
  // 40.17: tmp26 := tmp23[tmp24];                                                                  
                                                                                                    
                                                                                                    
  moverPath3611192 := ReadEval.Array.Queue.T(tid: Tid,this: Queue,tmp23: Array.Queue.T,tmp24: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611192 := m#moverPath(moverPath3611192);                                                    
  path3611192 := p#moverPath(moverPath3611192);                                                     
  assume Queue._state3611192 == Queue._state && Queue.elems3611192 == Queue.elems && Queue.head3611192 == Queue.head && Queue.tail3611192 == Queue.tail && Queue.spec3611192 == Queue.spec && Queue._lock3611192 == Queue._lock && Array.Queue.T._state3611192 == Array.Queue.T._state && Array.Queue.T._elems3611192 == Array.Queue.T._elems && Array.Queue.T._length3611192 == Array.Queue.T._length && tmp263611192 == tmp26 && tmp253611192 == tmp25 && tmp243611192 == tmp24 && tmp233611192 == tmp23 && tmp223611192 == tmp22 && tmp213611192 == tmp21 && tmp203611192 == tmp20 && tmp173611192 == tmp17 && tmp163611192 == tmp16 && tmp153611192 == tmp15 && i3611192 == i && tmp143611192 == tmp14 && tmp133611192 == tmp13 && tmp123611192 == tmp12 && tmp113611192 == tmp11 && o3611192 == o && tmp103611192 == tmp10 && tmp93611192 == tmp9 && result3611192 == result && tmp83611192 == tmp8 && tmp73611192 == tmp7 && tmp63611192 == tmp6 && tmp53611192 == tmp5 && $result3611192 == $result && this3611192 == this && tid3611192 == tid && _pc3611192 == _pc;
  assume $recorded.state3611192 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume tmp23 != Array.Queue.T.null;                                                              
  } else {                                                                                          
   assert tmp23 != Array.Queue.T.null;                                                                     // (40.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume 0 <= tmp24;                                                                               
  } else {                                                                                          
   assert 0 <= tmp24;                                                                                      // (40.17): index < 0.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume tmp24 < Array.Queue.T._length[tmp23];                                                     
  } else {                                                                                          
   assert tmp24 < Array.Queue.T._length[tmp23];                                                            // (40.17): index is >= length.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611192);                                                             
  assert _pc != PhaseError;                                                                                // (40.17): Reduction failure
  tmp26 := Array.Queue.T._elems[tmp23][tmp24];                                                      
                                                                                                    
  // 40.17: tmp20 = tmp21 == tmp26;                                                                 
                                                                                                    
  tmp20 := (tmp21==tmp26);                                                                          
                                                                                                    
  // 40.17: tmp15 = tmp16 ==> tmp20;                                                                
                                                                                                    
  tmp15 := (tmp16==>tmp20);                                                                         
                                                                                                    
  // 40.17: assert tmp15 /* == 0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i] */;
                                                                                                    
  assume Queue._state3611238 == Queue._state && Queue.elems3611238 == Queue.elems && Queue.head3611238 == Queue.head && Queue.tail3611238 == Queue.tail && Queue.spec3611238 == Queue.spec && Queue._lock3611238 == Queue._lock && Array.Queue.T._state3611238 == Array.Queue.T._state && Array.Queue.T._elems3611238 == Array.Queue.T._elems && Array.Queue.T._length3611238 == Array.Queue.T._length && tmp263611238 == tmp26 && tmp253611238 == tmp25 && tmp243611238 == tmp24 && tmp233611238 == tmp23 && tmp223611238 == tmp22 && tmp213611238 == tmp21 && tmp203611238 == tmp20 && tmp173611238 == tmp17 && tmp163611238 == tmp16 && tmp153611238 == tmp15 && i3611238 == i && tmp143611238 == tmp14 && tmp133611238 == tmp13 && tmp123611238 == tmp12 && tmp113611238 == tmp11 && o3611238 == o && tmp103611238 == tmp10 && tmp93611238 == tmp9 && result3611238 == result && tmp83611238 == tmp8 && tmp73611238 == tmp7 && tmp63611238 == tmp6 && tmp53611238 == tmp5 && $result3611238 == $result && this3611238 == this && tid3611238 == tid;
  assume $recorded.state3611238 == 1;                                                               
  assert tmp15 /* lowered (((0<=i)&&(i<SeqLen.int(Queue.spec[this])))==>(SeqNth.int(Queue.spec[this],i)==Array.Queue.T._elems[Queue.elems[this]][(Queue.head[this]+i)])) */;       // (40.17): This assertion may not hold.
                                                                                                    
  // 41.17: bool tmp27;                                                                             
                                                                                                    
                                                                                                    
  // 41.17: bool tmp28;                                                                             
                                                                                                    
                                                                                                    
  // 41.17: bool tmp29;                                                                             
                                                                                                    
                                                                                                    
  // 41.17: tmp29 = 0 <= i;                                                                         
                                                                                                    
  tmp29 := (0<=i);                                                                                  
  if (tmp29) {                                                                                      
                                                                                                    
   // 41.38: int tmp30;                                                                             
                                                                                                    
                                                                                                    
   // 41.38: tmp30 = SeqLen<int>(o);                                                                
                                                                                                    
   tmp30 := SeqLen.int(o);                                                                          
                                                                                                    
   // 41.36: tmp28 = i < tmp30;                                                                     
                                                                                                    
   tmp28 := (i<tmp30);                                                                              
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 41.17: bool tmp31;                                                                             
                                                                                                    
                                                                                                    
  // 41.17: int tmp32;                                                                              
                                                                                                    
                                                                                                    
  // 41.17: tmp32 = SeqNth<int>(o,i);                                                               
                                                                                                    
  tmp32 := SeqNth.int(o,i);                                                                         
                                                                                                    
  // 41.17: int tmp33;                                                                              
                                                                                                    
                                                                                                    
  // 41.17: Seq<int> tmp34;                                                                         
                                                                                                    
                                                                                                    
  // 41.17: tmp34 := this.spec;                                                                     
                                                                                                    
                                                                                                    
  moverPath3611293 := ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611293 := m#moverPath(moverPath3611293);                                                    
  path3611293 := p#moverPath(moverPath3611293);                                                     
  assume Queue._state3611293 == Queue._state && Queue.elems3611293 == Queue.elems && Queue.head3611293 == Queue.head && Queue.tail3611293 == Queue.tail && Queue.spec3611293 == Queue.spec && Queue._lock3611293 == Queue._lock && Array.Queue.T._state3611293 == Array.Queue.T._state && Array.Queue.T._elems3611293 == Array.Queue.T._elems && Array.Queue.T._length3611293 == Array.Queue.T._length && tmp343611293 == tmp34 && tmp333611293 == tmp33 && tmp323611293 == tmp32 && tmp313611293 == tmp31 && tmp293611293 == tmp29 && tmp283611293 == tmp28 && tmp273611293 == tmp27 && tmp263611293 == tmp26 && tmp253611293 == tmp25 && tmp243611293 == tmp24 && tmp233611293 == tmp23 && tmp223611293 == tmp22 && tmp213611293 == tmp21 && tmp203611293 == tmp20 && tmp173611293 == tmp17 && tmp163611293 == tmp16 && tmp153611293 == tmp15 && i3611293 == i && tmp143611293 == tmp14 && tmp133611293 == tmp13 && tmp123611293 == tmp12 && tmp113611293 == tmp11 && o3611293 == o && tmp103611293 == tmp10 && tmp93611293 == tmp9 && result3611293 == result && tmp83611293 == tmp8 && tmp73611293 == tmp7 && tmp63611293 == tmp6 && tmp53611293 == tmp5 && $result3611293 == $result && this3611293 == this && tid3611293 == tid && _pc3611293 == _pc;
  assume $recorded.state3611293 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (41.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611293);                                                             
  assert _pc != PhaseError;                                                                                // (41.17): Reduction failure
  tmp34 := Queue.spec[this];                                                                        
                                                                                                    
  // 41.17: int tmp35;                                                                              
                                                                                                    
                                                                                                    
  // 41.17: tmp35 = i + 1;                                                                          
                                                                                                    
  tmp35 := (i+1);                                                                                   
                                                                                                    
  // 41.17: tmp33 = SeqNth<int>(tmp34,tmp35);                                                       
                                                                                                    
  tmp33 := SeqNth.int(tmp34,tmp35);                                                                 
                                                                                                    
  // 41.17: tmp31 = tmp32 == tmp33;                                                                 
                                                                                                    
  tmp31 := (tmp32==tmp33);                                                                          
                                                                                                    
  // 41.17: tmp27 = tmp28 ==> tmp31;                                                                
                                                                                                    
  tmp27 := (tmp28==>tmp31);                                                                         
                                                                                                    
  // 41.17: assert tmp27 /* == 0 <= i && i < SeqLen<int>(o) ==> SeqNth<int>(o,i) == SeqNth<int>(this.spec,i + 1) */;
                                                                                                    
  assume Queue._state3611354 == Queue._state && Queue.elems3611354 == Queue.elems && Queue.head3611354 == Queue.head && Queue.tail3611354 == Queue.tail && Queue.spec3611354 == Queue.spec && Queue._lock3611354 == Queue._lock && Array.Queue.T._state3611354 == Array.Queue.T._state && Array.Queue.T._elems3611354 == Array.Queue.T._elems && Array.Queue.T._length3611354 == Array.Queue.T._length && tmp353611354 == tmp35 && tmp343611354 == tmp34 && tmp333611354 == tmp33 && tmp323611354 == tmp32 && tmp313611354 == tmp31 && tmp293611354 == tmp29 && tmp283611354 == tmp28 && tmp273611354 == tmp27 && tmp263611354 == tmp26 && tmp253611354 == tmp25 && tmp243611354 == tmp24 && tmp233611354 == tmp23 && tmp223611354 == tmp22 && tmp213611354 == tmp21 && tmp203611354 == tmp20 && tmp173611354 == tmp17 && tmp163611354 == tmp16 && tmp153611354 == tmp15 && i3611354 == i && tmp143611354 == tmp14 && tmp133611354 == tmp13 && tmp123611354 == tmp12 && tmp113611354 == tmp11 && o3611354 == o && tmp103611354 == tmp10 && tmp93611354 == tmp9 && result3611354 == result && tmp83611354 == tmp8 && tmp73611354 == tmp7 && tmp63611354 == tmp6 && tmp53611354 == tmp5 && $result3611354 == $result && this3611354 == this && tid3611354 == tid;
  assume $recorded.state3611354 == 1;                                                               
  assert tmp27 /* lowered (((0<=i)&&(i<SeqLen.int(o)))==>(SeqNth.int(o,i)==SeqNth.int(Queue.spec[this],(i+1)))) */;       // (41.17): This assertion may not hold.
                                                                                                    
  // 42.17: bool tmp36;                                                                             
                                                                                                    
                                                                                                    
  // 42.17: bool tmp37;                                                                             
                                                                                                    
                                                                                                    
  // 42.17: bool tmp38;                                                                             
                                                                                                    
                                                                                                    
  // 42.17: tmp38 = 0 <= i;                                                                         
                                                                                                    
  tmp38 := (0<=i);                                                                                  
  if (tmp38) {                                                                                      
                                                                                                    
   // 42.38: int tmp39;                                                                             
                                                                                                    
                                                                                                    
   // 42.38: tmp39 = SeqLen<int>(o);                                                                
                                                                                                    
   tmp39 := SeqLen.int(o);                                                                          
                                                                                                    
   // 42.36: tmp37 = i < tmp39;                                                                     
                                                                                                    
   tmp37 := (i<tmp39);                                                                              
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 42.17: bool tmp40;                                                                             
                                                                                                    
                                                                                                    
  // 42.17: int tmp41;                                                                              
                                                                                                    
                                                                                                    
  // 42.17: tmp41 = SeqNth<int>(o,i);                                                               
                                                                                                    
  tmp41 := SeqNth.int(o,i);                                                                         
                                                                                                    
  // 42.17: [Queue.T{this}] tmp42;                                                                  
                                                                                                    
                                                                                                    
  // 42.17: tmp42 := this.elems;                                                                    
                                                                                                    
                                                                                                    
  moverPath3611406 := ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611406 := m#moverPath(moverPath3611406);                                                    
  path3611406 := p#moverPath(moverPath3611406);                                                     
  assume Queue._state3611406 == Queue._state && Queue.elems3611406 == Queue.elems && Queue.head3611406 == Queue.head && Queue.tail3611406 == Queue.tail && Queue.spec3611406 == Queue.spec && Queue._lock3611406 == Queue._lock && Array.Queue.T._state3611406 == Array.Queue.T._state && Array.Queue.T._elems3611406 == Array.Queue.T._elems && Array.Queue.T._length3611406 == Array.Queue.T._length && tmp423611406 == tmp42 && tmp413611406 == tmp41 && tmp403611406 == tmp40 && tmp383611406 == tmp38 && tmp373611406 == tmp37 && tmp363611406 == tmp36 && tmp353611406 == tmp35 && tmp343611406 == tmp34 && tmp333611406 == tmp33 && tmp323611406 == tmp32 && tmp313611406 == tmp31 && tmp293611406 == tmp29 && tmp283611406 == tmp28 && tmp273611406 == tmp27 && tmp263611406 == tmp26 && tmp253611406 == tmp25 && tmp243611406 == tmp24 && tmp233611406 == tmp23 && tmp223611406 == tmp22 && tmp213611406 == tmp21 && tmp203611406 == tmp20 && tmp173611406 == tmp17 && tmp163611406 == tmp16 && tmp153611406 == tmp15 && i3611406 == i && tmp143611406 == tmp14 && tmp133611406 == tmp13 && tmp123611406 == tmp12 && tmp113611406 == tmp11 && o3611406 == o && tmp103611406 == tmp10 && tmp93611406 == tmp9 && result3611406 == result && tmp83611406 == tmp8 && tmp73611406 == tmp7 && tmp63611406 == tmp6 && tmp53611406 == tmp5 && $result3611406 == $result && this3611406 == this && tid3611406 == tid && _pc3611406 == _pc;
  assume $recorded.state3611406 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (42.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611406);                                                             
  assert _pc != PhaseError;                                                                                // (42.17): Reduction failure
  tmp42 := Queue.elems[this];                                                                       
                                                                                                    
  // 42.17: int tmp43;                                                                              
                                                                                                    
                                                                                                    
  // 42.17: int tmp44;                                                                              
                                                                                                    
                                                                                                    
  // 42.17: int tmp45;                                                                              
                                                                                                    
                                                                                                    
  // 42.17: tmp45 := this.head;                                                                     
                                                                                                    
                                                                                                    
  moverPath3611418 := ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611418 := m#moverPath(moverPath3611418);                                                    
  path3611418 := p#moverPath(moverPath3611418);                                                     
  assume Queue._state3611418 == Queue._state && Queue.elems3611418 == Queue.elems && Queue.head3611418 == Queue.head && Queue.tail3611418 == Queue.tail && Queue.spec3611418 == Queue.spec && Queue._lock3611418 == Queue._lock && Array.Queue.T._state3611418 == Array.Queue.T._state && Array.Queue.T._elems3611418 == Array.Queue.T._elems && Array.Queue.T._length3611418 == Array.Queue.T._length && tmp453611418 == tmp45 && tmp443611418 == tmp44 && tmp433611418 == tmp43 && tmp423611418 == tmp42 && tmp413611418 == tmp41 && tmp403611418 == tmp40 && tmp383611418 == tmp38 && tmp373611418 == tmp37 && tmp363611418 == tmp36 && tmp353611418 == tmp35 && tmp343611418 == tmp34 && tmp333611418 == tmp33 && tmp323611418 == tmp32 && tmp313611418 == tmp31 && tmp293611418 == tmp29 && tmp283611418 == tmp28 && tmp273611418 == tmp27 && tmp263611418 == tmp26 && tmp253611418 == tmp25 && tmp243611418 == tmp24 && tmp233611418 == tmp23 && tmp223611418 == tmp22 && tmp213611418 == tmp21 && tmp203611418 == tmp20 && tmp173611418 == tmp17 && tmp163611418 == tmp16 && tmp153611418 == tmp15 && i3611418 == i && tmp143611418 == tmp14 && tmp133611418 == tmp13 && tmp123611418 == tmp12 && tmp113611418 == tmp11 && o3611418 == o && tmp103611418 == tmp10 && tmp93611418 == tmp9 && result3611418 == result && tmp83611418 == tmp8 && tmp73611418 == tmp7 && tmp63611418 == tmp6 && tmp53611418 == tmp5 && $result3611418 == $result && this3611418 == this && tid3611418 == tid && _pc3611418 == _pc;
  assume $recorded.state3611418 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (42.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611418);                                                             
  assert _pc != PhaseError;                                                                                // (42.17): Reduction failure
  tmp45 := Queue.head[this];                                                                        
                                                                                                    
  // 42.17: tmp44 = tmp45 + 1;                                                                      
                                                                                                    
  tmp44 := (tmp45+1);                                                                               
                                                                                                    
  // 42.17: tmp43 = tmp44 + i;                                                                      
                                                                                                    
  tmp43 := (tmp44+i);                                                                               
                                                                                                    
  // 42.17: int tmp46;                                                                              
                                                                                                    
                                                                                                    
  // 42.17: tmp46 := tmp42[tmp43];                                                                  
                                                                                                    
                                                                                                    
  moverPath3611438 := ReadEval.Array.Queue.T(tid: Tid,this: Queue,tmp42: Array.Queue.T,tmp43: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611438 := m#moverPath(moverPath3611438);                                                    
  path3611438 := p#moverPath(moverPath3611438);                                                     
  assume Queue._state3611438 == Queue._state && Queue.elems3611438 == Queue.elems && Queue.head3611438 == Queue.head && Queue.tail3611438 == Queue.tail && Queue.spec3611438 == Queue.spec && Queue._lock3611438 == Queue._lock && Array.Queue.T._state3611438 == Array.Queue.T._state && Array.Queue.T._elems3611438 == Array.Queue.T._elems && Array.Queue.T._length3611438 == Array.Queue.T._length && tmp463611438 == tmp46 && tmp453611438 == tmp45 && tmp443611438 == tmp44 && tmp433611438 == tmp43 && tmp423611438 == tmp42 && tmp413611438 == tmp41 && tmp403611438 == tmp40 && tmp383611438 == tmp38 && tmp373611438 == tmp37 && tmp363611438 == tmp36 && tmp353611438 == tmp35 && tmp343611438 == tmp34 && tmp333611438 == tmp33 && tmp323611438 == tmp32 && tmp313611438 == tmp31 && tmp293611438 == tmp29 && tmp283611438 == tmp28 && tmp273611438 == tmp27 && tmp263611438 == tmp26 && tmp253611438 == tmp25 && tmp243611438 == tmp24 && tmp233611438 == tmp23 && tmp223611438 == tmp22 && tmp213611438 == tmp21 && tmp203611438 == tmp20 && tmp173611438 == tmp17 && tmp163611438 == tmp16 && tmp153611438 == tmp15 && i3611438 == i && tmp143611438 == tmp14 && tmp133611438 == tmp13 && tmp123611438 == tmp12 && tmp113611438 == tmp11 && o3611438 == o && tmp103611438 == tmp10 && tmp93611438 == tmp9 && result3611438 == result && tmp83611438 == tmp8 && tmp73611438 == tmp7 && tmp63611438 == tmp6 && tmp53611438 == tmp5 && $result3611438 == $result && this3611438 == this && tid3611438 == tid && _pc3611438 == _pc;
  assume $recorded.state3611438 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume tmp42 != Array.Queue.T.null;                                                              
  } else {                                                                                          
   assert tmp42 != Array.Queue.T.null;                                                                     // (42.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume 0 <= tmp43;                                                                               
  } else {                                                                                          
   assert 0 <= tmp43;                                                                                      // (42.17): index < 0.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume tmp43 < Array.Queue.T._length[tmp42];                                                     
  } else {                                                                                          
   assert tmp43 < Array.Queue.T._length[tmp42];                                                            // (42.17): index is >= length.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611438);                                                             
  assert _pc != PhaseError;                                                                                // (42.17): Reduction failure
  tmp46 := Array.Queue.T._elems[tmp42][tmp43];                                                      
                                                                                                    
  // 42.17: tmp40 = tmp41 == tmp46;                                                                 
                                                                                                    
  tmp40 := (tmp41==tmp46);                                                                          
                                                                                                    
  // 42.17: tmp36 = tmp37 ==> tmp40;                                                                
                                                                                                    
  tmp36 := (tmp37==>tmp40);                                                                         
                                                                                                    
  // 42.17: assert tmp36 /* == 0 <= i && i < SeqLen<int>(o) ==> SeqNth<int>(o,i) == this.elems[this.head + 1 + i] */;
                                                                                                    
  assume Queue._state3611486 == Queue._state && Queue.elems3611486 == Queue.elems && Queue.head3611486 == Queue.head && Queue.tail3611486 == Queue.tail && Queue.spec3611486 == Queue.spec && Queue._lock3611486 == Queue._lock && Array.Queue.T._state3611486 == Array.Queue.T._state && Array.Queue.T._elems3611486 == Array.Queue.T._elems && Array.Queue.T._length3611486 == Array.Queue.T._length && tmp463611486 == tmp46 && tmp453611486 == tmp45 && tmp443611486 == tmp44 && tmp433611486 == tmp43 && tmp423611486 == tmp42 && tmp413611486 == tmp41 && tmp403611486 == tmp40 && tmp383611486 == tmp38 && tmp373611486 == tmp37 && tmp363611486 == tmp36 && tmp353611486 == tmp35 && tmp343611486 == tmp34 && tmp333611486 == tmp33 && tmp323611486 == tmp32 && tmp313611486 == tmp31 && tmp293611486 == tmp29 && tmp283611486 == tmp28 && tmp273611486 == tmp27 && tmp263611486 == tmp26 && tmp253611486 == tmp25 && tmp243611486 == tmp24 && tmp233611486 == tmp23 && tmp223611486 == tmp22 && tmp213611486 == tmp21 && tmp203611486 == tmp20 && tmp173611486 == tmp17 && tmp163611486 == tmp16 && tmp153611486 == tmp15 && i3611486 == i && tmp143611486 == tmp14 && tmp133611486 == tmp13 && tmp123611486 == tmp12 && tmp113611486 == tmp11 && o3611486 == o && tmp103611486 == tmp10 && tmp93611486 == tmp9 && result3611486 == result && tmp83611486 == tmp8 && tmp73611486 == tmp7 && tmp63611486 == tmp6 && tmp53611486 == tmp5 && $result3611486 == $result && this3611486 == this && tid3611486 == tid;
  assume $recorded.state3611486 == 1;                                                               
  assert tmp36 /* lowered (((0<=i)&&(i<SeqLen.int(o)))==>(SeqNth.int(o,i)==Array.Queue.T._elems[Queue.elems[this]][((Queue.head[this]+1)+i)])) */;       // (42.17): This assertion may not hold.
                                                                                                    
  // 43.17: int tmp47;                                                                              
                                                                                                    
                                                                                                    
  // 43.17: int tmp48;                                                                              
                                                                                                    
                                                                                                    
  // 43.17: tmp48 := this.head;                                                                     
                                                                                                    
                                                                                                    
  moverPath3611495 := ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611495 := m#moverPath(moverPath3611495);                                                    
  path3611495 := p#moverPath(moverPath3611495);                                                     
  assume Queue._state3611495 == Queue._state && Queue.elems3611495 == Queue.elems && Queue.head3611495 == Queue.head && Queue.tail3611495 == Queue.tail && Queue.spec3611495 == Queue.spec && Queue._lock3611495 == Queue._lock && Array.Queue.T._state3611495 == Array.Queue.T._state && Array.Queue.T._elems3611495 == Array.Queue.T._elems && Array.Queue.T._length3611495 == Array.Queue.T._length && tmp483611495 == tmp48 && tmp473611495 == tmp47 && tmp463611495 == tmp46 && tmp453611495 == tmp45 && tmp443611495 == tmp44 && tmp433611495 == tmp43 && tmp423611495 == tmp42 && tmp413611495 == tmp41 && tmp403611495 == tmp40 && tmp383611495 == tmp38 && tmp373611495 == tmp37 && tmp363611495 == tmp36 && tmp353611495 == tmp35 && tmp343611495 == tmp34 && tmp333611495 == tmp33 && tmp323611495 == tmp32 && tmp313611495 == tmp31 && tmp293611495 == tmp29 && tmp283611495 == tmp28 && tmp273611495 == tmp27 && tmp263611495 == tmp26 && tmp253611495 == tmp25 && tmp243611495 == tmp24 && tmp233611495 == tmp23 && tmp223611495 == tmp22 && tmp213611495 == tmp21 && tmp203611495 == tmp20 && tmp173611495 == tmp17 && tmp163611495 == tmp16 && tmp153611495 == tmp15 && i3611495 == i && tmp143611495 == tmp14 && tmp133611495 == tmp13 && tmp123611495 == tmp12 && tmp113611495 == tmp11 && o3611495 == o && tmp103611495 == tmp10 && tmp93611495 == tmp9 && result3611495 == result && tmp83611495 == tmp8 && tmp73611495 == tmp7 && tmp63611495 == tmp6 && tmp53611495 == tmp5 && $result3611495 == $result && this3611495 == this && tid3611495 == tid && _pc3611495 == _pc;
  assume $recorded.state3611495 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (43.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611495);                                                             
  assert _pc != PhaseError;                                                                                // (43.17): Reduction failure
  tmp48 := Queue.head[this];                                                                        
                                                                                                    
  // 43.17: tmp47 = tmp48 + 1;                                                                      
                                                                                                    
  tmp47 := (tmp48+1);                                                                               
                                                                                                    
                                                                                                    
  // 43.17: this.head := tmp47;                                                                     
                                                                                                    
                                                                                                    
  moverPath3611505 := WriteEval.Queue.head(tid: Tid,this: Queue,tmp47: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611505 := m#moverPath(moverPath3611505);                                                    
  path3611505 := p#moverPath(moverPath3611505);                                                     
  assume Queue._state3611505 == Queue._state && Queue.elems3611505 == Queue.elems && Queue.head3611505 == Queue.head && Queue.tail3611505 == Queue.tail && Queue.spec3611505 == Queue.spec && Queue._lock3611505 == Queue._lock && Array.Queue.T._state3611505 == Array.Queue.T._state && Array.Queue.T._elems3611505 == Array.Queue.T._elems && Array.Queue.T._length3611505 == Array.Queue.T._length && tmp483611505 == tmp48 && tmp473611505 == tmp47 && tmp463611505 == tmp46 && tmp453611505 == tmp45 && tmp443611505 == tmp44 && tmp433611505 == tmp43 && tmp423611505 == tmp42 && tmp413611505 == tmp41 && tmp403611505 == tmp40 && tmp383611505 == tmp38 && tmp373611505 == tmp37 && tmp363611505 == tmp36 && tmp353611505 == tmp35 && tmp343611505 == tmp34 && tmp333611505 == tmp33 && tmp323611505 == tmp32 && tmp313611505 == tmp31 && tmp293611505 == tmp29 && tmp283611505 == tmp28 && tmp273611505 == tmp27 && tmp263611505 == tmp26 && tmp253611505 == tmp25 && tmp243611505 == tmp24 && tmp233611505 == tmp23 && tmp223611505 == tmp22 && tmp213611505 == tmp21 && tmp203611505 == tmp20 && tmp173611505 == tmp17 && tmp163611505 == tmp16 && tmp153611505 == tmp15 && i3611505 == i && tmp143611505 == tmp14 && tmp133611505 == tmp13 && tmp123611505 == tmp12 && tmp113611505 == tmp11 && o3611505 == o && tmp103611505 == tmp10 && tmp93611505 == tmp9 && result3611505 == result && tmp83611505 == tmp8 && tmp73611505 == tmp7 && tmp63611505 == tmp6 && tmp53611505 == tmp5 && $result3611505 == $result && this3611505 == this && tid3611505 == tid && _pc3611505 == _pc;
  assume $recorded.state3611505 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (43.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  _pc := transition(_pc, mover3611505);                                                             
  assert _pc != PhaseError;                                                                                // (43.17): Reduction failure
  Queue.head[this] := tmp47;                                                                        
                                                                                                    
                                                                                                    
  // 44.17: this.spec := o;                                                                         
                                                                                                    
                                                                                                    
  moverPath3611508 := WriteEval.Queue.spec(tid: Tid,this: Queue,o: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611508 := m#moverPath(moverPath3611508);                                                    
  path3611508 := p#moverPath(moverPath3611508);                                                     
  assume Queue._state3611508 == Queue._state && Queue.elems3611508 == Queue.elems && Queue.head3611508 == Queue.head && Queue.tail3611508 == Queue.tail && Queue.spec3611508 == Queue.spec && Queue._lock3611508 == Queue._lock && Array.Queue.T._state3611508 == Array.Queue.T._state && Array.Queue.T._elems3611508 == Array.Queue.T._elems && Array.Queue.T._length3611508 == Array.Queue.T._length && tmp483611508 == tmp48 && tmp473611508 == tmp47 && tmp463611508 == tmp46 && tmp453611508 == tmp45 && tmp443611508 == tmp44 && tmp433611508 == tmp43 && tmp423611508 == tmp42 && tmp413611508 == tmp41 && tmp403611508 == tmp40 && tmp383611508 == tmp38 && tmp373611508 == tmp37 && tmp363611508 == tmp36 && tmp353611508 == tmp35 && tmp343611508 == tmp34 && tmp333611508 == tmp33 && tmp323611508 == tmp32 && tmp313611508 == tmp31 && tmp293611508 == tmp29 && tmp283611508 == tmp28 && tmp273611508 == tmp27 && tmp263611508 == tmp26 && tmp253611508 == tmp25 && tmp243611508 == tmp24 && tmp233611508 == tmp23 && tmp223611508 == tmp22 && tmp213611508 == tmp21 && tmp203611508 == tmp20 && tmp173611508 == tmp17 && tmp163611508 == tmp16 && tmp153611508 == tmp15 && i3611508 == i && tmp143611508 == tmp14 && tmp133611508 == tmp13 && tmp123611508 == tmp12 && tmp113611508 == tmp11 && o3611508 == o && tmp103611508 == tmp10 && tmp93611508 == tmp9 && result3611508 == result && tmp83611508 == tmp8 && tmp73611508 == tmp7 && tmp63611508 == tmp6 && tmp53611508 == tmp5 && $result3611508 == $result && this3611508 == this && tid3611508 == tid && _pc3611508 == _pc;
  assume $recorded.state3611508 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (44.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  _pc := transition(_pc, mover3611508);                                                             
  assert _pc != PhaseError;                                                                                // (44.17): Reduction failure
  Queue.spec[this] := o;                                                                            
                                                                                                    
  // 45.17: bool tmp49;                                                                             
                                                                                                    
                                                                                                    
  // 45.17: bool tmp50;                                                                             
                                                                                                    
                                                                                                    
  // 45.17: bool tmp51;                                                                             
                                                                                                    
                                                                                                    
  // 45.17: tmp51 = 0 <= i;                                                                         
                                                                                                    
  tmp51 := (0<=i);                                                                                  
  if (tmp51) {                                                                                      
                                                                                                    
   // 45.38: int tmp52;                                                                             
                                                                                                    
                                                                                                    
   // 45.45: Seq<int> tmp53;                                                                        
                                                                                                    
                                                                                                    
   // 45.45: tmp53 := this.spec;                                                                    
                                                                                                    
                                                                                                    
   moverPath3611534 := ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
   mover3611534 := m#moverPath(moverPath3611534);                                                   
   path3611534 := p#moverPath(moverPath3611534);                                                    
   assume Queue._state3611534 == Queue._state && Queue.elems3611534 == Queue.elems && Queue.head3611534 == Queue.head && Queue.tail3611534 == Queue.tail && Queue.spec3611534 == Queue.spec && Queue._lock3611534 == Queue._lock && Array.Queue.T._state3611534 == Array.Queue.T._state && Array.Queue.T._elems3611534 == Array.Queue.T._elems && Array.Queue.T._length3611534 == Array.Queue.T._length && tmp533611534 == tmp53 && tmp523611534 == tmp52 && tmp513611534 == tmp51 && tmp503611534 == tmp50 && tmp493611534 == tmp49 && tmp483611534 == tmp48 && tmp473611534 == tmp47 && tmp463611534 == tmp46 && tmp453611534 == tmp45 && tmp443611534 == tmp44 && tmp433611534 == tmp43 && tmp423611534 == tmp42 && tmp413611534 == tmp41 && tmp403611534 == tmp40 && tmp383611534 == tmp38 && tmp373611534 == tmp37 && tmp363611534 == tmp36 && tmp353611534 == tmp35 && tmp343611534 == tmp34 && tmp333611534 == tmp33 && tmp323611534 == tmp32 && tmp313611534 == tmp31 && tmp293611534 == tmp29 && tmp283611534 == tmp28 && tmp273611534 == tmp27 && tmp263611534 == tmp26 && tmp253611534 == tmp25 && tmp243611534 == tmp24 && tmp233611534 == tmp23 && tmp223611534 == tmp22 && tmp213611534 == tmp21 && tmp203611534 == tmp20 && tmp173611534 == tmp17 && tmp163611534 == tmp16 && tmp153611534 == tmp15 && i3611534 == i && tmp143611534 == tmp14 && tmp133611534 == tmp13 && tmp123611534 == tmp12 && tmp113611534 == tmp11 && o3611534 == o && tmp103611534 == tmp10 && tmp93611534 == tmp9 && result3611534 == result && tmp83611534 == tmp8 && tmp73611534 == tmp7 && tmp63611534 == tmp6 && tmp53611534 == tmp5 && $result3611534 == $result && this3611534 == this && tid3611534 == tid && _pc3611534 == _pc;
   assume $recorded.state3611534 == 1;                                                              
   if (_pc == PreCommit) {                                                                          
    assume this != Queue.null;                                                                      
   } else {                                                                                         
    assert this != Queue.null;                                                                             // (45.45): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   _pc := transition(_pc, mover3611534);                                                            
   assert _pc != PhaseError;                                                                               // (45.45): Reduction failure
   tmp53 := Queue.spec[this];                                                                       
                                                                                                    
   // 45.38: tmp52 = SeqLen<int>(tmp53);                                                            
                                                                                                    
   tmp52 := SeqLen.int(tmp53);                                                                      
                                                                                                    
   // 45.36: tmp50 = i < tmp52;                                                                     
                                                                                                    
   tmp50 := (i<tmp52);                                                                              
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 45.17: bool tmp54;                                                                             
                                                                                                    
                                                                                                    
  // 45.17: int tmp55;                                                                              
                                                                                                    
                                                                                                    
  // 45.17: Seq<int> tmp56;                                                                         
                                                                                                    
                                                                                                    
  // 45.17: tmp56 := this.spec;                                                                     
                                                                                                    
                                                                                                    
  moverPath3611561 := ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611561 := m#moverPath(moverPath3611561);                                                    
  path3611561 := p#moverPath(moverPath3611561);                                                     
  assume Queue._state3611561 == Queue._state && Queue.elems3611561 == Queue.elems && Queue.head3611561 == Queue.head && Queue.tail3611561 == Queue.tail && Queue.spec3611561 == Queue.spec && Queue._lock3611561 == Queue._lock && Array.Queue.T._state3611561 == Array.Queue.T._state && Array.Queue.T._elems3611561 == Array.Queue.T._elems && Array.Queue.T._length3611561 == Array.Queue.T._length && tmp563611561 == tmp56 && tmp553611561 == tmp55 && tmp543611561 == tmp54 && tmp513611561 == tmp51 && tmp503611561 == tmp50 && tmp493611561 == tmp49 && tmp483611561 == tmp48 && tmp473611561 == tmp47 && tmp463611561 == tmp46 && tmp453611561 == tmp45 && tmp443611561 == tmp44 && tmp433611561 == tmp43 && tmp423611561 == tmp42 && tmp413611561 == tmp41 && tmp403611561 == tmp40 && tmp383611561 == tmp38 && tmp373611561 == tmp37 && tmp363611561 == tmp36 && tmp353611561 == tmp35 && tmp343611561 == tmp34 && tmp333611561 == tmp33 && tmp323611561 == tmp32 && tmp313611561 == tmp31 && tmp293611561 == tmp29 && tmp283611561 == tmp28 && tmp273611561 == tmp27 && tmp263611561 == tmp26 && tmp253611561 == tmp25 && tmp243611561 == tmp24 && tmp233611561 == tmp23 && tmp223611561 == tmp22 && tmp213611561 == tmp21 && tmp203611561 == tmp20 && tmp173611561 == tmp17 && tmp163611561 == tmp16 && tmp153611561 == tmp15 && i3611561 == i && tmp143611561 == tmp14 && tmp133611561 == tmp13 && tmp123611561 == tmp12 && tmp113611561 == tmp11 && o3611561 == o && tmp103611561 == tmp10 && tmp93611561 == tmp9 && result3611561 == result && tmp83611561 == tmp8 && tmp73611561 == tmp7 && tmp63611561 == tmp6 && tmp53611561 == tmp5 && $result3611561 == $result && this3611561 == this && tid3611561 == tid && _pc3611561 == _pc;
  assume $recorded.state3611561 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (45.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611561);                                                             
  assert _pc != PhaseError;                                                                                // (45.17): Reduction failure
  tmp56 := Queue.spec[this];                                                                        
                                                                                                    
  // 45.17: tmp55 = SeqNth<int>(tmp56,i);                                                           
                                                                                                    
  tmp55 := SeqNth.int(tmp56,i);                                                                     
                                                                                                    
  // 45.17: [Queue.T{this}] tmp57;                                                                  
                                                                                                    
                                                                                                    
  // 45.17: tmp57 := this.elems;                                                                    
                                                                                                    
                                                                                                    
  moverPath3611574 := ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611574 := m#moverPath(moverPath3611574);                                                    
  path3611574 := p#moverPath(moverPath3611574);                                                     
  assume Queue._state3611574 == Queue._state && Queue.elems3611574 == Queue.elems && Queue.head3611574 == Queue.head && Queue.tail3611574 == Queue.tail && Queue.spec3611574 == Queue.spec && Queue._lock3611574 == Queue._lock && Array.Queue.T._state3611574 == Array.Queue.T._state && Array.Queue.T._elems3611574 == Array.Queue.T._elems && Array.Queue.T._length3611574 == Array.Queue.T._length && tmp573611574 == tmp57 && tmp563611574 == tmp56 && tmp553611574 == tmp55 && tmp543611574 == tmp54 && tmp513611574 == tmp51 && tmp503611574 == tmp50 && tmp493611574 == tmp49 && tmp483611574 == tmp48 && tmp473611574 == tmp47 && tmp463611574 == tmp46 && tmp453611574 == tmp45 && tmp443611574 == tmp44 && tmp433611574 == tmp43 && tmp423611574 == tmp42 && tmp413611574 == tmp41 && tmp403611574 == tmp40 && tmp383611574 == tmp38 && tmp373611574 == tmp37 && tmp363611574 == tmp36 && tmp353611574 == tmp35 && tmp343611574 == tmp34 && tmp333611574 == tmp33 && tmp323611574 == tmp32 && tmp313611574 == tmp31 && tmp293611574 == tmp29 && tmp283611574 == tmp28 && tmp273611574 == tmp27 && tmp263611574 == tmp26 && tmp253611574 == tmp25 && tmp243611574 == tmp24 && tmp233611574 == tmp23 && tmp223611574 == tmp22 && tmp213611574 == tmp21 && tmp203611574 == tmp20 && tmp173611574 == tmp17 && tmp163611574 == tmp16 && tmp153611574 == tmp15 && i3611574 == i && tmp143611574 == tmp14 && tmp133611574 == tmp13 && tmp123611574 == tmp12 && tmp113611574 == tmp11 && o3611574 == o && tmp103611574 == tmp10 && tmp93611574 == tmp9 && result3611574 == result && tmp83611574 == tmp8 && tmp73611574 == tmp7 && tmp63611574 == tmp6 && tmp53611574 == tmp5 && $result3611574 == $result && this3611574 == this && tid3611574 == tid && _pc3611574 == _pc;
  assume $recorded.state3611574 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (45.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611574);                                                             
  assert _pc != PhaseError;                                                                                // (45.17): Reduction failure
  tmp57 := Queue.elems[this];                                                                       
                                                                                                    
  // 45.17: int tmp58;                                                                              
                                                                                                    
                                                                                                    
  // 45.17: int tmp59;                                                                              
                                                                                                    
                                                                                                    
  // 45.17: tmp59 := this.head;                                                                     
                                                                                                    
                                                                                                    
  moverPath3611583 := ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611583 := m#moverPath(moverPath3611583);                                                    
  path3611583 := p#moverPath(moverPath3611583);                                                     
  assume Queue._state3611583 == Queue._state && Queue.elems3611583 == Queue.elems && Queue.head3611583 == Queue.head && Queue.tail3611583 == Queue.tail && Queue.spec3611583 == Queue.spec && Queue._lock3611583 == Queue._lock && Array.Queue.T._state3611583 == Array.Queue.T._state && Array.Queue.T._elems3611583 == Array.Queue.T._elems && Array.Queue.T._length3611583 == Array.Queue.T._length && tmp593611583 == tmp59 && tmp583611583 == tmp58 && tmp573611583 == tmp57 && tmp563611583 == tmp56 && tmp553611583 == tmp55 && tmp543611583 == tmp54 && tmp513611583 == tmp51 && tmp503611583 == tmp50 && tmp493611583 == tmp49 && tmp483611583 == tmp48 && tmp473611583 == tmp47 && tmp463611583 == tmp46 && tmp453611583 == tmp45 && tmp443611583 == tmp44 && tmp433611583 == tmp43 && tmp423611583 == tmp42 && tmp413611583 == tmp41 && tmp403611583 == tmp40 && tmp383611583 == tmp38 && tmp373611583 == tmp37 && tmp363611583 == tmp36 && tmp353611583 == tmp35 && tmp343611583 == tmp34 && tmp333611583 == tmp33 && tmp323611583 == tmp32 && tmp313611583 == tmp31 && tmp293611583 == tmp29 && tmp283611583 == tmp28 && tmp273611583 == tmp27 && tmp263611583 == tmp26 && tmp253611583 == tmp25 && tmp243611583 == tmp24 && tmp233611583 == tmp23 && tmp223611583 == tmp22 && tmp213611583 == tmp21 && tmp203611583 == tmp20 && tmp173611583 == tmp17 && tmp163611583 == tmp16 && tmp153611583 == tmp15 && i3611583 == i && tmp143611583 == tmp14 && tmp133611583 == tmp13 && tmp123611583 == tmp12 && tmp113611583 == tmp11 && o3611583 == o && tmp103611583 == tmp10 && tmp93611583 == tmp9 && result3611583 == result && tmp83611583 == tmp8 && tmp73611583 == tmp7 && tmp63611583 == tmp6 && tmp53611583 == tmp5 && $result3611583 == $result && this3611583 == this && tid3611583 == tid && _pc3611583 == _pc;
  assume $recorded.state3611583 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (45.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611583);                                                             
  assert _pc != PhaseError;                                                                                // (45.17): Reduction failure
  tmp59 := Queue.head[this];                                                                        
                                                                                                    
  // 45.17: tmp58 = tmp59 + i;                                                                      
                                                                                                    
  tmp58 := (tmp59+i);                                                                               
                                                                                                    
  // 45.17: int tmp60;                                                                              
                                                                                                    
                                                                                                    
  // 45.17: tmp60 := tmp57[tmp58];                                                                  
                                                                                                    
                                                                                                    
  moverPath3611596 := ReadEval.Array.Queue.T(tid: Tid,this: Queue,tmp57: Array.Queue.T,tmp58: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3611596 := m#moverPath(moverPath3611596);                                                    
  path3611596 := p#moverPath(moverPath3611596);                                                     
  assume Queue._state3611596 == Queue._state && Queue.elems3611596 == Queue.elems && Queue.head3611596 == Queue.head && Queue.tail3611596 == Queue.tail && Queue.spec3611596 == Queue.spec && Queue._lock3611596 == Queue._lock && Array.Queue.T._state3611596 == Array.Queue.T._state && Array.Queue.T._elems3611596 == Array.Queue.T._elems && Array.Queue.T._length3611596 == Array.Queue.T._length && tmp603611596 == tmp60 && tmp593611596 == tmp59 && tmp583611596 == tmp58 && tmp573611596 == tmp57 && tmp563611596 == tmp56 && tmp553611596 == tmp55 && tmp543611596 == tmp54 && tmp513611596 == tmp51 && tmp503611596 == tmp50 && tmp493611596 == tmp49 && tmp483611596 == tmp48 && tmp473611596 == tmp47 && tmp463611596 == tmp46 && tmp453611596 == tmp45 && tmp443611596 == tmp44 && tmp433611596 == tmp43 && tmp423611596 == tmp42 && tmp413611596 == tmp41 && tmp403611596 == tmp40 && tmp383611596 == tmp38 && tmp373611596 == tmp37 && tmp363611596 == tmp36 && tmp353611596 == tmp35 && tmp343611596 == tmp34 && tmp333611596 == tmp33 && tmp323611596 == tmp32 && tmp313611596 == tmp31 && tmp293611596 == tmp29 && tmp283611596 == tmp28 && tmp273611596 == tmp27 && tmp263611596 == tmp26 && tmp253611596 == tmp25 && tmp243611596 == tmp24 && tmp233611596 == tmp23 && tmp223611596 == tmp22 && tmp213611596 == tmp21 && tmp203611596 == tmp20 && tmp173611596 == tmp17 && tmp163611596 == tmp16 && tmp153611596 == tmp15 && i3611596 == i && tmp143611596 == tmp14 && tmp133611596 == tmp13 && tmp123611596 == tmp12 && tmp113611596 == tmp11 && o3611596 == o && tmp103611596 == tmp10 && tmp93611596 == tmp9 && result3611596 == result && tmp83611596 == tmp8 && tmp73611596 == tmp7 && tmp63611596 == tmp6 && tmp53611596 == tmp5 && $result3611596 == $result && this3611596 == this && tid3611596 == tid && _pc3611596 == _pc;
  assume $recorded.state3611596 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume tmp57 != Array.Queue.T.null;                                                              
  } else {                                                                                          
   assert tmp57 != Array.Queue.T.null;                                                                     // (45.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume 0 <= tmp58;                                                                               
  } else {                                                                                          
   assert 0 <= tmp58;                                                                                      // (45.17): index < 0.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume tmp58 < Array.Queue.T._length[tmp57];                                                     
  } else {                                                                                          
   assert tmp58 < Array.Queue.T._length[tmp57];                                                            // (45.17): index is >= length.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3611596);                                                             
  assert _pc != PhaseError;                                                                                // (45.17): Reduction failure
  tmp60 := Array.Queue.T._elems[tmp57][tmp58];                                                      
                                                                                                    
  // 45.17: tmp54 = tmp55 == tmp60;                                                                 
                                                                                                    
  tmp54 := (tmp55==tmp60);                                                                          
                                                                                                    
  // 45.17: tmp49 = tmp50 ==> tmp54;                                                                
                                                                                                    
  tmp49 := (tmp50==>tmp54);                                                                         
                                                                                                    
  // 45.17: assert tmp49 /* == 0 <= i && i < SeqLen<int>(this.spec) ==> SeqNth<int>(this.spec,i) == this.elems[this.head + i] */;
                                                                                                    
  assume Queue._state3611642 == Queue._state && Queue.elems3611642 == Queue.elems && Queue.head3611642 == Queue.head && Queue.tail3611642 == Queue.tail && Queue.spec3611642 == Queue.spec && Queue._lock3611642 == Queue._lock && Array.Queue.T._state3611642 == Array.Queue.T._state && Array.Queue.T._elems3611642 == Array.Queue.T._elems && Array.Queue.T._length3611642 == Array.Queue.T._length && tmp603611642 == tmp60 && tmp593611642 == tmp59 && tmp583611642 == tmp58 && tmp573611642 == tmp57 && tmp563611642 == tmp56 && tmp553611642 == tmp55 && tmp543611642 == tmp54 && tmp513611642 == tmp51 && tmp503611642 == tmp50 && tmp493611642 == tmp49 && tmp483611642 == tmp48 && tmp473611642 == tmp47 && tmp463611642 == tmp46 && tmp453611642 == tmp45 && tmp443611642 == tmp44 && tmp433611642 == tmp43 && tmp423611642 == tmp42 && tmp413611642 == tmp41 && tmp403611642 == tmp40 && tmp383611642 == tmp38 && tmp373611642 == tmp37 && tmp363611642 == tmp36 && tmp353611642 == tmp35 && tmp343611642 == tmp34 && tmp333611642 == tmp33 && tmp323611642 == tmp32 && tmp313611642 == tmp31 && tmp293611642 == tmp29 && tmp283611642 == tmp28 && tmp273611642 == tmp27 && tmp263611642 == tmp26 && tmp253611642 == tmp25 && tmp243611642 == tmp24 && tmp233611642 == tmp23 && tmp223611642 == tmp22 && tmp213611642 == tmp21 && tmp203611642 == tmp20 && tmp173611642 == tmp17 && tmp163611642 == tmp16 && tmp153611642 == tmp15 && i3611642 == i && tmp143611642 == tmp14 && tmp133611642 == tmp13 && tmp123611642 == tmp12 && tmp113611642 == tmp11 && o3611642 == o && tmp103611642 == tmp10 && tmp93611642 == tmp9 && result3611642 == result && tmp83611642 == tmp8 && tmp73611642 == tmp7 && tmp63611642 == tmp6 && tmp53611642 == tmp5 && $result3611642 == $result && this3611642 == this && tid3611642 == tid;
  assume $recorded.state3611642 == 1;                                                               
  assert tmp49 /* lowered (((0<=i)&&(i<SeqLen.int(Queue.spec[this])))==>(SeqNth.int(Queue.spec[this],i)==Array.Queue.T._elems[Queue.elems[this]][(Queue.head[this]+i)])) */;       // (45.17): This assertion may not hold.
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (50.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert Queue._lock[this] == tid;                                                                         // (50.9): lock not held
  _pc := transition(_pc, _L);                                                                       
  assert _pc != PhaseError;                                                                                // (50.9): Reduction failure
  Queue._lock[this] := Tid.null;                                                                    
                                                                                                    
  // 46.17:  return result;                                                                         
                                                                                                    
  assume Queue._state3611646 == Queue._state && Queue.elems3611646 == Queue.elems && Queue.head3611646 == Queue.head && Queue.tail3611646 == Queue.tail && Queue.spec3611646 == Queue.spec && Queue._lock3611646 == Queue._lock && Array.Queue.T._state3611646 == Array.Queue.T._state && Array.Queue.T._elems3611646 == Array.Queue.T._elems && Array.Queue.T._length3611646 == Array.Queue.T._length && tmp603611646 == tmp60 && tmp593611646 == tmp59 && tmp583611646 == tmp58 && tmp573611646 == tmp57 && tmp563611646 == tmp56 && tmp553611646 == tmp55 && tmp543611646 == tmp54 && tmp513611646 == tmp51 && tmp503611646 == tmp50 && tmp493611646 == tmp49 && tmp483611646 == tmp48 && tmp473611646 == tmp47 && tmp463611646 == tmp46 && tmp453611646 == tmp45 && tmp443611646 == tmp44 && tmp433611646 == tmp43 && tmp423611646 == tmp42 && tmp413611646 == tmp41 && tmp403611646 == tmp40 && tmp383611646 == tmp38 && tmp373611646 == tmp37 && tmp363611646 == tmp36 && tmp353611646 == tmp35 && tmp343611646 == tmp34 && tmp333611646 == tmp33 && tmp323611646 == tmp32 && tmp313611646 == tmp31 && tmp293611646 == tmp29 && tmp283611646 == tmp28 && tmp273611646 == tmp27 && tmp263611646 == tmp26 && tmp253611646 == tmp25 && tmp243611646 == tmp24 && tmp233611646 == tmp23 && tmp223611646 == tmp22 && tmp213611646 == tmp21 && tmp203611646 == tmp20 && tmp173611646 == tmp17 && tmp163611646 == tmp16 && tmp153611646 == tmp15 && i3611646 == i && tmp143611646 == tmp14 && tmp133611646 == tmp13 && tmp123611646 == tmp12 && tmp113611646 == tmp11 && o3611646 == o && tmp103611646 == tmp10 && tmp93611646 == tmp9 && result3611646 == result && tmp83611646 == tmp8 && tmp73611646 == tmp7 && tmp63611646 == tmp6 && tmp53611646 == tmp5 && $result3611646 == $result && this3611646 == this && tid3611646 == tid;
  assume $recorded.state3611646 == 1;                                                               
  $result := result;                                                                                
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (46.17): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (46.17): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (46.17): Object invariant may not hold.
  return;                                                                                           
 } else {                                                                                           
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (50.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert Queue._lock[this] == tid;                                                                         // (50.9): lock not held
  _pc := transition(_pc, _L);                                                                       
  assert _pc != PhaseError;                                                                                // (50.9): Reduction failure
  Queue._lock[this] := Tid.null;                                                                    
                                                                                                    
  // 48.17:  return 0;                                                                              
                                                                                                    
  assume Queue._state3611653 == Queue._state && Queue.elems3611653 == Queue.elems && Queue.head3611653 == Queue.head && Queue.tail3611653 == Queue.tail && Queue.spec3611653 == Queue.spec && Queue._lock3611653 == Queue._lock && Array.Queue.T._state3611653 == Array.Queue.T._state && Array.Queue.T._elems3611653 == Array.Queue.T._elems && Array.Queue.T._length3611653 == Array.Queue.T._length && tmp83611653 == tmp8 && tmp73611653 == tmp7 && tmp63611653 == tmp6 && tmp53611653 == tmp5 && $result3611653 == $result && this3611653 == this && tid3611653 == tid;
  assume $recorded.state3611653 == 1;                                                               
  $result := 0;                                                                                     
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (48.17): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (48.17): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (48.17): Object invariant may not hold.
  return;                                                                                           
 }                                                                                                  
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (50.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Queue._lock[this] == tid;                                                                          // (50.9): lock not held
 _pc := transition(_pc, _L);                                                                        
 assert _pc != PhaseError;                                                                                 // (50.9): Reduction failure
 Queue._lock[this] := Tid.null;                                                                     
                                                                                                    
 // 34.26: // return -1;                                                                            
                                                                                                    
 assume Queue._state3611663 == Queue._state && Queue.elems3611663 == Queue.elems && Queue.head3611663 == Queue.head && Queue.tail3611663 == Queue.tail && Queue.spec3611663 == Queue.spec && Queue._lock3611663 == Queue._lock && Array.Queue.T._state3611663 == Array.Queue.T._state && Array.Queue.T._elems3611663 == Array.Queue.T._elems && Array.Queue.T._length3611663 == Array.Queue.T._length && $result3611663 == $result && this3611663 == this && tid3611663 == tid;
 assume $recorded.state3611663 == 1;                                                                
 $result := -1;                                                                                     
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (34.26): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (34.26): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (34.26): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
/*** Array Array.Queue.T ***/                                                                       
                                                                                                    
type Array.Queue.T;                                                                                 
const unique Array.Queue.T.null: Array.Queue.T;                                                     
var Array.Queue.T._state: [Array.Queue.T]State;                                                     
                                                                                                    
const Array.Queue.T._this : [Array.Queue.T]Queue;                                                   
const Array.Queue.T._length : [Array.Queue.T]int;                                                   
var Array.Queue.T._elems  : [Array.Queue.T]([int]int);                                              
                                                                                                    
axiom (forall $this : Array.Queue.T :: Array.Queue.T._length[$this] >= 0);                          
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
// Array.Queue.T: Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(Holds(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List())
                                                                                                    
function {:inline} ReadEval.Array.Queue.T(tid: Tid,this : Queue,athis : Array.Queue.T,index : int,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Queue._state[this], tid) && Queue._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
// Array.Queue.T: Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(Holds(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List())
                                                                                                    
function {:inline} WriteEval.Array.Queue.T(tid: Tid,this : Queue,athis : Array.Queue.T,index : int,newValue: int,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Queue._state[this], tid) && Queue._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (bool) {
  true &&                                                                                           
  (forall _i: Queue  :: _i == Queue.null <==> isNull(Queue._state[_i])) &&                          
  (forall _i: Array.Queue.T  :: _i == Array.Queue.T.null <==> isNull(Array.Queue.T._state[_i])) &&  
  (forall _t: Tid, _i: Array.Queue.T  :: ValidTid(_t) && isAccessible(Array.Queue.T._state[_i], _t) ==> isAccessible(Queue._state[Array.Queue.T._this[_i]], _t)) &&
  (forall _i: Queue :: { Array.Queue.T._state[Queue.elems[_i]] } (isShared(Queue._state[_i]) ==> isSharedAssignable(Array.Queue.T._state[Queue.elems[_i]]))) &&
  (forall _i: Queue :: { Array.Queue.T._state[Queue.elems[_i]] } (forall _t: Tid :: (ValidTid(_t) && isLocal(Queue._state[_i],_t) ==> isLocalAssignable(Array.Queue.T._state[Queue.elems[_i]], _t)))) &&
  (forall _i: Queue :: { Queue.elems[_i] } Array.Queue.T._this[Queue.elems[_i]] == _i) &&           
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, x: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.elems[x] := v;                                                                               
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.elems(u: Tid,x: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (9.5): Queue.elems failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, x: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.elems[x] := v;                                                                               
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Queue.elems(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (9.5): Queue.elems failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, x: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Array.Queue.T;                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.elems[x];                                                                        
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Queue.elems[x] := havocValue;                                                                      
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.elems(u: Tid,x: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (9.5): Queue.elems failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, x: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Array.Queue.T;                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.elems[x];                                                                        
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByU := ReadEval.Queue.elems(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (9.5): Queue.elems failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, x: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.elems(u: Tid,x: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (9.5): Queue.elems failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, x: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Array.Queue.T;                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume w == Queue.elems[x];                                                                        
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Queue.elems[x] := havocValue;                                                                      
 _writeByU := WriteEval.Queue.elems(u: Tid,x: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (9.5): Queue.elems failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Queue.head(t: Tid, u: Tid, v: int, w: int, x: Queue)         
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.head[x] := v;                                                                                
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (10.5): Queue.head failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Queue.head(t: Tid, u: Tid, v: int, w: int, x: Queue)          
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.head[x] := v;                                                                                
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Queue.head(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (10.5): Queue.head failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Queue.head(t: Tid, u: Tid, v: int, w: int, x: Queue)          
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.head[x];                                                                         
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Queue.head[x] := havocValue;                                                                       
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (10.5): Queue.head failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Queue.head(t: Tid, u: Tid, v: int, w: int, x: Queue)           
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.head[x];                                                                         
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByU := ReadEval.Queue.head(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (10.5): Queue.head failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Queue.head(t: Tid, u: Tid, v: int, w: int, x: Queue)               
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (10.5): Queue.head failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Queue.head(t: Tid, u: Tid, v: int, w: int, x: Queue)                
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume w == Queue.head[x];                                                                         
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Queue.head[x] := havocValue;                                                                       
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (10.5): Queue.head failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Queue.tail(t: Tid, u: Tid, v: int, w: int, x: Queue)         
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.tail[x] := v;                                                                                
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (11.5): Queue.tail failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Queue.tail(t: Tid, u: Tid, v: int, w: int, x: Queue)          
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.tail[x] := v;                                                                                
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Queue.tail(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (11.5): Queue.tail failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Queue.tail(t: Tid, u: Tid, v: int, w: int, x: Queue)          
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.tail[x];                                                                         
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Queue.tail[x] := havocValue;                                                                       
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (11.5): Queue.tail failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Queue.tail(t: Tid, u: Tid, v: int, w: int, x: Queue)           
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.tail[x];                                                                         
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByU := ReadEval.Queue.tail(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (11.5): Queue.tail failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Queue.tail(t: Tid, u: Tid, v: int, w: int, x: Queue)               
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (11.5): Queue.tail failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Queue.tail(t: Tid, u: Tid, v: int, w: int, x: Queue)                
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume w == Queue.tail[x];                                                                         
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Queue.tail[x] := havocValue;                                                                       
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (11.5): Queue.tail failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Queue) 
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.spec[x] := v;                                                                                
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.spec(u: Tid,x: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (19.5): Queue.spec failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Queue)  
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.spec[x] := v;                                                                                
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Queue.spec(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (19.5): Queue.spec failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Queue)  
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Seq.int;                                                                          
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.spec[x];                                                                         
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Queue.spec[x] := havocValue;                                                                       
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.spec(u: Tid,x: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (19.5): Queue.spec failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Queue)   
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Seq.int;                                                                          
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.spec[x];                                                                         
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByU := ReadEval.Queue.spec(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (19.5): Queue.spec failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Queue)       
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.spec(u: Tid,x: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (19.5): Queue.spec failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Queue)        
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Seq.int;                                                                          
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume w == Queue.spec[x];                                                                         
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Queue.spec[x] := havocValue;                                                                       
 _writeByU := WriteEval.Queue.spec(u: Tid,x: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (19.5): Queue.spec failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Queue, x: Array.Queue.T, i: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[x], u);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Array.Queue.T._elems[x][i] := v;                                                                   
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Array.Queue.T(u: Tid,x_owner: Queue,x: Array.Queue.T,i: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.5): Array Array.Queue.T failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Queue, x: Array.Queue.T, i: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[x], u);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Array.Queue.T._elems[x][i] := v;                                                                   
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Array.Queue.T(u: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (7.5): Array Array.Queue.T failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Queue, x: Array.Queue.T, i: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[x], u);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Array.Queue.T._elems[x][i];                                                            
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Array.Queue.T._elems[x][i] := havocValue;                                                          
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Array.Queue.T(u: Tid,x_owner: Queue,x: Array.Queue.T,i: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.5): Array Array.Queue.T failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Queue, x: Array.Queue.T, i: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[x], u);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Array.Queue.T._elems[x][i];                                                            
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _readByU := ReadEval.Array.Queue.T(u: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (7.5): Array Array.Queue.T failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Queue, x: Array.Queue.T, i: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[x], u);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Queue.T(u: Tid,x_owner: Queue,x: Array.Queue.T,i: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.5): Array Array.Queue.T failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Queue, x: Array.Queue.T, i: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[x], u);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume w == Array.Queue.T._elems[x][i];                                                            
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Array.Queue.T._elems[x][i] := havocValue;                                                          
 _writeByU := WriteEval.Array.Queue.T(u: Tid,x_owner: Queue,x: Array.Queue.T,i: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.5): Array Array.Queue.T failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.elems.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.elems.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.elems.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.elems.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[y] := w;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.elems (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.elems.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.elems.Queue.head(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.elems.Queue.head(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.elems.Queue.head(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.elems.Queue.head(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.elems.Queue.head(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Queue.head is not Write-Read Stable with respect to Queue.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.elems.Queue.tail(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.elems.Queue.tail(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.elems.Queue.tail(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.elems.Queue.tail(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.tail (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.elems.Queue.tail(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Queue.tail is not Write-Read Stable with respect to Queue.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Queue.tail is not Write-Read Stable with respect to Queue.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (11.5): Queue.tail is not Write-Read Stable with respect to Queue.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.elems.Queue.spec(t: Tid, u: Tid, v: Array.Queue.T, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.elems.Queue.spec(t: Tid, u: Tid, v: Array.Queue.T, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.elems.Queue.spec(t: Tid, u: Tid, v: Array.Queue.T, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.elems.Queue.spec(t: Tid, u: Tid, v: Array.Queue.T, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.spec (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.elems.Queue.spec(t: Tid, u: Tid, v: Array.Queue.T, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.spec is not Write-Read Stable with respect to Queue.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.spec is not Write-Read Stable with respect to Queue.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Queue.spec is not Write-Read Stable with respect to Queue.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.elems.Array.Queue.T._elems(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.elems;                                                                              
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.elems.Array.Queue.T._elems(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.elems;                                                                              
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.elems.Array.Queue.T._elems(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.elems;                                                                              
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.elems.Array.Queue.T._elems(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.elems;                                                                              
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[y][j] := w;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Array Array.Queue.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Array Array.Queue.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Array Array.Queue.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.elems.Array.Queue.T._elems(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.elems;                                                                              
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[y] := w;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.elems (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Queue.head is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (11.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.spec (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.spec is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.spec is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Queue.spec is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.head;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.head;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.head;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.head;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[y][j] := w;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Array Array.Queue.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Array Array.Queue.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Array Array.Queue.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.head;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[y] := w;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Queue.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Queue.elems (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Queue.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (11.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Queue.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Queue.spec (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Queue.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.spec is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.spec is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Queue.spec is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.tail;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.tail;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.tail;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.tail;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[y][j] := w;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Array Array.Queue.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Array Array.Queue.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Queue.tail is not Read-Write Stable with respect to Array Array.Queue.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.tail;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.spec.Queue.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.spec.Queue.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.spec.Queue.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.spec.Queue.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[y] := w;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Queue.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Queue.elems (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Queue.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.spec.Queue.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.spec.Queue.head(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.spec.Queue.head(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.spec.Queue.head(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.spec.Queue.head(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Queue.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.spec.Queue.head(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Queue.head is not Write-Read Stable with respect to Queue.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.spec.Queue.tail(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.spec.Queue.tail(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.spec.Queue.tail(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.spec.Queue.tail(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Queue.tail (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.spec.Queue.tail(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Queue.tail is not Write-Read Stable with respect to Queue.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Queue.tail is not Write-Read Stable with respect to Queue.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (11.5): Queue.tail is not Write-Read Stable with respect to Queue.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.spec.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.spec.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.spec.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.spec.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Queue.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Queue.spec (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Queue.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.spec.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.spec is not Write-Read Stable with respect to Queue.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.spec is not Write-Read Stable with respect to Queue.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Queue.spec is not Write-Read Stable with respect to Queue.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.spec.Array.Queue.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.spec;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.spec.Array.Queue.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.spec;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.spec.Array.Queue.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.spec;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.spec.Array.Queue.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.spec;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[y][j] := w;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Array Array.Queue.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Array Array.Queue.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.spec is not Read-Write Stable with respect to Array Array.Queue.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.spec.Array.Queue.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.spec;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Queue.T._elems.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var w0_post: Array.Queue.T;                                                                        
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Queue.T._elems.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var w0_post: Array.Queue.T;                                                                        
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Queue.T._elems.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var w0_post: Array.Queue.T;                                                                        
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Queue.T._elems.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var w0_post: Array.Queue.T;                                                                        
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[y] := w;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.elems (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Queue.T._elems.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var w0_post: Array.Queue.T;                                                                        
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Array Array.Queue.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Array Array.Queue.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Queue.elems is not Write-Read Stable with respect to Array Array.Queue.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Queue.T._elems.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Queue.T._elems.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Queue.T._elems.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Queue.T._elems.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Queue.T._elems.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Array Array.Queue.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Array Array.Queue.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Queue.head is not Write-Read Stable with respect to Array Array.Queue.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Queue.T._elems.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (11.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (11.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Queue.T._elems.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Queue.T._elems.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Queue.T._elems.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.tail (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Queue.T._elems.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Queue.tail is not Write-Read Stable with respect to Array Array.Queue.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Queue.tail is not Write-Read Stable with respect to Array Array.Queue.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (11.5): Queue.tail is not Write-Read Stable with respect to Array Array.Queue.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Queue.T._elems.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Queue.T._elems.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Queue.T._elems.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Queue.T._elems.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.spec (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Queue.T._elems.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.spec is not Write-Read Stable with respect to Array Array.Queue.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.spec is not Write-Read Stable with respect to Array Array.Queue.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Queue.spec is not Write-Read Stable with respect to Array Array.Queue.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Queue.T._elems.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Queue.T._elems.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Queue.T._elems.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Queue.T._elems.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[y][j] := w;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Array Array.Queue.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Array Array.Queue.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Array Array.Queue.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Queue.T._elems.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Array Array.Queue.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Array Array.Queue.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Array Array.Queue.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
requires ValidTid(tid);                                                                             
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
modifies Queue._state;                                                                              
modifies Queue.elems;                                                                               
modifies Queue.head;                                                                                
modifies Queue.tail;                                                                                
modifies Queue.spec;                                                                                
modifies Queue._lock;                                                                               
modifies Array.Queue.T._state;                                                                      
modifies Array.Queue.T._elems;                                                                      
ensures StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
ensures Y(tid , old(Queue._state), old(Queue.elems), old(Queue.head), old(Queue.tail), old(Queue.spec), old(Queue._lock), old(Array.Queue.T._state), old(Array.Queue.T._elems), old(Array.Queue.T._length) , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// Queue.elems:                                                                                     
                                                                                                    
function {:inline} Y_Queue.elems(tid : Tid, this: Queue, newValue: Array.Queue.T , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _R)) ==> (Queue.elems[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue.elems.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: Array.Queue.T , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue.elems(u: Tid,this: Queue,newValue: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)));
                                                                                                    
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.elems(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.elems.Reflexive(tid : Tid, this: Queue , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.elems(tid, this, Queue.elems[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.elems.Transitive(tid : Tid, this: Queue, newValue : Array.Queue.T , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires StateInvariant(Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (9.24): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (9.24): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (9.24): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Queue.tail_pre: [Queue]int;                                                                     
var _pc_pre: Phase;                                                                                 
var $recorded.state_pre: int;                                                                       
var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                 
var Queue._lock_pre: [Queue]Tid;                                                                    
var Queue.spec_pre: [Queue]Seq.int;                                                                 
var tid_pre: Tid;                                                                                   
var Queue._state_pre: [Queue]State;                                                                 
var Queue.elems_pre: [Queue]Array.Queue.T;                                                          
var newValue_pre: Array.Queue.T;                                                                    
var Queue.head_pre: [Queue]int;                                                                     
var this_pre: Queue;                                                                                
var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                            
var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                  
                                                                                                    
var Array.Queue.T._length_post: [Array.Queue.T]int;                                                 
var Queue.head_post: [Queue]int;                                                                    
var $recorded.state_post: int;                                                                      
var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                           
var Array.Queue.T._state_post: [Array.Queue.T]State;                                                
var tid_post: Tid;                                                                                  
var Queue.spec_post: [Queue]Seq.int;                                                                
var this_post: Queue;                                                                               
var newValue_post: Array.Queue.T;                                                                   
var Queue._state_post: [Queue]State;                                                                
var Queue.elems_post: [Queue]Array.Queue.T;                                                         
var _pc_post: Phase;                                                                                
var Queue.tail_post: [Queue]int;                                                                    
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assume Y_Queue.elems(tid, this, newValue , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
assume Queue._state_post == Queue._state_p && Queue.elems_post == Queue.elems_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue.spec_post == Queue.spec_p && Queue._lock_post == Queue._lock_p && Array.Queue.T._state_post == Array.Queue.T._state_p && Array.Queue.T._elems_post == Array.Queue.T._elems_p && Array.Queue.T._length_post == Array.Queue.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue.elems(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
// Queue.head:                                                                                      
                                                                                                    
function {:inline} Y_Queue.head(tid : Tid, this: Queue, newValue: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _R)) ==> (Queue.head[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue.head.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue.head(u: Tid,this: Queue,newValue: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)));
                                                                                                    
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.head(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.head.Reflexive(tid : Tid, this: Queue , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.head(tid, this, Queue.head[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.head.Transitive(tid : Tid, this: Queue, newValue : int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires StateInvariant(Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (10.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (10.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (10.33): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Queue.tail_pre: [Queue]int;                                                                     
var _pc_pre: Phase;                                                                                 
var $recorded.state_pre: int;                                                                       
var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                 
var newValue_pre: int;                                                                              
var Queue._lock_pre: [Queue]Tid;                                                                    
var Queue.spec_pre: [Queue]Seq.int;                                                                 
var tid_pre: Tid;                                                                                   
var Queue._state_pre: [Queue]State;                                                                 
var Queue.elems_pre: [Queue]Array.Queue.T;                                                          
var Queue.head_pre: [Queue]int;                                                                     
var this_pre: Queue;                                                                                
var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                            
var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                  
                                                                                                    
var Array.Queue.T._length_post: [Array.Queue.T]int;                                                 
var Queue.head_post: [Queue]int;                                                                    
var $recorded.state_post: int;                                                                      
var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                           
var newValue_post: int;                                                                             
var Array.Queue.T._state_post: [Array.Queue.T]State;                                                
var tid_post: Tid;                                                                                  
var Queue.spec_post: [Queue]Seq.int;                                                                
var this_post: Queue;                                                                               
var Queue._state_post: [Queue]State;                                                                
var Queue.elems_post: [Queue]Array.Queue.T;                                                         
var _pc_post: Phase;                                                                                
var Queue.tail_post: [Queue]int;                                                                    
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assume Y_Queue.head(tid, this, newValue , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
assume Queue._state_post == Queue._state_p && Queue.elems_post == Queue.elems_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue.spec_post == Queue.spec_p && Queue._lock_post == Queue._lock_p && Array.Queue.T._state_post == Array.Queue.T._state_p && Array.Queue.T._elems_post == Array.Queue.T._elems_p && Array.Queue.T._length_post == Array.Queue.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue.head(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
// Queue.tail:                                                                                      
                                                                                                    
function {:inline} Y_Queue.tail(tid : Tid, this: Queue, newValue: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.tail(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _R)) ==> (Queue.tail[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue.tail.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue.tail(u: Tid,this: Queue,newValue: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)));
                                                                                                    
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.tail(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.tail.Reflexive(tid : Tid, this: Queue , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.tail(tid, this, Queue.tail[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.tail.Transitive(tid : Tid, this: Queue, newValue : int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires StateInvariant(Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (11.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (11.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (11.33): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Queue.tail_pre: [Queue]int;                                                                     
var _pc_pre: Phase;                                                                                 
var $recorded.state_pre: int;                                                                       
var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                 
var newValue_pre: int;                                                                              
var Queue._lock_pre: [Queue]Tid;                                                                    
var Queue.spec_pre: [Queue]Seq.int;                                                                 
var tid_pre: Tid;                                                                                   
var Queue._state_pre: [Queue]State;                                                                 
var Queue.elems_pre: [Queue]Array.Queue.T;                                                          
var Queue.head_pre: [Queue]int;                                                                     
var this_pre: Queue;                                                                                
var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                            
var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                  
                                                                                                    
var Array.Queue.T._length_post: [Array.Queue.T]int;                                                 
var Queue.head_post: [Queue]int;                                                                    
var $recorded.state_post: int;                                                                      
var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                           
var newValue_post: int;                                                                             
var Array.Queue.T._state_post: [Array.Queue.T]State;                                                
var tid_post: Tid;                                                                                  
var Queue.spec_post: [Queue]Seq.int;                                                                
var this_post: Queue;                                                                               
var Queue._state_post: [Queue]State;                                                                
var Queue.elems_post: [Queue]Array.Queue.T;                                                         
var _pc_post: Phase;                                                                                
var Queue.tail_post: [Queue]int;                                                                    
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assume Y_Queue.tail(tid, this, newValue , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
assume Queue._state_post == Queue._state_p && Queue.elems_post == Queue.elems_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue.spec_post == Queue.spec_p && Queue._lock_post == Queue._lock_p && Array.Queue.T._state_post == Array.Queue.T._state_p && Array.Queue.T._elems_post == Array.Queue.T._elems_p && Array.Queue.T._length_post == Array.Queue.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue.tail(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
// Queue.spec:                                                                                      
                                                                                                    
function {:inline} Y_Queue.spec(tid : Tid, this: Queue, newValue: Seq.int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _R)) ==> (Queue.spec[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue.spec.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: Seq.int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue.spec(u: Tid,this: Queue,newValue: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)));
                                                                                                    
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.spec(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.spec.Reflexive(tid : Tid, this: Queue , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.spec(tid, this, Queue.spec[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.spec.Transitive(tid : Tid, this: Queue, newValue : Seq.int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires StateInvariant(Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (19.37): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (19.37): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (19.37): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Queue.tail_pre: [Queue]int;                                                                     
var _pc_pre: Phase;                                                                                 
var $recorded.state_pre: int;                                                                       
var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                 
var Queue._lock_pre: [Queue]Tid;                                                                    
var newValue_pre: Seq.int;                                                                          
var Queue.spec_pre: [Queue]Seq.int;                                                                 
var tid_pre: Tid;                                                                                   
var Queue._state_pre: [Queue]State;                                                                 
var Queue.elems_pre: [Queue]Array.Queue.T;                                                          
var Queue.head_pre: [Queue]int;                                                                     
var this_pre: Queue;                                                                                
var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                            
var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                  
                                                                                                    
var Array.Queue.T._length_post: [Array.Queue.T]int;                                                 
var Queue.head_post: [Queue]int;                                                                    
var $recorded.state_post: int;                                                                      
var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                           
var Array.Queue.T._state_post: [Array.Queue.T]State;                                                
var tid_post: Tid;                                                                                  
var Queue.spec_post: [Queue]Seq.int;                                                                
var this_post: Queue;                                                                               
var newValue_post: Seq.int;                                                                         
var Queue._state_post: [Queue]State;                                                                
var Queue.elems_post: [Queue]Array.Queue.T;                                                         
var _pc_post: Phase;                                                                                
var Queue.tail_post: [Queue]int;                                                                    
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assume Y_Queue.spec(tid, this, newValue , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
assume Queue._state_post == Queue._state_p && Queue.elems_post == Queue.elems_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue.spec_post == Queue.spec_p && Queue._lock_post == Queue._lock_p && Array.Queue.T._state_post == Array.Queue.T._state_p && Array.Queue.T._elems_post == Array.Queue.T._elems_p && Array.Queue.T._length_post == Array.Queue.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue.spec(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
// Queue._lock:                                                                                     
                                                                                                    
function {:inline} Y_Queue._lock(tid : Tid, this: Queue, newValue: Tid , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue._lock(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _R)) ==> (Queue._lock[this] == newValue))
 &&(((Queue._lock[this]==tid)==(newValue==tid)))                                                    
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue._lock.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: Tid , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue._lock(u: Tid,this: Queue,newValue: Tid,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)));
 assume leq(m#moverPath(ReadEval.Queue._lock(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _N);
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue._lock(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue._lock.Reflexive(tid : Tid, this: Queue , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue._lock(tid, this, Queue._lock[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue._lock.Transitive(tid : Tid, this: Queue, newValue : Tid , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires StateInvariant(Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (3.1): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (3.1): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (3.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Queue.tail_pre: [Queue]int;                                                                     
var _pc_pre: Phase;                                                                                 
var $recorded.state_pre: int;                                                                       
var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                 
var Queue._lock_pre: [Queue]Tid;                                                                    
var Queue.spec_pre: [Queue]Seq.int;                                                                 
var tid_pre: Tid;                                                                                   
var Queue._state_pre: [Queue]State;                                                                 
var Queue.elems_pre: [Queue]Array.Queue.T;                                                          
var Queue.head_pre: [Queue]int;                                                                     
var newValue_pre: Tid;                                                                              
var this_pre: Queue;                                                                                
var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                            
var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                  
                                                                                                    
var Array.Queue.T._length_post: [Array.Queue.T]int;                                                 
var Queue.head_post: [Queue]int;                                                                    
var $recorded.state_post: int;                                                                      
var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                           
var Array.Queue.T._state_post: [Array.Queue.T]State;                                                
var tid_post: Tid;                                                                                  
var Queue.spec_post: [Queue]Seq.int;                                                                
var this_post: Queue;                                                                               
var Queue._state_post: [Queue]State;                                                                
var Queue.elems_post: [Queue]Array.Queue.T;                                                         
var newValue_post: Tid;                                                                             
var _pc_post: Phase;                                                                                
var Queue.tail_post: [Queue]int;                                                                    
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assume Y_Queue._lock(tid, this, newValue , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
assume Queue._state_post == Queue._state_p && Queue.elems_post == Queue.elems_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue.spec_post == Queue.spec_p && Queue._lock_post == Queue._lock_p && Array.Queue.T._state_post == Array.Queue.T._state_p && Array.Queue.T._elems_post == Array.Queue.T._elems_p && Array.Queue.T._length_post == Array.Queue.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue._lock(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
// Array.Queue.T:                                                                                   
                                                                                                    
function {:inline} Y_Array.Queue.T(tid : Tid, athis: Array.Queue.T, index: int, newValue: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int): bool
{                                                                                                   
(var this := Array.Queue.T._this[athis];                                                            
 ((isAccessible(Array.Queue.T._state[athis], tid) && leq(m#moverPath(ReadEval.Array.Queue.T(tid: Tid,Array.Queue.T._this[athis]: Queue,athis: Array.Queue.T,index: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _R)) ==> (Array.Queue.T._elems[athis][index] == newValue))
                                                                                                    
)                                                                                                   
}                                                                                                   
                                                                                                    
procedure Y_Array.Queue.T.Subsumes.W(tid : Tid, u : Tid, this: Queue, athis: Array.Queue.T, index: int, newValue: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
 requires this == Array.Queue.T._this[athis];                                                       
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var athis_yield: Array.Queue.T;                                                                     
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var index_yield: int;                                                                               
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Array.Queue.T._state[athis], u);                                               
 assume !isError(m#moverPath(WriteEval.Array.Queue.T(u: Tid,Array.Queue.T._this[athis]: Queue,athis: Array.Queue.T,index: int,newValue: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)));
                                                                                                    
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && athis_yield == athis && index_yield == index && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Array.Queue.T(tid, athis, index, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Array.Queue.T.Reflexive(tid : Tid, this: Queue, athis: Array.Queue.T, index: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires this == Array.Queue.T._this[athis];                                                       
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var athis_yield: Array.Queue.T;                                                                     
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var index_yield: int;                                                                               
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Array.Queue.T._state[athis], tid);                                             
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && athis_yield == athis && index_yield == index && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Array.Queue.T(tid, athis, index, Array.Queue.T._elems[athis][index] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Array.Queue.T.Transitive(tid : Tid, this: Queue, athis: Array.Queue.T, index: int, newValue : int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires StateInvariant(Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598743(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (7.28): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598756(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (7.28): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3598791(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (7.28): Object invariant may not hold.
                                                                                                    
 requires this == Array.Queue.T._this[athis];                                                       
 requires ValidTid(tid);                                                                            
{                                                                                                   
var Queue.tail_pre: [Queue]int;                                                                     
var _pc_pre: Phase;                                                                                 
var $recorded.state_pre: int;                                                                       
var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                 
var index_pre: int;                                                                                 
var Queue._lock_pre: [Queue]Tid;                                                                    
var Queue.spec_pre: [Queue]Seq.int;                                                                 
var tid_pre: Tid;                                                                                   
var Queue._state_pre: [Queue]State;                                                                 
var Queue.elems_pre: [Queue]Array.Queue.T;                                                          
var Queue.head_pre: [Queue]int;                                                                     
var this_pre: Queue;                                                                                
var athis_pre: Array.Queue.T;                                                                       
var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                            
var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                  
                                                                                                    
var Array.Queue.T._length_post: [Array.Queue.T]int;                                                 
var Queue.head_post: [Queue]int;                                                                    
var $recorded.state_post: int;                                                                      
var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                           
var Array.Queue.T._state_post: [Array.Queue.T]State;                                                
var tid_post: Tid;                                                                                  
var Queue.spec_post: [Queue]Seq.int;                                                                
var athis_post: Array.Queue.T;                                                                      
var this_post: Queue;                                                                               
var index_post: int;                                                                                
var Queue._state_post: [Queue]State;                                                                
var Queue.elems_post: [Queue]Array.Queue.T;                                                         
var _pc_post: Phase;                                                                                
var Queue.tail_post: [Queue]int;                                                                    
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && athis_pre == athis && index_pre == index && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
assume Queue._state_post == Queue._state_p && Queue.elems_post == Queue.elems_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue.spec_post == Queue.spec_p && Queue._lock_post == Queue._lock_p && Array.Queue.T._state_post == Array.Queue.T._state_p && Array.Queue.T._elems_post == Array.Queue.T._elems_p && Array.Queue.T._length_post == Array.Queue.T._length_p && athis_post == athis && index_post == index && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assume isAccessible(Array.Queue.T._state[athis], tid);                                             
 assume Y(tid , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assume Y_Array.Queue.T(tid, athis, index, newValue , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assert Y_Array.Queue.T(tid, athis, index, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int): bool
{                                                                                                   
 (forall this: Queue :: Y_Queue.elems(tid : Tid, this, Queue.elems_p[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length))
 && (forall this: Queue :: Y_Queue.head(tid : Tid, this, Queue.head_p[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length))
 && (forall this: Queue :: Y_Queue.tail(tid : Tid, this, Queue.tail_p[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length))
 && (forall this: Queue :: Y_Queue.spec(tid : Tid, this, Queue.spec_p[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length))
 && (forall this: Queue :: Y_Queue._lock(tid : Tid, this, Queue._lock_p[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length))
 && (forall athis: Array.Queue.T, index: int :: Y_Array.Queue.T(tid : Tid, athis, index, Array.Queue.T._elems_p[athis][index] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length))
 && (forall _i : Queue :: isShared(Queue._state[_i]) ==> isShared(Queue._state_p[_i]))              
 && (forall _i : Queue :: isLocal(Queue._state[_i], tid) <==> isLocal(Queue._state_p[_i], tid))     
 && (forall _i : Array.Queue.T :: isShared(Array.Queue.T._state[_i]) ==> isShared(Array.Queue.T._state_p[_i]))
 && (forall _i : Array.Queue.T :: Array.Queue.T._length[_i] == Array.Queue.T._length_p[_i])         
 && (forall _i : Array.Queue.T :: isLocal(Array.Queue.T._state[_i], tid) <==> isLocal(Array.Queue.T._state_p[_i], tid))
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
/// Seq.int:                                                                                        
                                                                                                    
type {:builtin "(Seq Int)"} Seq.int;                                                                
                                                                                                    
function {:builtin "(as seq.empty (Seq Int))"} SeqEmpty.int(): Seq.int;                             
function {:builtin "seq.len"} SeqLen.int(s: Seq.int): int;                                          
function {:builtin "seq.++"} SeqConcat.int(s1: Seq.int, s2:Seq.int): Seq.int;                       
function {:builtin "seq.unit"} SeqUnit.int(v: int): Seq.int;                                        
function {:builtin "seq.nth"} SeqNth.int(s: Seq.int, i: int): int;                                  
function {:builtin "seq.extract"} SeqExtract.int(s: Seq.int, pos: int, len: int): Seq.int;          
                                                                                                    
function {:inline} SeqEqual.int(a: Seq.int, b: Seq.int) : bool {                                    
SeqLen.int(a) == SeqLen.int(b) &&                                                                   
(forall i : int :: 0 <= i && i < SeqLen.int(a) ==> (SeqNth.int(a, i) == SeqNth.int(b, i)))          
}                                                                                                   
                                                                                                    
function {:inline} SeqSub.int(a: Seq.int, start: int, end: int) : Seq.int {                         
SeqExtract.int(a, start, end-start)                                                                 
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
// 1318.1-1584.2: (Method:26.5)
// 1330.1-1330.24: (26.5): Bad tid
// 1336.1-1336.304: (26.5): Object invariant may not hold.
// 1337.1-1337.304: (26.5): Object invariant may not hold.
// 1338.1-1338.304: (26.5): Object invariant may not hold.
// 1341.1-1341.294: (26.5): Object invariant may not hold.
// 1342.1-1342.294: (26.5): Object invariant may not hold.
// 1343.1-1343.294: (26.5): Object invariant may not hold.
// 1444.1-1444.215: (26.5): Can only have right-mover memory accesses in requires clause
// 1446.2-1449.49: (class anchor.sink.Assume:26.5)
// 1450.2-1453.31: (class anchor.sink.Assume:26.5)
// 1454.2-1457.31: (class anchor.sink.Assume:26.5)
// 1458.2-1461.54: (class anchor.sink.Assume:26.5)
// 1462.2-1464.2: (class anchor.sink.VarDeclStmt:28.9)
// 1465.2-1468.25: (class anchor.sink.Assign:28.9)
// 1470.2-1486.27: (class anchor.sink.Write:28.9)
// 1482.1-1482.29: (28.9): Cannot have potential null deference in left-mover part.
// 1485.1-1485.27: (28.9): Reduction failure
// 1487.2-1489.2: (class anchor.sink.VarDeclStmt:29.9)
// 1490.2-1493.12: (class anchor.sink.Assign:29.9)
// 1495.2-1511.27: (class anchor.sink.Write:29.9)
// 1507.1-1507.29: (29.9): Cannot have potential null deference in left-mover part.
// 1510.1-1510.27: (29.9): Reduction failure
// 1512.2-1514.2: (class anchor.sink.VarDeclStmt:30.9)
// 1515.2-1518.12: (class anchor.sink.Assign:30.9)
// 1520.2-1536.27: (class anchor.sink.Write:30.9)
// 1532.1-1532.29: (30.9): Cannot have potential null deference in left-mover part.
// 1535.1-1535.27: (30.9): Reduction failure
// 1537.2-1539.2: (class anchor.sink.VarDeclStmt:31.9)
// 1540.2-1548.78: (class anchor.sink.AAlloc:31.9)
// 1550.2-1574.2: (class anchor.sink.Write:31.9)
// 1562.1-1562.29: (31.9): Cannot have potential null deference in left-mover part.
// 1565.1-1565.27: (31.9): Reduction failure
// 1571.1-1571.92: (31.9): tmp4 became shared, but Array.Queue.T._this[tmp4].elems may not be shared.
// 1575.2-1583.9: (class anchor.sink.Return:27.21)
// 1580.1-1580.294: (27.21): Object invariant may not hold.
// 1581.1-1581.294: (27.21): Object invariant may not hold.
// 1582.1-1582.294: (27.21): Object invariant may not hold.
// 1585.1-3963.2: (Method:34.5)
// 1598.1-1598.24: (34.5): Bad tid
// 1599.1-1599.39: (34.5): this is not global
// 1602.1-1602.295: (34.5): Object invariant may not hold.
// 1603.1-1603.295: (34.5): Object invariant may not hold.
// 1604.1-1604.295: (34.5): Object invariant may not hold.
// 1607.1-1607.294: (34.5): Object invariant may not hold.
// 1608.1-1608.294: (34.5): Object invariant may not hold.
// 1609.1-1609.294: (34.5): Object invariant may not hold.
// 3068.1-3068.29: (35.23): Cannot have potential null deference in left-mover part.
// 3072.1-3072.27: (35.23): Reduction failure
// 3074.2-3076.2: (class anchor.sink.VarDeclStmt:36.13)
// 3077.2-3079.2: (class anchor.sink.VarDeclStmt:36.13)
// 3080.2-3082.2: (class anchor.sink.VarDeclStmt:36.13)
// 3083.2-3100.27: (class anchor.sink.Read:36.13)
// 3095.1-3095.29: (36.13): Cannot have potential null deference in left-mover part.
// 3099.1-3099.27: (36.13): Reduction failure
// 3101.2-3103.2: (class anchor.sink.VarDeclStmt:36.13)
// 3104.2-3121.27: (class anchor.sink.Read:36.13)
// 3116.1-3116.29: (36.13): Cannot have potential null deference in left-mover part.
// 3120.1-3120.27: (36.13): Reduction failure
// 3122.2-3125.22: (class anchor.sink.Assign:36.13)
// 3126.2-3129.19: (class anchor.sink.Assign:36.13)
// 3131.3-3133.3: (class anchor.sink.VarDeclStmt:37.17)
// 3134.3-3136.3: (class anchor.sink.VarDeclStmt:37.17)
// 3137.3-3154.29: (class anchor.sink.Read:37.17)
// 3149.1-3149.30: (37.17): Cannot have potential null deference in left-mover part.
// 3153.1-3153.28: (37.17): Reduction failure
// 3155.3-3157.3: (class anchor.sink.VarDeclStmt:37.17)
// 3158.3-3175.29: (class anchor.sink.Read:37.17)
// 3170.1-3170.30: (37.17): Cannot have potential null deference in left-mover part.
// 3174.1-3174.28: (37.17): Reduction failure
// 3176.3-3203.47: (class anchor.sink.ARead:37.17)
// 3188.1-3188.38: (37.17): Cannot have potential null deference in left-mover part.
// 3193.1-3193.22: (37.17): index < 0.
// 3198.1-3198.47: (37.17): index is >= length.
// 3202.1-3202.28: (37.17): Reduction failure
// 3204.3-3206.3: (class anchor.sink.VarDeclStmt:38.17)
// 3207.3-3209.3: (class anchor.sink.VarDeclStmt:38.17)
// 3210.3-3227.29: (class anchor.sink.Read:38.17)
// 3222.1-3222.30: (38.17): Cannot have potential null deference in left-mover part.
// 3226.1-3226.28: (38.17): Reduction failure
// 3228.3-3230.3: (class anchor.sink.VarDeclStmt:38.17)
// 3231.3-3233.3: (class anchor.sink.VarDeclStmt:38.17)
// 3234.3-3236.3: (class anchor.sink.VarDeclStmt:38.17)
// 3237.3-3254.29: (class anchor.sink.Read:38.17)
// 3249.1-3249.30: (38.17): Cannot have potential null deference in left-mover part.
// 3253.1-3253.28: (38.17): Reduction failure
// 3255.3-3258.30: (class anchor.sink.Assign:38.17)
// 3259.3-3262.22: (class anchor.sink.Assign:38.17)
// 3263.3-3266.38: (class anchor.sink.Assign:38.17)
// 3267.3-3269.3: (class anchor.sink.VarDeclStmt:39.17)
// 3270.3-3272.3: (class anchor.sink.VarDeclStmt:40.17)
// 3273.3-3275.3: (class anchor.sink.VarDeclStmt:40.17)
// 3276.3-3278.3: (class anchor.sink.VarDeclStmt:40.17)
// 3279.3-3282.19: (class anchor.sink.Assign:40.17)
// 3284.4-3286.4: (class anchor.sink.VarDeclStmt:40.38)
// 3287.4-3289.4: (class anchor.sink.VarDeclStmt:40.45)
// 3290.4-3307.30: (class anchor.sink.Read:40.45)
// 3302.1-3302.31: (40.45): Cannot have potential null deference in left-mover part.
// 3306.1-3306.29: (40.45): Reduction failure
// 3308.4-3311.31: (class anchor.sink.Assign:40.38)
// 3312.4-3315.23: (class anchor.sink.Assign:40.36)
// 3318.3-3320.3: (class anchor.sink.VarDeclStmt:40.17)
// 3321.3-3323.3: (class anchor.sink.VarDeclStmt:40.17)
// 3324.3-3326.3: (class anchor.sink.VarDeclStmt:40.17)
// 3327.3-3344.29: (class anchor.sink.Read:40.17)
// 3339.1-3339.30: (40.17): Cannot have potential null deference in left-mover part.
// 3343.1-3343.28: (40.17): Reduction failure
// 3345.3-3348.32: (class anchor.sink.Assign:40.17)
// 3349.3-3351.3: (class anchor.sink.VarDeclStmt:40.17)
// 3352.3-3369.30: (class anchor.sink.Read:40.17)
// 3364.1-3364.30: (40.17): Cannot have potential null deference in left-mover part.
// 3368.1-3368.28: (40.17): Reduction failure
// 3370.3-3372.3: (class anchor.sink.VarDeclStmt:40.17)
// 3373.3-3375.3: (class anchor.sink.VarDeclStmt:40.17)
// 3376.3-3393.29: (class anchor.sink.Read:40.17)
// 3388.1-3388.30: (40.17): Cannot have potential null deference in left-mover part.
// 3392.1-3392.28: (40.17): Reduction failure
// 3394.3-3397.22: (class anchor.sink.Assign:40.17)
// 3398.3-3400.3: (class anchor.sink.VarDeclStmt:40.17)
// 3401.3-3428.47: (class anchor.sink.ARead:40.17)
// 3413.1-3413.39: (40.17): Cannot have potential null deference in left-mover part.
// 3418.1-3418.22: (40.17): index < 0.
// 3423.1-3423.48: (40.17): index is >= length.
// 3427.1-3427.28: (40.17): Reduction failure
// 3429.3-3432.27: (class anchor.sink.Assign:40.17)
// 3433.3-3436.28: (class anchor.sink.Assign:40.17)
// 3437.3-3442.173: (class anchor.sink.Assert:40.17)
// 3442.1-3442.173: (40.17): This assertion may not hold.
// 3443.3-3445.3: (class anchor.sink.VarDeclStmt:41.17)
// 3446.3-3448.3: (class anchor.sink.VarDeclStmt:41.17)
// 3449.3-3451.3: (class anchor.sink.VarDeclStmt:41.17)
// 3452.3-3455.19: (class anchor.sink.Assign:41.17)
// 3457.4-3459.4: (class anchor.sink.VarDeclStmt:41.38)
// 3460.4-3463.27: (class anchor.sink.Assign:41.38)
// 3464.4-3467.23: (class anchor.sink.Assign:41.36)
// 3470.3-3472.3: (class anchor.sink.VarDeclStmt:41.17)
// 3473.3-3475.3: (class anchor.sink.VarDeclStmt:41.17)
// 3476.3-3479.28: (class anchor.sink.Assign:41.17)
// 3480.3-3482.3: (class anchor.sink.VarDeclStmt:41.17)
// 3483.3-3485.3: (class anchor.sink.VarDeclStmt:41.17)
// 3486.3-3503.29: (class anchor.sink.Read:41.17)
// 3498.1-3498.30: (41.17): Cannot have potential null deference in left-mover part.
// 3502.1-3502.28: (41.17): Reduction failure
// 3504.3-3506.3: (class anchor.sink.VarDeclStmt:41.17)
// 3507.3-3510.18: (class anchor.sink.Assign:41.17)
// 3511.3-3514.36: (class anchor.sink.Assign:41.17)
// 3515.3-3518.27: (class anchor.sink.Assign:41.17)
// 3519.3-3522.28: (class anchor.sink.Assign:41.17)
// 3523.3-3528.116: (class anchor.sink.Assert:41.17)
// 3528.1-3528.116: (41.17): This assertion may not hold.
// 3529.3-3531.3: (class anchor.sink.VarDeclStmt:42.17)
// 3532.3-3534.3: (class anchor.sink.VarDeclStmt:42.17)
// 3535.3-3537.3: (class anchor.sink.VarDeclStmt:42.17)
// 3538.3-3541.19: (class anchor.sink.Assign:42.17)
// 3543.4-3545.4: (class anchor.sink.VarDeclStmt:42.38)
// 3546.4-3549.27: (class anchor.sink.Assign:42.38)
// 3550.4-3553.23: (class anchor.sink.Assign:42.36)
// 3556.3-3558.3: (class anchor.sink.VarDeclStmt:42.17)
// 3559.3-3561.3: (class anchor.sink.VarDeclStmt:42.17)
// 3562.3-3565.28: (class anchor.sink.Assign:42.17)
// 3566.3-3568.3: (class anchor.sink.VarDeclStmt:42.17)
// 3569.3-3586.30: (class anchor.sink.Read:42.17)
// 3581.1-3581.30: (42.17): Cannot have potential null deference in left-mover part.
// 3585.1-3585.28: (42.17): Reduction failure
// 3587.3-3589.3: (class anchor.sink.VarDeclStmt:42.17)
// 3590.3-3592.3: (class anchor.sink.VarDeclStmt:42.17)
// 3593.3-3595.3: (class anchor.sink.VarDeclStmt:42.17)
// 3596.3-3613.29: (class anchor.sink.Read:42.17)
// 3608.1-3608.30: (42.17): Cannot have potential null deference in left-mover part.
// 3612.1-3612.28: (42.17): Reduction failure
// 3614.3-3617.22: (class anchor.sink.Assign:42.17)
// 3618.3-3621.22: (class anchor.sink.Assign:42.17)
// 3622.3-3624.3: (class anchor.sink.VarDeclStmt:42.17)
// 3625.3-3652.47: (class anchor.sink.ARead:42.17)
// 3637.1-3637.39: (42.17): Cannot have potential null deference in left-mover part.
// 3642.1-3642.22: (42.17): index < 0.
// 3647.1-3647.48: (42.17): index is >= length.
// 3651.1-3651.28: (42.17): Reduction failure
// 3653.3-3656.27: (class anchor.sink.Assign:42.17)
// 3657.3-3660.28: (class anchor.sink.Assign:42.17)
// 3661.3-3666.147: (class anchor.sink.Assert:42.17)
// 3666.1-3666.147: (42.17): This assertion may not hold.
// 3667.3-3669.3: (class anchor.sink.VarDeclStmt:43.17)
// 3670.3-3672.3: (class anchor.sink.VarDeclStmt:43.17)
// 3673.3-3690.29: (class anchor.sink.Read:43.17)
// 3685.1-3685.30: (43.17): Cannot have potential null deference in left-mover part.
// 3689.1-3689.28: (43.17): Reduction failure
// 3691.3-3694.22: (class anchor.sink.Assign:43.17)
// 3696.3-3712.29: (class anchor.sink.Write:43.17)
// 3708.1-3708.30: (43.17): Cannot have potential null deference in left-mover part.
// 3711.1-3711.28: (43.17): Reduction failure
// 3714.3-3730.25: (class anchor.sink.Write:44.17)
// 3726.1-3726.30: (44.17): Cannot have potential null deference in left-mover part.
// 3729.1-3729.28: (44.17): Reduction failure
// 3731.3-3733.3: (class anchor.sink.VarDeclStmt:45.17)
// 3734.3-3736.3: (class anchor.sink.VarDeclStmt:45.17)
// 3737.3-3739.3: (class anchor.sink.VarDeclStmt:45.17)
// 3740.3-3743.19: (class anchor.sink.Assign:45.17)
// 3745.4-3747.4: (class anchor.sink.VarDeclStmt:45.38)
// 3748.4-3750.4: (class anchor.sink.VarDeclStmt:45.45)
// 3751.4-3768.30: (class anchor.sink.Read:45.45)
// 3763.1-3763.31: (45.45): Cannot have potential null deference in left-mover part.
// 3767.1-3767.29: (45.45): Reduction failure
// 3769.4-3772.31: (class anchor.sink.Assign:45.38)
// 3773.4-3776.23: (class anchor.sink.Assign:45.36)
// 3779.3-3781.3: (class anchor.sink.VarDeclStmt:45.17)
// 3782.3-3784.3: (class anchor.sink.VarDeclStmt:45.17)
// 3785.3-3787.3: (class anchor.sink.VarDeclStmt:45.17)
// 3788.3-3805.29: (class anchor.sink.Read:45.17)
// 3800.1-3800.30: (45.17): Cannot have potential null deference in left-mover part.
// 3804.1-3804.28: (45.17): Reduction failure
// 3806.3-3809.32: (class anchor.sink.Assign:45.17)
// 3810.3-3812.3: (class anchor.sink.VarDeclStmt:45.17)
// 3813.3-3830.30: (class anchor.sink.Read:45.17)
// 3825.1-3825.30: (45.17): Cannot have potential null deference in left-mover part.
// 3829.1-3829.28: (45.17): Reduction failure
// 3831.3-3833.3: (class anchor.sink.VarDeclStmt:45.17)
// 3834.3-3836.3: (class anchor.sink.VarDeclStmt:45.17)
// 3837.3-3854.29: (class anchor.sink.Read:45.17)
// 3849.1-3849.30: (45.17): Cannot have potential null deference in left-mover part.
// 3853.1-3853.28: (45.17): Reduction failure
// 3855.3-3858.22: (class anchor.sink.Assign:45.17)
// 3859.3-3861.3: (class anchor.sink.VarDeclStmt:45.17)
// 3862.3-3889.47: (class anchor.sink.ARead:45.17)
// 3874.1-3874.39: (45.17): Cannot have potential null deference in left-mover part.
// 3879.1-3879.22: (45.17): index < 0.
// 3884.1-3884.48: (45.17): index is >= length.
// 3888.1-3888.28: (45.17): Reduction failure
// 3890.3-3893.27: (class anchor.sink.Assign:45.17)
// 3894.3-3897.28: (class anchor.sink.Assign:45.17)
// 3898.3-3903.173: (class anchor.sink.Assert:45.17)
// 3903.1-3903.173: (45.17): This assertion may not hold.
// 3907.1-3907.30: (50.9): Cannot have potential null deference in left-mover part.
// 3909.1-3909.35: (50.9): lock not held
// 3911.1-3911.28: (50.9): Reduction failure
// 3913.3-3922.10: (class anchor.sink.Return:46.17)
// 3919.1-3919.295: (46.17): Object invariant may not hold.
// 3920.1-3920.295: (46.17): Object invariant may not hold.
// 3921.1-3921.295: (46.17): Object invariant may not hold.
// 3927.1-3927.30: (50.9): Cannot have potential null deference in left-mover part.
// 3929.1-3929.35: (50.9): lock not held
// 3931.1-3931.28: (50.9): Reduction failure
// 3933.3-3942.10: (class anchor.sink.Return:48.17)
// 3939.1-3939.295: (48.17): Object invariant may not hold.
// 3940.1-3940.295: (48.17): Object invariant may not hold.
// 3941.1-3941.295: (48.17): Object invariant may not hold.
// 3947.1-3947.29: (50.9): Cannot have potential null deference in left-mover part.
// 3949.1-3949.34: (50.9): lock not held
// 3951.1-3951.27: (50.9): Reduction failure
// 3953.2-3962.9: (class anchor.sink.Return:34.26)
// 3959.1-3959.294: (34.26): Object invariant may not hold.
// 3960.1-3960.294: (34.26): Object invariant may not hold.
// 3961.1-3961.294: (34.26): Object invariant may not hold.
// 4088.1-4088.34: (9.5): Queue.elems failed Write-Write Right-Mover Check
// 4138.1-4138.30: (9.5): Queue.elems failed Write-Read Right-Mover Check
// 4192.1-4192.34: (9.5): Queue.elems failed Write-Write Left-Mover Check
// 4243.1-4243.30: (9.5): Queue.elems failed Write-Read Left-Mover Check
// 4291.1-4291.34: (9.5): Queue.elems failed Read-Write Right-Mover Check
// 4342.1-4342.34: (9.5): Queue.elems failed Read-Write Left-Mover Check
// 4392.1-4392.34: (10.5): Queue.head failed Write-Write Right-Mover Check
// 4442.1-4442.30: (10.5): Queue.head failed Write-Read Right-Mover Check
// 4496.1-4496.34: (10.5): Queue.head failed Write-Write Left-Mover Check
// 4547.1-4547.30: (10.5): Queue.head failed Write-Read Left-Mover Check
// 4595.1-4595.34: (10.5): Queue.head failed Read-Write Right-Mover Check
// 4646.1-4646.34: (10.5): Queue.head failed Read-Write Left-Mover Check
// 4696.1-4696.34: (11.5): Queue.tail failed Write-Write Right-Mover Check
// 4746.1-4746.30: (11.5): Queue.tail failed Write-Read Right-Mover Check
// 4800.1-4800.34: (11.5): Queue.tail failed Write-Write Left-Mover Check
// 4851.1-4851.30: (11.5): Queue.tail failed Write-Read Left-Mover Check
// 4899.1-4899.34: (11.5): Queue.tail failed Read-Write Right-Mover Check
// 4950.1-4950.34: (11.5): Queue.tail failed Read-Write Left-Mover Check
// 5000.1-5000.34: (19.5): Queue.spec failed Write-Write Right-Mover Check
// 5050.1-5050.30: (19.5): Queue.spec failed Write-Read Right-Mover Check
// 5104.1-5104.34: (19.5): Queue.spec failed Write-Write Left-Mover Check
// 5155.1-5155.30: (19.5): Queue.spec failed Write-Read Left-Mover Check
// 5203.1-5203.34: (19.5): Queue.spec failed Read-Write Right-Mover Check
// 5254.1-5254.34: (19.5): Queue.spec failed Read-Write Left-Mover Check
// 5308.1-5308.34: (7.5): Array Array.Queue.T failed Write-Write Right-Mover Check
// 5362.1-5362.30: (7.5): Array Array.Queue.T failed Write-Read Right-Mover Check
// 5420.1-5420.34: (7.5): Array Array.Queue.T failed Write-Write Left-Mover Check
// 5475.1-5475.30: (7.5): Array Array.Queue.T failed Write-Read Left-Mover Check
// 5527.1-5527.34: (7.5): Array Array.Queue.T failed Read-Write Right-Mover Check
// 5582.1-5582.34: (7.5): Array Array.Queue.T failed Read-Write Left-Mover Check
// 5663.1-5663.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case A.1)
// 5664.1-5664.101: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case A.2)
// 5665.1-5665.158: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case A.3)
// 5776.1-5776.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case C)
// 5892.1-5892.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case D)
// 5893.1-5893.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case R)
// 5974.1-5974.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.elems (case F)
// 5975.1-5975.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.elems (case H)
// 5976.1-5976.146: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.elems (case I)
// 6056.1-6056.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.elems (case J)
// 6057.1-6057.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.elems (case K)
// 6058.1-6058.99: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.elems (case L)
// 6140.1-6140.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case A.1)
// 6141.1-6141.101: (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case A.2)
// 6142.1-6142.158: (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case A.3)
// 6253.1-6253.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case C)
// 6369.1-6369.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case D)
// 6370.1-6370.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case R)
// 6451.1-6451.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.head (case F)
// 6452.1-6452.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.head (case H)
// 6453.1-6453.146: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.head (case I)
// 6533.1-6533.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.elems (case J)
// 6534.1-6534.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.elems (case K)
// 6535.1-6535.99: (10.5): Queue.head is not Write-Read Stable with respect to Queue.elems (case L)
// 6617.1-6617.140: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case A.1)
// 6618.1-6618.101: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case A.2)
// 6619.1-6619.158: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case A.3)
// 6730.1-6730.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case C)
// 6846.1-6846.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case D)
// 6847.1-6847.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case R)
// 6928.1-6928.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.tail (case F)
// 6929.1-6929.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.tail (case H)
// 6930.1-6930.146: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.tail (case I)
// 7010.1-7010.136: (11.5): Queue.tail is not Write-Read Stable with respect to Queue.elems (case J)
// 7011.1-7011.136: (11.5): Queue.tail is not Write-Read Stable with respect to Queue.elems (case K)
// 7012.1-7012.99: (11.5): Queue.tail is not Write-Read Stable with respect to Queue.elems (case L)
// 7094.1-7094.140: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case A.1)
// 7095.1-7095.101: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case A.2)
// 7096.1-7096.158: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case A.3)
// 7207.1-7207.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case C)
// 7323.1-7323.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case D)
// 7324.1-7324.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case R)
// 7405.1-7405.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.spec (case F)
// 7406.1-7406.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.spec (case H)
// 7407.1-7407.146: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.spec (case I)
// 7487.1-7487.136: (19.5): Queue.spec is not Write-Read Stable with respect to Queue.elems (case J)
// 7488.1-7488.136: (19.5): Queue.spec is not Write-Read Stable with respect to Queue.elems (case K)
// 7489.1-7489.99: (19.5): Queue.spec is not Write-Read Stable with respect to Queue.elems (case L)
// 7576.1-7576.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case A.1)
// 7577.1-7577.101: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case A.2)
// 7578.1-7578.156: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case A.3)
// 7696.1-7696.140: (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case C)
// 7819.1-7819.144: (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case D)
// 7820.1-7820.144: (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case R)
// 7906.1-7906.136: (9.5): Queue.elems is not Read-Write Stable with respect to Array Array.Queue.T (case F)
// 7907.1-7907.136: (9.5): Queue.elems is not Read-Write Stable with respect to Array Array.Queue.T (case H)
// 7908.1-7908.144: (9.5): Queue.elems is not Read-Write Stable with respect to Array Array.Queue.T (case I)
// 7993.1-7993.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.elems (case J)
// 7994.1-7994.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.elems (case K)
// 7995.1-7995.99: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.elems (case L)
// 8077.1-8077.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case A.1)
// 8078.1-8078.101: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case A.2)
// 8079.1-8079.158: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case A.3)
// 8190.1-8190.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case C)
// 8306.1-8306.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case D)
// 8307.1-8307.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case R)
// 8388.1-8388.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.elems (case F)
// 8389.1-8389.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.elems (case H)
// 8390.1-8390.146: (10.5): Queue.head is not Read-Write Stable with respect to Queue.elems (case I)
// 8470.1-8470.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.head (case J)
// 8471.1-8471.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.head (case K)
// 8472.1-8472.99: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.head (case L)
// 8554.1-8554.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.1)
// 8555.1-8555.101: (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.2)
// 8556.1-8556.158: (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.3)
// 8667.1-8667.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case C)
// 8783.1-8783.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case D)
// 8784.1-8784.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case R)
// 8865.1-8865.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.head (case F)
// 8866.1-8866.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.head (case H)
// 8867.1-8867.146: (10.5): Queue.head is not Read-Write Stable with respect to Queue.head (case I)
// 8947.1-8947.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.head (case J)
// 8948.1-8948.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.head (case K)
// 8949.1-8949.99: (10.5): Queue.head is not Write-Read Stable with respect to Queue.head (case L)
// 9031.1-9031.140: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.1)
// 9032.1-9032.101: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.2)
// 9033.1-9033.158: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.3)
// 9144.1-9144.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case C)
// 9260.1-9260.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case D)
// 9261.1-9261.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case R)
// 9342.1-9342.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case F)
// 9343.1-9343.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case H)
// 9344.1-9344.146: (10.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case I)
// 9424.1-9424.136: (11.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case J)
// 9425.1-9425.136: (11.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case K)
// 9426.1-9426.99: (11.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case L)
// 9508.1-9508.140: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case A.1)
// 9509.1-9509.101: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case A.2)
// 9510.1-9510.158: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case A.3)
// 9621.1-9621.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case C)
// 9737.1-9737.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case D)
// 9738.1-9738.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case R)
// 9819.1-9819.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.spec (case F)
// 9820.1-9820.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.spec (case H)
// 9821.1-9821.146: (10.5): Queue.head is not Read-Write Stable with respect to Queue.spec (case I)
// 9901.1-9901.136: (19.5): Queue.spec is not Write-Read Stable with respect to Queue.head (case J)
// 9902.1-9902.136: (19.5): Queue.spec is not Write-Read Stable with respect to Queue.head (case K)
// 9903.1-9903.99: (19.5): Queue.spec is not Write-Read Stable with respect to Queue.head (case L)
// 9990.1-9990.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case A.1)
// 9991.1-9991.101: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case A.2)
// 9992.1-9992.156: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case A.3)
// 10110.1-10110.140: (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case C)
// 10233.1-10233.144: (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case D)
// 10234.1-10234.144: (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case R)
// 10320.1-10320.136: (10.5): Queue.head is not Read-Write Stable with respect to Array Array.Queue.T (case F)
// 10321.1-10321.136: (10.5): Queue.head is not Read-Write Stable with respect to Array Array.Queue.T (case H)
// 10322.1-10322.144: (10.5): Queue.head is not Read-Write Stable with respect to Array Array.Queue.T (case I)
// 10407.1-10407.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.head (case J)
// 10408.1-10408.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.head (case K)
// 10409.1-10409.99: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.head (case L)
// 10491.1-10491.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case A.1)
// 10492.1-10492.101: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case A.2)
// 10493.1-10493.158: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case A.3)
// 10604.1-10604.140: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case C)
// 10720.1-10720.144: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case D)
// 10721.1-10721.144: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case R)
// 10802.1-10802.136: (11.5): Queue.tail is not Read-Write Stable with respect to Queue.elems (case F)
// 10803.1-10803.136: (11.5): Queue.tail is not Read-Write Stable with respect to Queue.elems (case H)
// 10804.1-10804.146: (11.5): Queue.tail is not Read-Write Stable with respect to Queue.elems (case I)
// 10884.1-10884.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.tail (case J)
// 10885.1-10885.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.tail (case K)
// 10886.1-10886.99: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.tail (case L)
// 10968.1-10968.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.1)
// 10969.1-10969.101: (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.2)
// 10970.1-10970.158: (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.3)
// 11081.1-11081.140: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case C)
// 11197.1-11197.144: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case D)
// 11198.1-11198.144: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case R)
// 11279.1-11279.136: (11.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case F)
// 11280.1-11280.136: (11.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case H)
// 11281.1-11281.146: (11.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case I)
// 11361.1-11361.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case J)
// 11362.1-11362.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case K)
// 11363.1-11363.99: (10.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case L)
// 11445.1-11445.140: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.1)
// 11446.1-11446.101: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.2)
// 11447.1-11447.158: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.3)
// 11558.1-11558.140: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case C)
// 11674.1-11674.144: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case D)
// 11675.1-11675.144: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case R)
// 11756.1-11756.136: (11.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case F)
// 11757.1-11757.136: (11.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case H)
// 11758.1-11758.146: (11.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case I)
// 11838.1-11838.136: (11.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case J)
// 11839.1-11839.136: (11.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case K)
// 11840.1-11840.99: (11.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case L)
// 11922.1-11922.140: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case A.1)
// 11923.1-11923.101: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case A.2)
// 11924.1-11924.158: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case A.3)
// 12035.1-12035.140: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case C)
// 12151.1-12151.144: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case D)
// 12152.1-12152.144: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case R)
// 12233.1-12233.136: (11.5): Queue.tail is not Read-Write Stable with respect to Queue.spec (case F)
// 12234.1-12234.136: (11.5): Queue.tail is not Read-Write Stable with respect to Queue.spec (case H)
// 12235.1-12235.146: (11.5): Queue.tail is not Read-Write Stable with respect to Queue.spec (case I)
// 12315.1-12315.136: (19.5): Queue.spec is not Write-Read Stable with respect to Queue.tail (case J)
// 12316.1-12316.136: (19.5): Queue.spec is not Write-Read Stable with respect to Queue.tail (case K)
// 12317.1-12317.99: (19.5): Queue.spec is not Write-Read Stable with respect to Queue.tail (case L)
// 12404.1-12404.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case A.1)
// 12405.1-12405.101: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case A.2)
// 12406.1-12406.156: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case A.3)
// 12524.1-12524.140: (11.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case C)
// 12647.1-12647.144: (11.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case D)
// 12648.1-12648.144: (11.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case R)
// 12734.1-12734.136: (11.5): Queue.tail is not Read-Write Stable with respect to Array Array.Queue.T (case F)
// 12735.1-12735.136: (11.5): Queue.tail is not Read-Write Stable with respect to Array Array.Queue.T (case H)
// 12736.1-12736.144: (11.5): Queue.tail is not Read-Write Stable with respect to Array Array.Queue.T (case I)
// 12821.1-12821.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.tail (case J)
// 12822.1-12822.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.tail (case K)
// 12823.1-12823.99: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.tail (case L)
// 12905.1-12905.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case A.1)
// 12906.1-12906.101: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case A.2)
// 12907.1-12907.158: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case A.3)
// 13018.1-13018.140: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case C)
// 13134.1-13134.144: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case D)
// 13135.1-13135.144: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case R)
// 13216.1-13216.136: (19.5): Queue.spec is not Read-Write Stable with respect to Queue.elems (case F)
// 13217.1-13217.136: (19.5): Queue.spec is not Read-Write Stable with respect to Queue.elems (case H)
// 13218.1-13218.146: (19.5): Queue.spec is not Read-Write Stable with respect to Queue.elems (case I)
// 13298.1-13298.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.spec (case J)
// 13299.1-13299.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.spec (case K)
// 13300.1-13300.99: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.spec (case L)
// 13382.1-13382.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case A.1)
// 13383.1-13383.101: (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case A.2)
// 13384.1-13384.158: (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case A.3)
// 13495.1-13495.140: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case C)
// 13611.1-13611.144: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case D)
// 13612.1-13612.144: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case R)
// 13693.1-13693.136: (19.5): Queue.spec is not Read-Write Stable with respect to Queue.head (case F)
// 13694.1-13694.136: (19.5): Queue.spec is not Read-Write Stable with respect to Queue.head (case H)
// 13695.1-13695.146: (19.5): Queue.spec is not Read-Write Stable with respect to Queue.head (case I)
// 13775.1-13775.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.spec (case J)
// 13776.1-13776.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.spec (case K)
// 13777.1-13777.99: (10.5): Queue.head is not Write-Read Stable with respect to Queue.spec (case L)
// 13859.1-13859.140: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case A.1)
// 13860.1-13860.101: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case A.2)
// 13861.1-13861.158: (11.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case A.3)
// 13972.1-13972.140: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case C)
// 14088.1-14088.144: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case D)
// 14089.1-14089.144: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case R)
// 14170.1-14170.136: (19.5): Queue.spec is not Read-Write Stable with respect to Queue.tail (case F)
// 14171.1-14171.136: (19.5): Queue.spec is not Read-Write Stable with respect to Queue.tail (case H)
// 14172.1-14172.146: (19.5): Queue.spec is not Read-Write Stable with respect to Queue.tail (case I)
// 14252.1-14252.136: (11.5): Queue.tail is not Write-Read Stable with respect to Queue.spec (case J)
// 14253.1-14253.136: (11.5): Queue.tail is not Write-Read Stable with respect to Queue.spec (case K)
// 14254.1-14254.99: (11.5): Queue.tail is not Write-Read Stable with respect to Queue.spec (case L)
// 14336.1-14336.140: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case A.1)
// 14337.1-14337.101: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case A.2)
// 14338.1-14338.158: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case A.3)
// 14449.1-14449.140: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case C)
// 14565.1-14565.144: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case D)
// 14566.1-14566.144: (19.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case R)
// 14647.1-14647.136: (19.5): Queue.spec is not Read-Write Stable with respect to Queue.spec (case F)
// 14648.1-14648.136: (19.5): Queue.spec is not Read-Write Stable with respect to Queue.spec (case H)
// 14649.1-14649.146: (19.5): Queue.spec is not Read-Write Stable with respect to Queue.spec (case I)
// 14729.1-14729.136: (19.5): Queue.spec is not Write-Read Stable with respect to Queue.spec (case J)
// 14730.1-14730.136: (19.5): Queue.spec is not Write-Read Stable with respect to Queue.spec (case K)
// 14731.1-14731.99: (19.5): Queue.spec is not Write-Read Stable with respect to Queue.spec (case L)
// 14818.1-14818.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case A.1)
// 14819.1-14819.101: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case A.2)
// 14820.1-14820.156: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case A.3)
// 14938.1-14938.140: (19.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case C)
// 15061.1-15061.144: (19.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case D)
// 15062.1-15062.144: (19.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case R)
// 15148.1-15148.136: (19.5): Queue.spec is not Read-Write Stable with respect to Array Array.Queue.T (case F)
// 15149.1-15149.136: (19.5): Queue.spec is not Read-Write Stable with respect to Array Array.Queue.T (case H)
// 15150.1-15150.144: (19.5): Queue.spec is not Read-Write Stable with respect to Array Array.Queue.T (case I)
// 15235.1-15235.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.spec (case J)
// 15236.1-15236.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.spec (case K)
// 15237.1-15237.99: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.spec (case L)
// 15324.1-15324.140: (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
// 15325.1-15325.101: (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
// 15326.1-15326.156: (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
// 15444.1-15444.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case C)
// 15567.1-15567.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case D)
// 15568.1-15568.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case R)
// 15654.1-15654.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.elems (case F)
// 15655.1-15655.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.elems (case H)
// 15656.1-15656.144: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.elems (case I)
// 15741.1-15741.136: (9.5): Queue.elems is not Write-Read Stable with respect to Array Array.Queue.T (case J)
// 15742.1-15742.136: (9.5): Queue.elems is not Write-Read Stable with respect to Array Array.Queue.T (case K)
// 15743.1-15743.99: (9.5): Queue.elems is not Write-Read Stable with respect to Array Array.Queue.T (case L)
// 15830.1-15830.140: (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
// 15831.1-15831.101: (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
// 15832.1-15832.156: (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
// 15950.1-15950.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case C)
// 16073.1-16073.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case D)
// 16074.1-16074.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case R)
// 16160.1-16160.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.head (case F)
// 16161.1-16161.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.head (case H)
// 16162.1-16162.144: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.head (case I)
// 16247.1-16247.136: (10.5): Queue.head is not Write-Read Stable with respect to Array Array.Queue.T (case J)
// 16248.1-16248.136: (10.5): Queue.head is not Write-Read Stable with respect to Array Array.Queue.T (case K)
// 16249.1-16249.99: (10.5): Queue.head is not Write-Read Stable with respect to Array Array.Queue.T (case L)
// 16336.1-16336.140: (11.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
// 16337.1-16337.101: (11.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
// 16338.1-16338.156: (11.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
// 16456.1-16456.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case C)
// 16579.1-16579.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case D)
// 16580.1-16580.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case R)
// 16666.1-16666.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.tail (case F)
// 16667.1-16667.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.tail (case H)
// 16668.1-16668.144: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.tail (case I)
// 16753.1-16753.136: (11.5): Queue.tail is not Write-Read Stable with respect to Array Array.Queue.T (case J)
// 16754.1-16754.136: (11.5): Queue.tail is not Write-Read Stable with respect to Array Array.Queue.T (case K)
// 16755.1-16755.99: (11.5): Queue.tail is not Write-Read Stable with respect to Array Array.Queue.T (case L)
// 16842.1-16842.140: (19.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
// 16843.1-16843.101: (19.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
// 16844.1-16844.156: (19.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
// 16962.1-16962.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case C)
// 17085.1-17085.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case D)
// 17086.1-17086.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case R)
// 17172.1-17172.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.spec (case F)
// 17173.1-17173.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.spec (case H)
// 17174.1-17174.144: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.spec (case I)
// 17259.1-17259.136: (19.5): Queue.spec is not Write-Read Stable with respect to Array Array.Queue.T (case J)
// 17260.1-17260.136: (19.5): Queue.spec is not Write-Read Stable with respect to Array Array.Queue.T (case K)
// 17261.1-17261.99: (19.5): Queue.spec is not Write-Read Stable with respect to Array Array.Queue.T (case L)
// 17353.1-17353.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
// 17354.1-17354.101: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
// 17355.1-17355.156: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
// 17480.1-17480.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case C)
// 17610.1-17610.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case D)
// 17611.1-17611.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case R)
// 17702.1-17702.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Array Array.Queue.T (case F)
// 17703.1-17703.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Array Array.Queue.T (case H)
// 17704.1-17704.144: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Array Array.Queue.T (case I)
// 17794.1-17794.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Array Array.Queue.T (case J)
// 17795.1-17795.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Array Array.Queue.T (case K)
// 17796.1-17796.99: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Array Array.Queue.T (case L)
// 17803.1-17803.295: (<undefined position>): Object invariant may not hold.
// 17804.1-17804.295: (<undefined position>): Object invariant may not hold.
// 17805.1-17805.295: (<undefined position>): Object invariant may not hold.
// 17816.1-17816.294: (<undefined position>): Object invariant may not hold.
// 17817.1-17817.294: (<undefined position>): Object invariant may not hold.
// 17818.1-17818.294: (<undefined position>): Object invariant may not hold.
// 17832.1-17855.2: (9.24): yields_as clause for Queue.elems is not valid
// 17860.1-17880.2: (9.24): yields_as clause for Queue.elems is not reflexive
// 17886.1-17886.295: (9.24): Object invariant may not hold.
// 17887.1-17887.295: (9.24): Object invariant may not hold.
// 17888.1-17888.295: (9.24): Object invariant may not hold.
// 17889.1-17929.2: (9.24): yields_as clause for Queue.elems is not transitive
// 17942.1-17965.2: (10.33): yields_as clause for Queue.head is not valid
// 17970.1-17990.2: (10.33): yields_as clause for Queue.head is not reflexive
// 17996.1-17996.295: (10.33): Object invariant may not hold.
// 17997.1-17997.295: (10.33): Object invariant may not hold.
// 17998.1-17998.295: (10.33): Object invariant may not hold.
// 17999.1-18039.2: (10.33): yields_as clause for Queue.head is not transitive
// 18052.1-18075.2: (11.33): yields_as clause for Queue.tail is not valid
// 18080.1-18100.2: (11.33): yields_as clause for Queue.tail is not reflexive
// 18106.1-18106.295: (11.33): Object invariant may not hold.
// 18107.1-18107.295: (11.33): Object invariant may not hold.
// 18108.1-18108.295: (11.33): Object invariant may not hold.
// 18109.1-18149.2: (11.33): yields_as clause for Queue.tail is not transitive
// 18162.1-18185.2: (19.37): yields_as clause for Queue.spec is not valid
// 18190.1-18210.2: (19.37): yields_as clause for Queue.spec is not reflexive
// 18216.1-18216.295: (19.37): Object invariant may not hold.
// 18217.1-18217.295: (19.37): Object invariant may not hold.
// 18218.1-18218.295: (19.37): Object invariant may not hold.
// 18219.1-18259.2: (19.37): yields_as clause for Queue.spec is not transitive
// 18273.1-18296.2: (7.32): yields_as clause for Queue._lock is not valid
// 18301.1-18321.2: (7.32): yields_as clause for Queue._lock is not reflexive
// 18327.1-18327.295: (3.1): Object invariant may not hold.
// 18328.1-18328.295: (3.1): Object invariant may not hold.
// 18329.1-18329.295: (3.1): Object invariant may not hold.
// 18330.1-18370.2: (7.32): yields_as clause for Queue._lock is not transitive
// 18380.1-18409.2: (7.28): yields_as clause for Array.Queue.T is not valid
// 18410.1-18436.2: (7.28): yields_as clause for Array.Queue.T is not reflexive
// 18441.1-18441.295: (7.28): Object invariant may not hold.
// 18442.1-18442.295: (7.28): Object invariant may not hold.
// 18443.1-18443.295: (7.28): Object invariant may not hold.
// 18444.1-18488.2: (7.28): yields_as clause for Array.Queue.T is not transitive
