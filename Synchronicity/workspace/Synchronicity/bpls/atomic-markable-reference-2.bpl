                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/fzhao12/Synchronicity/workspace/Synchronicity/tests/atomic-markable-reference-2.anchor:      
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class V {                                                                                       
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        // return;                                                                                  
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Pair {                                                                                    
       V reference isLocal(this, tid)                                                               
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(V reference,boolean mark) {                                                         
        assume this.reference == V.null;                                                            
        assume this.mark == false;                                                                  
        {                                                                                           
          this.reference := reference;                                                              
          this.mark := mark;                                                                        
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      noABA volatile Pair pair isLocal(this, tid)                                                   
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? N                                                                                        
         : isLocal(newValue, tid) ? N : E                                                           
        yields_as this.pair != newValue ==> !isShared(newValue);                                    
                                                                                                    
                                                                                                    
      invariant  this.pair != Pair.null;                                                            
                                                                                                    
                                                                                                    
                                                                                                    
      void init(V initialRef,boolean initialMark) {                                                 
        assume this.pair == Pair.null;                                                              
        {                                                                                           
          Pair tmp1;                                                                                
          tmp1 = this.pairOf(initialRef,initialMark)                                                
          this.pair := tmp1;                                                                        
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      Pair pairOf(V initialRef,boolean initialMark) {                                               
        Pair p;                                                                                     
        p = new Pair();                                                                             
        p.init(initialRef,initialMark)                                                              
         return p;                                                                                  
        // return Pair.null;                                                                        
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      V getReference() {                                                                            
        V tmp2;                                                                                     
        Pair tmp3;                                                                                  
        tmp3 := this.pair;                                                                          
        tmp2 := tmp3.reference;                                                                     
         return tmp2;                                                                               
        // return V.null;                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean isMarked() {                                                                          
        boolean tmp4;                                                                               
        Pair tmp5;                                                                                  
        tmp5 := this.pair;                                                                          
        tmp4 := tmp5.mark;                                                                          
         return tmp4;                                                                               
        // return false;                                                                            
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      Pair get() {                                                                                  
        Pair tmp6;                                                                                  
        tmp6 := this.pair;                                                                          
         return tmp6;                                                                               
        // return Pair.null;                                                                        
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean compareAndSet(V expectedReference,V newReference,boolean expectedMark,boolean newMark) {
        Pair current;                                                                               
        current := this.pair;                                                                       
        boolean tmp7;                                                                               
        boolean tmp8;                                                                               
        boolean tmp9;                                                                               
        V tmp10;                                                                                    
        tmp10 := current.reference;                                                                 
        tmp9 = expectedReference == tmp10;                                                          
        if (tmp9) {                                                                                 
          boolean tmp11;                                                                            
          tmp11 := current.mark;                                                                    
          tmp8 = expectedMark == tmp11;                                                             
        } else {                                                                                    
          tmp8 = false;                                                                             
        }                                                                                           
        if (tmp8) {                                                                                 
          Pair tmp12;                                                                               
          tmp12 = this.pairOf(newReference,newMark)                                                 
          tmp7 = this.casPair(current,tmp12)                                                        
        } else {                                                                                    
          tmp7 = false;                                                                             
        }                                                                                           
         return tmp7;                                                                               
        // return false;                                                                            
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void set(V newReference,boolean newMark) {                                                    
        Pair tmp13;                                                                                 
        tmp13 = this.pairOf(newReference,newMark)                                                   
        this.pair := tmp13;                                                                         
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean attemptMark(V expectedReference,boolean newMark) {                                    
        Pair current;                                                                               
        current := this.pair;                                                                       
        boolean tmp14;                                                                              
        boolean tmp15;                                                                              
        V tmp16;                                                                                    
        tmp16 := current.reference;                                                                 
        tmp15 = expectedReference == tmp16;                                                         
        if (tmp15) {                                                                                
          Pair tmp17;                                                                               
          tmp17 = this.pairOf(expectedReference,newMark)                                            
          tmp14 = this.casPair(current,tmp17)                                                       
        } else {                                                                                    
          tmp14 = false;                                                                            
        }                                                                                           
         return tmp14;                                                                              
        // return false;                                                                            
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean casPair(Pair cmp,Pair val) {                                                          
        boolean tmp18;                                                                              
        tmp18 = this.pair@cmp :~ val;                                                               
         return tmp18;                                                                              
        // return false;                                                                            
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
      requires x != AtomicMarkableReference.null;                                                   
                                                                                                    
      public void f(AtomicMarkableReference x) {                                                    
        V d;                                                                                        
        d = new V();                                                                                
        d.init()                                                                                    
        Pair result;                                                                                
        result = x.get()                                                                            
        yield;                                                                                      
        Pair result2;                                                                               
        result2 = x.get()                                                                           
        yield;                                                                                      
        boolean b;                                                                                  
        V tmp19;                                                                                    
        tmp19 := result.reference;                                                                  
        boolean tmp20;                                                                              
        tmp20 := result.mark;                                                                       
        b = x.compareAndSet(tmp19,V.null,tmp20,true)                                                
        if (b /* == b */) {                                                                         
                                                                                                    
        } else {                                                                                    
                                                                                                    
        }                                                                                           
        // return;                                                                                  
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class V {                                                                                       
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Pair {                                                                                    
       V reference isLocal(this, tid)                                                               
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(V reference,boolean mark) {                                                         
        assume this.reference == V.null;                                                            
        assume this.mark == false;                                                                  
        {                                                                                           
          this.reference := reference;                                                              
          this.mark := mark;                                                                        
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      hasCASOperation noABA volatile Pair pair isLocal(this, tid)                                   
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? N                                                                                        
         : isLocal(newValue, tid) ? N : E                                                           
        yields_as this.pair != newValue ==> !isShared(newValue);                                    
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid pair_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.pair_nextThread == tid ? N : E                                                        
        yields_as this.pair_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Pair pair_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.pair_nextThread == tid ? N : E                                                        
        yields_as this.pair_nextThread == tid ==> newValue == this.pair_nextValue;                  
                                                                                                    
                                                                                                    
      invariant  this.pair != Pair.null;                                                            
                                                                                                    
                                                                                                    
                                                                                                    
      void init(V initialRef,boolean initialMark) {                                                 
        assume this.pair == Pair.null;                                                              
        {                                                                                           
          Pair tmp1;                                                                                
          tmp1 = this.pairOf(initialRef,initialMark)                                                
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.pair_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.pair := tmp1;                                                                      
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      Pair pairOf(V initialRef,boolean initialMark) {                                               
        Pair p;                                                                                     
        p = new Pair();                                                                             
        p.init(initialRef,initialMark)                                                              
        {                                                                                           
           return p;                                                                                
        }                                                                                           
        {                                                                                           
          // return Pair.null;                                                                      
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      V getReference() {                                                                            
        V tmp2;                                                                                     
        Pair tmp3;                                                                                  
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp3 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp3 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        tmp2 := tmp3.reference;                                                                     
        {                                                                                           
           return tmp2;                                                                             
        }                                                                                           
        {                                                                                           
          // return V.null;                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean isMarked() {                                                                          
        boolean tmp4;                                                                               
        Pair tmp5;                                                                                  
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp5 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp5 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        tmp4 := tmp5.mark;                                                                          
        {                                                                                           
           return tmp4;                                                                             
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      Pair get() {                                                                                  
        Pair tmp6;                                                                                  
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp6 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp6 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        {                                                                                           
           return tmp6;                                                                             
        }                                                                                           
        {                                                                                           
          // return Pair.null;                                                                      
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean compareAndSet(V expectedReference,V newReference,boolean expectedMark,boolean newMark) {
        Pair current;                                                                               
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            current := this.pair  as R;                                                             
          } else {                                                                                  
            noop(TraceOn);                                                                          
            current := this.pair;                                                                   
          }                                                                                         
        }                                                                                           
        boolean tmp7;                                                                               
        boolean tmp8;                                                                               
        boolean tmp9;                                                                               
        V tmp10;                                                                                    
        tmp10 := current.reference;                                                                 
        tmp9 = expectedReference == tmp10;                                                          
        if (tmp9) {                                                                                 
          boolean tmp11;                                                                            
          tmp11 := current.mark;                                                                    
          tmp8 = expectedMark == tmp11;                                                             
        } else {                                                                                    
          tmp8 = false;                                                                             
        }                                                                                           
        if (tmp8) {                                                                                 
          Pair tmp12;                                                                               
          tmp12 = this.pairOf(newReference,newMark)                                                 
          tmp7 = this.casPair(current,tmp12)                                                        
        } else {                                                                                    
          tmp7 = false;                                                                             
        }                                                                                           
        {                                                                                           
           return tmp7;                                                                             
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void set(V newReference,boolean newMark) {                                                    
        Pair tmp13;                                                                                 
        tmp13 = this.pairOf(newReference,newMark)                                                   
        {                                                                                           
          noop(TraceOff);                                                                           
          assume this.pair_nextThread == tid;                                                       
          noop(TraceOn);                                                                            
          this.pair := tmp13;                                                                       
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean attemptMark(V expectedReference,boolean newMark) {                                    
        Pair current;                                                                               
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            current := this.pair  as R;                                                             
          } else {                                                                                  
            noop(TraceOn);                                                                          
            current := this.pair;                                                                   
          }                                                                                         
        }                                                                                           
        boolean tmp14;                                                                              
        boolean tmp15;                                                                              
        V tmp16;                                                                                    
        tmp16 := current.reference;                                                                 
        tmp15 = expectedReference == tmp16;                                                         
        if (tmp15) {                                                                                
          Pair tmp17;                                                                               
          tmp17 = this.pairOf(expectedReference,newMark)                                            
          tmp14 = this.casPair(current,tmp17)                                                       
        } else {                                                                                    
          tmp14 = false;                                                                            
        }                                                                                           
        {                                                                                           
           return tmp14;                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean casPair(Pair cmp,Pair val) {                                                          
        boolean tmp18;                                                                              
        {                                                                                           
          noop(TraceOff);                                                                           
          boolean ctmp237616;                                                                       
          ctmp237616 = *;                                                                           
          if (ctmp237616) {                                                                         
            noop(TraceOn);                                                                          
            tmp18 = false;                                                                          
          } else {                                                                                  
            ctmp237616 = *;                                                                         
            if (ctmp237616) {                                                                       
              Tid tmpTid;                                                                           
              Pair tmpValue;                                                                        
              Mover _m;                                                                             
              _m = writePermission(this.pair, val);                                                 
              assume this.pair == cmp;                                                              
              assume !goesWrong(_m);                                                                
              assume this.pair_nextThread == tid;                                                   
              assume this.pair_nextValue == cmp;                                                    
              this.pair_nextThread := tmpTid as B;                                                  
              this.pair_nextValue := tmpValue as B;                                                 
              noop(TraceOn);                                                                        
              this.pair := val;                                                                     
              tmp18 = true;                                                                         
            } else {                                                                                
              assume this.pair_nextThread == tid;                                                   
              assume this.pair_nextValue == cmp;                                                    
              Pair _currentValue;                                                                   
              _currentValue := this.pair  as B;                                                     
              this.pair := cmp as B;                                                                
              Mover _m;                                                                             
              _m = writePermission(this.pair, val);                                                 
              this.pair := _currentValue as B;                                                      
              assume goesWrong(_m);                                                                 
              noop(TraceOn);                                                                        
              this.pair := val;                                                                     
              tmp18 = false;                                                                        
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
           return tmp18;                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires x != AtomicMarkableReference.null;                                                   
                                                                                                    
      public void f(AtomicMarkableReference x) {                                                    
        V d;                                                                                        
        d = new V();                                                                                
        d.init()                                                                                    
        Pair result;                                                                                
        result = x.get()                                                                            
        yield;                                                                                      
        Pair result2;                                                                               
        result2 = x.get()                                                                           
        yield;                                                                                      
        boolean b;                                                                                  
        V tmp19;                                                                                    
        tmp19 := result.reference;                                                                  
        boolean tmp20;                                                                              
        tmp20 := result.mark;                                                                       
        b = x.compareAndSet(tmp19,V.null,tmp20,true)                                                
        if (b /* == b */) {                                                                         
                                                                                                    
        } else {                                                                                    
                                                                                                    
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class V {                                                                                       
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Pair {                                                                                    
       V reference isLocal(this, tid)                                                               
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(V reference,boolean mark) {                                                         
        assume this.reference == V.null;                                                            
        assume this.mark == false;                                                                  
        {                                                                                           
          this.reference := reference;                                                              
          this.mark := mark;                                                                        
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      hasCASOperation noABA volatile Pair pair isLocal(this, tid)                                   
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? N                                                                                        
         : isLocal(newValue, tid) ? N : E                                                           
        yields_as this.pair != newValue ==> !isShared(newValue);                                    
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid pair_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.pair_nextThread == tid ? N : E                                                        
        yields_as this.pair_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Pair pair_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.pair_nextThread == tid ? N : E                                                        
        yields_as this.pair_nextThread == tid ==> newValue == this.pair_nextValue;                  
                                                                                                    
                                                                                                    
      invariant  this.pair != Pair.null;                                                            
                                                                                                    
                                                                                                    
                                                                                                    
      void init(V initialRef,boolean initialMark) {                                                 
        assume this.pair == Pair.null;                                                              
        {                                                                                           
          Pair tmp1;                                                                                
          tmp1 = this.pairOf(initialRef,initialMark)                                                
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.pair_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.pair := tmp1;                                                                      
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      Pair pairOf(V initialRef,boolean initialMark) {                                               
        Pair p;                                                                                     
        p = new Pair();                                                                             
        p.init(initialRef,initialMark)                                                              
        {                                                                                           
           return p;                                                                                
        }                                                                                           
        {                                                                                           
          // return Pair.null;                                                                      
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      V getReference() {                                                                            
        V tmp2;                                                                                     
        Pair tmp3;                                                                                  
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp3 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp3 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        tmp2 := tmp3.reference;                                                                     
        {                                                                                           
           return tmp2;                                                                             
        }                                                                                           
        {                                                                                           
          // return V.null;                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean isMarked() {                                                                          
        boolean tmp4;                                                                               
        Pair tmp5;                                                                                  
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp5 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp5 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        tmp4 := tmp5.mark;                                                                          
        {                                                                                           
           return tmp4;                                                                             
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      Pair get() {                                                                                  
        Pair tmp6;                                                                                  
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp6 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp6 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        {                                                                                           
           return tmp6;                                                                             
        }                                                                                           
        {                                                                                           
          // return Pair.null;                                                                      
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean compareAndSet(V expectedReference,V newReference,boolean expectedMark,boolean newMark) {
        Pair current;                                                                               
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            current := this.pair  as R;                                                             
          } else {                                                                                  
            noop(TraceOn);                                                                          
            current := this.pair;                                                                   
          }                                                                                         
        }                                                                                           
        boolean tmp7;                                                                               
        boolean tmp8;                                                                               
        boolean tmp9;                                                                               
        V tmp10;                                                                                    
        tmp10 := current.reference;                                                                 
        tmp9 = expectedReference == tmp10;                                                          
        if (tmp9) {                                                                                 
          boolean tmp11;                                                                            
          tmp11 := current.mark;                                                                    
          tmp8 = expectedMark == tmp11;                                                             
        } else {                                                                                    
          tmp8 = false;                                                                             
        }                                                                                           
        if (tmp8) {                                                                                 
          Pair tmp12;                                                                               
          tmp12 = this.pairOf(newReference,newMark)                                                 
          tmp7 = this.casPair(current,tmp12)                                                        
        } else {                                                                                    
          tmp7 = false;                                                                             
        }                                                                                           
        {                                                                                           
           return tmp7;                                                                             
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void set(V newReference,boolean newMark) {                                                    
        Pair tmp13;                                                                                 
        tmp13 = this.pairOf(newReference,newMark)                                                   
        {                                                                                           
          noop(TraceOff);                                                                           
          assume this.pair_nextThread == tid;                                                       
          noop(TraceOn);                                                                            
          this.pair := tmp13;                                                                       
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean attemptMark(V expectedReference,boolean newMark) {                                    
        Pair current;                                                                               
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            current := this.pair  as R;                                                             
          } else {                                                                                  
            noop(TraceOn);                                                                          
            current := this.pair;                                                                   
          }                                                                                         
        }                                                                                           
        boolean tmp14;                                                                              
        boolean tmp15;                                                                              
        V tmp16;                                                                                    
        tmp16 := current.reference;                                                                 
        tmp15 = expectedReference == tmp16;                                                         
        if (tmp15) {                                                                                
          Pair tmp17;                                                                               
          tmp17 = this.pairOf(expectedReference,newMark)                                            
          tmp14 = this.casPair(current,tmp17)                                                       
        } else {                                                                                    
          tmp14 = false;                                                                            
        }                                                                                           
        {                                                                                           
           return tmp14;                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean casPair(Pair cmp,Pair val) {                                                          
        boolean tmp18;                                                                              
        {                                                                                           
          noop(TraceOff);                                                                           
          boolean ctmp237616;                                                                       
          ctmp237616 = *;                                                                           
          if (ctmp237616) {                                                                         
            noop(TraceOn);                                                                          
            tmp18 = false;                                                                          
          } else {                                                                                  
            ctmp237616 = *;                                                                         
            if (ctmp237616) {                                                                       
              Tid tmpTid;                                                                           
              Pair tmpValue;                                                                        
              Mover _m;                                                                             
              _m = writePermission(this.pair, val);                                                 
              assume this.pair == cmp;                                                              
              assume !goesWrong(_m);                                                                
              assume this.pair_nextThread == tid;                                                   
              assume this.pair_nextValue == cmp;                                                    
              this.pair_nextThread := tmpTid as B;                                                  
              this.pair_nextValue := tmpValue as B;                                                 
              noop(TraceOn);                                                                        
              this.pair := val;                                                                     
              tmp18 = true;                                                                         
            } else {                                                                                
              assume this.pair_nextThread == tid;                                                   
              assume this.pair_nextValue == cmp;                                                    
              Pair _currentValue;                                                                   
              _currentValue := this.pair  as B;                                                     
              this.pair := cmp as B;                                                                
              Mover _m;                                                                             
              _m = writePermission(this.pair, val);                                                 
              this.pair := _currentValue as B;                                                      
              assume goesWrong(_m);                                                                 
              noop(TraceOn);                                                                        
              this.pair := val;                                                                     
              tmp18 = false;                                                                        
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
           return tmp18;                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires x != AtomicMarkableReference.null;                                                   
                                                                                                    
      public void f(AtomicMarkableReference x) {                                                    
        V d;                                                                                        
        d = new V();                                                                                
        {                                                                                           
          inlined d.init();                                                                         
          exit$2: {                                                                                 
            V this$2;                                                                               
            this$2 = d;                                                                             
            {                                                                                       
              {                                                                                     
                break exit$2;                                                                       
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        Pair result;                                                                                
        {                                                                                           
          inlined result = x.get();                                                                 
          exit$3: {                                                                                 
            AtomicMarkableReference this$3;                                                         
            this$3 = x;                                                                             
            {                                                                                       
              Pair tmp6$3;                                                                          
              {                                                                                     
                noop(TraceOff);                                                                     
                Tid _C_t$3;                                                                         
                _C_t$3 := this$3.pair_nextThread  as B;                                             
                Pair _C_v$3;                                                                        
                _C_v$3 := this$3.pair_nextValue  as B;                                              
                Pair _currentValue$3;                                                               
                _currentValue$3 := this$3.pair  as B;                                               
                Mover _R_t$3;                                                                       
                _R_t$3 = readPermission(this$3.pair);                                               
                boolean _casable$3;                                                                 
                _casable$3 = _R_t$3 != E && true && _C_t$3 == tid && _C_v$3 == _currentValue$3;     
                if (_casable$3) {                                                                   
                  noop(TraceOn);                                                                    
                  tmp6$3 := this$3.pair  as R;                                                      
                } else {                                                                            
                  noop(TraceOn);                                                                    
                  tmp6$3 := this$3.pair;                                                            
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result = tmp6$3;                                                                  
                  break exit$3;                                                                     
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result = Pair.null;                                                               
                  break exit$3;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        yield;                                                                                      
        Pair result2;                                                                               
        {                                                                                           
          inlined result2 = x.get();                                                                
          exit$4: {                                                                                 
            AtomicMarkableReference this$4;                                                         
            this$4 = x;                                                                             
            {                                                                                       
              Pair tmp6$4;                                                                          
              {                                                                                     
                noop(TraceOff);                                                                     
                Tid _C_t$4;                                                                         
                _C_t$4 := this$4.pair_nextThread  as B;                                             
                Pair _C_v$4;                                                                        
                _C_v$4 := this$4.pair_nextValue  as B;                                              
                Pair _currentValue$4;                                                               
                _currentValue$4 := this$4.pair  as B;                                               
                Mover _R_t$4;                                                                       
                _R_t$4 = readPermission(this$4.pair);                                               
                boolean _casable$4;                                                                 
                _casable$4 = _R_t$4 != E && true && _C_t$4 == tid && _C_v$4 == _currentValue$4;     
                if (_casable$4) {                                                                   
                  noop(TraceOn);                                                                    
                  tmp6$4 := this$4.pair  as R;                                                      
                } else {                                                                            
                  noop(TraceOn);                                                                    
                  tmp6$4 := this$4.pair;                                                            
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result2 = tmp6$4;                                                                 
                  break exit$4;                                                                     
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result2 = Pair.null;                                                              
                  break exit$4;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        yield;                                                                                      
        boolean b;                                                                                  
        V tmp19;                                                                                    
        tmp19 := result.reference;                                                                  
        boolean tmp20;                                                                              
        tmp20 := result.mark;                                                                       
        {                                                                                           
          inlined b = x.compareAndSet(tmp19,V.null,tmp20,true);                                     
          exit$5: {                                                                                 
            V expectedReference$5;                                                                  
            V newReference$5;                                                                       
            boolean expectedMark$5;                                                                 
            boolean newMark$5;                                                                      
            AtomicMarkableReference this$5;                                                         
            expectedReference$5 = tmp19;                                                            
            newReference$5 = V.null;                                                                
            expectedMark$5 = tmp20;                                                                 
            newMark$5 = true;                                                                       
            this$5 = x;                                                                             
            {                                                                                       
              Pair current$5;                                                                       
              {                                                                                     
                noop(TraceOff);                                                                     
                Tid _C_t$5;                                                                         
                _C_t$5 := this$5.pair_nextThread  as B;                                             
                Pair _C_v$5;                                                                        
                _C_v$5 := this$5.pair_nextValue  as B;                                              
                Pair _currentValue$5;                                                               
                _currentValue$5 := this$5.pair  as B;                                               
                Mover _R_t$5;                                                                       
                _R_t$5 = readPermission(this$5.pair);                                               
                boolean _casable$5;                                                                 
                _casable$5 = _R_t$5 != E && true && _C_t$5 == tid && _C_v$5 == _currentValue$5;     
                if (_casable$5) {                                                                   
                  noop(TraceOn);                                                                    
                  current$5 := this$5.pair  as R;                                                   
                } else {                                                                            
                  noop(TraceOn);                                                                    
                  current$5 := this$5.pair;                                                         
                }                                                                                   
              }                                                                                     
              boolean tmp7$5;                                                                       
              boolean tmp8$5;                                                                       
              boolean tmp9$5;                                                                       
              V tmp10$5;                                                                            
              tmp10$5 := current$5.reference;                                                       
              tmp9$5 = expectedReference$5 == tmp10$5;                                              
              if (tmp9$5) {                                                                         
                boolean tmp11$5;                                                                    
                tmp11$5 := current$5.mark;                                                          
                tmp8$5 = expectedMark$5 == tmp11$5;                                                 
              } else {                                                                              
                tmp8$5 = false;                                                                     
              }                                                                                     
              if (tmp8$5) {                                                                         
                Pair tmp12$5;                                                                       
                {                                                                                   
                  inlined tmp12$5 = this$5.pairOf(newReference$5,newMark$5);                        
                  exit$6: {                                                                         
                    V initialRef$6;                                                                 
                    boolean initialMark$6;                                                          
                    AtomicMarkableReference this$6;                                                 
                    initialRef$6 = newReference$5;                                                  
                    initialMark$6 = newMark$5;                                                      
                    this$6 = this$5;                                                                
                    {                                                                               
                      Pair p$6;                                                                     
                      p$6 = new Pair();                                                             
                      {                                                                             
                        inlined p$6.init(initialRef$6,initialMark$6);                               
                        exit$7: {                                                                   
                          V reference$7;                                                            
                          boolean mark$7;                                                           
                          Pair this$7;                                                              
                          reference$7 = initialRef$6;                                               
                          mark$7 = initialMark$6;                                                   
                          this$7 = p$6;                                                             
                          {                                                                         
                            assume this$7.reference == V.null;                                      
                            assume this$7.mark == false;                                            
                            {                                                                       
                              this$7.reference := reference$7;                                      
                              this$7.mark := mark$7;                                                
                              {                                                                     
                                break exit$7;                                                       
                              }                                                                     
                            }                                                                       
                          }                                                                         
                        }                                                                           
                        inlined return;                                                             
                      }                                                                             
                      {                                                                             
                        {                                                                           
                          tmp12$5 = p$6;                                                            
                          break exit$6;                                                             
                        }                                                                           
                      }                                                                             
                      {                                                                             
                        {                                                                           
                          tmp12$5 = Pair.null;                                                      
                          break exit$6;                                                             
                        }                                                                           
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                  inlined return;                                                                   
                }                                                                                   
                {                                                                                   
                  inlined tmp7$5 = this$5.casPair(current$5,tmp12$5);                               
                  exit$8: {                                                                         
                    Pair cmp$8;                                                                     
                    Pair val$8;                                                                     
                    AtomicMarkableReference this$8;                                                 
                    cmp$8 = current$5;                                                              
                    val$8 = tmp12$5;                                                                
                    this$8 = this$5;                                                                
                    {                                                                               
                      boolean tmp18$8;                                                              
                      {                                                                             
                        noop(TraceOff);                                                             
                        boolean ctmp237616$8;                                                       
                        ctmp237616$8 = *;                                                           
                        if (ctmp237616$8) {                                                         
                          noop(TraceOn);                                                            
                          tmp18$8 = false;                                                          
                        } else {                                                                    
                          ctmp237616$8 = *;                                                         
                          if (ctmp237616$8) {                                                       
                            Tid tmpTid$8;                                                           
                            Pair tmpValue$8;                                                        
                            Mover _m$8;                                                             
                            _m$8 = writePermission(this$8.pair, val$8);                             
                            assume this$8.pair == cmp$8;                                            
                            assume !goesWrong(_m$8);                                                
                            assume this$8.pair_nextThread == tid;                                   
                            assume this$8.pair_nextValue == cmp$8;                                  
                            this$8.pair_nextThread := tmpTid$8 as B;                                
                            this$8.pair_nextValue := tmpValue$8 as B;                               
                            noop(TraceOn);                                                          
                            this$8.pair := val$8;                                                   
                            tmp18$8 = true;                                                         
                          } else {                                                                  
                            assume this$8.pair_nextThread == tid;                                   
                            assume this$8.pair_nextValue == cmp$8;                                  
                            Pair _currentValue$8;                                                   
                            _currentValue$8 := this$8.pair  as B;                                   
                            this$8.pair := cmp$8 as B;                                              
                            Mover _m$8;                                                             
                            _m$8 = writePermission(this$8.pair, val$8);                             
                            this$8.pair := _currentValue$8 as B;                                    
                            assume goesWrong(_m$8);                                                 
                            noop(TraceOn);                                                          
                            this$8.pair := val$8;                                                   
                            tmp18$8 = false;                                                        
                          }                                                                         
                        }                                                                           
                      }                                                                             
                      {                                                                             
                        {                                                                           
                          tmp7$5 = tmp18$8;                                                         
                          break exit$8;                                                             
                        }                                                                           
                      }                                                                             
                      {                                                                             
                        {                                                                           
                          tmp7$5 = false;                                                           
                          break exit$8;                                                             
                        }                                                                           
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                  inlined return;                                                                   
                }                                                                                   
              } else {                                                                              
                tmp7$5 = false;                                                                     
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  b = tmp7$5;                                                                       
                  break exit$5;                                                                     
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  b = false;                                                                        
                  break exit$5;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        if (b /* == b */) {                                                                         
                                                                                                    
        } else {                                                                                    
                                                                                                    
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class V {                                                                                       
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Pair {                                                                                    
       V reference isLocal(this, tid)                                                               
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(V reference,boolean mark) {                                                         
        assume this.reference == V.null;                                                            
        assume this.mark == false;                                                                  
        {                                                                                           
          this.reference := reference;                                                              
          this.mark := mark;                                                                        
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      hasCASOperation noABA volatile Pair pair isLocal(this, tid)                                   
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? N                                                                                        
         : isLocal(newValue, tid) ? N : E                                                           
        yields_as this.pair != newValue ==> !isShared(newValue);                                    
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid pair_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.pair_nextThread == tid ? N : E                                                        
        yields_as this.pair_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Pair pair_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.pair_nextThread == tid ? N : E                                                        
        yields_as this.pair_nextThread == tid ==> newValue == this.pair_nextValue;                  
                                                                                                    
                                                                                                    
      invariant  this.pair != Pair.null;                                                            
                                                                                                    
                                                                                                    
                                                                                                    
      void init(V initialRef,boolean initialMark) {                                                 
        assume this.pair == Pair.null;                                                              
        {                                                                                           
          Pair tmp1;                                                                                
          tmp1 = this.pairOf(initialRef,initialMark)                                                
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.pair_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.pair := tmp1;                                                                      
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      Pair pairOf(V initialRef,boolean initialMark) {                                               
        Pair p;                                                                                     
        p = new Pair();                                                                             
        p.init(initialRef,initialMark)                                                              
        {                                                                                           
           return p;                                                                                
        }                                                                                           
        {                                                                                           
          // return Pair.null;                                                                      
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      V getReference() {                                                                            
        V tmp2;                                                                                     
        Pair tmp3;                                                                                  
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp3 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp3 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        tmp2 := tmp3.reference;                                                                     
        {                                                                                           
           return tmp2;                                                                             
        }                                                                                           
        {                                                                                           
          // return V.null;                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean isMarked() {                                                                          
        boolean tmp4;                                                                               
        Pair tmp5;                                                                                  
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp5 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp5 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        tmp4 := tmp5.mark;                                                                          
        {                                                                                           
           return tmp4;                                                                             
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      Pair get() {                                                                                  
        Pair tmp6;                                                                                  
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp6 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp6 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        {                                                                                           
           return tmp6;                                                                             
        }                                                                                           
        {                                                                                           
          // return Pair.null;                                                                      
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean compareAndSet(V expectedReference,V newReference,boolean expectedMark,boolean newMark) {
        Pair current;                                                                               
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            current := this.pair  as R;                                                             
          } else {                                                                                  
            noop(TraceOn);                                                                          
            current := this.pair;                                                                   
          }                                                                                         
        }                                                                                           
        boolean tmp7;                                                                               
        boolean tmp8;                                                                               
        boolean tmp9;                                                                               
        V tmp10;                                                                                    
        tmp10 := current.reference;                                                                 
        tmp9 = expectedReference == tmp10;                                                          
        if (tmp9) {                                                                                 
          boolean tmp11;                                                                            
          tmp11 := current.mark;                                                                    
          tmp8 = expectedMark == tmp11;                                                             
        } else {                                                                                    
          tmp8 = false;                                                                             
        }                                                                                           
        if (tmp8) {                                                                                 
          Pair tmp12;                                                                               
          tmp12 = this.pairOf(newReference,newMark)                                                 
          tmp7 = this.casPair(current,tmp12)                                                        
        } else {                                                                                    
          tmp7 = false;                                                                             
        }                                                                                           
        {                                                                                           
           return tmp7;                                                                             
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void set(V newReference,boolean newMark) {                                                    
        Pair tmp13;                                                                                 
        tmp13 = this.pairOf(newReference,newMark)                                                   
        {                                                                                           
          noop(TraceOff);                                                                           
          assume this.pair_nextThread == tid;                                                       
          noop(TraceOn);                                                                            
          this.pair := tmp13;                                                                       
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean attemptMark(V expectedReference,boolean newMark) {                                    
        Pair current;                                                                               
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Pair _C_v;                                                                                
          _C_v := this.pair_nextValue  as B;                                                        
          Pair _currentValue;                                                                       
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            current := this.pair  as R;                                                             
          } else {                                                                                  
            noop(TraceOn);                                                                          
            current := this.pair;                                                                   
          }                                                                                         
        }                                                                                           
        boolean tmp14;                                                                              
        boolean tmp15;                                                                              
        V tmp16;                                                                                    
        tmp16 := current.reference;                                                                 
        tmp15 = expectedReference == tmp16;                                                         
        if (tmp15) {                                                                                
          Pair tmp17;                                                                               
          tmp17 = this.pairOf(expectedReference,newMark)                                            
          tmp14 = this.casPair(current,tmp17)                                                       
        } else {                                                                                    
          tmp14 = false;                                                                            
        }                                                                                           
        {                                                                                           
           return tmp14;                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean casPair(Pair cmp,Pair val) {                                                          
        boolean tmp18;                                                                              
        {                                                                                           
          noop(TraceOff);                                                                           
          boolean ctmp237616;                                                                       
          ctmp237616 = *;                                                                           
          if (ctmp237616) {                                                                         
            noop(TraceOn);                                                                          
            tmp18 = false;                                                                          
          } else {                                                                                  
            ctmp237616 = *;                                                                         
            if (ctmp237616) {                                                                       
              Tid tmpTid;                                                                           
              Pair tmpValue;                                                                        
              Mover _m;                                                                             
              _m = writePermission(this.pair, val);                                                 
              assume this.pair == cmp;                                                              
              assume !goesWrong(_m);                                                                
              assume this.pair_nextThread == tid;                                                   
              assume this.pair_nextValue == cmp;                                                    
              this.pair_nextThread := tmpTid as B;                                                  
              this.pair_nextValue := tmpValue as B;                                                 
              noop(TraceOn);                                                                        
              this.pair := val;                                                                     
              tmp18 = true;                                                                         
            } else {                                                                                
              assume this.pair_nextThread == tid;                                                   
              assume this.pair_nextValue == cmp;                                                    
              Pair _currentValue;                                                                   
              _currentValue := this.pair  as B;                                                     
              this.pair := cmp as B;                                                                
              Mover _m;                                                                             
              _m = writePermission(this.pair, val);                                                 
              this.pair := _currentValue as B;                                                      
              assume goesWrong(_m);                                                                 
              noop(TraceOn);                                                                        
              this.pair := val;                                                                     
              tmp18 = false;                                                                        
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
           return tmp18;                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires x != AtomicMarkableReference.null;                                                   
                                                                                                    
      public void f(AtomicMarkableReference x) {                                                    
        V d;                                                                                        
        d = new V();                                                                                
        {                                                                                           
          inlined d.init();                                                                         
          exit$2: {                                                                                 
            V this$2;                                                                               
            this$2 = d;                                                                             
            {                                                                                       
              {                                                                                     
                break exit$2;                                                                       
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        Pair result;                                                                                
        {                                                                                           
          inlined result = x.get();                                                                 
          exit$3: {                                                                                 
            AtomicMarkableReference this$3;                                                         
            this$3 = x;                                                                             
            {                                                                                       
              Pair tmp6$3;                                                                          
              {                                                                                     
                noop(TraceOff);                                                                     
                Tid _C_t$3;                                                                         
                _C_t$3 := this$3.pair_nextThread  as B;                                             
                Pair _C_v$3;                                                                        
                _C_v$3 := this$3.pair_nextValue  as B;                                              
                Pair _currentValue$3;                                                               
                _currentValue$3 := this$3.pair  as B;                                               
                Mover _R_t$3;                                                                       
                _R_t$3 = readPermission(this$3.pair);                                               
                boolean _casable$3;                                                                 
                _casable$3 = _R_t$3 != E && true && _C_t$3 == tid && _C_v$3 == _currentValue$3;     
                if (_casable$3) {                                                                   
                  noop(TraceOn);                                                                    
                  tmp6$3 := this$3.pair  as R;                                                      
                } else {                                                                            
                  noop(TraceOn);                                                                    
                  tmp6$3 := this$3.pair;                                                            
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result = tmp6$3;                                                                  
                  break exit$3;                                                                     
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result = Pair.null;                                                               
                  break exit$3;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        yield;                                                                                      
        Pair result2;                                                                               
        {                                                                                           
          inlined result2 = x.get();                                                                
          exit$4: {                                                                                 
            AtomicMarkableReference this$4;                                                         
            this$4 = x;                                                                             
            {                                                                                       
              Pair tmp6$4;                                                                          
              {                                                                                     
                noop(TraceOff);                                                                     
                Tid _C_t$4;                                                                         
                _C_t$4 := this$4.pair_nextThread  as B;                                             
                Pair _C_v$4;                                                                        
                _C_v$4 := this$4.pair_nextValue  as B;                                              
                Pair _currentValue$4;                                                               
                _currentValue$4 := this$4.pair  as B;                                               
                Mover _R_t$4;                                                                       
                _R_t$4 = readPermission(this$4.pair);                                               
                boolean _casable$4;                                                                 
                _casable$4 = _R_t$4 != E && true && _C_t$4 == tid && _C_v$4 == _currentValue$4;     
                if (_casable$4) {                                                                   
                  noop(TraceOn);                                                                    
                  tmp6$4 := this$4.pair  as R;                                                      
                } else {                                                                            
                  noop(TraceOn);                                                                    
                  tmp6$4 := this$4.pair;                                                            
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result2 = tmp6$4;                                                                 
                  break exit$4;                                                                     
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result2 = Pair.null;                                                              
                  break exit$4;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        yield;                                                                                      
        boolean b;                                                                                  
        V tmp19;                                                                                    
        tmp19 := result.reference;                                                                  
        boolean tmp20;                                                                              
        tmp20 := result.mark;                                                                       
        {                                                                                           
          inlined b = x.compareAndSet(tmp19,V.null,tmp20,true);                                     
          exit$5: {                                                                                 
            V expectedReference$5;                                                                  
            V newReference$5;                                                                       
            boolean expectedMark$5;                                                                 
            boolean newMark$5;                                                                      
            AtomicMarkableReference this$5;                                                         
            expectedReference$5 = tmp19;                                                            
            newReference$5 = V.null;                                                                
            expectedMark$5 = tmp20;                                                                 
            newMark$5 = true;                                                                       
            this$5 = x;                                                                             
            {                                                                                       
              Pair current$5;                                                                       
              {                                                                                     
                noop(TraceOff);                                                                     
                Tid _C_t$5;                                                                         
                _C_t$5 := this$5.pair_nextThread  as B;                                             
                Pair _C_v$5;                                                                        
                _C_v$5 := this$5.pair_nextValue  as B;                                              
                Pair _currentValue$5;                                                               
                _currentValue$5 := this$5.pair  as B;                                               
                Mover _R_t$5;                                                                       
                _R_t$5 = readPermission(this$5.pair);                                               
                boolean _casable$5;                                                                 
                _casable$5 = _R_t$5 != E && true && _C_t$5 == tid && _C_v$5 == _currentValue$5;     
                if (_casable$5) {                                                                   
                  noop(TraceOn);                                                                    
                  current$5 := this$5.pair  as R;                                                   
                } else {                                                                            
                  noop(TraceOn);                                                                    
                  current$5 := this$5.pair;                                                         
                }                                                                                   
              }                                                                                     
              boolean tmp7$5;                                                                       
              boolean tmp8$5;                                                                       
              boolean tmp9$5;                                                                       
              V tmp10$5;                                                                            
              tmp10$5 := current$5.reference;                                                       
              tmp9$5 = expectedReference$5 == tmp10$5;                                              
              if (tmp9$5) {                                                                         
                boolean tmp11$5;                                                                    
                tmp11$5 := current$5.mark;                                                          
                tmp8$5 = expectedMark$5 == tmp11$5;                                                 
              } else {                                                                              
                tmp8$5 = false;                                                                     
              }                                                                                     
              if (tmp8$5) {                                                                         
                Pair tmp12$5;                                                                       
                {                                                                                   
                  inlined tmp12$5 = this$5.pairOf(newReference$5,newMark$5);                        
                  exit$6: {                                                                         
                    V initialRef$6;                                                                 
                    boolean initialMark$6;                                                          
                    AtomicMarkableReference this$6;                                                 
                    initialRef$6 = newReference$5;                                                  
                    initialMark$6 = newMark$5;                                                      
                    this$6 = this$5;                                                                
                    {                                                                               
                      Pair p$6;                                                                     
                      p$6 = new Pair();                                                             
                      {                                                                             
                        inlined p$6.init(initialRef$6,initialMark$6);                               
                        exit$7: {                                                                   
                          V reference$7;                                                            
                          boolean mark$7;                                                           
                          Pair this$7;                                                              
                          reference$7 = initialRef$6;                                               
                          mark$7 = initialMark$6;                                                   
                          this$7 = p$6;                                                             
                          {                                                                         
                            assume this$7.reference == V.null;                                      
                            assume this$7.mark == false;                                            
                            {                                                                       
                              this$7.reference := reference$7;                                      
                              this$7.mark := mark$7;                                                
                              {                                                                     
                                break exit$7;                                                       
                              }                                                                     
                            }                                                                       
                          }                                                                         
                        }                                                                           
                        inlined return;                                                             
                      }                                                                             
                      {                                                                             
                        {                                                                           
                          tmp12$5 = p$6;                                                            
                          break exit$6;                                                             
                        }                                                                           
                      }                                                                             
                      {                                                                             
                        {                                                                           
                          tmp12$5 = Pair.null;                                                      
                          break exit$6;                                                             
                        }                                                                           
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                  inlined return;                                                                   
                }                                                                                   
                {                                                                                   
                  inlined tmp7$5 = this$5.casPair(current$5,tmp12$5);                               
                  exit$8: {                                                                         
                    Pair cmp$8;                                                                     
                    Pair val$8;                                                                     
                    AtomicMarkableReference this$8;                                                 
                    cmp$8 = current$5;                                                              
                    val$8 = tmp12$5;                                                                
                    this$8 = this$5;                                                                
                    {                                                                               
                      boolean tmp18$8;                                                              
                      {                                                                             
                        noop(TraceOff);                                                             
                        boolean ctmp237616$8;                                                       
                        ctmp237616$8 = *;                                                           
                        if (ctmp237616$8) {                                                         
                          noop(TraceOn);                                                            
                          tmp18$8 = false;                                                          
                        } else {                                                                    
                          ctmp237616$8 = *;                                                         
                          if (ctmp237616$8) {                                                       
                            Tid tmpTid$8;                                                           
                            Pair tmpValue$8;                                                        
                            Mover _m$8;                                                             
                            _m$8 = writePermission(this$8.pair, val$8);                             
                            assume this$8.pair == cmp$8;                                            
                            assume !goesWrong(_m$8);                                                
                            assume this$8.pair_nextThread == tid;                                   
                            assume this$8.pair_nextValue == cmp$8;                                  
                            this$8.pair_nextThread := tmpTid$8 as B;                                
                            this$8.pair_nextValue := tmpValue$8 as B;                               
                            noop(TraceOn);                                                          
                            this$8.pair := val$8;                                                   
                            tmp18$8 = true;                                                         
                          } else {                                                                  
                            assume this$8.pair_nextThread == tid;                                   
                            assume this$8.pair_nextValue == cmp$8;                                  
                            Pair _currentValue$8;                                                   
                            _currentValue$8 := this$8.pair  as B;                                   
                            this$8.pair := cmp$8 as B;                                              
                            Mover _m$8;                                                             
                            _m$8 = writePermission(this$8.pair, val$8);                             
                            this$8.pair := _currentValue$8 as B;                                    
                            assume goesWrong(_m$8);                                                 
                            noop(TraceOn);                                                          
                            this$8.pair := val$8;                                                   
                            tmp18$8 = false;                                                        
                          }                                                                         
                        }                                                                           
                      }                                                                             
                      {                                                                             
                        {                                                                           
                          tmp7$5 = tmp18$8;                                                         
                          break exit$8;                                                             
                        }                                                                           
                      }                                                                             
                      {                                                                             
                        {                                                                           
                          tmp7$5 = false;                                                           
                          break exit$8;                                                             
                        }                                                                           
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                  inlined return;                                                                   
                }                                                                                   
              } else {                                                                              
                tmp7$5 = false;                                                                     
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  b = tmp7$5;                                                                       
                  break exit$5;                                                                     
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  b = false;                                                                        
                  break exit$5;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        if (b /* == b */) {                                                                         
                                                                                                    
        } else {                                                                                    
                                                                                                    
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl V ***/                                                                              
                                                                                                    
type V;                                                                                             
const unique V.null: V;                                                                             
var V._state: [V]State;                                                                             
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var V._lock: [V]Tid;                                                                                
                                                                                                    
function {:inline} ReadEval.V._lock(tid: Tid,this : V,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(V._state[this], tid)) then                                                             
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((V._lock[this]==tid)) then                                                                   
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((V._lock[this]==Tid.null)&&(newValue==tid))) then                                           
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((V._lock[this]==tid)&&(newValue==Tid.null))) then                                          
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.V._lock(tid: Tid,this : V,newValue: Tid,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(V._state[this], tid)) then                                                             
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((V._lock[this]==tid)) then                                                                   
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((V._lock[this]==Tid.null)&&(newValue==tid))) then                                           
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((V._lock[this]==tid)&&(newValue==Tid.null))) then                                          
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Pair ***/                                                                           
                                                                                                    
type Pair;                                                                                          
const unique Pair.null: Pair;                                                                       
var Pair._state: [Pair]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Pair.reference: [Pair]V;                                                                        
                                                                                                    
function {:inline} ReadEval.Pair.reference(tid: Tid,this : Pair,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := V.null;                                                                           
 if (isLocal(Pair._state[this], tid)) then                                                          
  if (isLocal(Pair._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Pair.reference(tid: Tid,this : Pair,newValue: V,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Pair._state[this], tid)) then                                                          
  if (isLocal(Pair._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Pair.mark: [Pair]bool;                                                                          
                                                                                                    
function {:inline} ReadEval.Pair.mark(tid: Tid,this : Pair,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := false;                                                                            
 if (isLocal(Pair._state[this], tid)) then                                                          
  if (isLocal(Pair._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Pair.mark(tid: Tid,this : Pair,newValue: bool,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Pair._state[this], tid)) then                                                          
  if (isLocal(Pair._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Pair._lock: [Pair]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Pair._lock(tid: Tid,this : Pair,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Pair._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Pair._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Pair._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Pair._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Pair._lock(tid: Tid,this : Pair,newValue: Tid,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Pair._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Pair._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Pair._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Pair._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl AtomicMarkableReference ***/                                                        
                                                                                                    
type AtomicMarkableReference;                                                                       
const unique AtomicMarkableReference.null: AtomicMarkableReference;                                 
var AtomicMarkableReference._state: [AtomicMarkableReference]State;                                 
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference.pair: [AtomicMarkableReference]Pair;                                    
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference.pair(tid: Tid,this : AtomicMarkableReference,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Pair.null;                                                                        
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isLocal(AtomicMarkableReference._state[this], tid)) then                                      
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   if (isLocal(Pair._state[newValue], tid)) then                                                    
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference.pair(tid: Tid,this : AtomicMarkableReference,newValue: Pair,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isLocal(AtomicMarkableReference._state[this], tid)) then                                      
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   if (isLocal(Pair._state[newValue], tid)) then                                                    
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference._lock: [AtomicMarkableReference]Tid;                                    
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference._lock(tid: Tid,this : AtomicMarkableReference,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((AtomicMarkableReference._lock[this]==tid)) then                                             
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((AtomicMarkableReference._lock[this]==Tid.null)&&(newValue==tid))) then                     
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((AtomicMarkableReference._lock[this]==tid)&&(newValue==Tid.null))) then                    
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference._lock(tid: Tid,this : AtomicMarkableReference,newValue: Tid,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((AtomicMarkableReference._lock[this]==tid)) then                                             
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((AtomicMarkableReference._lock[this]==Tid.null)&&(newValue==tid))) then                     
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((AtomicMarkableReference._lock[this]==tid)&&(newValue==Tid.null))) then                    
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid;                          
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this : AtomicMarkableReference,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((AtomicMarkableReference.pair_nextThread[this]==tid)) then                                    
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this : AtomicMarkableReference,newValue: Tid,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((AtomicMarkableReference.pair_nextThread[this]==tid)) then                                    
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair;                          
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this : AtomicMarkableReference,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Pair.null;                                                                        
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((AtomicMarkableReference.pair_nextThread[this]==tid)) then                                    
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this : AtomicMarkableReference,newValue: Pair,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((AtomicMarkableReference.pair_nextThread[this]==tid)) then                                    
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.AtomicMarkableReference.252911(tid: Tid,this : AtomicMarkableReference,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
 (AtomicMarkableReference.pair[this]!=Pair.null)                                                    
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Main ***/                                                                           
                                                                                                    
type Main;                                                                                          
const unique Main.null: Main;                                                                       
var Main._state: [Main]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Main._lock: [Main]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Main._lock(tid: Tid,this : Main,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Main._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Main._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Main._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Main._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Main._lock(tid: Tid,this : Main,newValue: Tid,V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Main._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Main._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Main._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Main._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Main.f(tid:Tid, this : Main, x : AtomicMarkableReference)                                
modifies V._state;                                                                                  
modifies V._lock;                                                                                   
modifies Pair._state;                                                                               
modifies Pair.reference;                                                                            
modifies Pair.mark;                                                                                 
modifies Pair._lock;                                                                                
modifies AtomicMarkableReference._state;                                                            
modifies AtomicMarkableReference.pair;                                                              
modifies AtomicMarkableReference._lock;                                                             
modifies AtomicMarkableReference.pair_nextThread;                                                   
modifies AtomicMarkableReference.pair_nextValue;                                                    
modifies Main._state;                                                                               
modifies Main._lock;                                                                                
                                                                                                    
requires ValidTid(tid);                                                                                    // (72.5): Bad tid
requires isSharedAssignable(AtomicMarkableReference._state[x]);                                            // (72.5): Parameter VarDecl(ClassType(AtomicMarkableReference),x) is not global
requires isShared(Main._state[this]);                                                                      // (72.5): this is not global
                                                                                                    
requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
requires (x!=AtomicMarkableReference.null);                                                         
                                                                                                    
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (72.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
ensures  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (72.5): Object invariant may not hold.
{                                                                                                   
 var mover261016: Mover;                                                                            
 var x260878: AtomicMarkableReference;                                                              
 var Pair._state261346: [Pair]State;                                                                
 var newReference$5261304: V;                                                                       
 var this261304: Main;                                                                              
 var Pair.reference260778: [Pair]V;                                                                 
 var $recorded.state260790: int;                                                                    
 var result261066: Pair;                                                                            
 var AtomicMarkableReference.pair_nextThread261301: [AtomicMarkableReference]Tid;                   
 var AtomicMarkableReference.pair_nextValue261420: [AtomicMarkableReference]Pair;                   
 var moverPath261010: MoverPath;                                                                    
 var mover261308: Mover;                                                                            
 var AtomicMarkableReference._lock261334: [AtomicMarkableReference]Tid;                             
 var tid261304: Tid;                                                                                
 var $recorded.state260878: int;                                                                    
 var AtomicMarkableReference._state261334: [AtomicMarkableReference]State;                          
 var newReference$5261353: V;                                                                       
 var Pair.reference261331: [Pair]V;                                                                 
 var newReference$5261180: V;                                                                       
 var result2261346: Pair;                                                                           
 var AtomicMarkableReference.pair_nextThread261346: [AtomicMarkableReference]Tid;                   
 var $recorded.state260884: int;                                                                    
 var tmp20261022: bool;                                                                             
 var Pair._state261010: [Pair]State;                                                                
 var Pair.mark260958: [Pair]bool;                                                                   
 var _C_t$4260878: Tid;                                                                             
 var this$5261308: AtomicMarkableReference;                                                         
 var tid260929: Tid;                                                                                
 var AtomicMarkableReference.pair_nextValue260934: [AtomicMarkableReference]Pair;                   
 var _C_v$4260890: Pair;                                                                            
 var this261183: Main;                                                                              
 var x260858: AtomicMarkableReference;                                                              
 var Main._lock261010: [Main]Tid;                                                                   
 var Pair._lock261331: [Pair]Tid;                                                                   
 var d260858: V;                                                                                    
 var Pair._lock260858: [Pair]Tid;                                                                   
 var V._lock261066: [V]Tid;                                                                         
 var _currentValue$3260834: Pair;                                                                   
 var mover261346: Mover;                                                                            
 var Pair._lock260929: [Pair]Tid;                                                                   
 var tmp8$5261331: bool;                                                                            
 var expectedReference$5261084: V;                                                                  
 var newReference$5261308: V;                                                                       
 var AtomicMarkableReference.pair_nextValue260858: [AtomicMarkableReference]Pair;                   
 var newReference$5261084: V;                                                                       
 var x261353: AtomicMarkableReference;                                                              
 var tmp8$5261180: bool;                                                                            
 var mover261066: Mover;                                                                            
 var moverPath261331: MoverPath;                                                                    
 var $pc260884: Phase;                                                                              
 var Pair.mark261183: [Pair]bool;                                                                   
 var Main._state260829: [Main]State;                                                                
 var AtomicMarkableReference._state260958: [AtomicMarkableReference]State;                          
 var tmp19261353: V;                                                                                
 var expectedMark$5261308: bool;                                                                    
 var $recorded.state260834: int;                                                                    
 var x260834: AtomicMarkableReference;                                                              
 var _C_v$4260934: Pair;                                                                            
 var $pc260967: Phase;                                                                              
 var AtomicMarkableReference.pair_nextValue261346: [AtomicMarkableReference]Pair;                   
 var Pair._state261016: [Pair]State;                                                                
 var result260834: Pair;                                                                            
 var tmp19261061: V;                                                                                
 var V._lock261097: [V]Tid;                                                                         
 var V._state260973: [V]State;                                                                      
 var tmp7$5: bool;                                                                                  
 var $recorded.state261022: int;                                                                    
 var this260958_post: Main;                                                                         
 var Pair.reference261346: [Pair]V;                                                                 
 var Main._lock261097: [Main]Tid;                                                                   
 var Pair.mark260967: [Pair]bool;                                                                   
 var path261301: int;                                                                               
 var V._lock261353: [V]Tid;                                                                         
 var Main._state261331: [Main]State;                                                                
 var Pair.reference260958_post: [Pair]V;                                                            
 var tmp9$5261346: bool;                                                                            
 var tid261010: Tid;                                                                                
 var path260934: int;                                                                               
 var $recorded.state261084: int;                                                                    
 var tmp8$5261301: bool;                                                                            
 var $recorded.state260958: int;                                                                    
 var $pc261022: Phase;                                                                              
 var this260890: Main;                                                                              
 var tmp20261066: bool;                                                                             
 var moverPath260790: MoverPath;                                                                    
 var AtomicMarkableReference._state260878: [AtomicMarkableReference]State;                          
 var mover261022: Mover;                                                                            
 var result2261061: Pair;                                                                           
 var tid260973: Tid;                                                                                
 var tid261331: Tid;                                                                                
 var this$5261183: AtomicMarkableReference;                                                         
 var path261346: int;                                                                               
 var _C_t$5261016: Tid;                                                                             
 var AtomicMarkableReference._lock260790: [AtomicMarkableReference]Tid;                             
 var tmp7$5261097: bool;                                                                            
 var $pc261180: Phase;                                                                              
 var this261308: Main;                                                                              
 var Pair._lock261308: [Pair]Tid;                                                                   
 var x260934: AtomicMarkableReference;                                                              
 var Pair._state260858: [Pair]State;                                                                
 var Main._lock260958_post: [Main]Tid;                                                              
 var Main._state261308: [Main]State;                                                                
 var expectedMark$5: bool;                                                                          
 var _casable$4: bool;                                                                              
 var reference$7261183: V;                                                                          
 var d260878: V;                                                                                    
 var Pair._lock261304: [Pair]Tid;                                                                   
 var AtomicMarkableReference.pair_nextThread261353: [AtomicMarkableReference]Tid;                   
 var tmp20261420: bool;                                                                             
 var expectedReference$5261097: V;                                                                  
 var path260790: int;                                                                               
 var tid260878: Tid;                                                                                
 var Main._state260929: [Main]State;                                                                
 var tmp19261304: V;                                                                                
 var Pair._state260784: [Pair]State;                                                                
 var V._lock261334: [V]Tid;                                                                         
 var Main._state260858: [Main]State;                                                                
 var _C_t$4: Tid;                                                                                   
 var Main._state260834: [Main]State;                                                                
 var Pair.mark261010: [Pair]bool;                                                                   
 var mover260790: Mover;                                                                            
 var path261308: int;                                                                               
 var Pair._lock260884: [Pair]Tid;                                                                   
 var d261010: V;                                                                                    
 var tmp19: V;                                                                                      
 var tmpTid$8261308: Tid;                                                                           
 var Pair.reference261420: [Pair]V;                                                                 
 var result2261304: Pair;                                                                           
 var AtomicMarkableReference.pair_nextValue260958: [AtomicMarkableReference]Pair;                   
 var _currentValue$4260934: Pair;                                                                   
 var expectedReference$5261331: V;                                                                  
 var Pair.reference260858_post: [Pair]V;                                                            
 var tmp18$8: bool;                                                                                 
 var $recorded.state260890: int;                                                                    
 var V._lock260973: [V]Tid;                                                                         
 var newMark$5261016: bool;                                                                         
 var _C_t$4260929: Tid;                                                                             
 var tmp10$5261334: V;                                                                              
 var Main._state260973: [Main]State;                                                                
 var AtomicMarkableReference._lock261308: [AtomicMarkableReference]Tid;                             
 var V._lock260884: [V]Tid;                                                                         
 var tid260884: Tid;                                                                                
 var _casable$3260829: bool;                                                                        
 var expectedReference$5261010: V;                                                                  
 var tmp6$4260934: Pair;                                                                            
 var Main._state260790: [Main]State;                                                                
 var AtomicMarkableReference.pair_nextValue261308: [AtomicMarkableReference]Pair;                   
 var AtomicMarkableReference._state261180: [AtomicMarkableReference]State;                          
 var this260958: Main;                                                                              
 var Pair._state261420: [Pair]State;                                                                
 var tmp19260967: V;                                                                                
 var AtomicMarkableReference._lock261097: [AtomicMarkableReference]Tid;                             
 var this$8261353: AtomicMarkableReference;                                                         
 var expectedReference$5261180: V;                                                                  
 var expectedReference$5261353: V;                                                                  
 var _C_v$5261066: Pair;                                                                            
 var tmp20261301: bool;                                                                             
 var ctmp237616$8261353: bool;                                                                      
 var AtomicMarkableReference.pair_nextValue260784: [AtomicMarkableReference]Pair;                   
 var this260929: Main;                                                                              
 var tid261022: Tid;                                                                                
 var AtomicMarkableReference.pair_nextThread261084: [AtomicMarkableReference]Tid;                   
 var x261016: AtomicMarkableReference;                                                              
 var _C_v$4260884: Pair;                                                                            
 var tmpValue$8: Pair;                                                                              
 var Pair._state260834: [Pair]State;                                                                
 var _C_t$3260784: Tid;                                                                             
 var result2261010: Pair;                                                                           
 var b260967: bool;                                                                                 
 var $recorded.state260929: int;                                                                    
 var Main._state261301: [Main]State;                                                                
 var path260890: int;                                                                               
 var Main._state261353: [Main]State;                                                                
 var this260858: Main;                                                                              
 var current$5261183: Pair;                                                                         
 var val$8261308: Pair;                                                                             
 var AtomicMarkableReference.pair_nextValue260878: [AtomicMarkableReference]Pair;                   
 var reference$7261180: V;                                                                          
 var current$5261084: Pair;                                                                         
 var V._state261420: [V]State;                                                                      
 var this$4260929: AtomicMarkableReference;                                                         
 var $recorded.state261010: int;                                                                    
 var V._state260829: [V]State;                                                                      
 var tmp20261084: bool;                                                                             
 var V._lock260790: [V]Tid;                                                                         
 var Main._state260934: [Main]State;                                                                
 var x260790: AtomicMarkableReference;                                                              
 var $recorded.state261061: int;                                                                    
 var this$5261301: AtomicMarkableReference;                                                         
 var AtomicMarkableReference.pair_nextValue261353: [AtomicMarkableReference]Pair;                   
 var d261301: V;                                                                                    
 var Pair._lock260967: [Pair]Tid;                                                                   
 var moverPath261066: MoverPath;                                                                    
 var Pair._state261353: [Pair]State;                                                                
 var this261331: Main;                                                                              
 var V._lock261346: [V]Tid;                                                                         
 var V._lock260878: [V]Tid;                                                                         
 var this$8261304: AtomicMarkableReference;                                                         
 var V._state260958: [V]State;                                                                      
 var tid260958: Tid;                                                                                
 var V._state260784: [V]State;                                                                      
 var _R_t$3: Mover;                                                                                 
 var moverPath261180: MoverPath;                                                                    
 var tmp10$5261180: V;                                                                              
 var current$5261334: Pair;                                                                         
 var Pair.reference260884: [Pair]V;                                                                 
 var expectedReference$5261022: V;                                                                  
 var V._lock261420: [V]Tid;                                                                         
 var V._state260778: [V]State;                                                                      
 var Main._state261183: [Main]State;                                                                
 var Pair._lock260784: [Pair]Tid;                                                                   
 var this$5261016: AtomicMarkableReference;                                                         
 var b261016: bool;                                                                                 
 var d261180: V;                                                                                    
 var AtomicMarkableReference.pair_nextValue261334: [AtomicMarkableReference]Pair;                   
 var tmp9$5261183: bool;                                                                            
 var expectedMark$5261334: bool;                                                                    
 var tmp10$5261084: V;                                                                              
 var result261353: Pair;                                                                            
 var result2261334: Pair;                                                                           
 var tmp8$5261308: bool;                                                                            
 var AtomicMarkableReference.pair261180: [AtomicMarkableReference]Pair;                             
 var result2261308: Pair;                                                                           
 var Main._lock260784: [Main]Tid;                                                                   
 var path260778: int;                                                                               
 var tmp18$8261331: bool;                                                                           
 var _C_v$3: Pair;                                                                                  
 var this$4260884: AtomicMarkableReference;                                                         
 var _currentValue$4: Pair;                                                                         
 var result260878: Pair;                                                                            
 var _C_v$3260829: Pair;                                                                            
 var _C_t$3260829: Tid;                                                                             
 var tmp18$8261301: bool;                                                                           
 var path260929: int;                                                                               
 var x261420: AtomicMarkableReference;                                                              
 var AtomicMarkableReference.pair261420: [AtomicMarkableReference]Pair;                             
 var Main._lock261084: [Main]Tid;                                                                   
 var tmp12$5261308: Pair;                                                                           
 var result2260973: Pair;                                                                           
 var expectedMark$5261183: bool;                                                                    
 var _m$8: Mover;                                                                                   
 var Pair.mark260858: [Pair]bool;                                                                   
 var Pair.mark260890: [Pair]bool;                                                                   
 var result2261084: Pair;                                                                           
 var mover261353: Mover;                                                                            
 var path261022: int;                                                                               
 var _currentValue$3260790: Pair;                                                                   
 var this260778: Main;                                                                              
 var moverPath261097: MoverPath;                                                                    
 var d260958: V;                                                                                    
 var result260890: Pair;                                                                            
 var _C_t$5: Tid;                                                                                   
 var Pair.mark260878: [Pair]bool;                                                                   
 var path260967: int;                                                                               
 var AtomicMarkableReference._state261353: [AtomicMarkableReference]State;                          
 var Pair.mark261334: [Pair]bool;                                                                   
 var AtomicMarkableReference.pair261353: [AtomicMarkableReference]Pair;                             
 var d260973: V;                                                                                    
 var mover261331: Mover;                                                                            
 var V._state261304: [V]State;                                                                      
 var $recorded.state261016: int;                                                                    
 var mark$7261183: bool;                                                                            
 var Pair.reference261180: [Pair]V;                                                                 
 var expectedMark$5261304: bool;                                                                    
 var result2260958: Pair;                                                                           
 var _C_t$5261022: Tid;                                                                             
 var mover260967: Mover;                                                                            
 var Pair.mark260929: [Pair]bool;                                                                   
 var AtomicMarkableReference.pair_nextValue261097: [AtomicMarkableReference]Pair;                   
 var $recorded.state260973: int;                                                                    
 var Pair.mark261016: [Pair]bool;                                                                   
 var Main._state260958: [Main]State;                                                                
 var moverPath261304: MoverPath;                                                                    
 var tmp8$5: bool;                                                                                  
 var Main._state260858_post: [Main]State;                                                           
 var moverPath260934: MoverPath;                                                                    
 var _C_v$4: Pair;                                                                                  
 var Main._state261084: [Main]State;                                                                
 var this$5261353: AtomicMarkableReference;                                                         
 var tmp7$5261308: bool;                                                                            
 var moverPath261016: MoverPath;                                                                    
 var AtomicMarkableReference._lock261016: [AtomicMarkableReference]Tid;                             
 var val$8261331: Pair;                                                                             
 var current$5261301: Pair;                                                                         
 var this$3260829: AtomicMarkableReference;                                                         
 var path260878: int;                                                                               
 var path261061: int;                                                                               
 var _C_t$3260778: Tid;                                                                             
 var newReference$5261022: V;                                                                       
 var AtomicMarkableReference._lock260784: [AtomicMarkableReference]Tid;                             
 var b260973: bool;                                                                                 
 var Main._lock261304: [Main]Tid;                                                                   
 var b261304: bool;                                                                                 
 var moverPath260778: MoverPath;                                                                    
 var tmp10$5261353: V;                                                                              
 var V._state261353: [V]State;                                                                      
 var $pc261353: Phase;                                                                              
 var Main._state261010: [Main]State;                                                                
 var AtomicMarkableReference.pair_nextValue261010: [AtomicMarkableReference]Pair;                   
 var x261304: AtomicMarkableReference;                                                              
 var path261353: int;                                                                               
 var d261061: V;                                                                                    
 var _R_t$3260834: Mover;                                                                           
 var path260829: int;                                                                               
 var tmp9$5261084: bool;                                                                            
 var moverPath261308: MoverPath;                                                                    
 var tmp18$8261334: bool;                                                                           
 var tmp20261180: bool;                                                                             
 var AtomicMarkableReference.pair_nextThread260878: [AtomicMarkableReference]Tid;                   
 var Pair._lock261010: [Pair]Tid;                                                                   
 var AtomicMarkableReference.pair261061: [AtomicMarkableReference]Pair;                             
 var $pc260790: Phase;                                                                              
 var this261022: Main;                                                                              
 var this$8261346: AtomicMarkableReference;                                                         
 var cmp$8261334: Pair;                                                                             
 var mover261084: Mover;                                                                            
 var expectedMark$5261084: bool;                                                                    
 var V._lock261304: [V]Tid;                                                                         
 var V._lock261016: [V]Tid;                                                                         
 var tid261183: Tid;                                                                                
 var x260829: AtomicMarkableReference;                                                              
 var expectedReference$5: V;                                                                        
 var Main._lock261180: [Main]Tid;                                                                   
 var _R_t$5261066: Mover;                                                                           
 var x261308: AtomicMarkableReference;                                                              
 var AtomicMarkableReference._lock260929: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference.pair260858_post: [AtomicMarkableReference]Pair;                        
 var tmp8$5261304: bool;                                                                            
 var this261084: Main;                                                                              
 var this261334: Main;                                                                              
 var tmp20261016: bool;                                                                             
 var mover260878: Mover;                                                                            
 var $pc260934: Phase;                                                                              
 var moverPath260884: MoverPath;                                                                    
 var V._lock261010: [V]Tid;                                                                         
 var d260790: V;                                                                                    
 var Pair.mark260784: [Pair]bool;                                                                   
 var current$5261097: Pair;                                                                         
 var Main._lock261420: [Main]Tid;                                                                   
 var Main._lock260834: [Main]Tid;                                                                   
 var tmp20261304: bool;                                                                             
 var tid261061: Tid;                                                                                
 var V._state260834: [V]State;                                                                      
 var AtomicMarkableReference.pair_nextThread260967: [AtomicMarkableReference]Tid;                   
 var Pair.mark260829: [Pair]bool;                                                                   
 var tid260784: Tid;                                                                                
 var V._state261180: [V]State;                                                                      
 var result2260967: Pair;                                                                           
 var x260958: AtomicMarkableReference;                                                              
 var Pair.reference260784: [Pair]V;                                                                 
 var Pair.reference260967: [Pair]V;                                                                 
 var newMark$5261183: bool;                                                                         
 var val$8261304: Pair;                                                                             
 var expectedMark$5261010: bool;                                                                    
 var d260958_post: V;                                                                               
 var V._lock260858: [V]Tid;                                                                         
 var $pc261084: Phase;                                                                              
 var cmp$8261331: Pair;                                                                             
 var Pair._lock260878: [Pair]Tid;                                                                   
 var val$8261301: Pair;                                                                             
 var _m$8261346: Mover;                                                                             
 var tmpValue$8261304: Pair;                                                                        
 var this261180: Main;                                                                              
 var $pc260973: Phase;                                                                              
 var _currentValue$8261353: Pair;                                                                   
 var moverPath260929: MoverPath;                                                                    
 var Pair._lock261420: [Pair]Tid;                                                                   
 var this$7: Pair;                                                                                  
 var initialMark$6261180: bool;                                                                     
 var path261183: int;                                                                               
 var Pair._state260934: [Pair]State;                                                                
 var AtomicMarkableReference.pair260929: [AtomicMarkableReference]Pair;                             
 var path260884: int;                                                                               
 var Main._lock261308: [Main]Tid;                                                                   
 var expectedReference$5261016: V;                                                                  
 var this260884: Main;                                                                              
 var expectedReference$5261334: V;                                                                  
 var result2260878: Pair;                                                                           
 var _currentValue$8261331: Pair;                                                                   
 var $pc261304: Phase;                                                                              
 var _m$8261353: Mover;                                                                             
 var x261346: AtomicMarkableReference;                                                              
 var x260929: AtomicMarkableReference;                                                              
 var _currentValue$3: Pair;                                                                         
 var $pc261331: Phase;                                                                              
 var Main._state260878: [Main]State;                                                                
 var Pair.reference260890: [Pair]V;                                                                 
 var Main._state260890: [Main]State;                                                                
 var $recorded.state260858: int;                                                                    
 var V._lock260934: [V]Tid;                                                                         
 var V._state260884: [V]State;                                                                      
 var AtomicMarkableReference.pair261346: [AtomicMarkableReference]Pair;                             
 var val$8261353: Pair;                                                                             
 var Pair.reference261304: [Pair]V;                                                                 
 var b261308: bool;                                                                                 
 var path261016: int;                                                                               
 var Main._state261022: [Main]State;                                                                
 var Main._lock260929: [Main]Tid;                                                                   
 var Pair._state260890: [Pair]State;                                                                
 var _currentValue$8261346: Pair;                                                                   
 var _C_t$5261066: Tid;                                                                             
 var tmp18$8261304: bool;                                                                           
 var Main._lock260878: [Main]Tid;                                                                   
 var Pair.reference260878: [Pair]V;                                                                 
 var Pair._lock261016: [Pair]Tid;                                                                   
 var result2261022: Pair;                                                                           
 var _casable$3260834: bool;                                                                        
 var x261061: AtomicMarkableReference;                                                              
 var Main._lock260790: [Main]Tid;                                                                   
 var $recorded.state260778: int;                                                                    
 var tid260967: Tid;                                                                                
 var b261353: bool;                                                                                 
 var expectedMark$5261301: bool;                                                                    
 var tmp19261346: V;                                                                                
 var _C_v$3260790: Pair;                                                                            
 var V._lock260929: [V]Tid;                                                                         
 var newMark$5261308: bool;                                                                         
 var _C_t$5261010: Tid;                                                                             
 var Pair._state261022: [Pair]State;                                                                
 var _currentValue$5261066: Pair;                                                                   
 var expectedMark$5261180: bool;                                                                    
 var result260958: Pair;                                                                            
 var Pair.reference261183: [Pair]V;                                                                 
 var tmp12$5261301: Pair;                                                                           
 var Main._lock261022: [Main]Tid;                                                                   
 var reference$7: V;                                                                                
 var tmp12$5261331: Pair;                                                                           
 var d261353: V;                                                                                    
 var current$5261353: Pair;                                                                         
 var $recorded.state261334: int;                                                                    
 var AtomicMarkableReference._state261346: [AtomicMarkableReference]State;                          
 var AtomicMarkableReference.pair261016: [AtomicMarkableReference]Pair;                             
 var AtomicMarkableReference.pair_nextValue261301: [AtomicMarkableReference]Pair;                   
 var AtomicMarkableReference._state261308: [AtomicMarkableReference]State;                          
 var Pair.mark260958_post: [Pair]bool;                                                              
 var Pair.reference260790: [Pair]V;                                                                 
 var $recorded.state260829: int;                                                                    
 var initialRef$6261183: V;                                                                         
 var expectedReference$5261183: V;                                                                  
 var expectedMark$5261331: bool;                                                                    
 var Pair.mark260934: [Pair]bool;                                                                   
 var tmp19261331: V;                                                                                
 var Pair.reference260934: [Pair]V;                                                                 
 var AtomicMarkableReference._state260790: [AtomicMarkableReference]State;                          
 var current$5261016: Pair;                                                                         
 var AtomicMarkableReference.pair_nextValue261304: [AtomicMarkableReference]Pair;                   
 var tid260890: Tid;                                                                                
 var this$6261183: AtomicMarkableReference;                                                         
 var Pair.reference260929: [Pair]V;                                                                 
 var tmpValue$8261308: Pair;                                                                        
 var Main._state261420: [Main]State;                                                                
 var Pair.reference261301: [Pair]V;                                                                 
 var AtomicMarkableReference.pair260784: [AtomicMarkableReference]Pair;                             
 var _R_t$4260929: Mover;                                                                           
 var tid261016: Tid;                                                                                
 var result261180: Pair;                                                                            
 var tmp19261066: V;                                                                                
 var Pair._state261180: [Pair]State;                                                                
 var Pair._state260929: [Pair]State;                                                                
 var path261334: int;                                                                               
 var result2261301: Pair;                                                                           
 var V._lock260784: [V]Tid;                                                                         
 var initialMark$6: bool;                                                                           
 var Pair.mark260778: [Pair]bool;                                                                   
 var tid261346: Tid;                                                                                
 var tmp8$5261346: bool;                                                                            
 var tmp9$5261180: bool;                                                                            
 var Pair.mark261308: [Pair]bool;                                                                   
 var expectedMark$5261016: bool;                                                                    
 var V._lock260890: [V]Tid;                                                                         
 var V._lock261301: [V]Tid;                                                                         
 var tmp6$3260778: Pair;                                                                            
 var Main._lock261016: [Main]Tid;                                                                   
 var AtomicMarkableReference.pair260958: [AtomicMarkableReference]Pair;                             
 var mover260890: Mover;                                                                            
 var AtomicMarkableReference.pair_nextValue261022: [AtomicMarkableReference]Pair;                   
 var ctmp237616$8261331: bool;                                                                      
 var Pair._state261066: [Pair]State;                                                                
 var AtomicMarkableReference.pair_nextThread260890: [AtomicMarkableReference]Tid;                   
 var AtomicMarkableReference.pair260884: [AtomicMarkableReference]Pair;                             
 var V._lock261022: [V]Tid;                                                                         
 var mover261180: Mover;                                                                            
 var tid260934: Tid;                                                                                
 var this$3260778: AtomicMarkableReference;                                                         
 var $recorded.state261301: int;                                                                    
 var $pc261061: Phase;                                                                              
 var mover261334: Mover;                                                                            
 var Pair._state260829: [Pair]State;                                                                
 var AtomicMarkableReference.pair_nextThread261334: [AtomicMarkableReference]Tid;                   
 var this261346: Main;                                                                              
 var newReference$5261016: V;                                                                       
 var result261334: Pair;                                                                            
 var tmp19261022: V;                                                                                
 var tmp9$5261304: bool;                                                                            
 var _C_t$3: Tid;                                                                                   
 var newReference$5261066: V;                                                                       
 var AtomicMarkableReference.pair260834: [AtomicMarkableReference]Pair;                             
 var $pc261010: Phase;                                                                              
 var expectedReference$5261066: V;                                                                  
 var tmp11$5261097: bool;                                                                           
 var tmp7$5261353: bool;                                                                            
 var tmp20261097: bool;                                                                             
 var Main._state261061: [Main]State;                                                                
 var cmp$8: Pair;                                                                                   
 var expectedReference$5261301: V;                                                                  
 var x261022: AtomicMarkableReference;                                                              
 var mover261010: Mover;                                                                            
 var Pair._lock261084: [Pair]Tid;                                                                   
 var AtomicMarkableReference._lock261331: [AtomicMarkableReference]Tid;                             
 var val$8: Pair;                                                                                   
 var newMark$5261304: bool;                                                                         
 var Pair.reference261097: [Pair]V;                                                                 
 var AtomicMarkableReference.pair260878: [AtomicMarkableReference]Pair;                             
 var $pc261346: Phase;                                                                              
 var ctmp237616$8261308: bool;                                                                      
 var $recorded.state260958_post: int;                                                               
 var AtomicMarkableReference.pair261022: [AtomicMarkableReference]Pair;                             
 var tid261334: Tid;                                                                                
 var $pc260778: Phase;                                                                              
 var AtomicMarkableReference._state261084: [AtomicMarkableReference]State;                          
 var tmp9$5261331: bool;                                                                            
 var Pair.reference261084: [Pair]V;                                                                 
 var path261066: int;                                                                               
 var V._lock260858_post: [V]Tid;                                                                    
 var tmp19261301: V;                                                                                
 var AtomicMarkableReference.pair_nextThread261420: [AtomicMarkableReference]Tid;                   
 var Pair.reference261010: [Pair]V;                                                                 
 var tmp20: bool;                                                                                   
 var V._state260858: [V]State;                                                                      
 var mover261301: Mover;                                                                            
 var this$6: AtomicMarkableReference;                                                               
 var moverPath261061: MoverPath;                                                                    
 var _C_v$4260929: Pair;                                                                            
 var result2260890: Pair;                                                                           
 var b261183: bool;                                                                                 
 var _C_v$5261061: Pair;                                                                            
 var AtomicMarkableReference.pair_nextThread261304: [AtomicMarkableReference]Tid;                   
 var $recorded.state261180: int;                                                                    
 var d260829: V;                                                                                    
 var AtomicMarkableReference._state261183: [AtomicMarkableReference]State;                          
 var b261301: bool;                                                                                 
 var result261331: Pair;                                                                            
 var d260884: V;                                                                                    
 var V._state260878: [V]State;                                                                      
 var Pair.reference261016: [Pair]V;                                                                 
 var moverPath260890: MoverPath;                                                                    
 var x261180: AtomicMarkableReference;                                                              
 var tmp7$5261084: bool;                                                                            
 var Pair.mark261061: [Pair]bool;                                                                   
 var _R_t$5: Mover;                                                                                 
 var AtomicMarkableReference.pair260858: [AtomicMarkableReference]Pair;                             
 var AtomicMarkableReference.pair_nextThread260790: [AtomicMarkableReference]Tid;                   
 var Pair.reference261022: [Pair]V;                                                                 
 var mover261304: Mover;                                                                            
 var Main._lock260934: [Main]Tid;                                                                   
 var _m$8261304: Mover;                                                                             
 var moverPath260967: MoverPath;                                                                    
 var tmp8$5261334: bool;                                                                            
 var moverPath261084: MoverPath;                                                                    
 var result260934: Pair;                                                                            
 var d: V;                                                                                          
 var d260834: V;                                                                                    
 var d261420: V;                                                                                    
 var Pair._state261084: [Pair]State;                                                                
 var tid260829: Tid;                                                                                
 var Main._lock261346: [Main]Tid;                                                                   
 var result260958_post: Pair;                                                                       
 var AtomicMarkableReference._lock260958: [AtomicMarkableReference]Tid;                             
 var Pair._state261334: [Pair]State;                                                                
 var Pair._state261331: [Pair]State;                                                                
 var AtomicMarkableReference._state261097: [AtomicMarkableReference]State;                          
 var V._lock261183: [V]Tid;                                                                         
 var AtomicMarkableReference.pair_nextThread261010: [AtomicMarkableReference]Tid;                   
 var $recorded.state261353: int;                                                                    
 var x261301: AtomicMarkableReference;                                                              
 var $pc261016: Phase;                                                                              
 var d260934: V;                                                                                    
 var newMark$5: bool;                                                                               
 var newReference$5: V;                                                                             
 var AtomicMarkableReference.pair260967: [AtomicMarkableReference]Pair;                             
 var Pair._lock261346: [Pair]Tid;                                                                   
 var Pair._lock261353: [Pair]Tid;                                                                   
 var this$5261010: AtomicMarkableReference;                                                         
 var result261183: Pair;                                                                            
 var result260829: Pair;                                                                            
 var result2260929: Pair;                                                                           
 var V._lock260778: [V]Tid;                                                                         
 var Pair.reference261334: [Pair]V;                                                                 
 var moverPath261346: MoverPath;                                                                    
 var cmp$8261308: Pair;                                                                             
 var result260929: Pair;                                                                            
 var Pair._lock261301: [Pair]Tid;                                                                   
 var current$5261308: Pair;                                                                         
 var Pair._lock261183: [Pair]Tid;                                                                   
 var tmp20261346: bool;                                                                             
 var b261180: bool;                                                                                 
 var result261016: Pair;                                                                            
 var _C_t$4260884: Tid;                                                                             
 var $pc260829: Phase;                                                                              
 var AtomicMarkableReference.pair261308: [AtomicMarkableReference]Pair;                             
 var path261097: int;                                                                               
 var this260878: Main;                                                                              
 var this261010: Main;                                                                              
 var AtomicMarkableReference._state260784: [AtomicMarkableReference]State;                          
 var tmp10$5261308: V;                                                                              
 var Pair._lock261334: [Pair]Tid;                                                                   
 var Pair._lock260790: [Pair]Tid;                                                                   
 var newMark$5261022: bool;                                                                         
 var this$7261183: Pair;                                                                            
 var AtomicMarkableReference.pair_nextThread261180: [AtomicMarkableReference]Tid;                   
 var AtomicMarkableReference._lock261084: [AtomicMarkableReference]Tid;                             
 var Main._state261097: [Main]State;                                                                
 var _R_t$4260934: Mover;                                                                           
 var this260829: Main;                                                                              
 var moverPath260834: MoverPath;                                                                    
 var V._state260890: [V]State;                                                                      
 var AtomicMarkableReference.pair_nextThread260884: [AtomicMarkableReference]Tid;                   
 var newReference$5261010: V;                                                                       
 var this$5261180: AtomicMarkableReference;                                                         
 var AtomicMarkableReference._lock260858_post: [AtomicMarkableReference]Tid;                        
 var this$5261331: AtomicMarkableReference;                                                         
 var AtomicMarkableReference._state260858: [AtomicMarkableReference]State;                          
 var tmp6$4260890: Pair;                                                                            
 var tmp20261334: bool;                                                                             
 var p$6261180: Pair;                                                                               
 var current$5261346: Pair;                                                                         
 var AtomicMarkableReference.pair_nextValue260973: [AtomicMarkableReference]Pair;                   
 var expectedMark$5261346: bool;                                                                    
 var AtomicMarkableReference._state260958_post: [AtomicMarkableReference]State;                     
 var _m$8261301: Mover;                                                                             
 var $recorded.state260967: int;                                                                    
 var AtomicMarkableReference.pair_nextValue261066: [AtomicMarkableReference]Pair;                   
 var ctmp237616$8261301: bool;                                                                      
 var _casable$4260929: bool;                                                                        
 var tmp10$5: V;                                                                                    
 var this$4260890: AtomicMarkableReference;                                                         
 var AtomicMarkableReference.pair261183: [AtomicMarkableReference]Pair;                             
 var p$6: Pair;                                                                                     
 var _R_t$3260829: Mover;                                                                           
 var $pc261301: Phase;                                                                              
 var Pair.reference261353: [Pair]V;                                                                 
 var Pair._state260967: [Pair]State;                                                                
 var newReference$5261334: V;                                                                       
 var tmp19261334: V;                                                                                
 var AtomicMarkableReference._lock260967: [AtomicMarkableReference]Tid;                             
 var Main._state261180: [Main]State;                                                                
 var _currentValue$8: Pair;                                                                         
 var tmpTid$8: Tid;                                                                                 
 var $pc261066: Phase;                                                                              
 var mover260834: Mover;                                                                            
 var result2261420: Pair;                                                                           
 var $pc260929: Phase;                                                                              
 var tmp19261308: V;                                                                                
 var tmp9$5261097: bool;                                                                            
 var AtomicMarkableReference.pair_nextValue260858_post: [AtomicMarkableReference]Pair;              
 var this260790: Main;                                                                              
 var _casable$5: bool;                                                                              
 var AtomicMarkableReference.pair_nextThread261331: [AtomicMarkableReference]Tid;                   
 var tid261097: Tid;                                                                                
 var V._state260790: [V]State;                                                                      
 var AtomicMarkableReference.pair_nextThread261308: [AtomicMarkableReference]Tid;                   
 var AtomicMarkableReference.pair_nextThread261061: [AtomicMarkableReference]Tid;                   
 var V._state260958_post: [V]State;                                                                 
 var tid260858_post: Tid;                                                                           
 var Pair._lock260778: [Pair]Tid;                                                                   
 var result2261066: Pair;                                                                           
 var Pair._state261061: [Pair]State;                                                                
 var path261010: int;                                                                               
 var result261346: Pair;                                                                            
 var $recorded.state261346: int;                                                                    
 var Pair._state260884: [Pair]State;                                                                
 var AtomicMarkableReference._state261066: [AtomicMarkableReference]State;                          
 var V._lock261308: [V]Tid;                                                                         
 var AtomicMarkableReference.pair_nextValue260890: [AtomicMarkableReference]Pair;                   
 var Pair.mark261420: [Pair]bool;                                                                   
 var AtomicMarkableReference._state261016: [AtomicMarkableReference]State;                          
 var AtomicMarkableReference._state261022: [AtomicMarkableReference]State;                          
 var $recorded.state261304: int;                                                                    
 var _C_v$3260784: Pair;                                                                            
 var tmpValue$8261301: Pair;                                                                        
 var Main._lock260829: [Main]Tid;                                                                   
 var _C_t$5261061: Tid;                                                                             
 var this$5261304: AtomicMarkableReference;                                                         
 var tmp10$5261183: V;                                                                              
 var tmp11$5: bool;                                                                                 
 var d260858_post: V;                                                                               
 var this260858_post: Main;                                                                         
 var b261084: bool;                                                                                 
 var Pair._lock261022: [Pair]Tid;                                                                   
 var $pc260890: Phase;                                                                              
 var initialMark$6261183: bool;                                                                     
 var Pair._state260958_post: [Pair]State;                                                           
 var tmp8$5261183: bool;                                                                            
 var ctmp237616$8: bool;                                                                            
 var moverPath260784: MoverPath;                                                                    
 var AtomicMarkableReference._lock261066: [AtomicMarkableReference]Tid;                             
 var _C_t$4260934: Tid;                                                                             
 var newReference$5261346: V;                                                                       
 var x261334: AtomicMarkableReference;                                                              
 var d261022: V;                                                                                    
 var tid261084: Tid;                                                                                
 var d260890: V;                                                                                    
 var Pair.reference260973: [Pair]V;                                                                 
 var result260858_post: Pair;                                                                       
 var tmp6$3: Pair;                                                                                  
 var Pair._lock261180: [Pair]Tid;                                                                   
 var x260890: AtomicMarkableReference;                                                              
 var val$8261334: Pair;                                                                             
 var AtomicMarkableReference.pair260934: [AtomicMarkableReference]Pair;                             
 var d261346: V;                                                                                    
 var this261066: Main;                                                                              
 var AtomicMarkableReference._lock261353: [AtomicMarkableReference]Tid;                             
 var _currentValue$5: Pair;                                                                         
 var x261010: AtomicMarkableReference;                                                              
 var this$5261022: AtomicMarkableReference;                                                         
 var AtomicMarkableReference._state260929: [AtomicMarkableReference]State;                          
 var $recorded.state261183: int;                                                                    
 var path260973: int;                                                                               
 var V._state260929: [V]State;                                                                      
 var tmp20261010: bool;                                                                             
 var AtomicMarkableReference._lock260884: [AtomicMarkableReference]Tid;                             
 var V._lock261180: [V]Tid;                                                                         
 var tmpTid$8261301: Tid;                                                                           
 var tmp10$5261304: V;                                                                              
 var tid260958_post: Tid;                                                                           
 var this$8261334: AtomicMarkableReference;                                                         
 var AtomicMarkableReference.pair_nextThread261016: [AtomicMarkableReference]Tid;                   
 var tmp18$8261346: bool;                                                                           
 var newMark$5261353: bool;                                                                         
 var expectedReference$5261304: V;                                                                  
 var cmp$8261301: Pair;                                                                             
 var Pair.reference260829: [Pair]V;                                                                 
 var result260973: Pair;                                                                            
 var _R_t$5261061: Mover;                                                                           
 var moverPath261022: MoverPath;                                                                    
 var Main._lock261061: [Main]Tid;                                                                   
 var V._state260858_post: [V]State;                                                                 
 var AtomicMarkableReference.pair_nextThread260958_post: [AtomicMarkableReference]Tid;              
 var _C_t$4260890: Tid;                                                                             
 var AtomicMarkableReference.pair_nextValue261084: [AtomicMarkableReference]Pair;                   
 var Pair._lock260958: [Pair]Tid;                                                                   
 var tmp19261016: V;                                                                                
 var d261308: V;                                                                                    
 var this$4260878: AtomicMarkableReference;                                                         
 var V._state261010: [V]State;                                                                      
 var this261097: Main;                                                                              
 var result261304: Pair;                                                                            
 var V._state261308: [V]State;                                                                      
 var AtomicMarkableReference._lock260878: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference.pair261097: [AtomicMarkableReference]Pair;                             
 var p$6261183: Pair;                                                                               
 var newReference$5261097: V;                                                                       
 var this261301: Main;                                                                              
 var val$8261346: Pair;                                                                             
 var tmp12$5261334: Pair;                                                                           
 var Pair._state261183: [Pair]State;                                                                
 var newReference$5261183: V;                                                                       
 var b261061: bool;                                                                                 
 var AtomicMarkableReference._state261420: [AtomicMarkableReference]State;                          
 var result261010: Pair;                                                                            
 var _C_v$3260834: Pair;                                                                            
 var x261084: AtomicMarkableReference;                                                              
 var AtomicMarkableReference._lock260778: [AtomicMarkableReference]Tid;                             
 var Main._state261016: [Main]State;                                                                
 var AtomicMarkableReference._lock260858: [AtomicMarkableReference]Tid;                             
 var V._lock261061: [V]Tid;                                                                         
 var this$8: AtomicMarkableReference;                                                               
 var $recorded.state260934: int;                                                                    
 var Pair._lock260973: [Pair]Tid;                                                                   
 var tid261301: Tid;                                                                                
 var AtomicMarkableReference.pair_nextThread260778: [AtomicMarkableReference]Tid;                   
 var newMark$5261180: bool;                                                                         
 var newMark$5261084: bool;                                                                         
 var this261353: Main;                                                                              
 var AtomicMarkableReference._lock261420: [AtomicMarkableReference]Tid;                             
 var newReference$5261061: V;                                                                       
 var _C_v$5261016: Pair;                                                                            
 var tmp12$5261353: Pair;                                                                           
 var _C_t$3260834: Tid;                                                                             
 var $recorded.state261066: int;                                                                    
 var this$7261180: Pair;                                                                            
 var Pair._lock261066: [Pair]Tid;                                                                   
 var AtomicMarkableReference._state261061: [AtomicMarkableReference]State;                          
 var current$5261061: Pair;                                                                         
 var tmp19261097: V;                                                                                
 var x260884: AtomicMarkableReference;                                                              
 var _currentValue$4260929: Pair;                                                                   
 var Main._state260884: [Main]State;                                                                
 var Pair._lock260858_post: [Pair]Tid;                                                              
 var tmp9$5261334: bool;                                                                            
 var Pair._state261097: [Pair]State;                                                                
 var tid260778: Tid;                                                                                
 var tmp19261084: V;                                                                                
 var AtomicMarkableReference.pair261304: [AtomicMarkableReference]Pair;                             
 var result260858: Pair;                                                                            
 var tmp7$5261180: bool;                                                                            
 var x260858_post: AtomicMarkableReference;                                                         
 var this$5261066: AtomicMarkableReference;                                                         
 var Pair.mark261301: [Pair]bool;                                                                   
 var result2261183: Pair;                                                                           
 var AtomicMarkableReference._lock260958_post: [AtomicMarkableReference]Tid;                        
 var _m$8261308: Mover;                                                                             
 var result261097: Pair;                                                                            
 var tmp19261420: V;                                                                                
 var Pair.reference261061: [Pair]V;                                                                 
 var AtomicMarkableReference.pair_nextThread260973: [AtomicMarkableReference]Tid;                   
 var mover261061: Mover;                                                                            
 var AtomicMarkableReference.pair_nextValue261016: [AtomicMarkableReference]Pair;                   
 var _currentValue$5261022: Pair;                                                                   
 var _currentValue$3260829: Pair;                                                                   
 var expectedMark$5261097: bool;                                                                    
 var mover260884: Mover;                                                                            
 var result2260934: Pair;                                                                           
 var AtomicMarkableReference._lock261022: [AtomicMarkableReference]Tid;                             
 var $pc260834: Phase;                                                                              
 var AtomicMarkableReference.pair_nextValue261183: [AtomicMarkableReference]Pair;                   
 var result261022: Pair;                                                                            
 var expectedReference$5261346: V;                                                                  
 var tmp9$5: bool;                                                                                  
 var AtomicMarkableReference._state260778: [AtomicMarkableReference]State;                          
 var this261016: Main;                                                                              
 var AtomicMarkableReference.pair260829: [AtomicMarkableReference]Pair;                             
 var V._state261097: [V]State;                                                                      
 var b261334: bool;                                                                                 
 var AtomicMarkableReference._state261301: [AtomicMarkableReference]State;                          
 var Pair.reference260958: [Pair]V;                                                                 
 var Pair._lock261097: [Pair]Tid;                                                                   
 var this260973: Main;                                                                              
 var tmp9$5261301: bool;                                                                            
 var newMark$5261346: bool;                                                                         
 var $recorded.state261420: int;                                                                    
 var result2260884: Pair;                                                                           
 var AtomicMarkableReference.pair_nextThread260858_post: [AtomicMarkableReference]Tid;              
 var d260967: V;                                                                                    
 var tmp12$5261180: Pair;                                                                           
 var tmp6$3260829: Pair;                                                                            
 var V._state261331: [V]State;                                                                      
 var AtomicMarkableReference._lock260890: [AtomicMarkableReference]Tid;                             
 var tid261353: Tid;                                                                                
 var Pair._state260790: [Pair]State;                                                                
 var tmp6$4260884: Pair;                                                                            
 var $pc261183: Phase;                                                                              
 var this$4: AtomicMarkableReference;                                                               
 var V._state261061: [V]State;                                                                      
 var $pc260958_post: Phase;                                                                         
 var Pair.mark261097: [Pair]bool;                                                                   
 var Pair._lock260958_post: [Pair]Tid;                                                              
 var tmp12$5261183: Pair;                                                                           
 var mover260929: Mover;                                                                            
 var result2261353: Pair;                                                                           
 var newMark$5261334: bool;                                                                         
 var Main._lock261183: [Main]Tid;                                                                   
 var AtomicMarkableReference._lock261304: [AtomicMarkableReference]Tid;                             
 var Pair.mark261353: [Pair]bool;                                                                   
 var result2260958_post: Pair;                                                                      
 var Main._lock261331: [Main]Tid;                                                                   
 var $pc261097: Phase;                                                                              
 var initialRef$6261180: V;                                                                         
 var AtomicMarkableReference._state261304: [AtomicMarkableReference]State;                          
 var Pair.mark261066: [Pair]bool;                                                                   
 var tmp20261061: bool;                                                                             
 var Pair.mark260973: [Pair]bool;                                                                   
 var result260778: Pair;                                                                            
 var _R_t$4: Mover;                                                                                 
 var tmp10$5261331: V;                                                                              
 var tid261420: Tid;                                                                                
 var AtomicMarkableReference.pair_nextThread260834: [AtomicMarkableReference]Tid;                   
 var Pair._lock261061: [Pair]Tid;                                                                   
 var tmp20261183: bool;                                                                             
 var Main._state261304: [Main]State;                                                                
 var result260784: Pair;                                                                            
 var b261010: bool;                                                                                 
 var d261334: V;                                                                                    
 var tmp19260973: V;                                                                                
 var tmp10$5261097: V;                                                                              
 var result260790: Pair;                                                                            
 var expectedReference$5261308: V;                                                                  
 var x261066: AtomicMarkableReference;                                                              
 var tid261180: Tid;                                                                                
 var b261097: bool;                                                                                 
 var tmp12$5261304: Pair;                                                                           
 var $recorded.state261331: int;                                                                    
 var tmp20261331: bool;                                                                             
 var newMark$5261010: bool;                                                                         
 var mover260973: Mover;                                                                            
 var result2261016: Pair;                                                                           
 var ctmp237616$8261304: bool;                                                                      
 var Pair.mark261180: [Pair]bool;                                                                   
 var tmp7$5261301: bool;                                                                            
 var moverPath260973: MoverPath;                                                                    
 var Pair.reference261066: [Pair]V;                                                                 
 var result2261097: Pair;                                                                           
 var tmp7$5261331: bool;                                                                            
 var AtomicMarkableReference.pair_nextValue261180: [AtomicMarkableReference]Pair;                   
 var tid261308: Tid;                                                                                
 var AtomicMarkableReference.pair_nextValue261331: [AtomicMarkableReference]Pair;                   
 var AtomicMarkableReference._lock260973: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference._lock260829: [AtomicMarkableReference]Tid;                             
 var Main._lock261066: [Main]Tid;                                                                   
 var this$5261346: AtomicMarkableReference;                                                         
 var AtomicMarkableReference.pair_nextThread260784: [AtomicMarkableReference]Tid;                   
 var $recorded.state260858_post: int;                                                               
 var path261304: int;                                                                               
 var $recorded.state261097: int;                                                                    
 var this$8261331: AtomicMarkableReference;                                                         
 var current$5261022: Pair;                                                                         
 var d261097: V;                                                                                    
 var Pair.reference260858: [Pair]V;                                                                 
 var $pc261308: Phase;                                                                              
 var b261066: bool;                                                                                 
 var result260884: Pair;                                                                            
 var tmp7$5261304: bool;                                                                            
 var ctmp237616$8261334: bool;                                                                      
 var cmp$8261304: Pair;                                                                             
 var _currentValue$4260890: Pair;                                                                   
 var AtomicMarkableReference.pair_nextThread260958: [AtomicMarkableReference]Tid;                   
 var V._state261334: [V]State;                                                                      
 var Pair.mark261331: [Pair]bool;                                                                   
 var AtomicMarkableReference._state260890: [AtomicMarkableReference]State;                          
 var mark$7261180: bool;                                                                            
 var tmpTid$8261304: Tid;                                                                           
 var mover261183: Mover;                                                                            
 var tmp7$5261183: bool;                                                                            
 var AtomicMarkableReference.pair_nextThread260858: [AtomicMarkableReference]Tid;                   
 var this$8261308: AtomicMarkableReference;                                                         
 var this261420: Main;                                                                              
 var tmp18$8261308: bool;                                                                           
 var $pc260858_post: Phase;                                                                         
 var mover260934: Mover;                                                                            
 var V._lock260958_post: [V]Tid;                                                                    
 var tmp19261180: V;                                                                                
 var result2261180: Pair;                                                                           
 var Main._lock260973: [Main]Tid;                                                                   
 var AtomicMarkableReference.pair_nextValue261061: [AtomicMarkableReference]Pair;                   
 var AtomicMarkableReference.pair261010: [AtomicMarkableReference]Pair;                             
 var _casable$5261061: bool;                                                                        
 var x260778: AtomicMarkableReference;                                                              
 var Pair._state260878: [Pair]State;                                                                
 var V._state261346: [V]State;                                                                      
 var AtomicMarkableReference._state261010: [AtomicMarkableReference]State;                          
 var path260784: int;                                                                               
 var this$3260834: AtomicMarkableReference;                                                         
 var _casable$3: bool;                                                                              
 var tmp9$5261308: bool;                                                                            
 var tmp20261353: bool;                                                                             
 var ctmp237616$8261346: bool;                                                                      
 var Pair.mark261304: [Pair]bool;                                                                   
 var AtomicMarkableReference.pair260973: [AtomicMarkableReference]Pair;                             
 var Main._lock260958: [Main]Tid;                                                                   
 var $recorded.state260784: int;                                                                    
 var path261084: int;                                                                               
 var V._lock260967: [V]Tid;                                                                         
 var $pc260958: Phase;                                                                              
 var d261304: V;                                                                                    
 var AtomicMarkableReference.pair_nextValue260829: [AtomicMarkableReference]Pair;                   
 var result2: Pair;                                                                                 
 var newMark$5261061: bool;                                                                         
 var Main._lock260967: [Main]Tid;                                                                   
 var AtomicMarkableReference.pair_nextValue260834: [AtomicMarkableReference]Pair;                   
 var d260784: V;                                                                                    
 var x261331: AtomicMarkableReference;                                                              
 var this$6261180: AtomicMarkableReference;                                                         
 var V._state261022: [V]State;                                                                      
 var tmp7$5261346: bool;                                                                            
 var b261346: bool;                                                                                 
 var AtomicMarkableReference.pair_nextValue260884: [AtomicMarkableReference]Pair;                   
 var tmp8$5261097: bool;                                                                            
 var V._state260934: [V]State;                                                                      
 var _currentValue$8261334: Pair;                                                                   
 var V._lock260834: [V]Tid;                                                                         
 var Main._lock260778: [Main]Tid;                                                                   
 var current$5261010: Pair;                                                                         
 var mark$7: bool;                                                                                  
 var Main._lock260890: [Main]Tid;                                                                   
 var result261308: Pair;                                                                            
 var this$8261301: AtomicMarkableReference;                                                         
 var d261084: V;                                                                                    
 var x260967: AtomicMarkableReference;                                                              
 var AtomicMarkableReference.pair_nextValue260778: [AtomicMarkableReference]Pair;                   
 var d261016: V;                                                                                    
 var Main._state260778: [Main]State;                                                                
 var V._lock261084: [V]Tid;                                                                         
 var newMark$5261097: bool;                                                                         
 var this261061: Main;                                                                              
 var _C_v$5: Pair;                                                                                  
 var AtomicMarkableReference.pair260890: [AtomicMarkableReference]Pair;                             
 var Pair._lock260890: [Pair]Tid;                                                                   
 var _C_v$5261022: Pair;                                                                            
 var tmp12$5: Pair;                                                                                 
 var AtomicMarkableReference.pair_nextThread261066: [AtomicMarkableReference]Tid;                   
 var cmp$8261353: Pair;                                                                             
 var Pair.mark261346: [Pair]bool;                                                                   
 var expectedReference$5261061: V;                                                                  
 var x260784: AtomicMarkableReference;                                                              
 var AtomicMarkableReference._lock261010: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference.pair261084: [AtomicMarkableReference]Pair;                             
 var Pair._state260778: [Pair]State;                                                                
 var Main._lock260858: [Main]Tid;                                                                   
 var path260834: int;                                                                               
 var tmp6$4260878: Pair;                                                                            
 var expectedMark$5261353: bool;                                                                    
 var tmp6$3260784: Pair;                                                                            
 var Pair.mark261022: [Pair]bool;                                                                   
 var AtomicMarkableReference.pair_nextThread261022: [AtomicMarkableReference]Tid;                   
 var newMark$5261301: bool;                                                                         
 var result: Pair;                                                                                  
 var Main._lock261334: [Main]Tid;                                                                   
 var _C_t$3260790: Tid;                                                                             
 var AtomicMarkableReference._lock260934: [AtomicMarkableReference]Tid;                             
 var this$5: AtomicMarkableReference;                                                               
 var tmp10$5261346: V;                                                                              
 var b261022: bool;                                                                                 
 var Pair.mark260858_post: [Pair]bool;                                                              
 var AtomicMarkableReference.pair_nextValue260790: [AtomicMarkableReference]Pair;                   
 var AtomicMarkableReference.pair_nextValue260958_post: [AtomicMarkableReference]Pair;              
 var AtomicMarkableReference.pair260958_post: [AtomicMarkableReference]Pair;                        
 var tid260834: Tid;                                                                                
 var tid261066: Tid;                                                                                
 var AtomicMarkableReference.pair260778: [AtomicMarkableReference]Pair;                             
 var _currentValue$5261061: Pair;                                                                   
 var AtomicMarkableReference._lock260834: [AtomicMarkableReference]Tid;                             
 var Pair._state260973: [Pair]State;                                                                
 var Main._state261066: [Main]State;                                                                
 var AtomicMarkableReference.pair_nextValue260967: [AtomicMarkableReference]Pair;                   
 var newMark$5261331: bool;                                                                         
 var tmp9$5261353: bool;                                                                            
 var b261331: bool;                                                                                 
 var AtomicMarkableReference._state260858_post: [AtomicMarkableReference]State;                     
 var AtomicMarkableReference.pair260790: [AtomicMarkableReference]Pair;                             
 var $pc260878: Phase;                                                                              
 var tid260790: Tid;                                                                                
 var Pair._lock260834: [Pair]Tid;                                                                   
 var d261331: V;                                                                                    
 var mover260778: Mover;                                                                            
 var V._state260967: [V]State;                                                                      
 var cmp$8261346: Pair;                                                                             
 var d261183: V;                                                                                    
 var AtomicMarkableReference._lock261180: [AtomicMarkableReference]Tid;                             
 var $pc261334: Phase;                                                                              
 var Pair._state260958: [Pair]State;                                                                
 var AtomicMarkableReference.pair_nextThread261097: [AtomicMarkableReference]Tid;                   
 var this$5261097: AtomicMarkableReference;                                                         
 var AtomicMarkableReference._lock261301: [AtomicMarkableReference]Tid;                             
 var V._lock260829: [V]Tid;                                                                         
 var Pair.mark261084: [Pair]bool;                                                                   
 var Main._state260958_post: [Main]State;                                                           
 var mover261097: Mover;                                                                            
 var AtomicMarkableReference._state260967: [AtomicMarkableReference]State;                          
 var AtomicMarkableReference.pair261066: [AtomicMarkableReference]Pair;                             
 var AtomicMarkableReference.pair261334: [AtomicMarkableReference]Pair;                             
 var Pair.mark260884: [Pair]bool;                                                                   
 var Pair.mark260790: [Pair]bool;                                                                   
 var newReference$5261301: V;                                                                       
 var Pair._lock260829: [Pair]Tid;                                                                   
 var expectedMark$5261022: bool;                                                                    
 var AtomicMarkableReference.pair261301: [AtomicMarkableReference]Pair;                             
 var this$3260790: AtomicMarkableReference;                                                         
 var tmp18$8261353: bool;                                                                           
 var this$5261061: AtomicMarkableReference;                                                         
 var b261420: bool;                                                                                 
 var _casable$4260934: bool;                                                                        
 var Main._lock260858_post: [Main]Tid;                                                              
 var Pair._lock260934: [Pair]Tid;                                                                   
 var this260967: Main;                                                                              
 var Main._state260967: [Main]State;                                                                
 var d260929: V;                                                                                    
 var this260934: Main;                                                                              
 var Main._lock260884: [Main]Tid;                                                                   
 var AtomicMarkableReference.pair_nextThread261183: [AtomicMarkableReference]Tid;                   
 var V._state261084: [V]State;                                                                      
 var _casable$5261066: bool;                                                                        
 var moverPath260829: MoverPath;                                                                    
 var AtomicMarkableReference._lock261346: [AtomicMarkableReference]Tid;                             
 var Pair._state261301: [Pair]State;                                                                
 var newReference$5261331: V;                                                                       
 var AtomicMarkableReference._state261331: [AtomicMarkableReference]State;                          
 var result261301: Pair;                                                                            
 var $pc260858: Phase;                                                                              
 var AtomicMarkableReference._state260884: [AtomicMarkableReference]State;                          
 var tmp19261010: V;                                                                                
 var tmp10$5261301: V;                                                                              
 var $recorded.state261308: int;                                                                    
 var tmp6$4260929: Pair;                                                                            
 var Pair._state261308: [Pair]State;                                                                
 var current$5261180: Pair;                                                                         
 var $pc261420: Phase;                                                                              
 var result260967: Pair;                                                                            
 var tmp6$4: Pair;                                                                                  
 var Main._lock261301: [Main]Tid;                                                                   
 var moverPath261183: MoverPath;                                                                    
 var newMark$5261066: bool;                                                                         
 var this260784: Main;                                                                              
 var AtomicMarkableReference._state260834: [AtomicMarkableReference]State;                          
 var Pair._state260858_post: [Pair]State;                                                           
 var x261097: AtomicMarkableReference;                                                              
 var AtomicMarkableReference._lock261061: [AtomicMarkableReference]Tid;                             
 var Pair.mark260834: [Pair]bool;                                                                   
 var Pair.reference261308: [Pair]V;                                                                 
 var d261066: V;                                                                                    
 var this$3: AtomicMarkableReference;                                                               
 var AtomicMarkableReference._lock261183: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference._state260829: [AtomicMarkableReference]State;                          
 var Main._lock261353: [Main]Tid;                                                                   
 var Main._state260784: [Main]State;                                                                
 var tmp8$5261084: bool;                                                                            
 var Main._state261334: [Main]State;                                                                
 var Pair.reference260834: [Pair]V;                                                                 
 var $pc260784: Phase;                                                                              
 var AtomicMarkableReference.pair_nextThread260829: [AtomicMarkableReference]Tid;                   
 var this$5261334: AtomicMarkableReference;                                                         
 var this$2: V;                                                                                     
 var AtomicMarkableReference.pair_nextThread260934: [AtomicMarkableReference]Tid;                   
 var result261084: Pair;                                                                            
 var V._lock261331: [V]Tid;                                                                         
 var this260834: Main;                                                                              
 var moverPath261301: MoverPath;                                                                    
 var V._state261066: [V]State;                                                                      
 var result261061: Pair;                                                                            
 var x260973: AtomicMarkableReference;                                                              
 var AtomicMarkableReference.pair261331: [AtomicMarkableReference]Pair;                             
 var V._lock260958: [V]Tid;                                                                         
 var initialRef$6: V;                                                                               
 var tid260858: Tid;                                                                                
 var tmp6$3260790: Pair;                                                                            
 var AtomicMarkableReference.pair_nextThread260929: [AtomicMarkableReference]Tid;                   
 var current$5: Pair;                                                                               
 var V._state261016: [V]State;                                                                      
 var current$5261066: Pair;                                                                         
 var tmp20261308: bool;                                                                             
 var tmp20260973: bool;                                                                             
 var result261420: Pair;                                                                            
 var tmp6$3260834: Pair;                                                                            
 var current$5261331: Pair;                                                                         
 var tmp8$5261353: bool;                                                                            
 var result2261331: Pair;                                                                           
 var x261183: AtomicMarkableReference;                                                              
 var expectedMark$5261066: bool;                                                                    
 var Pair._state261304: [Pair]State;                                                                
 var this$3260784: AtomicMarkableReference;                                                         
 var path261331: int;                                                                               
 var mover260784: Mover;                                                                            
 var mover260829: Mover;                                                                            
 var tmp12$5261346: Pair;                                                                           
 var current$5261304: Pair;                                                                         
 var moverPath261353: MoverPath;                                                                    
 var x260958_post: AtomicMarkableReference;                                                         
 var path261180: int;                                                                               
 var b: bool;                                                                                       
 var this$4260934: AtomicMarkableReference;                                                         
 var tmp7$5261334: bool;                                                                            
 var AtomicMarkableReference.pair_nextValue260929: [AtomicMarkableReference]Pair;                   
 var AtomicMarkableReference._state260973: [AtomicMarkableReference]State;                          
 var AtomicMarkableReference._state260934: [AtomicMarkableReference]State;                          
 var d260778: V;                                                                                    
 var V._state261183: [V]State;                                                                      
 var moverPath260878: MoverPath;                                                                    
 var expectedMark$5261061: bool;                                                                    
 var this$5261084: AtomicMarkableReference;                                                         
 var Main._state261346: [Main]State;                                                                
 var tmp19261183: V;                                                                                
 var V._state261301: [V]State;                                                                      
 var moverPath261334: MoverPath;                                                                    
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true;                                                                                              // (72.16): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 74.7: V d;                                                                                      
                                                                                                    
                                                                                                    
 // 74.7: d = new V();                                                                              
                                                                                                    
 havoc d;                                                                                           
 assume d != V.null && isFresh(V._state[d]);                                                        
 V._state[d] := LOCAL(tid);                                                                         
 assume V._lock[d]  == Tid.null;                                                                    
 // inlined: d.init()}                                                                              
 exit$2_top:                                                                                        
                                                                                                    
 // 74.7: V this$2;                                                                                 
                                                                                                    
                                                                                                    
 // 74.7: this$2 = d;                                                                               
                                                                                                    
 this$2 := d;                                                                                       
                                                                                                    
 // 2.11: break exit$2;                                                                             
                                                                                                    
 goto exit$2_bottom;                                                                                
 exit$2_bottom:                                                                                     
                                                                                                    
 // 75.7: Pair result;                                                                              
                                                                                                    
 // inlined: x.get()}                                                                               
 exit$3_top:                                                                                        
                                                                                                    
 // 75.7: AtomicMarkableReference this$3;                                                           
                                                                                                    
                                                                                                    
 // 75.7: this$3 = x;                                                                               
                                                                                                    
 this$3 := x;                                                                                       
                                                                                                    
 // 40.9: Pair tmp6$3;                                                                              
                                                                                                    
 // NoOp: 'TraceOff'                                                                                
                                                                                                    
 // 40.9: Tid _C_t$3;                                                                               
                                                                                                    
                                                                                                    
 // 40.9: _C_t$3 := this$3.pair_nextThread  as B;                                                   
                                                                                                    
                                                                                                    
 moverPath260778 := ReadEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this$3: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 mover260778 := m#moverPath(moverPath260778);                                                       
 path260778 := p#moverPath(moverPath260778);                                                        
 assume V._state260778 == V._state && V._lock260778 == V._lock && Pair._state260778 == Pair._state && Pair.reference260778 == Pair.reference && Pair.mark260778 == Pair.mark && Pair._lock260778 == Pair._lock && AtomicMarkableReference._state260778 == AtomicMarkableReference._state && AtomicMarkableReference.pair260778 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260778 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260778 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260778 == AtomicMarkableReference.pair_nextValue && Main._state260778 == Main._state && Main._lock260778 == Main._lock && _C_t$3260778 == _C_t$3 && tmp6$3260778 == tmp6$3 && this$3260778 == this$3 && result260778 == result && d260778 == d && x260778 == x && this260778 == this && tid260778 == tid && $pc260778 == $pc;
 assume $recorded.state260778 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this$3 != AtomicMarkableReference.null;                                                    
 } else {                                                                                           
  assert this$3 != AtomicMarkableReference.null;                                                           // (40.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (40.9): Reduction failure
 _C_t$3 := AtomicMarkableReference.pair_nextThread[this$3];                                         
                                                                                                    
 // 40.9: Pair _C_v$3;                                                                              
                                                                                                    
                                                                                                    
 // 40.9: _C_v$3 := this$3.pair_nextValue  as B;                                                    
                                                                                                    
                                                                                                    
 moverPath260784 := ReadEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this$3: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 mover260784 := m#moverPath(moverPath260784);                                                       
 path260784 := p#moverPath(moverPath260784);                                                        
 assume V._state260784 == V._state && V._lock260784 == V._lock && Pair._state260784 == Pair._state && Pair.reference260784 == Pair.reference && Pair.mark260784 == Pair.mark && Pair._lock260784 == Pair._lock && AtomicMarkableReference._state260784 == AtomicMarkableReference._state && AtomicMarkableReference.pair260784 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260784 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260784 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260784 == AtomicMarkableReference.pair_nextValue && Main._state260784 == Main._state && Main._lock260784 == Main._lock && _C_v$3260784 == _C_v$3 && _C_t$3260784 == _C_t$3 && tmp6$3260784 == tmp6$3 && this$3260784 == this$3 && result260784 == result && d260784 == d && x260784 == x && this260784 == this && tid260784 == tid && $pc260784 == $pc;
 assume $recorded.state260784 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this$3 != AtomicMarkableReference.null;                                                    
 } else {                                                                                           
  assert this$3 != AtomicMarkableReference.null;                                                           // (40.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (40.9): Reduction failure
 _C_v$3 := AtomicMarkableReference.pair_nextValue[this$3];                                          
                                                                                                    
 // 40.9: Pair _currentValue$3;                                                                     
                                                                                                    
                                                                                                    
 // 40.9: _currentValue$3 := this$3.pair  as B;                                                     
                                                                                                    
                                                                                                    
 moverPath260790 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this$3: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 mover260790 := m#moverPath(moverPath260790);                                                       
 path260790 := p#moverPath(moverPath260790);                                                        
 assume V._state260790 == V._state && V._lock260790 == V._lock && Pair._state260790 == Pair._state && Pair.reference260790 == Pair.reference && Pair.mark260790 == Pair.mark && Pair._lock260790 == Pair._lock && AtomicMarkableReference._state260790 == AtomicMarkableReference._state && AtomicMarkableReference.pair260790 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260790 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260790 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260790 == AtomicMarkableReference.pair_nextValue && Main._state260790 == Main._state && Main._lock260790 == Main._lock && _currentValue$3260790 == _currentValue$3 && _C_v$3260790 == _C_v$3 && _C_t$3260790 == _C_t$3 && tmp6$3260790 == tmp6$3 && this$3260790 == this$3 && result260790 == result && d260790 == d && x260790 == x && this260790 == this && tid260790 == tid && $pc260790 == $pc;
 assume $recorded.state260790 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this$3 != AtomicMarkableReference.null;                                                    
 } else {                                                                                           
  assert this$3 != AtomicMarkableReference.null;                                                           // (40.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (40.9): Reduction failure
 _currentValue$3 := AtomicMarkableReference.pair[this$3];                                           
                                                                                                    
 // 40.9: Mover _R_t$3;                                                                             
                                                                                                    
                                                                                                    
 // 40.9: _R_t$3 = readPermission(this$3.pair);                                                     
                                                                                                    
 _R_t$3 := m#moverPath(ReadEval.AtomicMarkableReference.pair(tid: Tid,this$3: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));
                                                                                                    
 // 40.9: boolean _casable$3;                                                                       
                                                                                                    
                                                                                                    
 // 40.9: _casable$3 = _R_t$3 != E && true && _C_t$3 == tid && _C_v$3 == _currentValue$3;           
                                                                                                    
 _casable$3 := ((((_R_t$3!=_E)&&true)&&(_C_t$3==tid))&&(_C_v$3==_currentValue$3));                  
 if (_casable$3) {                                                                                  
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 40.9: tmp6$3 := this$3.pair  as R;                                                             
                                                                                                    
                                                                                                    
  moverPath260829 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this$3: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
  mover260829 := m#moverPath(moverPath260829);                                                      
  path260829 := p#moverPath(moverPath260829);                                                       
  assume V._state260829 == V._state && V._lock260829 == V._lock && Pair._state260829 == Pair._state && Pair.reference260829 == Pair.reference && Pair.mark260829 == Pair.mark && Pair._lock260829 == Pair._lock && AtomicMarkableReference._state260829 == AtomicMarkableReference._state && AtomicMarkableReference.pair260829 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260829 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260829 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260829 == AtomicMarkableReference.pair_nextValue && Main._state260829 == Main._state && Main._lock260829 == Main._lock && _casable$3260829 == _casable$3 && _R_t$3260829 == _R_t$3 && _currentValue$3260829 == _currentValue$3 && _C_v$3260829 == _C_v$3 && _C_t$3260829 == _C_t$3 && tmp6$3260829 == tmp6$3 && this$3260829 == this$3 && result260829 == result && d260829 == d && x260829 == x && this260829 == this && tid260829 == tid && $pc260829 == $pc;
  assume $recorded.state260829 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this$3 != AtomicMarkableReference.null;                                                   
  } else {                                                                                          
   assert this$3 != AtomicMarkableReference.null;                                                          // (40.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _R);                                                                       
  assert $pc != PhaseError;                                                                                // (40.9): Reduction failure
  tmp6$3 := AtomicMarkableReference.pair[this$3];                                                   
 } else {                                                                                           
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 40.9: tmp6$3 := this$3.pair;                                                                   
                                                                                                    
                                                                                                    
  moverPath260834 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this$3: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
  mover260834 := m#moverPath(moverPath260834);                                                      
  path260834 := p#moverPath(moverPath260834);                                                       
  assume V._state260834 == V._state && V._lock260834 == V._lock && Pair._state260834 == Pair._state && Pair.reference260834 == Pair.reference && Pair.mark260834 == Pair.mark && Pair._lock260834 == Pair._lock && AtomicMarkableReference._state260834 == AtomicMarkableReference._state && AtomicMarkableReference.pair260834 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260834 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260834 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260834 == AtomicMarkableReference.pair_nextValue && Main._state260834 == Main._state && Main._lock260834 == Main._lock && _casable$3260834 == _casable$3 && _R_t$3260834 == _R_t$3 && _currentValue$3260834 == _currentValue$3 && _C_v$3260834 == _C_v$3 && _C_t$3260834 == _C_t$3 && tmp6$3260834 == tmp6$3 && this$3260834 == this$3 && result260834 == result && d260834 == d && x260834 == x && this260834 == this && tid260834 == tid && $pc260834 == $pc;
  assume $recorded.state260834 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this$3 != AtomicMarkableReference.null;                                                   
  } else {                                                                                          
   assert this$3 != AtomicMarkableReference.null;                                                          // (40.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover260834);                                                              
  assert $pc != PhaseError;                                                                                // (40.9): Reduction failure
  tmp6$3 := AtomicMarkableReference.pair[this$3];                                                   
 }                                                                                                  
                                                                                                    
 // 40.9: result = tmp6$3;                                                                          
                                                                                                    
 result := tmp6$3;                                                                                  
                                                                                                    
 // 40.9: break exit$3;                                                                             
                                                                                                    
 goto exit$3_bottom;                                                                                
                                                                                                    
 // 39.16: result = Pair.null;                                                                      
                                                                                                    
 result := Pair.null;                                                                               
                                                                                                    
 // 39.16: break exit$3;                                                                            
                                                                                                    
 goto exit$3_bottom;                                                                                
 exit$3_bottom:                                                                                     
                                                                                                    
 // 76.7: yield;                                                                                    
                                                                                                    
 assume V._state260858 == V._state && V._lock260858 == V._lock && Pair._state260858 == Pair._state && Pair.reference260858 == Pair.reference && Pair.mark260858 == Pair.mark && Pair._lock260858 == Pair._lock && AtomicMarkableReference._state260858 == AtomicMarkableReference._state && AtomicMarkableReference.pair260858 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260858 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260858 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260858 == AtomicMarkableReference.pair_nextValue && Main._state260858 == Main._state && Main._lock260858 == Main._lock && result260858 == result && d260858 == d && x260858 == x && this260858 == this && tid260858 == tid;
 assume $recorded.state260858 == 1;                                                                 
 assert  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (76.7): Object invariant may not hold.
 call Yield(tid);                                                                                   
 assume  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (76.7): Object invariant may not hold.
 $pc := PreCommit;                                                                                  
 assume V._state260858_post == V._state && V._lock260858_post == V._lock && Pair._state260858_post == Pair._state && Pair.reference260858_post == Pair.reference && Pair.mark260858_post == Pair.mark && Pair._lock260858_post == Pair._lock && AtomicMarkableReference._state260858_post == AtomicMarkableReference._state && AtomicMarkableReference.pair260858_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock260858_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260858_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260858_post == AtomicMarkableReference.pair_nextValue && Main._state260858_post == Main._state && Main._lock260858_post == Main._lock && result260858_post == result && d260858_post == d && x260858_post == x && this260858_post == this && tid260858_post == tid;
 assume $recorded.state260858_post == 1;                                                            
                                                                                                    
 // 77.7: Pair result2;                                                                             
                                                                                                    
 // inlined: x.get()}                                                                               
 exit$4_top:                                                                                        
                                                                                                    
 // 77.7: AtomicMarkableReference this$4;                                                           
                                                                                                    
                                                                                                    
 // 77.7: this$4 = x;                                                                               
                                                                                                    
 this$4 := x;                                                                                       
                                                                                                    
 // 40.9: Pair tmp6$4;                                                                              
                                                                                                    
 // NoOp: 'TraceOff'                                                                                
                                                                                                    
 // 40.9: Tid _C_t$4;                                                                               
                                                                                                    
                                                                                                    
 // 40.9: _C_t$4 := this$4.pair_nextThread  as B;                                                   
                                                                                                    
                                                                                                    
 moverPath260878 := ReadEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this$4: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 mover260878 := m#moverPath(moverPath260878);                                                       
 path260878 := p#moverPath(moverPath260878);                                                        
 assume V._state260878 == V._state && V._lock260878 == V._lock && Pair._state260878 == Pair._state && Pair.reference260878 == Pair.reference && Pair.mark260878 == Pair.mark && Pair._lock260878 == Pair._lock && AtomicMarkableReference._state260878 == AtomicMarkableReference._state && AtomicMarkableReference.pair260878 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260878 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260878 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260878 == AtomicMarkableReference.pair_nextValue && Main._state260878 == Main._state && Main._lock260878 == Main._lock && _C_t$4260878 == _C_t$4 && tmp6$4260878 == tmp6$4 && this$4260878 == this$4 && result2260878 == result2 && result260878 == result && d260878 == d && x260878 == x && this260878 == this && tid260878 == tid && $pc260878 == $pc;
 assume $recorded.state260878 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this$4 != AtomicMarkableReference.null;                                                    
 } else {                                                                                           
  assert this$4 != AtomicMarkableReference.null;                                                           // (40.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (40.9): Reduction failure
 _C_t$4 := AtomicMarkableReference.pair_nextThread[this$4];                                         
                                                                                                    
 // 40.9: Pair _C_v$4;                                                                              
                                                                                                    
                                                                                                    
 // 40.9: _C_v$4 := this$4.pair_nextValue  as B;                                                    
                                                                                                    
                                                                                                    
 moverPath260884 := ReadEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this$4: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 mover260884 := m#moverPath(moverPath260884);                                                       
 path260884 := p#moverPath(moverPath260884);                                                        
 assume V._state260884 == V._state && V._lock260884 == V._lock && Pair._state260884 == Pair._state && Pair.reference260884 == Pair.reference && Pair.mark260884 == Pair.mark && Pair._lock260884 == Pair._lock && AtomicMarkableReference._state260884 == AtomicMarkableReference._state && AtomicMarkableReference.pair260884 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260884 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260884 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260884 == AtomicMarkableReference.pair_nextValue && Main._state260884 == Main._state && Main._lock260884 == Main._lock && _C_v$4260884 == _C_v$4 && _C_t$4260884 == _C_t$4 && tmp6$4260884 == tmp6$4 && this$4260884 == this$4 && result2260884 == result2 && result260884 == result && d260884 == d && x260884 == x && this260884 == this && tid260884 == tid && $pc260884 == $pc;
 assume $recorded.state260884 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this$4 != AtomicMarkableReference.null;                                                    
 } else {                                                                                           
  assert this$4 != AtomicMarkableReference.null;                                                           // (40.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (40.9): Reduction failure
 _C_v$4 := AtomicMarkableReference.pair_nextValue[this$4];                                          
                                                                                                    
 // 40.9: Pair _currentValue$4;                                                                     
                                                                                                    
                                                                                                    
 // 40.9: _currentValue$4 := this$4.pair  as B;                                                     
                                                                                                    
                                                                                                    
 moverPath260890 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this$4: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 mover260890 := m#moverPath(moverPath260890);                                                       
 path260890 := p#moverPath(moverPath260890);                                                        
 assume V._state260890 == V._state && V._lock260890 == V._lock && Pair._state260890 == Pair._state && Pair.reference260890 == Pair.reference && Pair.mark260890 == Pair.mark && Pair._lock260890 == Pair._lock && AtomicMarkableReference._state260890 == AtomicMarkableReference._state && AtomicMarkableReference.pair260890 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260890 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260890 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260890 == AtomicMarkableReference.pair_nextValue && Main._state260890 == Main._state && Main._lock260890 == Main._lock && _currentValue$4260890 == _currentValue$4 && _C_v$4260890 == _C_v$4 && _C_t$4260890 == _C_t$4 && tmp6$4260890 == tmp6$4 && this$4260890 == this$4 && result2260890 == result2 && result260890 == result && d260890 == d && x260890 == x && this260890 == this && tid260890 == tid && $pc260890 == $pc;
 assume $recorded.state260890 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this$4 != AtomicMarkableReference.null;                                                    
 } else {                                                                                           
  assert this$4 != AtomicMarkableReference.null;                                                           // (40.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (40.9): Reduction failure
 _currentValue$4 := AtomicMarkableReference.pair[this$4];                                           
                                                                                                    
 // 40.9: Mover _R_t$4;                                                                             
                                                                                                    
                                                                                                    
 // 40.9: _R_t$4 = readPermission(this$4.pair);                                                     
                                                                                                    
 _R_t$4 := m#moverPath(ReadEval.AtomicMarkableReference.pair(tid: Tid,this$4: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));
                                                                                                    
 // 40.9: boolean _casable$4;                                                                       
                                                                                                    
                                                                                                    
 // 40.9: _casable$4 = _R_t$4 != E && true && _C_t$4 == tid && _C_v$4 == _currentValue$4;           
                                                                                                    
 _casable$4 := ((((_R_t$4!=_E)&&true)&&(_C_t$4==tid))&&(_C_v$4==_currentValue$4));                  
 if (_casable$4) {                                                                                  
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 40.9: tmp6$4 := this$4.pair  as R;                                                             
                                                                                                    
                                                                                                    
  moverPath260929 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this$4: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
  mover260929 := m#moverPath(moverPath260929);                                                      
  path260929 := p#moverPath(moverPath260929);                                                       
  assume V._state260929 == V._state && V._lock260929 == V._lock && Pair._state260929 == Pair._state && Pair.reference260929 == Pair.reference && Pair.mark260929 == Pair.mark && Pair._lock260929 == Pair._lock && AtomicMarkableReference._state260929 == AtomicMarkableReference._state && AtomicMarkableReference.pair260929 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260929 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260929 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260929 == AtomicMarkableReference.pair_nextValue && Main._state260929 == Main._state && Main._lock260929 == Main._lock && _casable$4260929 == _casable$4 && _R_t$4260929 == _R_t$4 && _currentValue$4260929 == _currentValue$4 && _C_v$4260929 == _C_v$4 && _C_t$4260929 == _C_t$4 && tmp6$4260929 == tmp6$4 && this$4260929 == this$4 && result2260929 == result2 && result260929 == result && d260929 == d && x260929 == x && this260929 == this && tid260929 == tid && $pc260929 == $pc;
  assume $recorded.state260929 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this$4 != AtomicMarkableReference.null;                                                   
  } else {                                                                                          
   assert this$4 != AtomicMarkableReference.null;                                                          // (40.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _R);                                                                       
  assert $pc != PhaseError;                                                                                // (40.9): Reduction failure
  tmp6$4 := AtomicMarkableReference.pair[this$4];                                                   
 } else {                                                                                           
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 40.9: tmp6$4 := this$4.pair;                                                                   
                                                                                                    
                                                                                                    
  moverPath260934 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this$4: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
  mover260934 := m#moverPath(moverPath260934);                                                      
  path260934 := p#moverPath(moverPath260934);                                                       
  assume V._state260934 == V._state && V._lock260934 == V._lock && Pair._state260934 == Pair._state && Pair.reference260934 == Pair.reference && Pair.mark260934 == Pair.mark && Pair._lock260934 == Pair._lock && AtomicMarkableReference._state260934 == AtomicMarkableReference._state && AtomicMarkableReference.pair260934 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260934 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260934 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260934 == AtomicMarkableReference.pair_nextValue && Main._state260934 == Main._state && Main._lock260934 == Main._lock && _casable$4260934 == _casable$4 && _R_t$4260934 == _R_t$4 && _currentValue$4260934 == _currentValue$4 && _C_v$4260934 == _C_v$4 && _C_t$4260934 == _C_t$4 && tmp6$4260934 == tmp6$4 && this$4260934 == this$4 && result2260934 == result2 && result260934 == result && d260934 == d && x260934 == x && this260934 == this && tid260934 == tid && $pc260934 == $pc;
  assume $recorded.state260934 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this$4 != AtomicMarkableReference.null;                                                   
  } else {                                                                                          
   assert this$4 != AtomicMarkableReference.null;                                                          // (40.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover260934);                                                              
  assert $pc != PhaseError;                                                                                // (40.9): Reduction failure
  tmp6$4 := AtomicMarkableReference.pair[this$4];                                                   
 }                                                                                                  
                                                                                                    
 // 40.9: result2 = tmp6$4;                                                                         
                                                                                                    
 result2 := tmp6$4;                                                                                 
                                                                                                    
 // 40.9: break exit$4;                                                                             
                                                                                                    
 goto exit$4_bottom;                                                                                
                                                                                                    
 // 39.16: result2 = Pair.null;                                                                     
                                                                                                    
 result2 := Pair.null;                                                                              
                                                                                                    
 // 39.16: break exit$4;                                                                            
                                                                                                    
 goto exit$4_bottom;                                                                                
 exit$4_bottom:                                                                                     
                                                                                                    
 // 78.7: yield;                                                                                    
                                                                                                    
 assume V._state260958 == V._state && V._lock260958 == V._lock && Pair._state260958 == Pair._state && Pair.reference260958 == Pair.reference && Pair.mark260958 == Pair.mark && Pair._lock260958 == Pair._lock && AtomicMarkableReference._state260958 == AtomicMarkableReference._state && AtomicMarkableReference.pair260958 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260958 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260958 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260958 == AtomicMarkableReference.pair_nextValue && Main._state260958 == Main._state && Main._lock260958 == Main._lock && result2260958 == result2 && result260958 == result && d260958 == d && x260958 == x && this260958 == this && tid260958 == tid;
 assume $recorded.state260958 == 1;                                                                 
 assert  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (78.7): Object invariant may not hold.
 call Yield(tid);                                                                                   
 assume  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (78.7): Object invariant may not hold.
 $pc := PreCommit;                                                                                  
 assume V._state260958_post == V._state && V._lock260958_post == V._lock && Pair._state260958_post == Pair._state && Pair.reference260958_post == Pair.reference && Pair.mark260958_post == Pair.mark && Pair._lock260958_post == Pair._lock && AtomicMarkableReference._state260958_post == AtomicMarkableReference._state && AtomicMarkableReference.pair260958_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock260958_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260958_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260958_post == AtomicMarkableReference.pair_nextValue && Main._state260958_post == Main._state && Main._lock260958_post == Main._lock && result2260958_post == result2 && result260958_post == result && d260958_post == d && x260958_post == x && this260958_post == this && tid260958_post == tid;
 assume $recorded.state260958_post == 1;                                                            
                                                                                                    
 // 79.7: boolean b;                                                                                
                                                                                                    
                                                                                                    
 // 79.7: V tmp19;                                                                                  
                                                                                                    
                                                                                                    
 // 79.7: tmp19 := result.reference;                                                                
                                                                                                    
                                                                                                    
 moverPath260967 := ReadEval.Pair.reference(tid: Tid,result: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 mover260967 := m#moverPath(moverPath260967);                                                       
 path260967 := p#moverPath(moverPath260967);                                                        
 assume V._state260967 == V._state && V._lock260967 == V._lock && Pair._state260967 == Pair._state && Pair.reference260967 == Pair.reference && Pair.mark260967 == Pair.mark && Pair._lock260967 == Pair._lock && AtomicMarkableReference._state260967 == AtomicMarkableReference._state && AtomicMarkableReference.pair260967 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260967 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260967 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260967 == AtomicMarkableReference.pair_nextValue && Main._state260967 == Main._state && Main._lock260967 == Main._lock && tmp19260967 == tmp19 && b260967 == b && result2260967 == result2 && result260967 == result && d260967 == d && x260967 == x && this260967 == this && tid260967 == tid && $pc260967 == $pc;
 assume $recorded.state260967 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume result != Pair.null;                                                                       
 } else {                                                                                           
  assert result != Pair.null;                                                                              // (79.7): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover260967);                                                               
 assert $pc != PhaseError;                                                                                 // (79.7): Reduction failure
 tmp19 := Pair.reference[result];                                                                   
                                                                                                    
 // 79.7: boolean tmp20;                                                                            
                                                                                                    
                                                                                                    
 // 79.7: tmp20 := result.mark;                                                                     
                                                                                                    
                                                                                                    
 moverPath260973 := ReadEval.Pair.mark(tid: Tid,result: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 mover260973 := m#moverPath(moverPath260973);                                                       
 path260973 := p#moverPath(moverPath260973);                                                        
 assume V._state260973 == V._state && V._lock260973 == V._lock && Pair._state260973 == Pair._state && Pair.reference260973 == Pair.reference && Pair.mark260973 == Pair.mark && Pair._lock260973 == Pair._lock && AtomicMarkableReference._state260973 == AtomicMarkableReference._state && AtomicMarkableReference.pair260973 == AtomicMarkableReference.pair && AtomicMarkableReference._lock260973 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread260973 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue260973 == AtomicMarkableReference.pair_nextValue && Main._state260973 == Main._state && Main._lock260973 == Main._lock && tmp20260973 == tmp20 && tmp19260973 == tmp19 && b260973 == b && result2260973 == result2 && result260973 == result && d260973 == d && x260973 == x && this260973 == this && tid260973 == tid && $pc260973 == $pc;
 assume $recorded.state260973 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume result != Pair.null;                                                                       
 } else {                                                                                           
  assert result != Pair.null;                                                                              // (79.7): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover260973);                                                               
 assert $pc != PhaseError;                                                                                 // (79.7): Reduction failure
 tmp20 := Pair.mark[result];                                                                        
 // inlined: x.compareAndSet(tmp19,V.null,tmp20,true)}                                              
 exit$5_top:                                                                                        
                                                                                                    
 // 79.7: V expectedReference$5;                                                                    
                                                                                                    
                                                                                                    
 // 79.7: V newReference$5;                                                                         
                                                                                                    
                                                                                                    
 // 79.7: boolean expectedMark$5;                                                                   
                                                                                                    
                                                                                                    
 // 79.7: boolean newMark$5;                                                                        
                                                                                                    
                                                                                                    
 // 79.7: AtomicMarkableReference this$5;                                                           
                                                                                                    
                                                                                                    
 // 79.7: expectedReference$5 = tmp19;                                                              
                                                                                                    
 expectedReference$5 := tmp19;                                                                      
                                                                                                    
 // 79.7: newReference$5 = V.null;                                                                  
                                                                                                    
 newReference$5 := V.null;                                                                          
                                                                                                    
 // 79.7: expectedMark$5 = tmp20;                                                                   
                                                                                                    
 expectedMark$5 := tmp20;                                                                           
                                                                                                    
 // 79.7: newMark$5 = true;                                                                         
                                                                                                    
 newMark$5 := true;                                                                                 
                                                                                                    
 // 79.7: this$5 = x;                                                                               
                                                                                                    
 this$5 := x;                                                                                       
                                                                                                    
 // 47.9: Pair current$5;                                                                           
                                                                                                    
 // NoOp: 'TraceOff'                                                                                
                                                                                                    
 // 47.9: Tid _C_t$5;                                                                               
                                                                                                    
                                                                                                    
 // 47.9: _C_t$5 := this$5.pair_nextThread  as B;                                                   
                                                                                                    
                                                                                                    
 moverPath261010 := ReadEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this$5: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 mover261010 := m#moverPath(moverPath261010);                                                       
 path261010 := p#moverPath(moverPath261010);                                                        
 assume V._state261010 == V._state && V._lock261010 == V._lock && Pair._state261010 == Pair._state && Pair.reference261010 == Pair.reference && Pair.mark261010 == Pair.mark && Pair._lock261010 == Pair._lock && AtomicMarkableReference._state261010 == AtomicMarkableReference._state && AtomicMarkableReference.pair261010 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261010 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261010 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261010 == AtomicMarkableReference.pair_nextValue && Main._state261010 == Main._state && Main._lock261010 == Main._lock && _C_t$5261010 == _C_t$5 && current$5261010 == current$5 && this$5261010 == this$5 && newMark$5261010 == newMark$5 && expectedMark$5261010 == expectedMark$5 && newReference$5261010 == newReference$5 && expectedReference$5261010 == expectedReference$5 && tmp20261010 == tmp20 && tmp19261010 == tmp19 && b261010 == b && result2261010 == result2 && result261010 == result && d261010 == d && x261010 == x && this261010 == this && tid261010 == tid && $pc261010 == $pc;
 assume $recorded.state261010 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this$5 != AtomicMarkableReference.null;                                                    
 } else {                                                                                           
  assert this$5 != AtomicMarkableReference.null;                                                           // (47.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (47.9): Reduction failure
 _C_t$5 := AtomicMarkableReference.pair_nextThread[this$5];                                         
                                                                                                    
 // 47.9: Pair _C_v$5;                                                                              
                                                                                                    
                                                                                                    
 // 47.9: _C_v$5 := this$5.pair_nextValue  as B;                                                    
                                                                                                    
                                                                                                    
 moverPath261016 := ReadEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this$5: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 mover261016 := m#moverPath(moverPath261016);                                                       
 path261016 := p#moverPath(moverPath261016);                                                        
 assume V._state261016 == V._state && V._lock261016 == V._lock && Pair._state261016 == Pair._state && Pair.reference261016 == Pair.reference && Pair.mark261016 == Pair.mark && Pair._lock261016 == Pair._lock && AtomicMarkableReference._state261016 == AtomicMarkableReference._state && AtomicMarkableReference.pair261016 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261016 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261016 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261016 == AtomicMarkableReference.pair_nextValue && Main._state261016 == Main._state && Main._lock261016 == Main._lock && _C_v$5261016 == _C_v$5 && _C_t$5261016 == _C_t$5 && current$5261016 == current$5 && this$5261016 == this$5 && newMark$5261016 == newMark$5 && expectedMark$5261016 == expectedMark$5 && newReference$5261016 == newReference$5 && expectedReference$5261016 == expectedReference$5 && tmp20261016 == tmp20 && tmp19261016 == tmp19 && b261016 == b && result2261016 == result2 && result261016 == result && d261016 == d && x261016 == x && this261016 == this && tid261016 == tid && $pc261016 == $pc;
 assume $recorded.state261016 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this$5 != AtomicMarkableReference.null;                                                    
 } else {                                                                                           
  assert this$5 != AtomicMarkableReference.null;                                                           // (47.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (47.9): Reduction failure
 _C_v$5 := AtomicMarkableReference.pair_nextValue[this$5];                                          
                                                                                                    
 // 47.9: Pair _currentValue$5;                                                                     
                                                                                                    
                                                                                                    
 // 47.9: _currentValue$5 := this$5.pair  as B;                                                     
                                                                                                    
                                                                                                    
 moverPath261022 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this$5: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 mover261022 := m#moverPath(moverPath261022);                                                       
 path261022 := p#moverPath(moverPath261022);                                                        
 assume V._state261022 == V._state && V._lock261022 == V._lock && Pair._state261022 == Pair._state && Pair.reference261022 == Pair.reference && Pair.mark261022 == Pair.mark && Pair._lock261022 == Pair._lock && AtomicMarkableReference._state261022 == AtomicMarkableReference._state && AtomicMarkableReference.pair261022 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261022 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261022 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261022 == AtomicMarkableReference.pair_nextValue && Main._state261022 == Main._state && Main._lock261022 == Main._lock && _currentValue$5261022 == _currentValue$5 && _C_v$5261022 == _C_v$5 && _C_t$5261022 == _C_t$5 && current$5261022 == current$5 && this$5261022 == this$5 && newMark$5261022 == newMark$5 && expectedMark$5261022 == expectedMark$5 && newReference$5261022 == newReference$5 && expectedReference$5261022 == expectedReference$5 && tmp20261022 == tmp20 && tmp19261022 == tmp19 && b261022 == b && result2261022 == result2 && result261022 == result && d261022 == d && x261022 == x && this261022 == this && tid261022 == tid && $pc261022 == $pc;
 assume $recorded.state261022 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this$5 != AtomicMarkableReference.null;                                                    
 } else {                                                                                           
  assert this$5 != AtomicMarkableReference.null;                                                           // (47.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (47.9): Reduction failure
 _currentValue$5 := AtomicMarkableReference.pair[this$5];                                           
                                                                                                    
 // 47.9: Mover _R_t$5;                                                                             
                                                                                                    
                                                                                                    
 // 47.9: _R_t$5 = readPermission(this$5.pair);                                                     
                                                                                                    
 _R_t$5 := m#moverPath(ReadEval.AtomicMarkableReference.pair(tid: Tid,this$5: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));
                                                                                                    
 // 47.9: boolean _casable$5;                                                                       
                                                                                                    
                                                                                                    
 // 47.9: _casable$5 = _R_t$5 != E && true && _C_t$5 == tid && _C_v$5 == _currentValue$5;           
                                                                                                    
 _casable$5 := ((((_R_t$5!=_E)&&true)&&(_C_t$5==tid))&&(_C_v$5==_currentValue$5));                  
 if (_casable$5) {                                                                                  
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 47.9: current$5 := this$5.pair  as R;                                                          
                                                                                                    
                                                                                                    
  moverPath261061 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this$5: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
  mover261061 := m#moverPath(moverPath261061);                                                      
  path261061 := p#moverPath(moverPath261061);                                                       
  assume V._state261061 == V._state && V._lock261061 == V._lock && Pair._state261061 == Pair._state && Pair.reference261061 == Pair.reference && Pair.mark261061 == Pair.mark && Pair._lock261061 == Pair._lock && AtomicMarkableReference._state261061 == AtomicMarkableReference._state && AtomicMarkableReference.pair261061 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261061 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261061 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261061 == AtomicMarkableReference.pair_nextValue && Main._state261061 == Main._state && Main._lock261061 == Main._lock && _casable$5261061 == _casable$5 && _R_t$5261061 == _R_t$5 && _currentValue$5261061 == _currentValue$5 && _C_v$5261061 == _C_v$5 && _C_t$5261061 == _C_t$5 && current$5261061 == current$5 && this$5261061 == this$5 && newMark$5261061 == newMark$5 && expectedMark$5261061 == expectedMark$5 && newReference$5261061 == newReference$5 && expectedReference$5261061 == expectedReference$5 && tmp20261061 == tmp20 && tmp19261061 == tmp19 && b261061 == b && result2261061 == result2 && result261061 == result && d261061 == d && x261061 == x && this261061 == this && tid261061 == tid && $pc261061 == $pc;
  assume $recorded.state261061 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this$5 != AtomicMarkableReference.null;                                                   
  } else {                                                                                          
   assert this$5 != AtomicMarkableReference.null;                                                          // (47.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _R);                                                                       
  assert $pc != PhaseError;                                                                                // (47.9): Reduction failure
  current$5 := AtomicMarkableReference.pair[this$5];                                                
 } else {                                                                                           
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 47.9: current$5 := this$5.pair;                                                                
                                                                                                    
                                                                                                    
  moverPath261066 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this$5: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
  mover261066 := m#moverPath(moverPath261066);                                                      
  path261066 := p#moverPath(moverPath261066);                                                       
  assume V._state261066 == V._state && V._lock261066 == V._lock && Pair._state261066 == Pair._state && Pair.reference261066 == Pair.reference && Pair.mark261066 == Pair.mark && Pair._lock261066 == Pair._lock && AtomicMarkableReference._state261066 == AtomicMarkableReference._state && AtomicMarkableReference.pair261066 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261066 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261066 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261066 == AtomicMarkableReference.pair_nextValue && Main._state261066 == Main._state && Main._lock261066 == Main._lock && _casable$5261066 == _casable$5 && _R_t$5261066 == _R_t$5 && _currentValue$5261066 == _currentValue$5 && _C_v$5261066 == _C_v$5 && _C_t$5261066 == _C_t$5 && current$5261066 == current$5 && this$5261066 == this$5 && newMark$5261066 == newMark$5 && expectedMark$5261066 == expectedMark$5 && newReference$5261066 == newReference$5 && expectedReference$5261066 == expectedReference$5 && tmp20261066 == tmp20 && tmp19261066 == tmp19 && b261066 == b && result2261066 == result2 && result261066 == result && d261066 == d && x261066 == x && this261066 == this && tid261066 == tid && $pc261066 == $pc;
  assume $recorded.state261066 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this$5 != AtomicMarkableReference.null;                                                   
  } else {                                                                                          
   assert this$5 != AtomicMarkableReference.null;                                                          // (47.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover261066);                                                              
  assert $pc != PhaseError;                                                                                // (47.9): Reduction failure
  current$5 := AtomicMarkableReference.pair[this$5];                                                
 }                                                                                                  
                                                                                                    
 // 48.9: boolean tmp7$5;                                                                           
                                                                                                    
                                                                                                    
 // 48.9: boolean tmp8$5;                                                                           
                                                                                                    
                                                                                                    
 // 48.9: boolean tmp9$5;                                                                           
                                                                                                    
                                                                                                    
 // 48.9: V tmp10$5;                                                                                
                                                                                                    
                                                                                                    
 // 48.9: tmp10$5 := current$5.reference;                                                           
                                                                                                    
                                                                                                    
 moverPath261084 := ReadEval.Pair.reference(tid: Tid,current$5: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 mover261084 := m#moverPath(moverPath261084);                                                       
 path261084 := p#moverPath(moverPath261084);                                                        
 assume V._state261084 == V._state && V._lock261084 == V._lock && Pair._state261084 == Pair._state && Pair.reference261084 == Pair.reference && Pair.mark261084 == Pair.mark && Pair._lock261084 == Pair._lock && AtomicMarkableReference._state261084 == AtomicMarkableReference._state && AtomicMarkableReference.pair261084 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261084 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261084 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261084 == AtomicMarkableReference.pair_nextValue && Main._state261084 == Main._state && Main._lock261084 == Main._lock && tmp10$5261084 == tmp10$5 && tmp9$5261084 == tmp9$5 && tmp8$5261084 == tmp8$5 && tmp7$5261084 == tmp7$5 && current$5261084 == current$5 && this$5261084 == this$5 && newMark$5261084 == newMark$5 && expectedMark$5261084 == expectedMark$5 && newReference$5261084 == newReference$5 && expectedReference$5261084 == expectedReference$5 && tmp20261084 == tmp20 && tmp19261084 == tmp19 && b261084 == b && result2261084 == result2 && result261084 == result && d261084 == d && x261084 == x && this261084 == this && tid261084 == tid && $pc261084 == $pc;
 assume $recorded.state261084 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume current$5 != Pair.null;                                                                    
 } else {                                                                                           
  assert current$5 != Pair.null;                                                                           // (48.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover261084);                                                               
 assert $pc != PhaseError;                                                                                 // (48.9): Reduction failure
 tmp10$5 := Pair.reference[current$5];                                                              
                                                                                                    
 // 48.9: tmp9$5 = expectedReference$5 == tmp10$5;                                                  
                                                                                                    
 tmp9$5 := (expectedReference$5==tmp10$5);                                                          
 if (tmp9$5) {                                                                                      
                                                                                                    
  // 50.29: boolean tmp11$5;                                                                        
                                                                                                    
                                                                                                    
  // 50.29: tmp11$5 := current$5.mark;                                                              
                                                                                                    
                                                                                                    
  moverPath261097 := ReadEval.Pair.mark(tid: Tid,current$5: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
  mover261097 := m#moverPath(moverPath261097);                                                      
  path261097 := p#moverPath(moverPath261097);                                                       
  assume V._state261097 == V._state && V._lock261097 == V._lock && Pair._state261097 == Pair._state && Pair.reference261097 == Pair.reference && Pair.mark261097 == Pair.mark && Pair._lock261097 == Pair._lock && AtomicMarkableReference._state261097 == AtomicMarkableReference._state && AtomicMarkableReference.pair261097 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261097 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261097 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261097 == AtomicMarkableReference.pair_nextValue && Main._state261097 == Main._state && Main._lock261097 == Main._lock && tmp11$5261097 == tmp11$5 && tmp10$5261097 == tmp10$5 && tmp9$5261097 == tmp9$5 && tmp8$5261097 == tmp8$5 && tmp7$5261097 == tmp7$5 && current$5261097 == current$5 && this$5261097 == this$5 && newMark$5261097 == newMark$5 && expectedMark$5261097 == expectedMark$5 && newReference$5261097 == newReference$5 && expectedReference$5261097 == expectedReference$5 && tmp20261097 == tmp20 && tmp19261097 == tmp19 && b261097 == b && result2261097 == result2 && result261097 == result && d261097 == d && x261097 == x && this261097 == this && tid261097 == tid && $pc261097 == $pc;
  assume $recorded.state261097 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume current$5 != Pair.null;                                                                   
  } else {                                                                                          
   assert current$5 != Pair.null;                                                                          // (50.29): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover261097);                                                              
  assert $pc != PhaseError;                                                                                // (50.29): Reduction failure
  tmp11$5 := Pair.mark[current$5];                                                                  
                                                                                                    
  // 50.26: tmp8$5 = expectedMark$5 == tmp11$5;                                                     
                                                                                                    
  tmp8$5 := (expectedMark$5==tmp11$5);                                                              
 } else {                                                                                           
                                                                                                    
  // <undefined position>: tmp8$5 = false;                                                          
                                                                                                    
  tmp8$5 := false;                                                                                  
 }                                                                                                  
 if (tmp8$5) {                                                                                      
                                                                                                    
  // 51.35: Pair tmp12$5;                                                                           
                                                                                                    
  // inlined: this$5.pairOf(newReference$5,newMark$5)}                                              
  exit$6_top:                                                                                       
                                                                                                    
  // 51.35: V initialRef$6;                                                                         
                                                                                                    
                                                                                                    
  // 51.35: boolean initialMark$6;                                                                  
                                                                                                    
                                                                                                    
  // 51.35: AtomicMarkableReference this$6;                                                         
                                                                                                    
                                                                                                    
  // 51.35: initialRef$6 = newReference$5;                                                          
                                                                                                    
  initialRef$6 := newReference$5;                                                                   
                                                                                                    
  // 51.35: initialMark$6 = newMark$5;                                                              
                                                                                                    
  initialMark$6 := newMark$5;                                                                       
                                                                                                    
  // 51.35: this$6 = this$5;                                                                        
                                                                                                    
  this$6 := this$5;                                                                                 
                                                                                                    
  // 23.7: Pair p$6;                                                                                
                                                                                                    
                                                                                                    
  // 23.7: p$6 = new Pair();                                                                        
                                                                                                    
  havoc p$6;                                                                                        
  assume p$6 != Pair.null && isFresh(Pair._state[p$6]);                                             
  Pair._state[p$6] := LOCAL(tid);                                                                   
  assume Pair.reference[p$6]  == V.null;                                                            
  assume Pair.mark[p$6]  == false;                                                                  
  assume Pair._lock[p$6]  == Tid.null;                                                              
  // inlined: p$6.init(initialRef$6,initialMark$6)}                                                 
  exit$7_top:                                                                                       
                                                                                                    
  // 23.7: V reference$7;                                                                           
                                                                                                    
                                                                                                    
  // 23.7: boolean mark$7;                                                                          
                                                                                                    
                                                                                                    
  // 23.7: Pair this$7;                                                                             
                                                                                                    
                                                                                                    
  // 23.7: reference$7 = initialRef$6;                                                              
                                                                                                    
  reference$7 := initialRef$6;                                                                      
                                                                                                    
  // 23.7: mark$7 = initialMark$6;                                                                  
                                                                                                    
  mark$7 := initialMark$6;                                                                          
                                                                                                    
  // 23.7: this$7 = p$6;                                                                            
                                                                                                    
  this$7 := p$6;                                                                                    
                                                                                                    
  // 7.5: assume this$7.reference == V.null;                                                        
                                                                                                    
  assume (Pair.reference[this$7]==V.null);                                                          
                                                                                                    
  // 7.5: assume this$7.mark == false;                                                              
                                                                                                    
  assume (Pair.mark[this$7]==false);                                                                
                                                                                                    
                                                                                                    
  // 8.9: this$7.reference := reference$7;                                                          
                                                                                                    
                                                                                                    
  moverPath261180 := WriteEval.Pair.reference(tid: Tid,this$7: Pair,reference$7: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
  mover261180 := m#moverPath(moverPath261180);                                                      
  path261180 := p#moverPath(moverPath261180);                                                       
  assume V._state261180 == V._state && V._lock261180 == V._lock && Pair._state261180 == Pair._state && Pair.reference261180 == Pair.reference && Pair.mark261180 == Pair.mark && Pair._lock261180 == Pair._lock && AtomicMarkableReference._state261180 == AtomicMarkableReference._state && AtomicMarkableReference.pair261180 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261180 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261180 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261180 == AtomicMarkableReference.pair_nextValue && Main._state261180 == Main._state && Main._lock261180 == Main._lock && this$7261180 == this$7 && mark$7261180 == mark$7 && reference$7261180 == reference$7 && p$6261180 == p$6 && this$6261180 == this$6 && initialMark$6261180 == initialMark$6 && initialRef$6261180 == initialRef$6 && tmp12$5261180 == tmp12$5 && tmp10$5261180 == tmp10$5 && tmp9$5261180 == tmp9$5 && tmp8$5261180 == tmp8$5 && tmp7$5261180 == tmp7$5 && current$5261180 == current$5 && this$5261180 == this$5 && newMark$5261180 == newMark$5 && expectedMark$5261180 == expectedMark$5 && newReference$5261180 == newReference$5 && expectedReference$5261180 == expectedReference$5 && tmp20261180 == tmp20 && tmp19261180 == tmp19 && b261180 == b && result2261180 == result2 && result261180 == result && d261180 == d && x261180 == x && this261180 == this && tid261180 == tid && $pc261180 == $pc;
  assume $recorded.state261180 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this$7 != Pair.null;                                                                      
  } else {                                                                                          
   assert this$7 != Pair.null;                                                                             // (8.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover261180);                                                              
  assert $pc != PhaseError;                                                                                // (8.9): Reduction failure
  Pair.reference[this$7] := reference$7;                                                            
  if (isLocal(V._state[reference$7], tid)) {                                                        
   V._state[reference$7] := SHARED();                                                               
  }                                                                                                 
                                                                                                    
                                                                                                    
                                                                                                    
  // 9.9: this$7.mark := mark$7;                                                                    
                                                                                                    
                                                                                                    
  moverPath261183 := WriteEval.Pair.mark(tid: Tid,this$7: Pair,mark$7: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
  mover261183 := m#moverPath(moverPath261183);                                                      
  path261183 := p#moverPath(moverPath261183);                                                       
  assume V._state261183 == V._state && V._lock261183 == V._lock && Pair._state261183 == Pair._state && Pair.reference261183 == Pair.reference && Pair.mark261183 == Pair.mark && Pair._lock261183 == Pair._lock && AtomicMarkableReference._state261183 == AtomicMarkableReference._state && AtomicMarkableReference.pair261183 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261183 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261183 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261183 == AtomicMarkableReference.pair_nextValue && Main._state261183 == Main._state && Main._lock261183 == Main._lock && this$7261183 == this$7 && mark$7261183 == mark$7 && reference$7261183 == reference$7 && p$6261183 == p$6 && this$6261183 == this$6 && initialMark$6261183 == initialMark$6 && initialRef$6261183 == initialRef$6 && tmp12$5261183 == tmp12$5 && tmp10$5261183 == tmp10$5 && tmp9$5261183 == tmp9$5 && tmp8$5261183 == tmp8$5 && tmp7$5261183 == tmp7$5 && current$5261183 == current$5 && this$5261183 == this$5 && newMark$5261183 == newMark$5 && expectedMark$5261183 == expectedMark$5 && newReference$5261183 == newReference$5 && expectedReference$5261183 == expectedReference$5 && tmp20261183 == tmp20 && tmp19261183 == tmp19 && b261183 == b && result2261183 == result2 && result261183 == result && d261183 == d && x261183 == x && this261183 == this && tid261183 == tid && $pc261183 == $pc;
  assume $recorded.state261183 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this$7 != Pair.null;                                                                      
  } else {                                                                                          
   assert this$7 != Pair.null;                                                                             // (9.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover261183);                                                              
  assert $pc != PhaseError;                                                                                // (9.9): Reduction failure
  Pair.mark[this$7] := mark$7;                                                                      
                                                                                                    
  // 7.37: break exit$7;                                                                            
                                                                                                    
  goto exit$7_bottom;                                                                               
  exit$7_bottom:                                                                                    
                                                                                                    
  // 24.7: tmp12$5 = p$6;                                                                           
                                                                                                    
  tmp12$5 := p$6;                                                                                   
                                                                                                    
  // 24.7: break exit$6;                                                                            
                                                                                                    
  goto exit$6_bottom;                                                                               
                                                                                                    
  // 22.52: tmp12$5 = Pair.null;                                                                    
                                                                                                    
  tmp12$5 := Pair.null;                                                                             
                                                                                                    
  // 22.52: break exit$6;                                                                           
                                                                                                    
  goto exit$6_bottom;                                                                               
  exit$6_bottom:                                                                                    
  // inlined: this$5.casPair(current$5,tmp12$5)}                                                    
  exit$8_top:                                                                                       
                                                                                                    
  // 51.13: Pair cmp$8;                                                                             
                                                                                                    
                                                                                                    
  // 51.13: Pair val$8;                                                                             
                                                                                                    
                                                                                                    
  // 51.13: AtomicMarkableReference this$8;                                                         
                                                                                                    
                                                                                                    
  // 51.13: cmp$8 = current$5;                                                                      
                                                                                                    
  cmp$8 := current$5;                                                                               
                                                                                                    
  // 51.13: val$8 = tmp12$5;                                                                        
                                                                                                    
  val$8 := tmp12$5;                                                                                 
                                                                                                    
  // 51.13: this$8 = this$5;                                                                        
                                                                                                    
  this$8 := this$5;                                                                                 
                                                                                                    
  // 66.9: boolean tmp18$8;                                                                         
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 66.9: boolean ctmp237616$8;                                                                    
                                                                                                    
                                                                                                    
  // 66.9: ctmp237616$8 = *;                                                                        
                                                                                                    
  havoc ctmp237616$8;                                                                               
  if (ctmp237616$8) {                                                                               
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 66.9: tmp18$8 = false;                                                                        
                                                                                                    
   tmp18$8 := false;                                                                                
  } else {                                                                                          
                                                                                                    
   // 66.9: ctmp237616$8 = *;                                                                       
                                                                                                    
   havoc ctmp237616$8;                                                                              
   if (ctmp237616$8) {                                                                              
                                                                                                    
    // 66.9: Tid tmpTid$8;                                                                          
                                                                                                    
                                                                                                    
    // 66.9: Pair tmpValue$8;                                                                       
                                                                                                    
                                                                                                    
    // 66.9: Mover _m$8;                                                                            
                                                                                                    
                                                                                                    
    // 66.9: _m$8 = writePermission(this$8.pair, val$8);                                            
                                                                                                    
    _m$8 := m#moverPath(WriteEval.AtomicMarkableReference.pair(tid: Tid,this$8: AtomicMarkableReference,val$8: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));
                                                                                                    
    // 66.9: assume this$8.pair == cmp$8;                                                           
                                                                                                    
    assume (AtomicMarkableReference.pair[this$8]==cmp$8);                                           
                                                                                                    
    // 66.9: assume !goesWrong(_m$8);                                                               
                                                                                                    
    assume !(transition($pc, _m$8) == PhaseError);                                                  
                                                                                                    
    // 66.9: assume this$8.pair_nextThread == tid;                                                  
                                                                                                    
    assume (AtomicMarkableReference.pair_nextThread[this$8]==tid);                                  
                                                                                                    
    // 66.9: assume this$8.pair_nextValue == cmp$8;                                                 
                                                                                                    
    assume (AtomicMarkableReference.pair_nextValue[this$8]==cmp$8);                                 
                                                                                                    
                                                                                                    
    // 66.9: this$8.pair_nextThread := tmpTid$8 as B;                                               
                                                                                                    
                                                                                                    
    moverPath261301 := WriteEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this$8: AtomicMarkableReference,tmpTid$8: Tid,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
    mover261301 := m#moverPath(moverPath261301);                                                    
    path261301 := p#moverPath(moverPath261301);                                                     
    assume V._state261301 == V._state && V._lock261301 == V._lock && Pair._state261301 == Pair._state && Pair.reference261301 == Pair.reference && Pair.mark261301 == Pair.mark && Pair._lock261301 == Pair._lock && AtomicMarkableReference._state261301 == AtomicMarkableReference._state && AtomicMarkableReference.pair261301 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261301 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261301 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261301 == AtomicMarkableReference.pair_nextValue && Main._state261301 == Main._state && Main._lock261301 == Main._lock && _m$8261301 == _m$8 && tmpValue$8261301 == tmpValue$8 && tmpTid$8261301 == tmpTid$8 && ctmp237616$8261301 == ctmp237616$8 && tmp18$8261301 == tmp18$8 && this$8261301 == this$8 && val$8261301 == val$8 && cmp$8261301 == cmp$8 && tmp12$5261301 == tmp12$5 && tmp10$5261301 == tmp10$5 && tmp9$5261301 == tmp9$5 && tmp8$5261301 == tmp8$5 && tmp7$5261301 == tmp7$5 && current$5261301 == current$5 && this$5261301 == this$5 && newMark$5261301 == newMark$5 && expectedMark$5261301 == expectedMark$5 && newReference$5261301 == newReference$5 && expectedReference$5261301 == expectedReference$5 && tmp20261301 == tmp20 && tmp19261301 == tmp19 && b261301 == b && result2261301 == result2 && result261301 == result && d261301 == d && x261301 == x && this261301 == this && tid261301 == tid && $pc261301 == $pc;
    assume $recorded.state261301 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this$8 != AtomicMarkableReference.null;                                                 
    } else {                                                                                        
     assert this$8 != AtomicMarkableReference.null;                                                        // (66.9): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (66.9): Reduction failure
    AtomicMarkableReference.pair_nextThread[this$8] := tmpTid$8;                                    
                                                                                                    
                                                                                                    
    // 66.9: this$8.pair_nextValue := tmpValue$8 as B;                                              
                                                                                                    
                                                                                                    
    moverPath261304 := WriteEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this$8: AtomicMarkableReference,tmpValue$8: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
    mover261304 := m#moverPath(moverPath261304);                                                    
    path261304 := p#moverPath(moverPath261304);                                                     
    assume V._state261304 == V._state && V._lock261304 == V._lock && Pair._state261304 == Pair._state && Pair.reference261304 == Pair.reference && Pair.mark261304 == Pair.mark && Pair._lock261304 == Pair._lock && AtomicMarkableReference._state261304 == AtomicMarkableReference._state && AtomicMarkableReference.pair261304 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261304 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261304 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261304 == AtomicMarkableReference.pair_nextValue && Main._state261304 == Main._state && Main._lock261304 == Main._lock && _m$8261304 == _m$8 && tmpValue$8261304 == tmpValue$8 && tmpTid$8261304 == tmpTid$8 && ctmp237616$8261304 == ctmp237616$8 && tmp18$8261304 == tmp18$8 && this$8261304 == this$8 && val$8261304 == val$8 && cmp$8261304 == cmp$8 && tmp12$5261304 == tmp12$5 && tmp10$5261304 == tmp10$5 && tmp9$5261304 == tmp9$5 && tmp8$5261304 == tmp8$5 && tmp7$5261304 == tmp7$5 && current$5261304 == current$5 && this$5261304 == this$5 && newMark$5261304 == newMark$5 && expectedMark$5261304 == expectedMark$5 && newReference$5261304 == newReference$5 && expectedReference$5261304 == expectedReference$5 && tmp20261304 == tmp20 && tmp19261304 == tmp19 && b261304 == b && result2261304 == result2 && result261304 == result && d261304 == d && x261304 == x && this261304 == this && tid261304 == tid && $pc261304 == $pc;
    assume $recorded.state261304 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this$8 != AtomicMarkableReference.null;                                                 
    } else {                                                                                        
     assert this$8 != AtomicMarkableReference.null;                                                        // (66.9): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (66.9): Reduction failure
    AtomicMarkableReference.pair_nextValue[this$8] := tmpValue$8;                                   
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 66.9: this$8.pair := val$8;                                                                  
                                                                                                    
                                                                                                    
    moverPath261308 := WriteEval.AtomicMarkableReference.pair(tid: Tid,this$8: AtomicMarkableReference,val$8: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
    mover261308 := m#moverPath(moverPath261308);                                                    
    path261308 := p#moverPath(moverPath261308);                                                     
    assume V._state261308 == V._state && V._lock261308 == V._lock && Pair._state261308 == Pair._state && Pair.reference261308 == Pair.reference && Pair.mark261308 == Pair.mark && Pair._lock261308 == Pair._lock && AtomicMarkableReference._state261308 == AtomicMarkableReference._state && AtomicMarkableReference.pair261308 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261308 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261308 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261308 == AtomicMarkableReference.pair_nextValue && Main._state261308 == Main._state && Main._lock261308 == Main._lock && _m$8261308 == _m$8 && tmpValue$8261308 == tmpValue$8 && tmpTid$8261308 == tmpTid$8 && ctmp237616$8261308 == ctmp237616$8 && tmp18$8261308 == tmp18$8 && this$8261308 == this$8 && val$8261308 == val$8 && cmp$8261308 == cmp$8 && tmp12$5261308 == tmp12$5 && tmp10$5261308 == tmp10$5 && tmp9$5261308 == tmp9$5 && tmp8$5261308 == tmp8$5 && tmp7$5261308 == tmp7$5 && current$5261308 == current$5 && this$5261308 == this$5 && newMark$5261308 == newMark$5 && expectedMark$5261308 == expectedMark$5 && newReference$5261308 == newReference$5 && expectedReference$5261308 == expectedReference$5 && tmp20261308 == tmp20 && tmp19261308 == tmp19 && b261308 == b && result2261308 == result2 && result261308 == result && d261308 == d && x261308 == x && this261308 == this && tid261308 == tid && $pc261308 == $pc;
    assume $recorded.state261308 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this$8 != AtomicMarkableReference.null;                                                 
    } else {                                                                                        
     assert this$8 != AtomicMarkableReference.null;                                                        // (66.9): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover261308);                                                            
    assert $pc != PhaseError;                                                                              // (66.9): Reduction failure
    AtomicMarkableReference.pair[this$8] := val$8;                                                  
    if (isLocal(Pair._state[val$8], tid)) {                                                         
     Pair._state[val$8] := SHARED();                                                                
     assert isSharedAssignable(V._state[Pair.reference[val$8]]);                                           // (66.9): val$8 became shared, but val$8.reference may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 66.9: tmp18$8 = true;                                                                        
                                                                                                    
    tmp18$8 := true;                                                                                
   } else {                                                                                         
                                                                                                    
    // 66.9: assume this$8.pair_nextThread == tid;                                                  
                                                                                                    
    assume (AtomicMarkableReference.pair_nextThread[this$8]==tid);                                  
                                                                                                    
    // 66.9: assume this$8.pair_nextValue == cmp$8;                                                 
                                                                                                    
    assume (AtomicMarkableReference.pair_nextValue[this$8]==cmp$8);                                 
                                                                                                    
    // 66.9: Pair _currentValue$8;                                                                  
                                                                                                    
                                                                                                    
    // 66.9: _currentValue$8 := this$8.pair  as B;                                                  
                                                                                                    
                                                                                                    
    moverPath261331 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this$8: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
    mover261331 := m#moverPath(moverPath261331);                                                    
    path261331 := p#moverPath(moverPath261331);                                                     
    assume V._state261331 == V._state && V._lock261331 == V._lock && Pair._state261331 == Pair._state && Pair.reference261331 == Pair.reference && Pair.mark261331 == Pair.mark && Pair._lock261331 == Pair._lock && AtomicMarkableReference._state261331 == AtomicMarkableReference._state && AtomicMarkableReference.pair261331 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261331 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261331 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261331 == AtomicMarkableReference.pair_nextValue && Main._state261331 == Main._state && Main._lock261331 == Main._lock && _currentValue$8261331 == _currentValue$8 && ctmp237616$8261331 == ctmp237616$8 && tmp18$8261331 == tmp18$8 && this$8261331 == this$8 && val$8261331 == val$8 && cmp$8261331 == cmp$8 && tmp12$5261331 == tmp12$5 && tmp10$5261331 == tmp10$5 && tmp9$5261331 == tmp9$5 && tmp8$5261331 == tmp8$5 && tmp7$5261331 == tmp7$5 && current$5261331 == current$5 && this$5261331 == this$5 && newMark$5261331 == newMark$5 && expectedMark$5261331 == expectedMark$5 && newReference$5261331 == newReference$5 && expectedReference$5261331 == expectedReference$5 && tmp20261331 == tmp20 && tmp19261331 == tmp19 && b261331 == b && result2261331 == result2 && result261331 == result && d261331 == d && x261331 == x && this261331 == this && tid261331 == tid && $pc261331 == $pc;
    assume $recorded.state261331 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this$8 != AtomicMarkableReference.null;                                                 
    } else {                                                                                        
     assert this$8 != AtomicMarkableReference.null;                                                        // (66.9): Cannot have potential null deference in left-mover part.
    }                                                                                               
                                                                                                    
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (66.9): Reduction failure
    _currentValue$8 := AtomicMarkableReference.pair[this$8];                                        
                                                                                                    
                                                                                                    
    // 66.9: this$8.pair := cmp$8 as B;                                                             
                                                                                                    
                                                                                                    
    moverPath261334 := WriteEval.AtomicMarkableReference.pair(tid: Tid,this$8: AtomicMarkableReference,cmp$8: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
    mover261334 := m#moverPath(moverPath261334);                                                    
    path261334 := p#moverPath(moverPath261334);                                                     
    assume V._state261334 == V._state && V._lock261334 == V._lock && Pair._state261334 == Pair._state && Pair.reference261334 == Pair.reference && Pair.mark261334 == Pair.mark && Pair._lock261334 == Pair._lock && AtomicMarkableReference._state261334 == AtomicMarkableReference._state && AtomicMarkableReference.pair261334 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261334 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261334 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261334 == AtomicMarkableReference.pair_nextValue && Main._state261334 == Main._state && Main._lock261334 == Main._lock && _currentValue$8261334 == _currentValue$8 && ctmp237616$8261334 == ctmp237616$8 && tmp18$8261334 == tmp18$8 && this$8261334 == this$8 && val$8261334 == val$8 && cmp$8261334 == cmp$8 && tmp12$5261334 == tmp12$5 && tmp10$5261334 == tmp10$5 && tmp9$5261334 == tmp9$5 && tmp8$5261334 == tmp8$5 && tmp7$5261334 == tmp7$5 && current$5261334 == current$5 && this$5261334 == this$5 && newMark$5261334 == newMark$5 && expectedMark$5261334 == expectedMark$5 && newReference$5261334 == newReference$5 && expectedReference$5261334 == expectedReference$5 && tmp20261334 == tmp20 && tmp19261334 == tmp19 && b261334 == b && result2261334 == result2 && result261334 == result && d261334 == d && x261334 == x && this261334 == this && tid261334 == tid && $pc261334 == $pc;
    assume $recorded.state261334 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this$8 != AtomicMarkableReference.null;                                                 
    } else {                                                                                        
     assert this$8 != AtomicMarkableReference.null;                                                        // (66.9): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (66.9): Reduction failure
    AtomicMarkableReference.pair[this$8] := cmp$8;                                                  
    if (isLocal(Pair._state[cmp$8], tid)) {                                                         
     Pair._state[cmp$8] := SHARED();                                                                
     assert isSharedAssignable(V._state[Pair.reference[cmp$8]]);                                           // (66.9): cmp$8 became shared, but cmp$8.reference may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 66.9: Mover _m$8;                                                                            
                                                                                                    
                                                                                                    
    // 66.9: _m$8 = writePermission(this$8.pair, val$8);                                            
                                                                                                    
    _m$8 := m#moverPath(WriteEval.AtomicMarkableReference.pair(tid: Tid,this$8: AtomicMarkableReference,val$8: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));
                                                                                                    
                                                                                                    
    // 66.9: this$8.pair := _currentValue$8 as B;                                                   
                                                                                                    
                                                                                                    
    moverPath261346 := WriteEval.AtomicMarkableReference.pair(tid: Tid,this$8: AtomicMarkableReference,_currentValue$8: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
    mover261346 := m#moverPath(moverPath261346);                                                    
    path261346 := p#moverPath(moverPath261346);                                                     
    assume V._state261346 == V._state && V._lock261346 == V._lock && Pair._state261346 == Pair._state && Pair.reference261346 == Pair.reference && Pair.mark261346 == Pair.mark && Pair._lock261346 == Pair._lock && AtomicMarkableReference._state261346 == AtomicMarkableReference._state && AtomicMarkableReference.pair261346 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261346 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261346 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261346 == AtomicMarkableReference.pair_nextValue && Main._state261346 == Main._state && Main._lock261346 == Main._lock && _m$8261346 == _m$8 && _currentValue$8261346 == _currentValue$8 && ctmp237616$8261346 == ctmp237616$8 && tmp18$8261346 == tmp18$8 && this$8261346 == this$8 && val$8261346 == val$8 && cmp$8261346 == cmp$8 && tmp12$5261346 == tmp12$5 && tmp10$5261346 == tmp10$5 && tmp9$5261346 == tmp9$5 && tmp8$5261346 == tmp8$5 && tmp7$5261346 == tmp7$5 && current$5261346 == current$5 && this$5261346 == this$5 && newMark$5261346 == newMark$5 && expectedMark$5261346 == expectedMark$5 && newReference$5261346 == newReference$5 && expectedReference$5261346 == expectedReference$5 && tmp20261346 == tmp20 && tmp19261346 == tmp19 && b261346 == b && result2261346 == result2 && result261346 == result && d261346 == d && x261346 == x && this261346 == this && tid261346 == tid && $pc261346 == $pc;
    assume $recorded.state261346 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this$8 != AtomicMarkableReference.null;                                                 
    } else {                                                                                        
     assert this$8 != AtomicMarkableReference.null;                                                        // (66.9): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (66.9): Reduction failure
    AtomicMarkableReference.pair[this$8] := _currentValue$8;                                        
    if (isLocal(Pair._state[_currentValue$8], tid)) {                                               
     Pair._state[_currentValue$8] := SHARED();                                                      
     assert isSharedAssignable(V._state[Pair.reference[_currentValue$8]]);                                 // (66.9): _currentValue$8 became shared, but _currentValue$8.reference may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 66.9: assume goesWrong(_m$8);                                                                
                                                                                                    
    assume transition($pc, _m$8) == PhaseError;                                                     
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 66.9: this$8.pair := val$8;                                                                  
                                                                                                    
                                                                                                    
    moverPath261353 := WriteEval.AtomicMarkableReference.pair(tid: Tid,this$8: AtomicMarkableReference,val$8: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
    mover261353 := m#moverPath(moverPath261353);                                                    
    path261353 := p#moverPath(moverPath261353);                                                     
    assume V._state261353 == V._state && V._lock261353 == V._lock && Pair._state261353 == Pair._state && Pair.reference261353 == Pair.reference && Pair.mark261353 == Pair.mark && Pair._lock261353 == Pair._lock && AtomicMarkableReference._state261353 == AtomicMarkableReference._state && AtomicMarkableReference.pair261353 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261353 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261353 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261353 == AtomicMarkableReference.pair_nextValue && Main._state261353 == Main._state && Main._lock261353 == Main._lock && _m$8261353 == _m$8 && _currentValue$8261353 == _currentValue$8 && ctmp237616$8261353 == ctmp237616$8 && tmp18$8261353 == tmp18$8 && this$8261353 == this$8 && val$8261353 == val$8 && cmp$8261353 == cmp$8 && tmp12$5261353 == tmp12$5 && tmp10$5261353 == tmp10$5 && tmp9$5261353 == tmp9$5 && tmp8$5261353 == tmp8$5 && tmp7$5261353 == tmp7$5 && current$5261353 == current$5 && this$5261353 == this$5 && newMark$5261353 == newMark$5 && expectedMark$5261353 == expectedMark$5 && newReference$5261353 == newReference$5 && expectedReference$5261353 == expectedReference$5 && tmp20261353 == tmp20 && tmp19261353 == tmp19 && b261353 == b && result2261353 == result2 && result261353 == result && d261353 == d && x261353 == x && this261353 == this && tid261353 == tid && $pc261353 == $pc;
    assume $recorded.state261353 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this$8 != AtomicMarkableReference.null;                                                 
    } else {                                                                                        
     assert this$8 != AtomicMarkableReference.null;                                                        // (66.9): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover261353);                                                            
    assert $pc != PhaseError;                                                                              // (66.9): Reduction failure
    AtomicMarkableReference.pair[this$8] := val$8;                                                  
    if (isLocal(Pair._state[val$8], tid)) {                                                         
     Pair._state[val$8] := SHARED();                                                                
     assert isSharedAssignable(V._state[Pair.reference[val$8]]);                                           // (66.9): val$8 became shared, but val$8.reference may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 66.9: tmp18$8 = false;                                                                       
                                                                                                    
    tmp18$8 := false;                                                                               
   }                                                                                                
  }                                                                                                 
                                                                                                    
  // 66.9: tmp7$5 = tmp18$8;                                                                        
                                                                                                    
  tmp7$5 := tmp18$8;                                                                                
                                                                                                    
  // 66.9: break exit$8;                                                                            
                                                                                                    
  goto exit$8_bottom;                                                                               
                                                                                                    
  // 65.41: tmp7$5 = false;                                                                         
                                                                                                    
  tmp7$5 := false;                                                                                  
                                                                                                    
  // 65.41: break exit$8;                                                                           
                                                                                                    
  goto exit$8_bottom;                                                                               
  exit$8_bottom:                                                                                    
 } else {                                                                                           
                                                                                                    
  // <undefined position>: tmp7$5 = false;                                                          
                                                                                                    
  tmp7$5 := false;                                                                                  
 }                                                                                                  
                                                                                                    
 // 48.9: b = tmp7$5;                                                                               
                                                                                                    
 b := tmp7$5;                                                                                       
                                                                                                    
 // 48.9: break exit$5;                                                                             
                                                                                                    
 goto exit$5_bottom;                                                                                
                                                                                                    
 // 46.51: b = false;                                                                               
                                                                                                    
 b := false;                                                                                        
                                                                                                    
 // 46.51: break exit$5;                                                                            
                                                                                                    
 goto exit$5_bottom;                                                                                
 exit$5_bottom:                                                                                     
 if (b /* lowered b */) {                                                                           
 } else {                                                                                           
 }                                                                                                  
                                                                                                    
 // 73.46: // return;                                                                               
                                                                                                    
 assume V._state261420 == V._state && V._lock261420 == V._lock && Pair._state261420 == Pair._state && Pair.reference261420 == Pair.reference && Pair.mark261420 == Pair.mark && Pair._lock261420 == Pair._lock && AtomicMarkableReference._state261420 == AtomicMarkableReference._state && AtomicMarkableReference.pair261420 == AtomicMarkableReference.pair && AtomicMarkableReference._lock261420 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread261420 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue261420 == AtomicMarkableReference.pair_nextValue && Main._state261420 == Main._state && Main._lock261420 == Main._lock && tmp20261420 == tmp20 && tmp19261420 == tmp19 && b261420 == b && result2261420 == result2 && result261420 == result && d261420 == d && x261420 == x && this261420 == this && tid261420 == tid;
 assume $recorded.state261420 == 1;                                                                 
 assert  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (73.46): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(V._state: [V]State,V._lock: [V]Tid,Pair._state: [Pair]State,Pair.reference: [Pair]V,Pair.mark: [Pair]bool,Pair._lock: [Pair]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Pair,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
  true &&                                                                                           
  (forall _i: V  :: _i == V.null <==> isNull(V._state[_i])) &&                                      
  (forall _i: Pair  :: _i == Pair.null <==> isNull(Pair._state[_i])) &&                             
  (forall _i: AtomicMarkableReference  :: _i == AtomicMarkableReference.null <==> isNull(AtomicMarkableReference._state[_i])) &&
  (forall _i: Main  :: _i == Main.null <==> isNull(Main._state[_i])) &&                             
  (forall _i: Pair ::  (isShared(Pair._state[_i]) ==> isSharedAssignable(V._state[Pair.reference[_i]]))) &&
  (forall _i: Pair ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Pair._state[_i],_t) ==> isLocalAssignable(V._state[Pair.reference[_i]], _t)))) &&
  (forall _i: AtomicMarkableReference ::  (isShared(AtomicMarkableReference._state[_i]) ==> isSharedAssignable(Pair._state[AtomicMarkableReference.pair[_i]]))) &&
  (forall _i: AtomicMarkableReference ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(AtomicMarkableReference._state[_i],_t) ==> isLocalAssignable(Pair._state[AtomicMarkableReference.pair[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Pair.reference(t: Tid, u: Tid, v: V, w: V, x: Pair)          
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[x], u);                                                          
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Pair.reference[x] := v;                                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Pair.reference(u: Tid,x: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.5): Pair.reference failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Pair.reference(t: Tid, u: Tid, v: V, w: V, x: Pair)           
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[x], u);                                                          
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Pair.reference[x] := v;                                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Pair.reference(u: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (5.5): Pair.reference failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Pair.reference(t: Tid, u: Tid, v: V, w: V, x: Pair)           
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[x], u);                                                          
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : V;                                                                                
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Pair.reference[x];                                                                     
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Pair.reference[x] := havocValue;                                                                   
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Pair.reference(u: Tid,x: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.5): Pair.reference failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Pair.reference(t: Tid, u: Tid, v: V, w: V, x: Pair)            
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[x], u);                                                          
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : V;                                                                                
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Pair.reference[x];                                                                     
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Pair.reference(u: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (5.5): Pair.reference failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Pair.reference(t: Tid, u: Tid, v: V, w: V, x: Pair)                
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[x], u);                                                          
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Pair.reference(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Pair.reference(u: Tid,x: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.5): Pair.reference failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Pair.reference(t: Tid, u: Tid, v: V, w: V, x: Pair)                 
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[x], u);                                                          
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : V;                                                                                
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Pair.reference[x];                                                                     
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Pair.reference(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Pair.reference[x] := havocValue;                                                                   
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Pair.reference(u: Tid,x: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.5): Pair.reference failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Pair.mark(t: Tid, u: Tid, v: bool, w: bool, x: Pair)         
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[x], u);                                                          
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Pair.mark[x] := v;                                                                                 
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Pair.mark(u: Tid,x: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.5): Pair.mark failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Pair.mark(t: Tid, u: Tid, v: bool, w: bool, x: Pair)          
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[x], u);                                                          
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Pair.mark[x] := v;                                                                                 
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Pair.mark(u: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (6.5): Pair.mark failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Pair.mark(t: Tid, u: Tid, v: bool, w: bool, x: Pair)          
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[x], u);                                                          
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Pair.mark[x];                                                                          
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Pair.mark[x] := havocValue;                                                                        
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Pair.mark(u: Tid,x: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.5): Pair.mark failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Pair.mark(t: Tid, u: Tid, v: bool, w: bool, x: Pair)           
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[x], u);                                                          
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : bool;                                                                             
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Pair.mark[x];                                                                          
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Pair.mark(u: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (6.5): Pair.mark failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Pair.mark(t: Tid, u: Tid, v: bool, w: bool, x: Pair)               
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[x], u);                                                          
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Pair.mark(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Pair.mark(u: Tid,x: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.5): Pair.mark failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Pair.mark(t: Tid, u: Tid, v: bool, w: bool, x: Pair)                
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[x], u);                                                          
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Pair.mark[x];                                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Pair.mark(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Pair.mark[x] := havocValue;                                                                        
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Pair.mark(u: Tid,x: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.5): Pair.mark failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Pair, w: Pair, x: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReference.pair[x] := v;                                                              
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (15.5): AtomicMarkableReference.pair failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Pair, w: Pair, x: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReference.pair[x] := v;                                                              
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (15.5): AtomicMarkableReference.pair failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Pair, w: Pair, x: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Pair;                                                                             
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReference.pair[x];                                                       
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 AtomicMarkableReference.pair[x] := havocValue;                                                     
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (15.5): AtomicMarkableReference.pair failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Pair, w: Pair, x: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Pair;                                                                             
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReference.pair[x];                                                       
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (15.5): AtomicMarkableReference.pair failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Pair, w: Pair, x: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (15.5): AtomicMarkableReference.pair failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Pair, w: Pair, x: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Pair;                                                                             
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == AtomicMarkableReference.pair[x];                                                       
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 AtomicMarkableReference.pair[x] := havocValue;                                                     
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (15.5): AtomicMarkableReference.pair failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Pair.reference.Pair.reference(t: Tid, u: Tid, v: V, w: V, w0: V, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.reference;                                                                           
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.reference[x] := v;                                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to Pair.reference (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Pair.reference is not Write-Write Stable with respect to Pair.reference (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to Pair.reference (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Pair.reference.Pair.reference(t: Tid, u: Tid, v: V, w: V, w0: V, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.reference;                                                                           
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : V;                                                                                      
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var x_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: V;                                                                                      
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var w0_mid: V;                                                                                     
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var v_mid: V;                                                                                      
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Pair.reference[x];                                                                         
 Pair.reference[x] := v;                                                                            
                                                                                                    
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Pair.reference[x] := tmpV;                                                                         
 Pair.reference[y] := w;                                                                            
 _writeByTPost := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to Pair.reference (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Pair.reference.Pair.reference(t: Tid, u: Tid, v: V, w: V, w0: V, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.reference;                                                                           
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : V;                                                                                      
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var x_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: V;                                                                                      
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var w0_mid: V;                                                                                     
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var v_mid: V;                                                                                      
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Pair.reference[x];                                                                         
 Pair.reference[x] := v;                                                                            
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Pair.reference[x] := tmpV;                                                                         
 Pair.reference[y] := w;                                                                            
 _writeByTPost := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to Pair.reference (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to Pair.reference (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Pair.reference.Pair.reference(t: Tid, u: Tid, v: V, w: V, w0: V, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.reference;                                                                           
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Pair.reference(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.reference[y] := w;                                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Pair.reference(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Pair.reference is not Read-Write Stable with respect to Pair.reference (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Pair.reference is not Read-Write Stable with respect to Pair.reference (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Pair.reference is not Read-Write Stable with respect to Pair.reference (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Pair.reference.Pair.reference(t: Tid, u: Tid, v: V, w: V, w0: V, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.reference;                                                                           
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Pair.reference(u: Tid,y: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.reference[x] := v;                                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Pair.reference(u: Tid,y: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Pair.reference is not Write-Read Stable with respect to Pair.reference (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Pair.reference is not Write-Read Stable with respect to Pair.reference (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Pair.reference is not Write-Read Stable with respect to Pair.reference (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Pair.reference.Pair.mark(t: Tid, u: Tid, v: V, w: bool, w0: bool, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.reference;                                                                           
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.reference[x] := v;                                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to Pair.reference (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Pair.mark is not Write-Write Stable with respect to Pair.reference (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to Pair.reference (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Pair.reference.Pair.mark(t: Tid, u: Tid, v: V, w: bool, w0: bool, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.reference;                                                                           
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : V;                                                                                      
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var x_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var v_mid: V;                                                                                      
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Pair.reference[x];                                                                         
 Pair.reference[x] := v;                                                                            
                                                                                                    
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Pair.reference[x] := tmpV;                                                                         
 Pair.mark[y] := w;                                                                                 
 _writeByTPost := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to Pair.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Pair.reference.Pair.mark(t: Tid, u: Tid, v: V, w: bool, w0: bool, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.reference;                                                                           
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : V;                                                                                      
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var x_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var v_mid: V;                                                                                      
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Pair.reference[x];                                                                         
 Pair.reference[x] := v;                                                                            
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Pair.reference[x] := tmpV;                                                                         
 Pair.mark[y] := w;                                                                                 
 _writeByTPost := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to Pair.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to Pair.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Pair.reference.Pair.mark(t: Tid, u: Tid, v: V, w: bool, w0: bool, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.reference;                                                                           
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Pair.reference(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.mark[y] := w;                                                                                 
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Pair.reference(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Pair.reference is not Read-Write Stable with respect to Pair.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Pair.reference is not Read-Write Stable with respect to Pair.mark (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Pair.reference is not Read-Write Stable with respect to Pair.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Pair.reference.Pair.mark(t: Tid, u: Tid, v: V, w: bool, w0: bool, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.reference;                                                                           
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Pair.mark(u: Tid,y: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.reference[x] := v;                                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Pair.mark(u: Tid,y: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Pair.mark is not Write-Read Stable with respect to Pair.reference (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Pair.mark is not Write-Read Stable with respect to Pair.reference (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Pair.mark is not Write-Read Stable with respect to Pair.reference (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Pair.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: V, w: Pair, w0: Pair, x: Pair, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Pair.reference;                                                                           
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.reference[x] := v;                                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.reference (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.reference (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.reference (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Pair.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: V, w: Pair, w0: Pair, x: Pair, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Pair.reference;                                                                           
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : V;                                                                                      
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var w_mid: Pair;                                                                                   
 var x_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var w0_mid: Pair;                                                                                  
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var v_mid: V;                                                                                      
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Pair.reference[x];                                                                         
 Pair.reference[x] := v;                                                                            
                                                                                                    
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Pair.reference[x] := tmpV;                                                                         
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Pair.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: V, w: Pair, w0: Pair, x: Pair, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Pair.reference;                                                                           
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : V;                                                                                      
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var w_mid: Pair;                                                                                   
 var x_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var w0_mid: Pair;                                                                                  
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var v_mid: V;                                                                                      
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Pair.reference[x];                                                                         
 Pair.reference[x] := v;                                                                            
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Pair.reference[x] := tmpV;                                                                         
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Pair.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: V, w: Pair, w0: Pair, x: Pair, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Pair.reference;                                                                           
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Pair.reference(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[y] := w;                                                              
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Pair.reference(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Pair.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Pair.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Pair.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Pair.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: V, w: Pair, w0: Pair, x: Pair, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Pair.reference;                                                                           
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var v_pre: V;                                                                                      
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v_post: V;                                                                                     
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Pair.reference(t: Tid,x: Pair,v: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.reference[x] := v;                                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Pair.reference (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Pair.reference (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Pair.reference (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Pair.mark.Pair.reference(t: Tid, u: Tid, v: bool, w: V, w0: V, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.mark;                                                                                
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.mark[x] := v;                                                                                 
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to Pair.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Pair.reference is not Write-Write Stable with respect to Pair.mark (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to Pair.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Pair.mark.Pair.reference(t: Tid, u: Tid, v: bool, w: V, w0: V, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.mark;                                                                                
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var x_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: V;                                                                                      
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var w0_mid: V;                                                                                     
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Pair.mark[x];                                                                              
 Pair.mark[x] := v;                                                                                 
                                                                                                    
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Pair.mark[x] := tmpV;                                                                              
 Pair.reference[y] := w;                                                                            
 _writeByTPost := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to Pair.reference (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Pair.mark.Pair.reference(t: Tid, u: Tid, v: bool, w: V, w0: V, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.mark;                                                                                
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var x_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: V;                                                                                      
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var w0_mid: V;                                                                                     
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Pair.mark[x];                                                                              
 Pair.mark[x] := v;                                                                                 
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Pair.mark[x] := tmpV;                                                                              
 Pair.reference[y] := w;                                                                            
 _writeByTPost := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to Pair.reference (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to Pair.reference (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Pair.mark.Pair.reference(t: Tid, u: Tid, v: bool, w: V, w0: V, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.mark;                                                                                
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Pair.mark(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.reference[y] := w;                                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Pair.mark(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Pair.mark is not Read-Write Stable with respect to Pair.reference (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Pair.mark is not Read-Write Stable with respect to Pair.reference (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Pair.mark is not Read-Write Stable with respect to Pair.reference (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Pair.mark.Pair.reference(t: Tid, u: Tid, v: bool, w: V, w0: V, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.mark;                                                                                
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Pair.reference(u: Tid,y: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.mark[x] := v;                                                                                 
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Pair.reference(u: Tid,y: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Pair.reference is not Write-Read Stable with respect to Pair.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Pair.reference is not Write-Read Stable with respect to Pair.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Pair.reference is not Write-Read Stable with respect to Pair.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Pair.mark.Pair.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.mark;                                                                                
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.mark[x] := v;                                                                                 
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to Pair.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Pair.mark is not Write-Write Stable with respect to Pair.mark (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to Pair.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Pair.mark.Pair.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.mark;                                                                                
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var x_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var w0_mid: bool;                                                                                  
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Pair.mark[x];                                                                              
 Pair.mark[x] := v;                                                                                 
                                                                                                    
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Pair.mark[x] := tmpV;                                                                              
 Pair.mark[y] := w;                                                                                 
 _writeByTPost := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to Pair.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Pair.mark.Pair.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.mark;                                                                                
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var x_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var w0_mid: bool;                                                                                  
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Pair.mark[x];                                                                              
 Pair.mark[x] := v;                                                                                 
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Pair.mark[x] := tmpV;                                                                              
 Pair.mark[y] := w;                                                                                 
 _writeByTPost := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to Pair.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to Pair.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Pair.mark.Pair.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.mark;                                                                                
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Pair.mark(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.mark[y] := w;                                                                                 
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Pair.mark(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Pair.mark is not Read-Write Stable with respect to Pair.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Pair.mark is not Read-Write Stable with respect to Pair.mark (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Pair.mark is not Read-Write Stable with respect to Pair.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Pair.mark.Pair.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Pair, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(Pair._state[y], u);                                                          
 modifies Pair.mark;                                                                                
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Pair.mark(u: Tid,y: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.mark[x] := v;                                                                                 
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Pair.mark(u: Tid,y: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Pair.mark is not Write-Read Stable with respect to Pair.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Pair.mark is not Write-Read Stable with respect to Pair.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Pair.mark is not Write-Read Stable with respect to Pair.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Pair.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Pair, w0: Pair, x: Pair, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Pair.mark;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.mark[x] := v;                                                                                 
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.mark (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Pair.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Pair, w0: Pair, x: Pair, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Pair.mark;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var w_mid: Pair;                                                                                   
 var x_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var w0_mid: Pair;                                                                                  
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Pair.mark[x];                                                                              
 Pair.mark[x] := v;                                                                                 
                                                                                                    
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Pair.mark[x] := tmpV;                                                                              
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Pair.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Pair, w0: Pair, x: Pair, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Pair.mark;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var w_mid: Pair;                                                                                   
 var x_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var w0_mid: Pair;                                                                                  
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Pair.mark[x];                                                                              
 Pair.mark[x] := v;                                                                                 
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Pair.mark[x] := tmpV;                                                                              
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Pair.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Pair, w0: Pair, x: Pair, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Pair.mark;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Pair.mark(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[y] := w;                                                              
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Pair.mark(t: Tid,x: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Pair.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Pair.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Pair.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Pair.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Pair, w0: Pair, x: Pair, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Pair._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Pair.mark;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: Pair;                                                                                   
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var x_post: Pair;                                                                                  
 var v_post: bool;                                                                                  
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Pair.mark(t: Tid,x: Pair,v: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.mark[x] := v;                                                                                 
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Pair.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Pair.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Pair.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.pair.Pair.reference(t: Tid, u: Tid, v: Pair, w: V, w0: V, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.pair.Pair.reference(t: Tid, u: Tid, v: Pair, w: V, w0: V, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : Pair;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: V;                                                                                      
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Pair;                                                                                   
 var w0_mid: V;                                                                                     
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
                                                                                                    
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Pair.reference[y] := w;                                                                            
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.reference (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.pair.Pair.reference(t: Tid, u: Tid, v: Pair, w: V, w0: V, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : Pair;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: V;                                                                                      
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Pair;                                                                                   
 var w0_mid: V;                                                                                     
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Pair.reference[y] := w;                                                                            
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.reference (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.reference (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.pair.Pair.reference(t: Tid, u: Tid, v: Pair, w: V, w0: V, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.reference[y] := w;                                                                            
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Pair.reference (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Pair.reference (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Pair.reference (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.pair.Pair.reference(t: Tid, u: Tid, v: Pair, w: V, w0: V, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var w0_pre: V;                                                                                     
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w0_post: V;                                                                                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Pair.reference(u: Tid,y: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Pair.reference(u: Tid,y: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Pair.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Pair.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Pair.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.AtomicMarkableReference.pair.Pair.reference(t: Tid, u: Tid, v: Pair, w1: V, w2: V, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpW: V;                                                                                       
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var w1_pre: V;                                                                                     
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w2_pre: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var w2_mid: V;                                                                                     
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Pair;                                                                                   
 var w1_mid: V;                                                                                     
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var w1_post: V;                                                                                    
 var v_post: Pair;                                                                                  
 var w2_post: V;                                                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w1: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Pair.reference[y];                                                                         
 Pair.reference[y] := w1;                                                                           
                                                                                                    
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Pair.reference(u: Tid,y: Pair,w2: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Pair.reference[y] := tmpW;                                                                         
                                                                                                    
 AtomicMarkableReference.pair[x] := v;                                                              
 Pair.reference[y] := w1;                                                                           
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Pair.reference(u: Tid,y: Pair,w2: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.AtomicMarkableReference.pair.Pair.reference(t: Tid, u: Tid, v1: Pair, v2: Pair, w: V, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.reference;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV: Pair;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var v2_pre: Pair;                                                                                  
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var v1_pre: Pair;                                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: V;                                                                                      
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var v1_mid: Pair;                                                                                  
 var u_mid: Tid;                                                                                    
 var w_mid: V;                                                                                      
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var v2_mid: Pair;                                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v2_post: Pair;                                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w_post: V;                                                                                     
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v1_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.reference(u: Tid,y: Pair,w: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v1;                                                             
 _writeByTAfterT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v2: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 AtomicMarkableReference.pair[x] := tmpV;                                                           
                                                                                                    
 Pair.reference[y] := w;                                                                            
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v1: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 AtomicMarkableReference.pair[x] := v1;                                                             
 _writeByTAfterUAndT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v2: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.pair.Pair.mark(t: Tid, u: Tid, v: Pair, w: bool, w0: bool, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.pair.Pair.mark(t: Tid, u: Tid, v: Pair, w: bool, w0: bool, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Pair;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Pair;                                                                                   
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
                                                                                                    
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Pair.mark[y] := w;                                                                                 
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.pair.Pair.mark(t: Tid, u: Tid, v: Pair, w: bool, w0: bool, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Pair;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Pair;                                                                                   
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Pair.mark[y] := w;                                                                                 
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.pair.Pair.mark(t: Tid, u: Tid, v: Pair, w: bool, w0: bool, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Pair.mark[y] := w;                                                                                 
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Pair.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Pair.mark (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Pair.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.pair.Pair.mark(t: Tid, u: Tid, v: Pair, w: bool, w0: bool, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Pair.mark(u: Tid,y: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Pair.mark(u: Tid,y: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Pair.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Pair.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Pair.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.AtomicMarkableReference.pair.Pair.mark(t: Tid, u: Tid, v: Pair, w1: bool, w2: bool, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpW: bool;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var w2_pre: bool;                                                                                  
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var w1_pre: bool;                                                                                  
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Pair;                                                                                   
 var w1_mid: bool;                                                                                  
 var w2_mid: bool;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var w2_post: bool;                                                                                 
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var w1_post: bool;                                                                                 
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w1: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Pair.mark[y];                                                                              
 Pair.mark[y] := w1;                                                                                
                                                                                                    
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Pair.mark(u: Tid,y: Pair,w2: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Pair.mark[y] := tmpW;                                                                              
                                                                                                    
 AtomicMarkableReference.pair[x] := v;                                                              
 Pair.mark[y] := w1;                                                                                
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Pair.mark(u: Tid,y: Pair,w2: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.AtomicMarkableReference.pair.Pair.mark(t: Tid, u: Tid, v1: Pair, v2: Pair, w: bool, x: AtomicMarkableReference, y: Pair)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Pair._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Pair.mark;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV: Pair;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var V._state_pre: [V]State;                                                                        
 var w_pre: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var y_pre: Pair;                                                                                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Pair.reference_pre: [Pair]V;                                                                   
 var v2_pre: Pair;                                                                                  
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var v1_pre: Pair;                                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var v1_mid: Pair;                                                                                  
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var v2_mid: Pair;                                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var y_mid: Pair;                                                                                   
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v2_post: Pair;                                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: Pair;                                                                                  
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v1_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Pair.mark(u: Tid,y: Pair,w: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v1;                                                             
 _writeByTAfterT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v2: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 AtomicMarkableReference.pair[x] := tmpV;                                                           
                                                                                                    
 Pair.mark[y] := w;                                                                                 
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v1: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 AtomicMarkableReference.pair[x] := v1;                                                             
 _writeByTAfterUAndT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v2: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Pair, w: Pair, w0: Pair, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Pair, w: Pair, w0: Pair, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Pair;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var w_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var w0_mid: Pair;                                                                                  
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
                                                                                                    
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Pair, w: Pair, w0: Pair, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Pair;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var w_mid: Pair;                                                                                   
 var u_mid: Tid;                                                                                    
 var w0_mid: Pair;                                                                                  
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Pair, w: Pair, w0: Pair, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[y] := w;                                                              
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Pair, w: Pair, w0: Pair, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var w0_pre: Pair;                                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var w0_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Pair, w1: Pair, w2: Pair, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpW: Pair;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var V._state_pre: [V]State;                                                                        
 var v_pre: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var w2_pre: Pair;                                                                                  
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var w1_pre: Pair;                                                                                  
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Pair;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var w2_mid: Pair;                                                                                  
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var Pair._state_mid: [Pair]State;                                                                  
 var w1_mid: Pair;                                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var w2_post: Pair;                                                                                 
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var w1_post: Pair;                                                                                 
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v_post: Pair;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w1: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := AtomicMarkableReference.pair[y];                                                           
 AtomicMarkableReference.pair[y] := w1;                                                             
                                                                                                    
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w2: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 AtomicMarkableReference.pair[y] := tmpW;                                                           
                                                                                                    
 AtomicMarkableReference.pair[x] := v;                                                              
 AtomicMarkableReference.pair[y] := w1;                                                             
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w2: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v1: Pair, v2: Pair, w: Pair, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV: Pair;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var w_pre: Pair;                                                                                   
 var V._state_pre: [V]State;                                                                        
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var V._lock_pre: [V]Tid;                                                                           
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Pair.reference_pre: [Pair]V;                                                                   
 var v2_pre: Pair;                                                                                  
 var Pair._state_pre: [Pair]State;                                                                  
 var Pair.mark_pre: [Pair]bool;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                               
 var v1_pre: Pair;                                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Pair._lock_pre: [Pair]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                     
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var V._lock_mid: [V]Tid;                                                                           
 var Pair._lock_mid: [Pair]Tid;                                                                     
 var t_mid: Tid;                                                                                    
 var w_mid: Pair;                                                                                   
 var v1_mid: Pair;                                                                                  
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var Pair.reference_mid: [Pair]V;                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Pair;                     
 var Pair.mark_mid: [Pair]bool;                                                                     
 var v2_mid: Pair;                                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Pair;                               
 var $pc_mid: Phase;                                                                                
 var V._state_mid: [V]State;                                                                        
 var Pair._state_mid: [Pair]State;                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var V._state_post: [V]State;                                                                       
 var v2_post: Pair;                                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var w_post: Pair;                                                                                  
 var y_post: AtomicMarkableReference;                                                               
 var V._lock_post: [V]Tid;                                                                          
 var t_post: Tid;                                                                                   
 var Pair.mark_post: [Pair]bool;                                                                    
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                    
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                              
 var Pair._state_post: [Pair]State;                                                                 
 var Main._lock_post: [Main]Tid;                                                                    
 var Pair.reference_post: [Pair]V;                                                                  
 var Pair._lock_post: [Pair]Tid;                                                                    
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var v1_post: Pair;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v1;                                                             
 _writeByTAfterT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v2: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 AtomicMarkableReference.pair[x] := tmpV;                                                           
                                                                                                    
 AtomicMarkableReference.pair[y] := w;                                                              
 assume V._state_mid == V._state && V._lock_mid == V._lock && Pair._state_mid == Pair._state && Pair.reference_mid == Pair.reference && Pair.mark_mid == Pair.mark && Pair._lock_mid == Pair._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v1: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 AtomicMarkableReference.pair[x] := v1;                                                             
 _writeByTAfterUAndT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v2: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
requires ValidTid(tid);                                                                             
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
modifies V._state;                                                                                  
modifies V._lock;                                                                                   
modifies Pair._state;                                                                               
modifies Pair.reference;                                                                            
modifies Pair.mark;                                                                                 
modifies Pair._lock;                                                                                
modifies AtomicMarkableReference._state;                                                            
modifies AtomicMarkableReference.pair;                                                              
modifies AtomicMarkableReference._lock;                                                             
modifies AtomicMarkableReference.pair_nextThread;                                                   
modifies AtomicMarkableReference.pair_nextValue;                                                    
modifies Main._state;                                                                               
modifies Main._lock;                                                                                
ensures StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
ensures Y(tid , old(V._state), old(V._lock), old(Pair._state), old(Pair.reference), old(Pair.mark), old(Pair._lock), old(AtomicMarkableReference._state), old(AtomicMarkableReference.pair), old(AtomicMarkableReference._lock), old(AtomicMarkableReference.pair_nextThread), old(AtomicMarkableReference.pair_nextValue), old(Main._state), old(Main._lock) , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
ensures  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// V._lock:                                                                                         
                                                                                                    
function {:inline} Y_V._lock(tid : Tid, this: V, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(V._state[this], tid) && leq(m#moverPath(ReadEval.V._lock(tid: Tid,this: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)), _R)) ==> (V._lock[this] == newValue))
 &&(((V._lock[this]==tid)==(newValue==tid)))                                                        
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_V._lock(tid : Tid, this: V, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_V._lock.Subsumes.W(tid : Tid, u : Tid, this: V, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var newValue_yield: Tid;                                                                            
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var this_yield: V;                                                                                  
var V._lock_yield: [V]Tid;                                                                          
var u_yield: Tid;                                                                                   
var Pair.reference_yield: [Pair]V;                                                                  
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(V._state[this], tid);                                                          
 assume isAccessible(V._state[this], u);                                                            
 assume !isError(m#moverPath(WriteEval.V._lock(u: Tid,this: V,newValue: Tid,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.V._lock(tid: Tid,this: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)), _N);
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_V._lock(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_V._lock.Reflexive(tid : Tid, this: V , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var this_yield: V;                                                                                  
var V._lock_yield: [V]Tid;                                                                          
var Pair.reference_yield: [Pair]V;                                                                  
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(V._state[this], tid);                                                          
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_V._lock(tid, this, V._lock[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_V._lock.Transitive(tid : Tid, this: V, newValue : Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid , V._state_p: [V]State, V._lock_p: [V]Tid, Pair._state_p: [Pair]State, Pair.reference_p: [Pair]V, Pair.mark_p: [Pair]bool, Pair._lock_p: [Pair]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Pair, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires StateInvariant(V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (2.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var V._state_pre: [V]State;                                                                         
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var V._lock_pre: [V]Tid;                                                                            
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Pair.reference_pre: [Pair]V;                                                                    
var Pair._state_pre: [Pair]State;                                                                   
var Pair.mark_pre: [Pair]bool;                                                                      
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                                
var tid_pre: Tid;                                                                                   
var Pair._lock_pre: [Pair]Tid;                                                                      
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                      
var this_pre: V;                                                                                    
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var V._state_post: [V]State;                                                                        
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var V._lock_post: [V]Tid;                                                                           
var Pair.mark_post: [Pair]bool;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                     
var tid_post: Tid;                                                                                  
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                               
var Pair._state_post: [Pair]State;                                                                  
var Main._lock_post: [Main]Tid;                                                                     
var Pair.reference_post: [Pair]V;                                                                   
var Pair._lock_post: [Pair]Tid;                                                                     
var this_post: V;                                                                                   
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
var newValue_post: Tid;                                                                             
                                                                                                    
assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(V._state[this], tid);                                                          
 assume Y(tid , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 assume Y_V._lock(tid, this, newValue , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
assume V._state_post == V._state_p && V._lock_post == V._lock_p && Pair._state_post == Pair._state_p && Pair.reference_post == Pair.reference_p && Pair.mark_post == Pair.mark_p && Pair._lock_post == Pair._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread_p && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_V._lock(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
// Pair.reference:                                                                                  
                                                                                                    
function {:inline} Y_Pair.reference(tid : Tid, this: Pair, newValue: V , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Pair._state[this], tid) && leq(m#moverPath(ReadEval.Pair.reference(tid: Tid,this: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)), _R)) ==> (Pair.reference[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Pair.reference(tid : Tid, this: Pair, newValue: V , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Pair.reference.Subsumes.W(tid : Tid, u : Tid, this: Pair, newValue: V , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var this_yield: Pair;                                                                               
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var V._lock_yield: [V]Tid;                                                                          
var u_yield: Tid;                                                                                   
var Pair.reference_yield: [Pair]V;                                                                  
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var newValue_yield: V;                                                                              
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Pair._state[this], tid);                                                       
 assume isAccessible(Pair._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Pair.reference(u: Tid,this: Pair,newValue: V,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)));
                                                                                                    
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Pair.reference(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Pair.reference.Reflexive(tid : Tid, this: Pair , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var this_yield: Pair;                                                                               
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var V._lock_yield: [V]Tid;                                                                          
var Pair.reference_yield: [Pair]V;                                                                  
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Pair._state[this], tid);                                                       
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Pair.reference(tid, this, Pair.reference[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Pair.reference.Transitive(tid : Tid, this: Pair, newValue : V , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid , V._state_p: [V]State, V._lock_p: [V]Tid, Pair._state_p: [Pair]State, Pair.reference_p: [Pair]V, Pair.mark_p: [Pair]bool, Pair._lock_p: [Pair]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Pair, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires StateInvariant(V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (5.29): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var V._state_pre: [V]State;                                                                         
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var V._lock_pre: [V]Tid;                                                                            
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Pair.reference_pre: [Pair]V;                                                                    
var Pair._state_pre: [Pair]State;                                                                   
var Pair.mark_pre: [Pair]bool;                                                                      
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                                
var this_pre: Pair;                                                                                 
var tid_pre: Tid;                                                                                   
var Pair._lock_pre: [Pair]Tid;                                                                      
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                      
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: V;                                                                                
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var V._state_post: [V]State;                                                                        
var this_post: Pair;                                                                                
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var V._lock_post: [V]Tid;                                                                           
var Pair.mark_post: [Pair]bool;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                     
var tid_post: Tid;                                                                                  
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                               
var newValue_post: V;                                                                               
var Pair._state_post: [Pair]State;                                                                  
var Main._lock_post: [Main]Tid;                                                                     
var Pair.reference_post: [Pair]V;                                                                   
var Pair._lock_post: [Pair]Tid;                                                                     
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
                                                                                                    
assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Pair._state[this], tid);                                                       
 assume Y(tid , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 assume Y_Pair.reference(tid, this, newValue , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
assume V._state_post == V._state_p && V._lock_post == V._lock_p && Pair._state_post == Pair._state_p && Pair.reference_post == Pair.reference_p && Pair.mark_post == Pair.mark_p && Pair._lock_post == Pair._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread_p && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Pair.reference(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
// Pair.mark:                                                                                       
                                                                                                    
function {:inline} Y_Pair.mark(tid : Tid, this: Pair, newValue: bool , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Pair._state[this], tid) && leq(m#moverPath(ReadEval.Pair.mark(tid: Tid,this: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)), _R)) ==> (Pair.mark[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Pair.mark(tid : Tid, this: Pair, newValue: bool , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Pair.mark.Subsumes.W(tid : Tid, u : Tid, this: Pair, newValue: bool , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var newValue_yield: bool;                                                                           
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var this_yield: Pair;                                                                               
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var V._lock_yield: [V]Tid;                                                                          
var u_yield: Tid;                                                                                   
var Pair.reference_yield: [Pair]V;                                                                  
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Pair._state[this], tid);                                                       
 assume isAccessible(Pair._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Pair.mark(u: Tid,this: Pair,newValue: bool,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)));
                                                                                                    
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Pair.mark(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Pair.mark.Reflexive(tid : Tid, this: Pair , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var this_yield: Pair;                                                                               
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var V._lock_yield: [V]Tid;                                                                          
var Pair.reference_yield: [Pair]V;                                                                  
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Pair._state[this], tid);                                                       
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Pair.mark(tid, this, Pair.mark[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Pair.mark.Transitive(tid : Tid, this: Pair, newValue : bool , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid , V._state_p: [V]State, V._lock_p: [V]Tid, Pair._state_p: [Pair]State, Pair.reference_p: [Pair]V, Pair.mark_p: [Pair]bool, Pair._lock_p: [Pair]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Pair, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires StateInvariant(V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (6.32): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var V._state_pre: [V]State;                                                                         
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var V._lock_pre: [V]Tid;                                                                            
var newValue_pre: bool;                                                                             
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Pair.reference_pre: [Pair]V;                                                                    
var Pair._state_pre: [Pair]State;                                                                   
var Pair.mark_pre: [Pair]bool;                                                                      
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                                
var this_pre: Pair;                                                                                 
var tid_pre: Tid;                                                                                   
var Pair._lock_pre: [Pair]Tid;                                                                      
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                      
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var V._state_post: [V]State;                                                                        
var this_post: Pair;                                                                                
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var V._lock_post: [V]Tid;                                                                           
var Pair.mark_post: [Pair]bool;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                     
var tid_post: Tid;                                                                                  
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                               
var Pair._state_post: [Pair]State;                                                                  
var Main._lock_post: [Main]Tid;                                                                     
var Pair.reference_post: [Pair]V;                                                                   
var Pair._lock_post: [Pair]Tid;                                                                     
var newValue_post: bool;                                                                            
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
                                                                                                    
assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Pair._state[this], tid);                                                       
 assume Y(tid , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 assume Y_Pair.mark(tid, this, newValue , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
assume V._state_post == V._state_p && V._lock_post == V._lock_p && Pair._state_post == Pair._state_p && Pair.reference_post == Pair.reference_p && Pair.mark_post == Pair.mark_p && Pair._lock_post == Pair._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread_p && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Pair.mark(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
// Pair._lock:                                                                                      
                                                                                                    
function {:inline} Y_Pair._lock(tid : Tid, this: Pair, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Pair._state[this], tid) && leq(m#moverPath(ReadEval.Pair._lock(tid: Tid,this: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)), _R)) ==> (Pair._lock[this] == newValue))
 &&(((Pair._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Pair._lock(tid : Tid, this: Pair, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Pair._lock.Subsumes.W(tid : Tid, u : Tid, this: Pair, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var newValue_yield: Tid;                                                                            
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var this_yield: Pair;                                                                               
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var V._lock_yield: [V]Tid;                                                                          
var u_yield: Tid;                                                                                   
var Pair.reference_yield: [Pair]V;                                                                  
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Pair._state[this], tid);                                                       
 assume isAccessible(Pair._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Pair._lock(u: Tid,this: Pair,newValue: Tid,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.Pair._lock(tid: Tid,this: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)), _N);
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Pair._lock(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Pair._lock.Reflexive(tid : Tid, this: Pair , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var this_yield: Pair;                                                                               
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var V._lock_yield: [V]Tid;                                                                          
var Pair.reference_yield: [Pair]V;                                                                  
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Pair._state[this], tid);                                                       
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Pair._lock(tid, this, Pair._lock[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Pair._lock.Transitive(tid : Tid, this: Pair, newValue : Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid , V._state_p: [V]State, V._lock_p: [V]Tid, Pair._state_p: [Pair]State, Pair.reference_p: [Pair]V, Pair.mark_p: [Pair]bool, Pair._lock_p: [Pair]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Pair, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires StateInvariant(V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (4.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var V._state_pre: [V]State;                                                                         
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var V._lock_pre: [V]Tid;                                                                            
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Pair.reference_pre: [Pair]V;                                                                    
var Pair._state_pre: [Pair]State;                                                                   
var Pair.mark_pre: [Pair]bool;                                                                      
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                                
var this_pre: Pair;                                                                                 
var tid_pre: Tid;                                                                                   
var Pair._lock_pre: [Pair]Tid;                                                                      
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                      
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var V._state_post: [V]State;                                                                        
var this_post: Pair;                                                                                
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var V._lock_post: [V]Tid;                                                                           
var Pair.mark_post: [Pair]bool;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                     
var tid_post: Tid;                                                                                  
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                               
var Pair._state_post: [Pair]State;                                                                  
var Main._lock_post: [Main]Tid;                                                                     
var Pair.reference_post: [Pair]V;                                                                   
var Pair._lock_post: [Pair]Tid;                                                                     
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
var newValue_post: Tid;                                                                             
                                                                                                    
assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Pair._state[this], tid);                                                       
 assume Y(tid , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 assume Y_Pair._lock(tid, this, newValue , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
assume V._state_post == V._state_p && V._lock_post == V._lock_p && Pair._state_post == Pair._state_p && Pair.reference_post == Pair.reference_p && Pair.mark_post == Pair.mark_p && Pair._lock_post == Pair._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread_p && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Pair._lock(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
// AtomicMarkableReference.pair:                                                                    
                                                                                                    
function {:inline} Y_AtomicMarkableReference.pair(tid : Tid, this: AtomicMarkableReference, newValue: Pair , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)), _R)) ==> (AtomicMarkableReference.pair[this] == newValue))
 &&(((AtomicMarkableReference.pair[this]!=newValue)==>!(isShared(Pair._state[newValue]))))          
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference.pair(tid : Tid, this: AtomicMarkableReference, newValue: Pair , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.pair.Subsumes.W(tid : Tid, u : Tid, this: AtomicMarkableReference, newValue: Pair , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var newValue_yield: Pair;                                                                           
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var V._lock_yield: [V]Tid;                                                                          
var u_yield: Tid;                                                                                   
var Pair.reference_yield: [Pair]V;                                                                  
var this_yield: AtomicMarkableReference;                                                            
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume isAccessible(AtomicMarkableReference._state[this], u);                                      
 assume !isError(m#moverPath(WriteEval.AtomicMarkableReference.pair(u: Tid,this: AtomicMarkableReference,newValue: Pair,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)));
                                                                                                    
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference.pair(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.pair.Reflexive(tid : Tid, this: AtomicMarkableReference , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var V._lock_yield: [V]Tid;                                                                          
var Pair.reference_yield: [Pair]V;                                                                  
var this_yield: AtomicMarkableReference;                                                            
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference.pair(tid, this, AtomicMarkableReference.pair[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.pair.Transitive(tid : Tid, this: AtomicMarkableReference, newValue : Pair , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid , V._state_p: [V]State, V._lock_p: [V]Tid, Pair._state_p: [Pair]State, Pair.reference_p: [Pair]V, Pair.mark_p: [Pair]bool, Pair._lock_p: [Pair]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Pair, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires StateInvariant(V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (15.40): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var V._state_pre: [V]State;                                                                         
var this_pre: AtomicMarkableReference;                                                              
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var V._lock_pre: [V]Tid;                                                                            
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Pair.reference_pre: [Pair]V;                                                                    
var Pair._state_pre: [Pair]State;                                                                   
var newValue_pre: Pair;                                                                             
var Pair.mark_pre: [Pair]bool;                                                                      
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                                
var tid_pre: Tid;                                                                                   
var Pair._lock_pre: [Pair]Tid;                                                                      
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                      
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var V._state_post: [V]State;                                                                        
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var V._lock_post: [V]Tid;                                                                           
var Pair.mark_post: [Pair]bool;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                     
var tid_post: Tid;                                                                                  
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                               
var this_post: AtomicMarkableReference;                                                             
var newValue_post: Pair;                                                                            
var Pair._state_post: [Pair]State;                                                                  
var Main._lock_post: [Main]Tid;                                                                     
var Pair.reference_post: [Pair]V;                                                                   
var Pair._lock_post: [Pair]Tid;                                                                     
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
                                                                                                    
assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume Y(tid , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 assume Y_AtomicMarkableReference.pair(tid, this, newValue , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
assume V._state_post == V._state_p && V._lock_post == V._lock_p && Pair._state_post == Pair._state_p && Pair.reference_post == Pair.reference_p && Pair.mark_post == Pair.mark_p && Pair._lock_post == Pair._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread_p && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_AtomicMarkableReference.pair(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Check_AtomicMarkableReference.pair.ABAFree(tid : Tid, this: AtomicMarkableReference, A : Pair, B : Pair)
 modifies AtomicMarkableReference.pair;                                                             
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires AtomicMarkableReference.pair[this] == A;                                                  
 requires isAccessible(AtomicMarkableReference._state[this], tid);                                  
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (15.40): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var A_pre: Pair;                                                                                    
var V._state_pre: [V]State;                                                                         
var this_pre: AtomicMarkableReference;                                                              
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var V._lock_pre: [V]Tid;                                                                            
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Pair.reference_pre: [Pair]V;                                                                    
var Pair._state_pre: [Pair]State;                                                                   
var B_pre: Pair;                                                                                    
var Pair.mark_pre: [Pair]bool;                                                                      
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                                
var tid_pre: Tid;                                                                                   
var Pair._lock_pre: [Pair]Tid;                                                                      
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                      
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var V._state_post: [V]State;                                                                        
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var A_post: Pair;                                                                                   
var V._lock_post: [V]Tid;                                                                           
var Pair.mark_post: [Pair]bool;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                     
var tid_post: Tid;                                                                                  
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                               
var this_post: AtomicMarkableReference;                                                             
var Pair._state_post: [Pair]State;                                                                  
var Main._lock_post: [Main]Tid;                                                                     
var Pair.reference_post: [Pair]V;                                                                   
var Pair._lock_post: [Pair]Tid;                                                                     
var B_post: Pair;                                                                                   
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
                                                                                                    
assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && B_pre == B && A_pre == A && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume Y_AtomicMarkableReference.pair(tid, this, B , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 assume A != B;                                                                                     
AtomicMarkableReference.pair[this] := B;                                                            
assume V._state_post == V._state && V._lock_post == V._lock && Pair._state_post == Pair._state && Pair.reference_post == Pair.reference && Pair.mark_post == Pair.mark && Pair._lock_post == Pair._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && Main._state_post == Main._state && Main._lock_post == Main._lock && B_post == B && A_post == A && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert !(Y_AtomicMarkableReference.pair(tid, this, A , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock));
}                                                                                                   
// AtomicMarkableReference._lock:                                                                   
                                                                                                    
function {:inline} Y_AtomicMarkableReference._lock(tid : Tid, this: AtomicMarkableReference, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference._lock(tid: Tid,this: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)), _R)) ==> (AtomicMarkableReference._lock[this] == newValue))
 &&(((AtomicMarkableReference._lock[this]==tid)==(newValue==tid)))                                  
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference._lock(tid : Tid, this: AtomicMarkableReference, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference._lock.Subsumes.W(tid : Tid, u : Tid, this: AtomicMarkableReference, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var newValue_yield: Tid;                                                                            
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var V._lock_yield: [V]Tid;                                                                          
var u_yield: Tid;                                                                                   
var Pair.reference_yield: [Pair]V;                                                                  
var this_yield: AtomicMarkableReference;                                                            
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume isAccessible(AtomicMarkableReference._state[this], u);                                      
 assume !isError(m#moverPath(WriteEval.AtomicMarkableReference._lock(u: Tid,this: AtomicMarkableReference,newValue: Tid,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.AtomicMarkableReference._lock(tid: Tid,this: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)), _N);
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference._lock(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference._lock.Reflexive(tid : Tid, this: AtomicMarkableReference , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var V._lock_yield: [V]Tid;                                                                          
var Pair.reference_yield: [Pair]V;                                                                  
var this_yield: AtomicMarkableReference;                                                            
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference._lock(tid, this, AtomicMarkableReference._lock[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference._lock.Transitive(tid : Tid, this: AtomicMarkableReference, newValue : Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid , V._state_p: [V]State, V._lock_p: [V]Tid, Pair._state_p: [Pair]State, Pair.reference_p: [Pair]V, Pair.mark_p: [Pair]bool, Pair._lock_p: [Pair]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Pair, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires StateInvariant(V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (13.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var V._state_pre: [V]State;                                                                         
var this_pre: AtomicMarkableReference;                                                              
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var V._lock_pre: [V]Tid;                                                                            
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Pair.reference_pre: [Pair]V;                                                                    
var Pair._state_pre: [Pair]State;                                                                   
var Pair.mark_pre: [Pair]bool;                                                                      
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                                
var tid_pre: Tid;                                                                                   
var Pair._lock_pre: [Pair]Tid;                                                                      
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                      
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var V._state_post: [V]State;                                                                        
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var V._lock_post: [V]Tid;                                                                           
var Pair.mark_post: [Pair]bool;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                     
var tid_post: Tid;                                                                                  
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                               
var this_post: AtomicMarkableReference;                                                             
var Pair._state_post: [Pair]State;                                                                  
var Main._lock_post: [Main]Tid;                                                                     
var Pair.reference_post: [Pair]V;                                                                   
var Pair._lock_post: [Pair]Tid;                                                                     
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
var newValue_post: Tid;                                                                             
                                                                                                    
assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume Y(tid , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 assume Y_AtomicMarkableReference._lock(tid, this, newValue , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
assume V._state_post == V._state_p && V._lock_post == V._lock_p && Pair._state_post == Pair._state_p && Pair.reference_post == Pair.reference_p && Pair.mark_post == Pair.mark_p && Pair._lock_post == Pair._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread_p && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_AtomicMarkableReference._lock(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
// AtomicMarkableReference.pair_nextThread:                                                         
                                                                                                    
function {:inline} Y_AtomicMarkableReference.pair_nextThread(tid : Tid, this: AtomicMarkableReference, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)), _R)) ==> (AtomicMarkableReference.pair_nextThread[this] == newValue))
 &&(((AtomicMarkableReference.pair_nextThread[this]==tid)==>(newValue==tid)))                       
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference.pair_nextThread(tid : Tid, this: AtomicMarkableReference, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// AtomicMarkableReference.pair_nextValue:                                                          
                                                                                                    
function {:inline} Y_AtomicMarkableReference.pair_nextValue(tid : Tid, this: AtomicMarkableReference, newValue: Pair , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this: AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)), _R)) ==> (AtomicMarkableReference.pair_nextValue[this] == newValue))
 &&(((AtomicMarkableReference.pair_nextThread[this]==tid)==>(newValue==AtomicMarkableReference.pair_nextValue[this])))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference.pair_nextValue(tid : Tid, this: AtomicMarkableReference, newValue: Pair , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// Main._lock:                                                                                      
                                                                                                    
function {:inline} Y_Main._lock(tid : Tid, this: Main, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Main._state[this], tid) && leq(m#moverPath(ReadEval.Main._lock(tid: Tid,this: Main,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)), _R)) ==> (Main._lock[this] == newValue))
 &&(((Main._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Main._lock(tid : Tid, this: Main, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Main._lock.Subsumes.W(tid : Tid, u : Tid, this: Main, newValue: Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var newValue_yield: Tid;                                                                            
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var this_yield: Main;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var V._lock_yield: [V]Tid;                                                                          
var u_yield: Tid;                                                                                   
var Pair.reference_yield: [Pair]V;                                                                  
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Main._state[this], tid);                                                       
 assume isAccessible(Main._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Main._lock(u: Tid,this: Main,newValue: Tid,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.Main._lock(tid: Tid,this: Main,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock)), _N);
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Main._lock(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Main._lock.Reflexive(tid : Tid, this: Main , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Pair;                    
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Pair._state_yield: [Pair]State;                                                                 
var $pc_yield: Phase;                                                                               
var this_yield: Main;                                                                               
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Pair;                              
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var V._lock_yield: [V]Tid;                                                                          
var Pair.reference_yield: [Pair]V;                                                                  
var Pair._lock_yield: [Pair]Tid;                                                                    
var Pair.mark_yield: [Pair]bool;                                                                    
var V._state_yield: [V]State;                                                                       
var Main._state_yield: [Main]State;                                                                 
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Main._state[this], tid);                                                       
assume V._state_yield == V._state && V._lock_yield == V._lock && Pair._state_yield == Pair._state && Pair.reference_yield == Pair.reference && Pair.mark_yield == Pair.mark && Pair._lock_yield == Pair._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Main._lock(tid, this, Main._lock[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Main._lock.Transitive(tid : Tid, this: Main, newValue : Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid , V._state_p: [V]State, V._lock_p: [V]Tid, Pair._state_p: [Pair]State, Pair.reference_p: [Pair]V, Pair.mark_p: [Pair]bool, Pair._lock_p: [Pair]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Pair, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
 requires StateInvariant(V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.252911(tid: Tid,_this : AtomicMarkableReference,V._state,V._lock,Pair._state,Pair.reference,Pair.mark,Pair._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue,Main._state,Main._lock));       // (70.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var V._state_pre: [V]State;                                                                         
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var V._lock_pre: [V]Tid;                                                                            
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Pair.reference_pre: [Pair]V;                                                                    
var this_pre: Main;                                                                                 
var Pair._state_pre: [Pair]State;                                                                   
var Pair.mark_pre: [Pair]bool;                                                                      
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Pair;                                
var tid_pre: Tid;                                                                                   
var Pair._lock_pre: [Pair]Tid;                                                                      
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Pair;                      
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var V._state_post: [V]State;                                                                        
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var this_post: Main;                                                                                
var $recorded.state_post: int;                                                                      
var V._lock_post: [V]Tid;                                                                           
var Pair.mark_post: [Pair]bool;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Pair;                     
var tid_post: Tid;                                                                                  
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Pair;                               
var Pair._state_post: [Pair]State;                                                                  
var Main._lock_post: [Main]Tid;                                                                     
var Pair.reference_post: [Pair]V;                                                                   
var Pair._lock_post: [Pair]Tid;                                                                     
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
var newValue_post: Tid;                                                                             
                                                                                                    
assume V._state_pre == V._state && V._lock_pre == V._lock && Pair._state_pre == Pair._state && Pair.reference_pre == Pair.reference && Pair.mark_pre == Pair.mark && Pair._lock_pre == Pair._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Main._state[this], tid);                                                       
 assume Y(tid , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
 assume Y_Main._lock(tid, this, newValue , V._state_p, V._lock_p, Pair._state_p, Pair.reference_p, Pair.mark_p, Pair._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p, Main._state_p, Main._lock_p);
assume V._state_post == V._state_p && V._lock_post == V._lock_p && Pair._state_post == Pair._state_p && Pair.reference_post == Pair.reference_p && Pair.mark_post == Pair.mark_p && Pair._lock_post == Pair._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread_p && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Main._lock(tid, this, newValue , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , V._state: [V]State, V._lock: [V]Tid, Pair._state: [Pair]State, Pair.reference: [Pair]V, Pair.mark: [Pair]bool, Pair._lock: [Pair]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Pair, Main._state: [Main]State, Main._lock: [Main]Tid , V._state_p: [V]State, V._lock_p: [V]Tid, Pair._state_p: [Pair]State, Pair.reference_p: [Pair]V, Pair.mark_p: [Pair]bool, Pair._lock_p: [Pair]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Pair, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Pair, Main._state_p: [Main]State, Main._lock_p: [Main]Tid): bool
{                                                                                                   
 (forall this: V :: Y_V._lock(tid : Tid, this, V._lock_p[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock))
 && (forall this: Pair :: Y_Pair.reference(tid : Tid, this, Pair.reference_p[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock))
 && (forall this: Pair :: Y_Pair.mark(tid : Tid, this, Pair.mark_p[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock))
 && (forall this: Pair :: Y_Pair._lock(tid : Tid, this, Pair._lock_p[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference.pair(tid : Tid, this, AtomicMarkableReference.pair_p[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference._lock(tid : Tid, this, AtomicMarkableReference._lock_p[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference.pair_nextThread(tid : Tid, this, AtomicMarkableReference.pair_nextThread_p[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference.pair_nextValue(tid : Tid, this, AtomicMarkableReference.pair_nextValue_p[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock))
 && (forall this: Main :: Y_Main._lock(tid : Tid, this, Main._lock_p[this] , V._state, V._lock, Pair._state, Pair.reference, Pair.mark, Pair._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue, Main._state, Main._lock))
 && (forall _i : V :: isShared(V._state[_i]) ==> isShared(V._state_p[_i]))                          
 && (forall _i : V :: isLocal(V._state[_i], tid) <==> isLocal(V._state_p[_i], tid))                 
 && (forall _i : Pair :: isShared(Pair._state[_i]) ==> isShared(Pair._state_p[_i]))                 
 && (forall _i : Pair :: isLocal(Pair._state[_i], tid) <==> isLocal(Pair._state_p[_i], tid))        
 && (forall _i : AtomicMarkableReference :: isShared(AtomicMarkableReference._state[_i]) ==> isShared(AtomicMarkableReference._state_p[_i]))
 && (forall _i : AtomicMarkableReference :: isLocal(AtomicMarkableReference._state[_i], tid) <==> isLocal(AtomicMarkableReference._state_p[_i], tid))
 && (forall _i : Main :: isShared(Main._state[_i]) ==> isShared(Main._state_p[_i]))                 
 && (forall _i : Main :: isLocal(Main._state[_i], tid) <==> isLocal(Main._state_p[_i], tid))        
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 2794.1-5047.2: (Method:72.5)
// 2811.1-2811.24: (72.5): Bad tid
// 2812.1-2812.64: (72.5): Parameter VarDecl(ClassType(AtomicMarkableReference),x) is not global
// 2813.1-2813.38: (72.5): this is not global
// 2818.1-2818.507: (72.5): Object invariant may not hold.
// 2821.1-2821.506: (72.5): Object invariant may not hold.
// 3989.1-3989.14: (72.16): Can only have right-mover memory accesses in requires clause
// 3991.2-3993.2: (class anchor.sink.VarDeclStmt:74.7)
// 3994.2-4000.33: (class anchor.sink.Alloc:74.7)
// 4003.2-4005.2: (class anchor.sink.VarDeclStmt:74.7)
// 4006.2-4009.14: (class anchor.sink.Assign:74.7)
// 4010.2-4013.21: (class anchor.sink.Break:2.11)
// 4015.2-4017.2: (class anchor.sink.VarDeclStmt:75.7)
// 4020.2-4022.2: (class anchor.sink.VarDeclStmt:75.7)
// 4023.2-4026.14: (class anchor.sink.Assign:75.7)
// 4027.2-4029.2: (class anchor.sink.VarDeclStmt:40.9)
// 4031.2-4033.2: (class anchor.sink.VarDeclStmt:40.9)
// 4034.2-4051.60: (class anchor.sink.Read:40.9)
// 4046.1-4046.49: (40.9): Cannot have potential null deference in left-mover part.
// 4050.1-4050.27: (40.9): Reduction failure
// 4052.2-4054.2: (class anchor.sink.VarDeclStmt:40.9)
// 4055.2-4072.59: (class anchor.sink.Read:40.9)
// 4067.1-4067.49: (40.9): Cannot have potential null deference in left-mover part.
// 4071.1-4071.27: (40.9): Reduction failure
// 4073.2-4075.2: (class anchor.sink.VarDeclStmt:40.9)
// 4076.2-4093.58: (class anchor.sink.Read:40.9)
// 4088.1-4088.49: (40.9): Cannot have potential null deference in left-mover part.
// 4092.1-4092.27: (40.9): Reduction failure
// 4094.2-4096.2: (class anchor.sink.VarDeclStmt:40.9)
// 4097.2-4100.362: (class anchor.sink.Assign:40.9)
// 4101.2-4103.2: (class anchor.sink.VarDeclStmt:40.9)
// 4104.2-4107.83: (class anchor.sink.Assign:40.9)
// 4110.3-4127.50: (class anchor.sink.Read:40.9)
// 4122.1-4122.50: (40.9): Cannot have potential null deference in left-mover part.
// 4126.1-4126.28: (40.9): Reduction failure
// 4130.3-4147.50: (class anchor.sink.Read:40.9)
// 4142.1-4142.50: (40.9): Cannot have potential null deference in left-mover part.
// 4146.1-4146.28: (40.9): Reduction failure
// 4149.2-4152.19: (class anchor.sink.Assign:40.9)
// 4153.2-4156.21: (class anchor.sink.Break:40.9)
// 4157.2-4160.22: (class anchor.sink.Assign:39.16)
// 4161.2-4164.21: (class anchor.sink.Break:39.16)
// 4166.2-4176.41: (class anchor.sink.Yield:76.7)
// 4171.1-4171.506: (76.7): Object invariant may not hold.
// 4173.1-4173.506: (76.7): Object invariant may not hold.
// 4177.2-4179.2: (class anchor.sink.VarDeclStmt:77.7)
// 4182.2-4184.2: (class anchor.sink.VarDeclStmt:77.7)
// 4185.2-4188.14: (class anchor.sink.Assign:77.7)
// 4189.2-4191.2: (class anchor.sink.VarDeclStmt:40.9)
// 4193.2-4195.2: (class anchor.sink.VarDeclStmt:40.9)
// 4196.2-4213.60: (class anchor.sink.Read:40.9)
// 4208.1-4208.49: (40.9): Cannot have potential null deference in left-mover part.
// 4212.1-4212.27: (40.9): Reduction failure
// 4214.2-4216.2: (class anchor.sink.VarDeclStmt:40.9)
// 4217.2-4234.59: (class anchor.sink.Read:40.9)
// 4229.1-4229.49: (40.9): Cannot have potential null deference in left-mover part.
// 4233.1-4233.27: (40.9): Reduction failure
// 4235.2-4237.2: (class anchor.sink.VarDeclStmt:40.9)
// 4238.2-4255.58: (class anchor.sink.Read:40.9)
// 4250.1-4250.49: (40.9): Cannot have potential null deference in left-mover part.
// 4254.1-4254.27: (40.9): Reduction failure
// 4256.2-4258.2: (class anchor.sink.VarDeclStmt:40.9)
// 4259.2-4262.362: (class anchor.sink.Assign:40.9)
// 4263.2-4265.2: (class anchor.sink.VarDeclStmt:40.9)
// 4266.2-4269.83: (class anchor.sink.Assign:40.9)
// 4272.3-4289.50: (class anchor.sink.Read:40.9)
// 4284.1-4284.50: (40.9): Cannot have potential null deference in left-mover part.
// 4288.1-4288.28: (40.9): Reduction failure
// 4292.3-4309.50: (class anchor.sink.Read:40.9)
// 4304.1-4304.50: (40.9): Cannot have potential null deference in left-mover part.
// 4308.1-4308.28: (40.9): Reduction failure
// 4311.2-4314.20: (class anchor.sink.Assign:40.9)
// 4315.2-4318.21: (class anchor.sink.Break:40.9)
// 4319.2-4322.23: (class anchor.sink.Assign:39.16)
// 4323.2-4326.21: (class anchor.sink.Break:39.16)
// 4328.2-4338.41: (class anchor.sink.Yield:78.7)
// 4333.1-4333.506: (78.7): Object invariant may not hold.
// 4335.1-4335.506: (78.7): Object invariant may not hold.
// 4339.2-4341.2: (class anchor.sink.VarDeclStmt:79.7)
// 4342.2-4344.2: (class anchor.sink.VarDeclStmt:79.7)
// 4345.2-4362.34: (class anchor.sink.Read:79.7)
// 4357.1-4357.30: (79.7): Cannot have potential null deference in left-mover part.
// 4361.1-4361.27: (79.7): Reduction failure
// 4363.2-4365.2: (class anchor.sink.VarDeclStmt:79.7)
// 4366.2-4383.29: (class anchor.sink.Read:79.7)
// 4378.1-4378.30: (79.7): Cannot have potential null deference in left-mover part.
// 4382.1-4382.27: (79.7): Reduction failure
// 4386.2-4388.2: (class anchor.sink.VarDeclStmt:79.7)
// 4389.2-4391.2: (class anchor.sink.VarDeclStmt:79.7)
// 4392.2-4394.2: (class anchor.sink.VarDeclStmt:79.7)
// 4395.2-4397.2: (class anchor.sink.VarDeclStmt:79.7)
// 4398.2-4400.2: (class anchor.sink.VarDeclStmt:79.7)
// 4401.2-4404.31: (class anchor.sink.Assign:79.7)
// 4405.2-4408.27: (class anchor.sink.Assign:79.7)
// 4409.2-4412.26: (class anchor.sink.Assign:79.7)
// 4413.2-4416.20: (class anchor.sink.Assign:79.7)
// 4417.2-4420.14: (class anchor.sink.Assign:79.7)
// 4421.2-4423.2: (class anchor.sink.VarDeclStmt:47.9)
// 4425.2-4427.2: (class anchor.sink.VarDeclStmt:47.9)
// 4428.2-4445.60: (class anchor.sink.Read:47.9)
// 4440.1-4440.49: (47.9): Cannot have potential null deference in left-mover part.
// 4444.1-4444.27: (47.9): Reduction failure
// 4446.2-4448.2: (class anchor.sink.VarDeclStmt:47.9)
// 4449.2-4466.59: (class anchor.sink.Read:47.9)
// 4461.1-4461.49: (47.9): Cannot have potential null deference in left-mover part.
// 4465.1-4465.27: (47.9): Reduction failure
// 4467.2-4469.2: (class anchor.sink.VarDeclStmt:47.9)
// 4470.2-4487.58: (class anchor.sink.Read:47.9)
// 4482.1-4482.49: (47.9): Cannot have potential null deference in left-mover part.
// 4486.1-4486.27: (47.9): Reduction failure
// 4488.2-4490.2: (class anchor.sink.VarDeclStmt:47.9)
// 4491.2-4494.362: (class anchor.sink.Assign:47.9)
// 4495.2-4497.2: (class anchor.sink.VarDeclStmt:47.9)
// 4498.2-4501.83: (class anchor.sink.Assign:47.9)
// 4504.3-4521.53: (class anchor.sink.Read:47.9)
// 4516.1-4516.50: (47.9): Cannot have potential null deference in left-mover part.
// 4520.1-4520.28: (47.9): Reduction failure
// 4524.3-4541.53: (class anchor.sink.Read:47.9)
// 4536.1-4536.50: (47.9): Cannot have potential null deference in left-mover part.
// 4540.1-4540.28: (47.9): Reduction failure
// 4543.2-4545.2: (class anchor.sink.VarDeclStmt:48.9)
// 4546.2-4548.2: (class anchor.sink.VarDeclStmt:48.9)
// 4549.2-4551.2: (class anchor.sink.VarDeclStmt:48.9)
// 4552.2-4554.2: (class anchor.sink.VarDeclStmt:48.9)
// 4555.2-4572.39: (class anchor.sink.Read:48.9)
// 4567.1-4567.33: (48.9): Cannot have potential null deference in left-mover part.
// 4571.1-4571.27: (48.9): Reduction failure
// 4573.2-4576.43: (class anchor.sink.Assign:48.9)
// 4578.3-4580.3: (class anchor.sink.VarDeclStmt:50.29)
// 4581.3-4598.35: (class anchor.sink.Read:50.29)
// 4593.1-4593.34: (50.29): Cannot have potential null deference in left-mover part.
// 4597.1-4597.28: (50.29): Reduction failure
// 4599.3-4602.39: (class anchor.sink.Assign:50.26)
// 4604.3-4607.19: (class anchor.sink.Assign:<undefined position>)
// 4610.3-4612.3: (class anchor.sink.VarDeclStmt:51.35)
// 4615.3-4617.3: (class anchor.sink.VarDeclStmt:51.35)
// 4618.3-4620.3: (class anchor.sink.VarDeclStmt:51.35)
// 4621.3-4623.3: (class anchor.sink.VarDeclStmt:51.35)
// 4624.3-4627.34: (class anchor.sink.Assign:51.35)
// 4628.3-4631.30: (class anchor.sink.Assign:51.35)
// 4632.3-4635.20: (class anchor.sink.Assign:51.35)
// 4636.3-4638.3: (class anchor.sink.VarDeclStmt:23.7)
// 4639.3-4647.39: (class anchor.sink.Alloc:23.7)
// 4650.3-4652.3: (class anchor.sink.VarDeclStmt:23.7)
// 4653.3-4655.3: (class anchor.sink.VarDeclStmt:23.7)
// 4656.3-4658.3: (class anchor.sink.VarDeclStmt:23.7)
// 4659.3-4662.31: (class anchor.sink.Assign:23.7)
// 4663.3-4666.27: (class anchor.sink.Assign:23.7)
// 4667.3-4670.17: (class anchor.sink.Assign:23.7)
// 4671.3-4674.43: (class anchor.sink.Assume:7.5)
// 4675.3-4678.37: (class anchor.sink.Assume:7.5)
// 4680.3-4700.3: (class anchor.sink.Write:8.9)
// 4692.1-4692.31: (8.9): Cannot have potential null deference in left-mover part.
// 4695.1-4695.28: (8.9): Reduction failure
// 4702.3-4718.31: (class anchor.sink.Write:9.9)
// 4714.1-4714.31: (9.9): Cannot have potential null deference in left-mover part.
// 4717.1-4717.28: (9.9): Reduction failure
// 4719.3-4722.22: (class anchor.sink.Break:7.37)
// 4724.3-4727.18: (class anchor.sink.Assign:24.7)
// 4728.3-4731.22: (class anchor.sink.Break:24.7)
// 4732.3-4735.24: (class anchor.sink.Assign:22.52)
// 4736.3-4739.22: (class anchor.sink.Break:22.52)
// 4743.3-4745.3: (class anchor.sink.VarDeclStmt:51.13)
// 4746.3-4748.3: (class anchor.sink.VarDeclStmt:51.13)
// 4749.3-4751.3: (class anchor.sink.VarDeclStmt:51.13)
// 4752.3-4755.22: (class anchor.sink.Assign:51.13)
// 4756.3-4759.20: (class anchor.sink.Assign:51.13)
// 4760.3-4763.20: (class anchor.sink.Assign:51.13)
// 4764.3-4766.3: (class anchor.sink.VarDeclStmt:66.9)
// 4768.3-4770.3: (class anchor.sink.VarDeclStmt:66.9)
// 4771.3-4774.22: (class anchor.sink.Assign:66.9)
// 4777.4-4780.21: (class anchor.sink.Assign:66.9)
// 4782.4-4785.23: (class anchor.sink.Assign:66.9)
// 4787.5-4789.5: (class anchor.sink.VarDeclStmt:66.9)
// 4790.5-4792.5: (class anchor.sink.VarDeclStmt:66.9)
// 4793.5-4795.5: (class anchor.sink.VarDeclStmt:66.9)
// 4796.5-4799.376: (class anchor.sink.Assign:66.9)
// 4800.5-4803.58: (class anchor.sink.Assume:66.9)
// 4804.5-4807.51: (class anchor.sink.Assume:66.9)
// 4808.5-4811.67: (class anchor.sink.Assume:66.9)
// 4812.5-4815.68: (class anchor.sink.Assume:66.9)
// 4817.5-4833.65: (class anchor.sink.Write:66.9)
// 4829.1-4829.52: (66.9): Cannot have potential null deference in left-mover part.
// 4832.1-4832.30: (66.9): Reduction failure
// 4835.5-4851.66: (class anchor.sink.Write:66.9)
// 4847.1-4847.52: (66.9): Cannot have potential null deference in left-mover part.
// 4850.1-4850.30: (66.9): Reduction failure
// 4854.5-4875.5: (class anchor.sink.Write:66.9)
// 4866.1-4866.52: (66.9): Cannot have potential null deference in left-mover part.
// 4869.1-4869.30: (66.9): Reduction failure
// 4873.1-4873.65: (66.9): val$8 became shared, but val$8.reference may not be shared.
// 4876.5-4879.21: (class anchor.sink.Assign:66.9)
// 4881.5-4884.67: (class anchor.sink.Assume:66.9)
// 4885.5-4888.68: (class anchor.sink.Assume:66.9)
// 4889.5-4891.5: (class anchor.sink.VarDeclStmt:66.9)
// 4892.5-4909.61: (class anchor.sink.Read:66.9)
// 4904.1-4904.52: (66.9): Cannot have potential null deference in left-mover part.
// 4908.1-4908.30: (66.9): Reduction failure
// 4911.5-4932.5: (class anchor.sink.Write:66.9)
// 4923.1-4923.52: (66.9): Cannot have potential null deference in left-mover part.
// 4926.1-4926.30: (66.9): Reduction failure
// 4930.1-4930.65: (66.9): cmp$8 became shared, but cmp$8.reference may not be shared.
// 4933.5-4935.5: (class anchor.sink.VarDeclStmt:66.9)
// 4936.5-4939.376: (class anchor.sink.Assign:66.9)
// 4941.5-4962.5: (class anchor.sink.Write:66.9)
// 4953.1-4953.52: (66.9): Cannot have potential null deference in left-mover part.
// 4956.1-4956.30: (66.9): Reduction failure
// 4960.1-4960.75: (66.9): _currentValue$8 became shared, but _currentValue$8.reference may not be shared.
// 4963.5-4966.48: (class anchor.sink.Assume:66.9)
// 4969.5-4990.5: (class anchor.sink.Write:66.9)
// 4981.1-4981.52: (66.9): Cannot have potential null deference in left-mover part.
// 4984.1-4984.30: (66.9): Reduction failure
// 4988.1-4988.65: (66.9): val$8 became shared, but val$8.reference may not be shared.
// 4991.5-4994.22: (class anchor.sink.Assign:66.9)
// 4997.3-5000.21: (class anchor.sink.Assign:66.9)
// 5001.3-5004.22: (class anchor.sink.Break:66.9)
// 5005.3-5008.19: (class anchor.sink.Assign:65.41)
// 5009.3-5012.22: (class anchor.sink.Break:65.41)
// 5015.3-5018.19: (class anchor.sink.Assign:<undefined position>)
// 5020.2-5023.14: (class anchor.sink.Assign:48.9)
// 5024.2-5027.21: (class anchor.sink.Break:48.9)
// 5028.2-5031.13: (class anchor.sink.Assign:46.51)
// 5032.2-5035.21: (class anchor.sink.Break:46.51)
// 5040.2-5046.9: (class anchor.sink.Return:73.46)
// 5045.1-5045.506: (73.46): Object invariant may not hold.
// 5148.1-5148.34: (5.5): Pair.reference failed Write-Write Right-Mover Check
// 5225.1-5225.30: (5.5): Pair.reference failed Write-Read Right-Mover Check
// 5306.1-5306.34: (5.5): Pair.reference failed Write-Write Left-Mover Check
// 5384.1-5384.30: (5.5): Pair.reference failed Write-Read Left-Mover Check
// 5459.1-5459.34: (5.5): Pair.reference failed Read-Write Right-Mover Check
// 5537.1-5537.34: (5.5): Pair.reference failed Read-Write Left-Mover Check
// 5614.1-5614.34: (6.5): Pair.mark failed Write-Write Right-Mover Check
// 5691.1-5691.30: (6.5): Pair.mark failed Write-Read Right-Mover Check
// 5772.1-5772.34: (6.5): Pair.mark failed Write-Write Left-Mover Check
// 5850.1-5850.30: (6.5): Pair.mark failed Write-Read Left-Mover Check
// 5925.1-5925.34: (6.5): Pair.mark failed Read-Write Right-Mover Check
// 6003.1-6003.34: (6.5): Pair.mark failed Read-Write Left-Mover Check
// 6080.1-6080.34: (15.5): AtomicMarkableReference.pair failed Write-Write Right-Mover Check
// 6157.1-6157.30: (15.5): AtomicMarkableReference.pair failed Write-Read Right-Mover Check
// 6238.1-6238.34: (15.5): AtomicMarkableReference.pair failed Write-Write Left-Mover Check
// 6316.1-6316.30: (15.5): AtomicMarkableReference.pair failed Write-Read Left-Mover Check
// 6391.1-6391.34: (15.5): AtomicMarkableReference.pair failed Read-Write Right-Mover Check
// 6469.1-6469.34: (15.5): AtomicMarkableReference.pair failed Read-Write Left-Mover Check
// 6558.1-6558.140: (5.5): Pair.reference is not Write-Write Stable with respect to Pair.reference (case A.1)
// 6559.1-6559.101: (5.5): Pair.reference is not Write-Write Stable with respect to Pair.reference (case A.2)
// 6560.1-6560.158: (5.5): Pair.reference is not Write-Write Stable with respect to Pair.reference (case A.3)
// 6683.1-6683.140: (5.5): Pair.reference is not Write-Write Stable with respect to Pair.reference (case C)
// 6811.1-6811.144: (5.5): Pair.reference is not Write-Write Stable with respect to Pair.reference (case D)
// 6812.1-6812.144: (5.5): Pair.reference is not Write-Write Stable with respect to Pair.reference (case R)
// 6901.1-6901.136: (5.5): Pair.reference is not Read-Write Stable with respect to Pair.reference (case F)
// 6902.1-6902.136: (5.5): Pair.reference is not Read-Write Stable with respect to Pair.reference (case H)
// 6903.1-6903.146: (5.5): Pair.reference is not Read-Write Stable with respect to Pair.reference (case I)
// 6991.1-6991.136: (5.5): Pair.reference is not Write-Read Stable with respect to Pair.reference (case J)
// 6992.1-6992.136: (5.5): Pair.reference is not Write-Read Stable with respect to Pair.reference (case K)
// 6993.1-6993.99: (5.5): Pair.reference is not Write-Read Stable with respect to Pair.reference (case L)
// 7083.1-7083.140: (6.5): Pair.mark is not Write-Write Stable with respect to Pair.reference (case A.1)
// 7084.1-7084.101: (6.5): Pair.mark is not Write-Write Stable with respect to Pair.reference (case A.2)
// 7085.1-7085.158: (6.5): Pair.mark is not Write-Write Stable with respect to Pair.reference (case A.3)
// 7208.1-7208.140: (5.5): Pair.reference is not Write-Write Stable with respect to Pair.mark (case C)
// 7336.1-7336.144: (5.5): Pair.reference is not Write-Write Stable with respect to Pair.mark (case D)
// 7337.1-7337.144: (5.5): Pair.reference is not Write-Write Stable with respect to Pair.mark (case R)
// 7426.1-7426.136: (5.5): Pair.reference is not Read-Write Stable with respect to Pair.mark (case F)
// 7427.1-7427.136: (5.5): Pair.reference is not Read-Write Stable with respect to Pair.mark (case H)
// 7428.1-7428.146: (5.5): Pair.reference is not Read-Write Stable with respect to Pair.mark (case I)
// 7516.1-7516.136: (6.5): Pair.mark is not Write-Read Stable with respect to Pair.reference (case J)
// 7517.1-7517.136: (6.5): Pair.mark is not Write-Read Stable with respect to Pair.reference (case K)
// 7518.1-7518.99: (6.5): Pair.mark is not Write-Read Stable with respect to Pair.reference (case L)
// 7608.1-7608.140: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.reference (case A.1)
// 7609.1-7609.101: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.reference (case A.2)
// 7610.1-7610.156: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.reference (case A.3)
// 7733.1-7733.140: (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
// 7861.1-7861.144: (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
// 7862.1-7862.144: (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
// 7951.1-7951.136: (5.5): Pair.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
// 7952.1-7952.136: (5.5): Pair.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
// 7953.1-7953.144: (5.5): Pair.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
// 8041.1-8041.136: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Pair.reference (case J)
// 8042.1-8042.136: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Pair.reference (case K)
// 8043.1-8043.99: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Pair.reference (case L)
// 8133.1-8133.140: (5.5): Pair.reference is not Write-Write Stable with respect to Pair.mark (case A.1)
// 8134.1-8134.101: (5.5): Pair.reference is not Write-Write Stable with respect to Pair.mark (case A.2)
// 8135.1-8135.158: (5.5): Pair.reference is not Write-Write Stable with respect to Pair.mark (case A.3)
// 8258.1-8258.140: (6.5): Pair.mark is not Write-Write Stable with respect to Pair.reference (case C)
// 8386.1-8386.144: (6.5): Pair.mark is not Write-Write Stable with respect to Pair.reference (case D)
// 8387.1-8387.144: (6.5): Pair.mark is not Write-Write Stable with respect to Pair.reference (case R)
// 8476.1-8476.136: (6.5): Pair.mark is not Read-Write Stable with respect to Pair.reference (case F)
// 8477.1-8477.136: (6.5): Pair.mark is not Read-Write Stable with respect to Pair.reference (case H)
// 8478.1-8478.146: (6.5): Pair.mark is not Read-Write Stable with respect to Pair.reference (case I)
// 8566.1-8566.136: (5.5): Pair.reference is not Write-Read Stable with respect to Pair.mark (case J)
// 8567.1-8567.136: (5.5): Pair.reference is not Write-Read Stable with respect to Pair.mark (case K)
// 8568.1-8568.99: (5.5): Pair.reference is not Write-Read Stable with respect to Pair.mark (case L)
// 8658.1-8658.140: (6.5): Pair.mark is not Write-Write Stable with respect to Pair.mark (case A.1)
// 8659.1-8659.101: (6.5): Pair.mark is not Write-Write Stable with respect to Pair.mark (case A.2)
// 8660.1-8660.158: (6.5): Pair.mark is not Write-Write Stable with respect to Pair.mark (case A.3)
// 8783.1-8783.140: (6.5): Pair.mark is not Write-Write Stable with respect to Pair.mark (case C)
// 8911.1-8911.144: (6.5): Pair.mark is not Write-Write Stable with respect to Pair.mark (case D)
// 8912.1-8912.144: (6.5): Pair.mark is not Write-Write Stable with respect to Pair.mark (case R)
// 9001.1-9001.136: (6.5): Pair.mark is not Read-Write Stable with respect to Pair.mark (case F)
// 9002.1-9002.136: (6.5): Pair.mark is not Read-Write Stable with respect to Pair.mark (case H)
// 9003.1-9003.146: (6.5): Pair.mark is not Read-Write Stable with respect to Pair.mark (case I)
// 9091.1-9091.136: (6.5): Pair.mark is not Write-Read Stable with respect to Pair.mark (case J)
// 9092.1-9092.136: (6.5): Pair.mark is not Write-Read Stable with respect to Pair.mark (case K)
// 9093.1-9093.99: (6.5): Pair.mark is not Write-Read Stable with respect to Pair.mark (case L)
// 9183.1-9183.140: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.mark (case A.1)
// 9184.1-9184.101: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.mark (case A.2)
// 9185.1-9185.156: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.mark (case A.3)
// 9308.1-9308.140: (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
// 9436.1-9436.144: (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
// 9437.1-9437.144: (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
// 9526.1-9526.136: (6.5): Pair.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
// 9527.1-9527.136: (6.5): Pair.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
// 9528.1-9528.144: (6.5): Pair.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
// 9616.1-9616.136: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Pair.mark (case J)
// 9617.1-9617.136: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Pair.mark (case K)
// 9618.1-9618.99: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Pair.mark (case L)
// 9708.1-9708.140: (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
// 9709.1-9709.101: (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
// 9710.1-9710.156: (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
// 9833.1-9833.140: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.reference (case C)
// 9961.1-9961.144: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.reference (case D)
// 9962.1-9962.144: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.reference (case R)
// 10051.1-10051.136: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Pair.reference (case F)
// 10052.1-10052.136: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Pair.reference (case H)
// 10053.1-10053.144: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Pair.reference (case I)
// 10141.1-10141.136: (5.5): Pair.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
// 10142.1-10142.136: (5.5): Pair.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
// 10143.1-10143.99: (5.5): Pair.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
// 10276.1-10276.142: (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case M)
// 10407.1-10407.130: (5.5): Pair.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case N)
// 10498.1-10498.140: (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
// 10499.1-10499.101: (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
// 10500.1-10500.156: (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
// 10623.1-10623.140: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.mark (case C)
// 10751.1-10751.144: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.mark (case D)
// 10752.1-10752.144: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Pair.mark (case R)
// 10841.1-10841.136: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Pair.mark (case F)
// 10842.1-10842.136: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Pair.mark (case H)
// 10843.1-10843.144: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Pair.mark (case I)
// 10931.1-10931.136: (6.5): Pair.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
// 10932.1-10932.136: (6.5): Pair.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
// 10933.1-10933.99: (6.5): Pair.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
// 11066.1-11066.142: (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case M)
// 11197.1-11197.130: (6.5): Pair.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case N)
// 11288.1-11288.140: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
// 11289.1-11289.101: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
// 11290.1-11290.158: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
// 11413.1-11413.140: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
// 11541.1-11541.144: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
// 11542.1-11542.144: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
// 11631.1-11631.136: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
// 11632.1-11632.136: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
// 11633.1-11633.146: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
// 11721.1-11721.136: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
// 11722.1-11722.136: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
// 11723.1-11723.99: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
// 11856.1-11856.142: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case M)
// 11987.1-11987.130: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case N)
// 11995.1-11995.507: (<undefined position>): Object invariant may not hold.
// 12011.1-12011.506: (<undefined position>): Object invariant may not hold.
// 12032.1-12061.2: (7.32): yields_as clause for V._lock is not valid
// 12066.1-12090.2: (7.32): yields_as clause for V._lock is not reflexive
// 12096.1-12096.507: (2.1): Object invariant may not hold.
// 12097.1-12145.2: (7.32): yields_as clause for V._lock is not transitive
// 12164.1-12193.2: (5.5): yields_as clause for Pair.reference is not valid
// 12198.1-12222.2: (5.5): yields_as clause for Pair.reference is not reflexive
// 12228.1-12228.507: (5.29): Object invariant may not hold.
// 12229.1-12277.2: (5.5): yields_as clause for Pair.reference is not transitive
// 12296.1-12325.2: (6.5): yields_as clause for Pair.mark is not valid
// 12330.1-12354.2: (6.5): yields_as clause for Pair.mark is not reflexive
// 12360.1-12360.507: (6.32): Object invariant may not hold.
// 12361.1-12409.2: (6.5): yields_as clause for Pair.mark is not transitive
// 12429.1-12458.2: (7.32): yields_as clause for Pair._lock is not valid
// 12463.1-12487.2: (7.32): yields_as clause for Pair._lock is not reflexive
// 12493.1-12493.507: (4.1): Object invariant may not hold.
// 12494.1-12542.2: (7.32): yields_as clause for Pair._lock is not transitive
// 12562.1-12591.2: (18.43): yields_as clause for AtomicMarkableReference.pair is not valid
// 12596.1-12620.2: (18.43): yields_as clause for AtomicMarkableReference.pair is not reflexive
// 12626.1-12626.507: (15.40): Object invariant may not hold.
// 12627.1-12675.2: (18.43): yields_as clause for AtomicMarkableReference.pair is not transitive
// 12683.1-12683.507: (15.40): Object invariant may not hold.
// 12684.1-12734.2: (18.43): AtomicMarkableReference.pair is not ABA-free
// 12754.1-12783.2: (7.32): yields_as clause for AtomicMarkableReference._lock is not valid
// 12788.1-12812.2: (7.32): yields_as clause for AtomicMarkableReference._lock is not reflexive
// 12818.1-12818.507: (13.1): Object invariant may not hold.
// 12819.1-12867.2: (7.32): yields_as clause for AtomicMarkableReference._lock is not transitive
// 12915.1-12944.2: (7.32): yields_as clause for Main._lock is not valid
// 12949.1-12973.2: (7.32): yields_as clause for Main._lock is not reflexive
// 12979.1-12979.507: (70.1): Object invariant may not hold.
// 12980.1-13028.2: (7.32): yields_as clause for Main._lock is not transitive
