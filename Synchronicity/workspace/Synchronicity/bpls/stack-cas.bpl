                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/stack-cas.sink:                         
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int value isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
    }                                                                                               
    class Stack {                                                                                   
       Node top isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public void push(int v) {                                                                     
        while (true)   {                                                                            
          Node next;                                                                                
          next := this.top;                                                                         
          Node nu;                                                                                  
          nu = new Node();                                                                          
          nu.value := v;                                                                            
          nu.next := next;                                                                          
          yield;                                                                                    
          boolean result;                                                                           
          result = this.top@next :~ nu;                                                             
          if (result) {                                                                             
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
        }                                                                                           
         return;                                                                                    
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public void push2(int v) {                                                                    
        Node nu;                                                                                    
        nu = new Node();                                                                            
        nu.value := v;                                                                              
        while (true)                                                                                
          invariant isLocal(nu, tid);                                                               
          {                                                                                         
          Node next;                                                                                
          next := this.top;                                                                         
          nu.next := next;                                                                          
          yield;                                                                                    
          boolean result;                                                                           
          result = this.top@next :~ nu;                                                             
          if (result) {                                                                             
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
        }                                                                                           
         return;                                                                                    
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public int pop() {                                                                            
        while (true)   {                                                                            
          Node top;                                                                                 
          top := this.top;                                                                          
          if (top == Node.null) {                                                                   
             return -1;                                                                             
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
          Node next;                                                                                
          next := top.next;                                                                         
          boolean result;                                                                           
          result = this.top@top :~ next;                                                            
          if (result) {                                                                             
            int value;                                                                              
            value := top.value;                                                                     
             return value;                                                                          
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
        }                                                                                           
         return -1;                                                                                 
        // return -1;                                                                               
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int value isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
    }                                                                                               
    class Stack {                                                                                   
      hasCASOperation Node top isLocal(this, tid)                                                   
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid top_nextThread isLocal(this, tid)                                           
       ? B                                                                                          
       : this.top_nextThread == tid ? N : E                                                         
        yields_as this.top_nextThread == tid ==> newValue == tid;                                   
                                                                                                    
                                                                                                    
      updatesViaCAS Node top_nextValue isLocal(this, tid)                                           
       ? B                                                                                          
       : this.top_nextThread == tid ? N : E                                                         
        yields_as this.top_nextThread == tid ==> newValue == this.top_nextValue;                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public void push(int v) {                                                                     
        while (true)   {                                                                            
          Node next;                                                                                
          {                                                                                         
            noop(TraceOff);                                                                         
            Tid _C_t;                                                                               
            _C_t := this.top_nextThread  as B;                                                      
            Node _C_v;                                                                              
            _C_v := this.top_nextValue  as B;                                                       
            Node _currentValue;                                                                     
            _currentValue := this.top  as B;                                                        
            Mover _R_t;                                                                             
            _R_t = readPermission(this.top);                                                        
            boolean _casable;                                                                       
            _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
            if (_casable) {                                                                         
              noop(TraceOn);                                                                        
              next := this.top  as R;                                                               
            } else {                                                                                
              noop(TraceOn);                                                                        
              next := this.top;                                                                     
            }                                                                                       
          }                                                                                         
          Node nu;                                                                                  
          nu = new Node();                                                                          
          nu.value := v;                                                                            
          nu.next := next;                                                                          
          yield;                                                                                    
          boolean result;                                                                           
          {                                                                                         
            noop(TraceOff);                                                                         
            boolean ctmp4290129;                                                                    
            ctmp4290129 = *;                                                                        
            if (ctmp4290129) {                                                                      
              noop(TraceOn);                                                                        
              result = false;                                                                       
            } else {                                                                                
              ctmp4290129 = *;                                                                      
              if (ctmp4290129) {                                                                    
                Tid tmpTid;                                                                         
                Node tmpValue;                                                                      
                Mover _m;                                                                           
                _m = writePermission(this.top, nu);                                                 
                assume this.top == next;                                                            
                assume !goesWrong(_m);                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == next;                                                  
                this.top_nextThread := tmpTid as B;                                                 
                this.top_nextValue := tmpValue as B;                                                
                noop(TraceOn);                                                                      
                this.top := nu;                                                                     
                result = true;                                                                      
              } else {                                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == next;                                                  
                Node _currentValue;                                                                 
                _currentValue := this.top  as B;                                                    
                this.top := next as B;                                                              
                Mover _m;                                                                           
                _m = writePermission(this.top, nu);                                                 
                this.top := _currentValue as B;                                                     
                assume goesWrong(_m);                                                               
                noop(TraceOn);                                                                      
                this.top := nu;                                                                     
                result = false;                                                                     
              }                                                                                     
            }                                                                                       
          }                                                                                         
          if (result) {                                                                             
            {                                                                                       
              break;                                                                                
            }                                                                                       
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
        }                                                                                           
        {                                                                                           
           return;                                                                                  
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public void push2(int v) {                                                                    
        Node nu;                                                                                    
        nu = new Node();                                                                            
        nu.value := v;                                                                              
        while (true)                                                                                
          invariant isLocal(nu, tid);                                                               
          {                                                                                         
          Node next;                                                                                
          {                                                                                         
            noop(TraceOff);                                                                         
            Tid _C_t;                                                                               
            _C_t := this.top_nextThread  as B;                                                      
            Node _C_v;                                                                              
            _C_v := this.top_nextValue  as B;                                                       
            Node _currentValue;                                                                     
            _currentValue := this.top  as B;                                                        
            Mover _R_t;                                                                             
            _R_t = readPermission(this.top);                                                        
            boolean _casable;                                                                       
            _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
            if (_casable) {                                                                         
              noop(TraceOn);                                                                        
              next := this.top  as R;                                                               
            } else {                                                                                
              noop(TraceOn);                                                                        
              next := this.top;                                                                     
            }                                                                                       
          }                                                                                         
          nu.next := next;                                                                          
          yield;                                                                                    
          boolean result;                                                                           
          {                                                                                         
            noop(TraceOff);                                                                         
            boolean ctmp4290176;                                                                    
            ctmp4290176 = *;                                                                        
            if (ctmp4290176) {                                                                      
              noop(TraceOn);                                                                        
              result = false;                                                                       
            } else {                                                                                
              ctmp4290176 = *;                                                                      
              if (ctmp4290176) {                                                                    
                Tid tmpTid;                                                                         
                Node tmpValue;                                                                      
                Mover _m;                                                                           
                _m = writePermission(this.top, nu);                                                 
                assume this.top == next;                                                            
                assume !goesWrong(_m);                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == next;                                                  
                this.top_nextThread := tmpTid as B;                                                 
                this.top_nextValue := tmpValue as B;                                                
                noop(TraceOn);                                                                      
                this.top := nu;                                                                     
                result = true;                                                                      
              } else {                                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == next;                                                  
                Node _currentValue;                                                                 
                _currentValue := this.top  as B;                                                    
                this.top := next as B;                                                              
                Mover _m;                                                                           
                _m = writePermission(this.top, nu);                                                 
                this.top := _currentValue as B;                                                     
                assume goesWrong(_m);                                                               
                noop(TraceOn);                                                                      
                this.top := nu;                                                                     
                result = false;                                                                     
              }                                                                                     
            }                                                                                       
          }                                                                                         
          if (result) {                                                                             
            {                                                                                       
              break;                                                                                
            }                                                                                       
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
        }                                                                                           
        {                                                                                           
           return;                                                                                  
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public int pop() {                                                                            
        while (true)   {                                                                            
          Node top;                                                                                 
          {                                                                                         
            noop(TraceOff);                                                                         
            Tid _C_t;                                                                               
            _C_t := this.top_nextThread  as B;                                                      
            Node _C_v;                                                                              
            _C_v := this.top_nextValue  as B;                                                       
            Node _currentValue;                                                                     
            _currentValue := this.top  as B;                                                        
            Mover _R_t;                                                                             
            _R_t = readPermission(this.top);                                                        
            boolean _casable;                                                                       
            _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
            if (_casable) {                                                                         
              noop(TraceOn);                                                                        
              top := this.top  as R;                                                                
            } else {                                                                                
              noop(TraceOn);                                                                        
              top := this.top;                                                                      
            }                                                                                       
          }                                                                                         
          if (top == Node.null) {                                                                   
            {                                                                                       
               return -1;                                                                           
            }                                                                                       
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
          Node next;                                                                                
          next := top.next;                                                                         
          boolean result;                                                                           
          {                                                                                         
            noop(TraceOff);                                                                         
            boolean ctmp4290233;                                                                    
            ctmp4290233 = *;                                                                        
            if (ctmp4290233) {                                                                      
              noop(TraceOn);                                                                        
              result = false;                                                                       
            } else {                                                                                
              ctmp4290233 = *;                                                                      
              if (ctmp4290233) {                                                                    
                Tid tmpTid;                                                                         
                Node tmpValue;                                                                      
                Mover _m;                                                                           
                _m = writePermission(this.top, next);                                               
                assume this.top == top;                                                             
                assume !goesWrong(_m);                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == top;                                                   
                this.top_nextThread := tmpTid as B;                                                 
                this.top_nextValue := tmpValue as B;                                                
                noop(TraceOn);                                                                      
                this.top := next;                                                                   
                result = true;                                                                      
              } else {                                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == top;                                                   
                Node _currentValue;                                                                 
                _currentValue := this.top  as B;                                                    
                this.top := top as B;                                                               
                Mover _m;                                                                           
                _m = writePermission(this.top, next);                                               
                this.top := _currentValue as B;                                                     
                assume goesWrong(_m);                                                               
                noop(TraceOn);                                                                      
                this.top := next;                                                                   
                result = false;                                                                     
              }                                                                                     
            }                                                                                       
          }                                                                                         
          if (result) {                                                                             
            int value;                                                                              
            value := top.value;                                                                     
            {                                                                                       
               return value;                                                                        
            }                                                                                       
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
        }                                                                                           
        {                                                                                           
           return -1;                                                                               
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int value isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
    }                                                                                               
    class Stack {                                                                                   
      hasCASOperation Node top isLocal(this, tid)                                                   
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid top_nextThread isLocal(this, tid)                                           
       ? B                                                                                          
       : this.top_nextThread == tid ? N : E                                                         
        yields_as this.top_nextThread == tid ==> newValue == tid;                                   
                                                                                                    
                                                                                                    
      updatesViaCAS Node top_nextValue isLocal(this, tid)                                           
       ? B                                                                                          
       : this.top_nextThread == tid ? N : E                                                         
        yields_as this.top_nextThread == tid ==> newValue == this.top_nextValue;                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public void push(int v) {                                                                     
        while (true)   {                                                                            
          Node next;                                                                                
          {                                                                                         
            noop(TraceOff);                                                                         
            Tid _C_t;                                                                               
            _C_t := this.top_nextThread  as B;                                                      
            Node _C_v;                                                                              
            _C_v := this.top_nextValue  as B;                                                       
            Node _currentValue;                                                                     
            _currentValue := this.top  as B;                                                        
            Mover _R_t;                                                                             
            _R_t = readPermission(this.top);                                                        
            boolean _casable;                                                                       
            _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
            if (_casable) {                                                                         
              noop(TraceOn);                                                                        
              next := this.top  as R;                                                               
            } else {                                                                                
              noop(TraceOn);                                                                        
              next := this.top;                                                                     
            }                                                                                       
          }                                                                                         
          Node nu;                                                                                  
          nu = new Node();                                                                          
          nu.value := v;                                                                            
          nu.next := next;                                                                          
          yield;                                                                                    
          boolean result;                                                                           
          {                                                                                         
            noop(TraceOff);                                                                         
            boolean ctmp4290129;                                                                    
            ctmp4290129 = *;                                                                        
            if (ctmp4290129) {                                                                      
              noop(TraceOn);                                                                        
              result = false;                                                                       
            } else {                                                                                
              ctmp4290129 = *;                                                                      
              if (ctmp4290129) {                                                                    
                Tid tmpTid;                                                                         
                Node tmpValue;                                                                      
                Mover _m;                                                                           
                _m = writePermission(this.top, nu);                                                 
                assume this.top == next;                                                            
                assume !goesWrong(_m);                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == next;                                                  
                this.top_nextThread := tmpTid as B;                                                 
                this.top_nextValue := tmpValue as B;                                                
                noop(TraceOn);                                                                      
                this.top := nu;                                                                     
                result = true;                                                                      
              } else {                                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == next;                                                  
                Node _currentValue;                                                                 
                _currentValue := this.top  as B;                                                    
                this.top := next as B;                                                              
                Mover _m;                                                                           
                _m = writePermission(this.top, nu);                                                 
                this.top := _currentValue as B;                                                     
                assume goesWrong(_m);                                                               
                noop(TraceOn);                                                                      
                this.top := nu;                                                                     
                result = false;                                                                     
              }                                                                                     
            }                                                                                       
          }                                                                                         
          if (result) {                                                                             
            {                                                                                       
              break;                                                                                
            }                                                                                       
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
        }                                                                                           
        {                                                                                           
           return;                                                                                  
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public void push2(int v) {                                                                    
        Node nu;                                                                                    
        nu = new Node();                                                                            
        nu.value := v;                                                                              
        while (true)                                                                                
          invariant isLocal(nu, tid);                                                               
          {                                                                                         
          Node next;                                                                                
          {                                                                                         
            noop(TraceOff);                                                                         
            Tid _C_t;                                                                               
            _C_t := this.top_nextThread  as B;                                                      
            Node _C_v;                                                                              
            _C_v := this.top_nextValue  as B;                                                       
            Node _currentValue;                                                                     
            _currentValue := this.top  as B;                                                        
            Mover _R_t;                                                                             
            _R_t = readPermission(this.top);                                                        
            boolean _casable;                                                                       
            _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
            if (_casable) {                                                                         
              noop(TraceOn);                                                                        
              next := this.top  as R;                                                               
            } else {                                                                                
              noop(TraceOn);                                                                        
              next := this.top;                                                                     
            }                                                                                       
          }                                                                                         
          nu.next := next;                                                                          
          yield;                                                                                    
          boolean result;                                                                           
          {                                                                                         
            noop(TraceOff);                                                                         
            boolean ctmp4290176;                                                                    
            ctmp4290176 = *;                                                                        
            if (ctmp4290176) {                                                                      
              noop(TraceOn);                                                                        
              result = false;                                                                       
            } else {                                                                                
              ctmp4290176 = *;                                                                      
              if (ctmp4290176) {                                                                    
                Tid tmpTid;                                                                         
                Node tmpValue;                                                                      
                Mover _m;                                                                           
                _m = writePermission(this.top, nu);                                                 
                assume this.top == next;                                                            
                assume !goesWrong(_m);                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == next;                                                  
                this.top_nextThread := tmpTid as B;                                                 
                this.top_nextValue := tmpValue as B;                                                
                noop(TraceOn);                                                                      
                this.top := nu;                                                                     
                result = true;                                                                      
              } else {                                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == next;                                                  
                Node _currentValue;                                                                 
                _currentValue := this.top  as B;                                                    
                this.top := next as B;                                                              
                Mover _m;                                                                           
                _m = writePermission(this.top, nu);                                                 
                this.top := _currentValue as B;                                                     
                assume goesWrong(_m);                                                               
                noop(TraceOn);                                                                      
                this.top := nu;                                                                     
                result = false;                                                                     
              }                                                                                     
            }                                                                                       
          }                                                                                         
          if (result) {                                                                             
            {                                                                                       
              break;                                                                                
            }                                                                                       
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
        }                                                                                           
        {                                                                                           
           return;                                                                                  
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public int pop() {                                                                            
        while (true)   {                                                                            
          Node top;                                                                                 
          {                                                                                         
            noop(TraceOff);                                                                         
            Tid _C_t;                                                                               
            _C_t := this.top_nextThread  as B;                                                      
            Node _C_v;                                                                              
            _C_v := this.top_nextValue  as B;                                                       
            Node _currentValue;                                                                     
            _currentValue := this.top  as B;                                                        
            Mover _R_t;                                                                             
            _R_t = readPermission(this.top);                                                        
            boolean _casable;                                                                       
            _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
            if (_casable) {                                                                         
              noop(TraceOn);                                                                        
              top := this.top  as R;                                                                
            } else {                                                                                
              noop(TraceOn);                                                                        
              top := this.top;                                                                      
            }                                                                                       
          }                                                                                         
          if (top == Node.null) {                                                                   
            {                                                                                       
               return -1;                                                                           
            }                                                                                       
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
          Node next;                                                                                
          next := top.next;                                                                         
          boolean result;                                                                           
          {                                                                                         
            noop(TraceOff);                                                                         
            boolean ctmp4290233;                                                                    
            ctmp4290233 = *;                                                                        
            if (ctmp4290233) {                                                                      
              noop(TraceOn);                                                                        
              result = false;                                                                       
            } else {                                                                                
              ctmp4290233 = *;                                                                      
              if (ctmp4290233) {                                                                    
                Tid tmpTid;                                                                         
                Node tmpValue;                                                                      
                Mover _m;                                                                           
                _m = writePermission(this.top, next);                                               
                assume this.top == top;                                                             
                assume !goesWrong(_m);                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == top;                                                   
                this.top_nextThread := tmpTid as B;                                                 
                this.top_nextValue := tmpValue as B;                                                
                noop(TraceOn);                                                                      
                this.top := next;                                                                   
                result = true;                                                                      
              } else {                                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == top;                                                   
                Node _currentValue;                                                                 
                _currentValue := this.top  as B;                                                    
                this.top := top as B;                                                               
                Mover _m;                                                                           
                _m = writePermission(this.top, next);                                               
                this.top := _currentValue as B;                                                     
                assume goesWrong(_m);                                                               
                noop(TraceOn);                                                                      
                this.top := next;                                                                   
                result = false;                                                                     
              }                                                                                     
            }                                                                                       
          }                                                                                         
          if (result) {                                                                             
            int value;                                                                              
            value := top.value;                                                                     
            {                                                                                       
               return value;                                                                        
            }                                                                                       
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
        }                                                                                           
        {                                                                                           
           return -1;                                                                               
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int value isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
    }                                                                                               
    class Stack {                                                                                   
      hasCASOperation Node top isLocal(this, tid)                                                   
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid top_nextThread isLocal(this, tid)                                           
       ? B                                                                                          
       : this.top_nextThread == tid ? N : E                                                         
        yields_as this.top_nextThread == tid ==> newValue == tid;                                   
                                                                                                    
                                                                                                    
      updatesViaCAS Node top_nextValue isLocal(this, tid)                                           
       ? B                                                                                          
       : this.top_nextThread == tid ? N : E                                                         
        yields_as this.top_nextThread == tid ==> newValue == this.top_nextValue;                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public void push(int v) {                                                                     
        while (true)   {                                                                            
          Node next;                                                                                
          {                                                                                         
            noop(TraceOff);                                                                         
            Tid _C_t;                                                                               
            _C_t := this.top_nextThread  as B;                                                      
            Node _C_v;                                                                              
            _C_v := this.top_nextValue  as B;                                                       
            Node _currentValue;                                                                     
            _currentValue := this.top  as B;                                                        
            Mover _R_t;                                                                             
            _R_t = readPermission(this.top);                                                        
            boolean _casable;                                                                       
            _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
            if (_casable) {                                                                         
              noop(TraceOn);                                                                        
              next := this.top  as R;                                                               
            } else {                                                                                
              noop(TraceOn);                                                                        
              next := this.top;                                                                     
            }                                                                                       
          }                                                                                         
          Node nu;                                                                                  
          nu = new Node();                                                                          
          nu.value := v;                                                                            
          nu.next := next;                                                                          
          yield;                                                                                    
          boolean result;                                                                           
          {                                                                                         
            noop(TraceOff);                                                                         
            boolean ctmp4290129;                                                                    
            ctmp4290129 = *;                                                                        
            if (ctmp4290129) {                                                                      
              noop(TraceOn);                                                                        
              result = false;                                                                       
            } else {                                                                                
              ctmp4290129 = *;                                                                      
              if (ctmp4290129) {                                                                    
                Tid tmpTid;                                                                         
                Node tmpValue;                                                                      
                Mover _m;                                                                           
                _m = writePermission(this.top, nu);                                                 
                assume this.top == next;                                                            
                assume !goesWrong(_m);                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == next;                                                  
                this.top_nextThread := tmpTid as B;                                                 
                this.top_nextValue := tmpValue as B;                                                
                noop(TraceOn);                                                                      
                this.top := nu;                                                                     
                result = true;                                                                      
              } else {                                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == next;                                                  
                Node _currentValue;                                                                 
                _currentValue := this.top  as B;                                                    
                this.top := next as B;                                                              
                Mover _m;                                                                           
                _m = writePermission(this.top, nu);                                                 
                this.top := _currentValue as B;                                                     
                assume goesWrong(_m);                                                               
                noop(TraceOn);                                                                      
                this.top := nu;                                                                     
                result = false;                                                                     
              }                                                                                     
            }                                                                                       
          }                                                                                         
          if (result) {                                                                             
            {                                                                                       
              break;                                                                                
            }                                                                                       
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
        }                                                                                           
        {                                                                                           
           return;                                                                                  
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public void push2(int v) {                                                                    
        Node nu;                                                                                    
        nu = new Node();                                                                            
        nu.value := v;                                                                              
        while (true)                                                                                
          invariant isLocal(nu, tid);                                                               
          {                                                                                         
          Node next;                                                                                
          {                                                                                         
            noop(TraceOff);                                                                         
            Tid _C_t;                                                                               
            _C_t := this.top_nextThread  as B;                                                      
            Node _C_v;                                                                              
            _C_v := this.top_nextValue  as B;                                                       
            Node _currentValue;                                                                     
            _currentValue := this.top  as B;                                                        
            Mover _R_t;                                                                             
            _R_t = readPermission(this.top);                                                        
            boolean _casable;                                                                       
            _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
            if (_casable) {                                                                         
              noop(TraceOn);                                                                        
              next := this.top  as R;                                                               
            } else {                                                                                
              noop(TraceOn);                                                                        
              next := this.top;                                                                     
            }                                                                                       
          }                                                                                         
          nu.next := next;                                                                          
          yield;                                                                                    
          boolean result;                                                                           
          {                                                                                         
            noop(TraceOff);                                                                         
            boolean ctmp4290176;                                                                    
            ctmp4290176 = *;                                                                        
            if (ctmp4290176) {                                                                      
              noop(TraceOn);                                                                        
              result = false;                                                                       
            } else {                                                                                
              ctmp4290176 = *;                                                                      
              if (ctmp4290176) {                                                                    
                Tid tmpTid;                                                                         
                Node tmpValue;                                                                      
                Mover _m;                                                                           
                _m = writePermission(this.top, nu);                                                 
                assume this.top == next;                                                            
                assume !goesWrong(_m);                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == next;                                                  
                this.top_nextThread := tmpTid as B;                                                 
                this.top_nextValue := tmpValue as B;                                                
                noop(TraceOn);                                                                      
                this.top := nu;                                                                     
                result = true;                                                                      
              } else {                                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == next;                                                  
                Node _currentValue;                                                                 
                _currentValue := this.top  as B;                                                    
                this.top := next as B;                                                              
                Mover _m;                                                                           
                _m = writePermission(this.top, nu);                                                 
                this.top := _currentValue as B;                                                     
                assume goesWrong(_m);                                                               
                noop(TraceOn);                                                                      
                this.top := nu;                                                                     
                result = false;                                                                     
              }                                                                                     
            }                                                                                       
          }                                                                                         
          if (result) {                                                                             
            {                                                                                       
              break;                                                                                
            }                                                                                       
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
        }                                                                                           
        {                                                                                           
           return;                                                                                  
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public int pop() {                                                                            
        while (true)   {                                                                            
          Node top;                                                                                 
          {                                                                                         
            noop(TraceOff);                                                                         
            Tid _C_t;                                                                               
            _C_t := this.top_nextThread  as B;                                                      
            Node _C_v;                                                                              
            _C_v := this.top_nextValue  as B;                                                       
            Node _currentValue;                                                                     
            _currentValue := this.top  as B;                                                        
            Mover _R_t;                                                                             
            _R_t = readPermission(this.top);                                                        
            boolean _casable;                                                                       
            _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
            if (_casable) {                                                                         
              noop(TraceOn);                                                                        
              top := this.top  as R;                                                                
            } else {                                                                                
              noop(TraceOn);                                                                        
              top := this.top;                                                                      
            }                                                                                       
          }                                                                                         
          if (top == Node.null) {                                                                   
            {                                                                                       
               return -1;                                                                           
            }                                                                                       
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
          Node next;                                                                                
          next := top.next;                                                                         
          boolean result;                                                                           
          {                                                                                         
            noop(TraceOff);                                                                         
            boolean ctmp4290233;                                                                    
            ctmp4290233 = *;                                                                        
            if (ctmp4290233) {                                                                      
              noop(TraceOn);                                                                        
              result = false;                                                                       
            } else {                                                                                
              ctmp4290233 = *;                                                                      
              if (ctmp4290233) {                                                                    
                Tid tmpTid;                                                                         
                Node tmpValue;                                                                      
                Mover _m;                                                                           
                _m = writePermission(this.top, next);                                               
                assume this.top == top;                                                             
                assume !goesWrong(_m);                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == top;                                                   
                this.top_nextThread := tmpTid as B;                                                 
                this.top_nextValue := tmpValue as B;                                                
                noop(TraceOn);                                                                      
                this.top := next;                                                                   
                result = true;                                                                      
              } else {                                                                              
                assume this.top_nextThread == tid;                                                  
                assume this.top_nextValue == top;                                                   
                Node _currentValue;                                                                 
                _currentValue := this.top  as B;                                                    
                this.top := top as B;                                                               
                Mover _m;                                                                           
                _m = writePermission(this.top, next);                                               
                this.top := _currentValue as B;                                                     
                assume goesWrong(_m);                                                               
                noop(TraceOn);                                                                      
                this.top := next;                                                                   
                result = false;                                                                     
              }                                                                                     
            }                                                                                       
          }                                                                                         
          if (result) {                                                                             
            int value;                                                                              
            value := top.value;                                                                     
            {                                                                                       
               return value;                                                                        
            }                                                                                       
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          yield;                                                                                    
        }                                                                                           
        {                                                                                           
           return -1;                                                                               
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Node ***/                                                                           
                                                                                                    
type Node;                                                                                          
const unique Node.null: Node;                                                                       
var Node._state: [Node]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.value: [Node]int;                                                                          
                                                                                                    
function {:inline} ReadEval.Node.value(tid: Tid,this : Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.value(tid: Tid,this : Node,newValue: int,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.next: [Node]Node;                                                                          
                                                                                                    
function {:inline} ReadEval.Node.next(tid: Tid,this : Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.next(tid: Tid,this : Node,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node._lock: [Node]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Node._lock(tid: Tid,this : Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node._lock(tid: Tid,this : Node,newValue: Tid,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Stack ***/                                                                          
                                                                                                    
type Stack;                                                                                         
const unique Stack.null: Stack;                                                                     
var Stack._state: [Stack]State;                                                                     
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Stack.top: [Stack]Node;                                                                         
                                                                                                    
function {:inline} ReadEval.Stack.top(tid: Tid,this : Stack,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Stack._state[this], tid)) then                                                         
  if (isLocal(Stack._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Stack.top(tid: Tid,this : Stack,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Stack._state[this], tid)) then                                                         
  if (isLocal(Stack._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Stack._lock: [Stack]Tid;                                                                        
                                                                                                    
function {:inline} ReadEval.Stack._lock(tid: Tid,this : Stack,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Stack._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Stack._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Stack._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Stack._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Stack._lock(tid: Tid,this : Stack,newValue: Tid,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Stack._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Stack._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Stack._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Stack._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Stack.top_nextThread: [Stack]Tid;                                                               
                                                                                                    
function {:inline} ReadEval.Stack.top_nextThread(tid: Tid,this : Stack,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Stack._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Stack.top_nextThread[this]==tid)) then                                                       
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Stack.top_nextThread(tid: Tid,this : Stack,newValue: Tid,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Stack._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Stack.top_nextThread[this]==tid)) then                                                       
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Stack.top_nextValue: [Stack]Node;                                                               
                                                                                                    
function {:inline} ReadEval.Stack.top_nextValue(tid: Tid,this : Stack,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Stack._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Stack.top_nextThread[this]==tid)) then                                                       
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Stack.top_nextValue(tid: Tid,this : Stack,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Stack._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Stack.top_nextThread[this]==tid)) then                                                       
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Stack.push(tid:Tid, this : Stack, v : int)                                               
modifies Node._state;                                                                               
modifies Node.value;                                                                                
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Stack._state;                                                                              
modifies Stack.top;                                                                                 
modifies Stack._lock;                                                                               
modifies Stack.top_nextThread;                                                                      
modifies Stack.top_nextValue;                                                                       
                                                                                                    
requires ValidTid(tid);                                                                                    // (11.2): Bad tid
requires isShared(Stack._state[this]);                                                                     // (11.2): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
                                                                                                    
ensures StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
{                                                                                                   
 var _C_v4297732: Node;                                                                             
 var Stack._state4297796_post: [Stack]State;                                                        
 var Node.next4297901: [Node]Node;                                                                  
 var nu4297923_post: Node;                                                                          
 var Stack._state4297738: [Stack]State;                                                             
 var Node.value4297923_post: [Node]int;                                                             
 var Stack._state4297908: [Stack]State;                                                             
 var Stack._lock4297901: [Stack]Tid;                                                                
 var next4297732: Node;                                                                             
 var tmpValue4297859: Node;                                                                         
 var ctmp42901294297859: bool;                                                                      
 var Stack._lock4297856: [Stack]Tid;                                                                
 var $pc4297923_post: Phase;                                                                        
 var mover4297908: Mover;                                                                           
 var Stack.top4297926: [Stack]Node;                                                                 
 var nu4297859: Node;                                                                               
 var nu4297795: Node;                                                                               
 var $pc4297796_post: Phase;                                                                        
 var _R_t4297776: Mover;                                                                            
 var Node._lock4297928: [Node]Tid;                                                                  
 var Stack.top4297776: [Stack]Node;                                                                 
 var Node._state4297738: [Node]State;                                                               
 var moverPath4297908: MoverPath;                                                                   
 var Node.next4297886: [Node]Node;                                                                  
 var _casable4297781: bool;                                                                         
 var Stack.top_nextThread4297796_post: [Stack]Tid;                                                  
 var $recorded.state4297901: int;                                                                   
 var tid4297776: Tid;                                                                               
 var $pc4297792: Phase;                                                                             
 var _currentValue4297776: Node;                                                                    
 var _casable4297776: bool;                                                                         
 var next: Node;                                                                                    
 var path4297908: int;                                                                              
 var nu4297886: Node;                                                                               
 var tid4297925: Tid;                                                                               
 var Node.value4297776: [Node]int;                                                                  
 var _C_t: Tid;                                                                                     
 var $pc4297859: Phase;                                                                             
 var Stack.top_nextValue4297738: [Stack]Node;                                                       
 var moverPath4297738: MoverPath;                                                                   
 var Node.next4297889: [Node]Node;                                                                  
 var Stack.top_nextValue4297889: [Stack]Node;                                                       
 var next4297901: Node;                                                                             
 var Stack._lock4297925: [Stack]Tid;                                                                
 var Stack._state4297732: [Stack]State;                                                             
 var $pc4297923: Phase;                                                                             
 var Stack.top_nextValue4297925_bottom: [Stack]Node;                                                
 var ctmp42901294297863: bool;                                                                      
 var Node.next4297776: [Node]Node;                                                                  
 var Stack.top_nextThread4297925: [Stack]Tid;                                                       
 var Stack._lock4297863: [Stack]Tid;                                                                
 var _m4297859: Mover;                                                                              
 var Node._state4297925_bottom: [Node]State;                                                        
 var tmpTid4297863: Tid;                                                                            
 var Stack.top_nextValue4297886: [Stack]Node;                                                       
 var Stack.top4297889: [Stack]Node;                                                                 
 var Node._lock4297796_post: [Node]Tid;                                                             
 var Node._lock4297889: [Node]Tid;                                                                  
 var v4297928: int;                                                                                 
 var _currentValue4297889: Node;                                                                    
 var Stack._lock4297859: [Stack]Tid;                                                                
 var path4297901: int;                                                                              
 var Node.next4297796_post: [Node]Node;                                                             
 var tmpValue: Node;                                                                                
 var Stack._state4297859: [Stack]State;                                                             
 var _casable: bool;                                                                                
 var Node.next4297859: [Node]Node;                                                                  
 var this4297928: Stack;                                                                            
 var $pc4297795: Phase;                                                                             
 var nu4297901: Node;                                                                               
 var tid4297795: Tid;                                                                               
 var Node._state4297792: [Node]State;                                                               
 var Node._lock4297738: [Node]Tid;                                                                  
 var next4297795: Node;                                                                             
 var v4297886: int;                                                                                 
 var moverPath4297901: MoverPath;                                                                   
 var ctmp42901294297889: bool;                                                                      
 var Node.value4297928: [Node]int;                                                                  
 var this4297889: Stack;                                                                            
 var nu4297792: Node;                                                                               
 var Stack._lock4297738: [Stack]Tid;                                                                
 var mover4297889: Mover;                                                                           
 var path4297792: int;                                                                              
 var Stack.top_nextValue4297781: [Stack]Node;                                                       
 var Stack.top4297732: [Stack]Node;                                                                 
 var Stack._lock4297923_post: [Stack]Tid;                                                           
 var tid4297923: Tid;                                                                               
 var mover4297859: Mover;                                                                           
 var $recorded.state4297781: int;                                                                   
 var Node.next4297726: [Node]Node;                                                                  
 var tid4297925_bottom: Tid;                                                                        
 var Node._lock4297781: [Node]Tid;                                                                  
 var path4297781: int;                                                                              
 var next4297856: Node;                                                                             
 var result4297908: bool;                                                                           
 var Stack._lock4297925_bottom: [Stack]Tid;                                                         
 var Stack._state4297792: [Stack]State;                                                             
 var $recorded.state4297796_post: int;                                                              
 var Node.next4297795: [Node]Node;                                                                  
 var v4297796_post: int;                                                                            
 var tid4297726: Tid;                                                                               
 var v4297859: int;                                                                                 
 var Stack.top_nextThread4297796: [Stack]Tid;                                                       
 var Node._lock4297732: [Node]Tid;                                                                  
 var Stack._lock4297781: [Stack]Tid;                                                                
 var $recorded.state4297792: int;                                                                   
 var Stack.top_nextValue4297908: [Stack]Node;                                                       
 var Stack._lock4297792: [Stack]Tid;                                                                
 var Node._state4297925: [Node]State;                                                               
 var tmpTid4297859: Tid;                                                                            
 var $pc4297781: Phase;                                                                             
 var Node.next4297738: [Node]Node;                                                                  
 var Node._state4297863: [Node]State;                                                               
 var v4297889: int;                                                                                 
 var v4297925: int;                                                                                 
 var next4297792: Node;                                                                             
 var Node._lock4297792: [Node]Tid;                                                                  
 var $pc4297796: Phase;                                                                             
 var _currentValue4297901: Node;                                                                    
 var Node._state4297732: [Node]State;                                                               
 var Stack.top_nextThread4297856: [Stack]Tid;                                                       
 var this4297925_bottom: Stack;                                                                     
 var tid4297738: Tid;                                                                               
 var Stack.top4297923_post: [Stack]Node;                                                            
 var Node.value4297856: [Node]int;                                                                  
 var Stack.top4297726: [Stack]Node;                                                                 
 var Stack.top_nextValue4297795: [Stack]Node;                                                       
 var v4297901: int;                                                                                 
 var Stack.top_nextThread4297781: [Stack]Tid;                                                       
 var Stack.top_nextThread4297923: [Stack]Tid;                                                       
 var Stack.top_nextValue4297863: [Stack]Node;                                                       
 var _C_v4297776: Node;                                                                             
 var this4297926: Stack;                                                                            
 var $pc4297776: Phase;                                                                             
 var tid4297863: Tid;                                                                               
 var Node._lock4297776: [Node]Tid;                                                                  
 var Stack._state4297886: [Stack]State;                                                             
 var Node._lock4297726: [Node]Tid;                                                                  
 var next4297781: Node;                                                                             
 var $pc4297738: Phase;                                                                             
 var moverPath4297732: MoverPath;                                                                   
 var _currentValue4297908: Node;                                                                    
 var $pc4297901: Phase;                                                                             
 var Node._state4297886: [Node]State;                                                               
 var Stack._state4297863: [Stack]State;                                                             
 var Stack.top4297781: [Stack]Node;                                                                 
 var Stack._lock4297732: [Stack]Tid;                                                                
 var tid4297889: Tid;                                                                               
 var Stack.top4297792: [Stack]Node;                                                                 
 var Node.value4297901: [Node]int;                                                                  
 var nu4297863: Node;                                                                               
 var Node.value4297926: [Node]int;                                                                  
 var Stack.top4297859: [Stack]Node;                                                                 
 var Stack.top4297925: [Stack]Node;                                                                 
 var v4297738: int;                                                                                 
 var $recorded.state4297795: int;                                                                   
 var nu4297889: Node;                                                                               
 var mover4297901: Mover;                                                                           
 var Stack._lock4297908: [Stack]Tid;                                                                
 var Node.next4297923_post: [Node]Node;                                                             
 var Stack._lock4297726: [Stack]Tid;                                                                
 var nu4297908: Node;                                                                               
 var $recorded.state4297889: int;                                                                   
 var Stack.top4297856: [Stack]Node;                                                                 
 var path4297863: int;                                                                              
 var this4297795: Stack;                                                                            
 var Node._state4297776: [Node]State;                                                               
 var Stack.top_nextThread4297923_post: [Stack]Tid;                                                  
 var this4297925: Stack;                                                                            
 var next4297923: Node;                                                                             
 var Stack.top4297908: [Stack]Node;                                                                 
 var tid4297886: Tid;                                                                               
 var Stack._state4297901: [Stack]State;                                                             
 var this4297886: Stack;                                                                            
 var Stack.top4297925_bottom: [Stack]Node;                                                          
 var Node._state4297796: [Node]State;                                                               
 var v4297926: int;                                                                                 
 var $recorded.state4297776: int;                                                                   
 var Stack.top_nextThread4297863: [Stack]Tid;                                                       
 var path4297776: int;                                                                              
 var tid4297928: Tid;                                                                               
 var $recorded.state4297732: int;                                                                   
 var result4297859: bool;                                                                           
 var this4297908: Stack;                                                                            
 var Stack.top_nextValue4297901: [Stack]Node;                                                       
 var next4297923_post: Node;                                                                        
 var nu4297796_post: Node;                                                                          
 var _m4297863: Mover;                                                                              
 var Node._lock4297863: [Node]Tid;                                                                  
 var Node._lock4297923: [Node]Tid;                                                                  
 var _C_v: Node;                                                                                    
 var ctmp4290129: bool;                                                                             
 var Node.next4297923: [Node]Node;                                                                  
 var Stack.top_nextValue4297726: [Stack]Node;                                                       
 var $recorded.state4297923_post: int;                                                              
 var path4297726: int;                                                                              
 var Node.next4297908: [Node]Node;                                                                  
 var Node._state4297856: [Node]State;                                                               
 var Node._state4297901: [Node]State;                                                               
 var $recorded.state4297925_bottom: int;                                                            
 var v4297863: int;                                                                                 
 var next4297859: Node;                                                                             
 var _C_t4297781: Tid;                                                                              
 var Node._state4297795: [Node]State;                                                               
 var tid4297926: Tid;                                                                               
 var this4297796_post: Stack;                                                                       
 var Stack.top4297923: [Stack]Node;                                                                 
 var tid4297859: Tid;                                                                               
 var v4297776: int;                                                                                 
 var mover4297863: Mover;                                                                           
 var Node._lock4297856: [Node]Tid;                                                                  
 var result: bool;                                                                                  
 var moverPath4297726: MoverPath;                                                                   
 var Node.value4297795: [Node]int;                                                                  
 var Stack._state4297856: [Stack]State;                                                             
 var Stack.top4297796: [Stack]Node;                                                                 
 var tid4297781: Tid;                                                                               
 var moverPath4297863: MoverPath;                                                                   
 var Stack._state4297776: [Stack]State;                                                             
 var Stack.top_nextThread4297926: [Stack]Tid;                                                       
 var Stack._lock4297923: [Stack]Tid;                                                                
 var Node.value4297908: [Node]int;                                                                  
 var moverPath4297781: MoverPath;                                                                   
 var _R_t4297781: Mover;                                                                            
 var Stack.top_nextThread4297908: [Stack]Tid;                                                       
 var Stack._state4297925: [Stack]State;                                                             
 var v4297726: int;                                                                                 
 var moverPath4297889: MoverPath;                                                                   
 var Stack._state4297928: [Stack]State;                                                             
 var Stack.top_nextValue4297925: [Stack]Node;                                                       
 var Node._lock4297795: [Node]Tid;                                                                  
 var Node._lock4297859: [Node]Tid;                                                                  
 var $recorded.state4297926: int;                                                                   
 var path4297856: int;                                                                              
 var next4297908: Node;                                                                             
 var result4297863: bool;                                                                           
 var this4297796: Stack;                                                                            
 var result4297889: bool;                                                                           
 var $pc4297732: Phase;                                                                             
 var _m4297856: Mover;                                                                              
 var this4297923: Stack;                                                                            
 var Stack.top_nextThread4297792: [Stack]Tid;                                                       
 var Stack._lock4297886: [Stack]Tid;                                                                
 var Node._lock4297886: [Node]Tid;                                                                  
 var ctmp42901294297901: bool;                                                                      
 var Node.value4297925_bottom: [Node]int;                                                           
 var path4297738: int;                                                                              
 var _currentValue4297781: Node;                                                                    
 var Stack._lock4297796: [Stack]Tid;                                                                
 var Node._lock4297796: [Node]Tid;                                                                  
 var Stack.top_nextThread4297889: [Stack]Tid;                                                       
 var v4297732: int;                                                                                 
 var mover4297856: Mover;                                                                           
 var Node._lock4297925_bottom: [Node]Tid;                                                           
 var Stack.top_nextValue4297923_post: [Stack]Node;                                                  
 var v4297856: int;                                                                                 
 var this4297726: Stack;                                                                            
 var Stack._lock4297928: [Stack]Tid;                                                                
 var Node.next4297796: [Node]Node;                                                                  
 var v4297781: int;                                                                                 
 var Node._lock4297923_post: [Node]Tid;                                                             
 var Stack.top_nextThread4297738: [Stack]Tid;                                                       
 var Node._lock4297925: [Node]Tid;                                                                  
 var Stack.top_nextThread4297859: [Stack]Tid;                                                       
 var phase4297925: Phase;                                                                           
 var $recorded.state4297908: int;                                                                   
 var nu4297923: Node;                                                                               
 var Stack.top4297738: [Stack]Node;                                                                 
 var _C_t4297738: Tid;                                                                              
 var v4297908: int;                                                                                 
 var result4297923_post: bool;                                                                      
 var path4297795: int;                                                                              
 var Stack._state4297923: [Stack]State;                                                             
 var v4297923: int;                                                                                 
 var _currentValue: Node;                                                                           
 var this4297859: Stack;                                                                            
 var $recorded.state4297859: int;                                                                   
 var Node.next4297781: [Node]Node;                                                                  
 var $pc4297726: Phase;                                                                             
 var _C_v4297738: Node;                                                                             
 var Stack._lock4297776: [Stack]Tid;                                                                
 var moverPath4297859: MoverPath;                                                                   
 var next4297889: Node;                                                                             
 var Stack.top_nextValue4297859: [Stack]Node;                                                       
 var _R_t: Mover;                                                                                   
 var _C_t4297726: Tid;                                                                              
 var Node.value4297859: [Node]int;                                                                  
 var this4297781: Stack;                                                                            
 var Node.value4297781: [Node]int;                                                                  
 var Stack.top_nextValue4297923: [Stack]Node;                                                       
 var $recorded.state4297886: int;                                                                   
 var next4297886: Node;                                                                             
 var nu4297796: Node;                                                                               
 var _C_t4297776: Tid;                                                                              
 var Stack.top_nextThread4297726: [Stack]Tid;                                                       
 var Stack.top_nextValue4297776: [Stack]Node;                                                       
 var Node._state4297908: [Node]State;                                                               
 var _m4297901: Mover;                                                                              
 var Stack._lock4297796_post: [Stack]Tid;                                                           
 var moverPath4297886: MoverPath;                                                                   
 var Stack.top_nextThread4297928: [Stack]Tid;                                                       
 var _m: Mover;                                                                                     
 var Stack._lock4297926: [Stack]Tid;                                                                
 var Node.next4297928: [Node]Node;                                                                  
 var Node._state4297859: [Node]State;                                                               
 var Node.value4297796: [Node]int;                                                                  
 var this4297863: Stack;                                                                            
 var Stack.top_nextValue4297796_post: [Stack]Node;                                                  
 var $recorded.state4297856: int;                                                                   
 var v4297925_bottom: int;                                                                          
 var result4297923: bool;                                                                           
 var Node._state4297726: [Node]State;                                                               
 var next4297863: Node;                                                                             
 var path4297886: int;                                                                              
 var tmpValue4297863: Node;                                                                         
 var tmpValue4297856: Node;                                                                         
 var $pc4297856: Phase;                                                                             
 var mover4297726: Mover;                                                                           
 var Node._lock4297901: [Node]Tid;                                                                  
 var _C_v4297781: Node;                                                                             
 var Node.value4297889: [Node]int;                                                                  
 var $pc4297925_bottom: Phase;                                                                      
 var Node.value4297738: [Node]int;                                                                  
 var Node.value4297792: [Node]int;                                                                  
 var $pc4297926: Phase;                                                                             
 var Stack._state4297781: [Stack]State;                                                             
 var $pc4297863: Phase;                                                                             
 var mover4297776: Mover;                                                                           
 var Node._state4297889: [Node]State;                                                               
 var mover4297781: Mover;                                                                           
 var Stack.top_nextThread4297795: [Stack]Tid;                                                       
 var path4297889: int;                                                                              
 var next4297726: Node;                                                                             
 var $recorded.state4297726: int;                                                                   
 var tid4297732: Tid;                                                                               
 var $pc4297925: Phase;                                                                             
 var Stack._lock4297889: [Stack]Tid;                                                                
 var Stack._state4297925_bottom: [Stack]State;                                                      
 var $pc4297889: Phase;                                                                             
 var this4297856: Stack;                                                                            
 var Node.value4297886: [Node]int;                                                                  
 var v4297795: int;                                                                                 
 var Stack._state4297889: [Stack]State;                                                             
 var mover4297886: Mover;                                                                           
 var v4297792: int;                                                                                 
 var result4297901: bool;                                                                           
 var Node._lock4297926: [Node]Tid;                                                                  
 var mover4297732: Mover;                                                                           
 var _currentValue4297886: Node;                                                                    
 var Node._state4297926: [Node]State;                                                               
 var mover4297792: Mover;                                                                           
 var Node.next4297925_bottom: [Node]Node;                                                           
 var result4297886: bool;                                                                           
 var tid4297923_post: Tid;                                                                          
 var this4297923_post: Stack;                                                                       
 var $recorded.state4297738: int;                                                                   
 var tmpTid: Tid;                                                                                   
 var Node.next4297856: [Node]Node;                                                                  
 var Stack.top4297886: [Stack]Node;                                                                 
 var Node.value4297863: [Node]int;                                                                  
 var moverPath4297856: MoverPath;                                                                   
 var this4297738: Stack;                                                                            
 var tid4297908: Tid;                                                                               
 var Node._state4297923: [Node]State;                                                               
 var moverPath4297795: MoverPath;                                                                   
 var moverPath4297776: MoverPath;                                                                   
 var Stack._state4297726: [Stack]State;                                                             
 var tid4297856: Tid;                                                                               
 var next4297738: Node;                                                                             
 var Node.next4297925: [Node]Node;                                                                  
 var tmpTid4297856: Tid;                                                                            
 var Stack._state4297926: [Stack]State;                                                             
 var Stack.top4297928: [Stack]Node;                                                                 
 var Node.value4297925: [Node]int;                                                                  
 var this4297776: Stack;                                                                            
 var tid4297901: Tid;                                                                               
 var Node.next4297792: [Node]Node;                                                                  
 var Stack.top_nextThread4297925_bottom: [Stack]Tid;                                                
 var this4297901: Stack;                                                                            
 var Node.value4297923: [Node]int;                                                                  
 var Node._lock4297908: [Node]Tid;                                                                  
 var $pc4297908: Phase;                                                                             
 var ctmp42901294297886: bool;                                                                      
 var $recorded.state4297925: int;                                                                   
 var v4297796: int;                                                                                 
 var Node.value4297732: [Node]int;                                                                  
 var Stack.top_nextThread4297776: [Stack]Tid;                                                       
 var Stack.top4297863: [Stack]Node;                                                                 
 var tid4297796_post: Tid;                                                                          
 var Stack.top_nextValue4297926: [Stack]Node;                                                       
 var Stack._state4297923_post: [Stack]State;                                                        
 var Node.next4297863: [Node]Node;                                                                  
 var ctmp42901294297856: bool;                                                                      
 var mover4297738: Mover;                                                                           
 var this4297732: Stack;                                                                            
 var Stack.top_nextValue4297732: [Stack]Node;                                                       
 var Stack.top_nextThread4297901: [Stack]Tid;                                                       
 var next4297776: Node;                                                                             
 var _currentValue4297738: Node;                                                                    
 var ctmp42901294297908: bool;                                                                      
 var Stack.top_nextValue4297792: [Stack]Node;                                                       
 var v4297923_post: int;                                                                            
 var result4297856: bool;                                                                           
 var _C_t4297732: Tid;                                                                              
 var $pc4297886: Phase;                                                                             
 var $recorded.state4297928: int;                                                                   
 var Stack._lock4297795: [Stack]Tid;                                                                
 var Node._state4297796_post: [Node]State;                                                          
 var next4297796_post: Node;                                                                        
 var Stack.top4297901: [Stack]Node;                                                                 
 var tid4297796: Tid;                                                                               
 var path4297732: int;                                                                              
 var Stack.top_nextThread4297732: [Stack]Tid;                                                       
 var Node.value4297796_post: [Node]int;                                                             
 var Node.next4297732: [Node]Node;                                                                  
 var Node.value4297726: [Node]int;                                                                  
 var Node.next4297926: [Node]Node;                                                                  
 var Stack.top_nextThread4297886: [Stack]Tid;                                                       
 var $recorded.state4297796: int;                                                                   
 var this4297792: Stack;                                                                            
 var Stack.top_nextValue4297856: [Stack]Node;                                                       
 var $recorded.state4297863: int;                                                                   
 var next4297796: Node;                                                                             
 var Stack._state4297795: [Stack]State;                                                             
 var Stack.top_nextValue4297928: [Stack]Node;                                                       
 var Node._state4297928: [Node]State;                                                               
 var Stack.top_nextValue4297796: [Stack]Node;                                                       
 var _m4297908: Mover;                                                                              
 var mover4297795: Mover;                                                                           
 var path4297859: int;                                                                              
 var $recorded.state4297923: int;                                                                   
 var Stack._state4297796: [Stack]State;                                                             
 var tid4297792: Tid;                                                                               
 var Node._state4297781: [Node]State;                                                               
 var nu: Node;                                                                                      
 var Stack.top4297795: [Stack]Node;                                                                 
 var $pc4297928: Phase;                                                                             
 var Stack.top4297796_post: [Stack]Node;                                                            
 var nu4297856: Node;                                                                               
 var moverPath4297792: MoverPath;                                                                   
 var Node._state4297923_post: [Node]State;                                                          
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state4297925 == Node._state && Node.value4297925 == Node.value && Node.next4297925 == Node.next && Node._lock4297925 == Node._lock && Stack._state4297925 == Stack._state && Stack.top4297925 == Stack.top && Stack._lock4297925 == Stack._lock && Stack.top_nextThread4297925 == Stack.top_nextThread && Stack.top_nextValue4297925 == Stack.top_nextValue && v4297925 == v && this4297925 == this && tid4297925 == tid;
 assume $recorded.state4297925 == 1;                                                                
                                                                                                    
 // 12.4: while (true)   {                                                                          
                                                                                                    
 phase4297925 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (11.2): Bad tid
  invariant isShared(Stack._state[this]);                                                                  // (11.2): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
  invariant (forall _this : Node :: Invariant.Y_Node.value(tid : Tid, _this, Node.value[_this] ,Node._state4297925,Node.value4297925,Node.next4297925,Node._lock4297925,Stack._state4297925,Stack.top4297925,Stack._lock4297925,Stack.top_nextThread4297925,Stack.top_nextValue4297925));       // (12.4): Loop does not preserve yields_as annotation for field value
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state4297925,Node.value4297925,Node.next4297925,Node._lock4297925,Stack._state4297925,Stack.top4297925,Stack._lock4297925,Stack.top_nextThread4297925,Stack.top_nextValue4297925));       // (12.4): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Stack :: Invariant.Y_Stack.top(tid : Tid, _this, Stack.top[_this] ,Node._state4297925,Node.value4297925,Node.next4297925,Node._lock4297925,Stack._state4297925,Stack.top4297925,Stack._lock4297925,Stack.top_nextThread4297925,Stack.top_nextValue4297925));       // (12.4): Loop does not preserve yields_as annotation for field top
  invariant phase4297925 == $pc;                                                                           // (12.4): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (12.4): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 13.5: Node next;                                                                               
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 13.5: Tid _C_t;                                                                                
                                                                                                    
                                                                                                    
  // 13.5: _C_t := this.top_nextThread  as B;                                                       
                                                                                                    
                                                                                                    
  moverPath4297726 := ReadEval.Stack.top_nextThread(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
  mover4297726 := m#moverPath(moverPath4297726);                                                    
  path4297726 := p#moverPath(moverPath4297726);                                                     
  assume Node._state4297726 == Node._state && Node.value4297726 == Node.value && Node.next4297726 == Node.next && Node._lock4297726 == Node._lock && Stack._state4297726 == Stack._state && Stack.top4297726 == Stack.top && Stack._lock4297726 == Stack._lock && Stack.top_nextThread4297726 == Stack.top_nextThread && Stack.top_nextValue4297726 == Stack.top_nextValue && _C_t4297726 == _C_t && next4297726 == next && v4297726 == v && this4297726 == this && tid4297726 == tid && $pc4297726 == $pc;
  assume $recorded.state4297726 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (13.5): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (13.5): Reduction failure
  _C_t := Stack.top_nextThread[this];                                                               
                                                                                                    
  // 13.5: Node _C_v;                                                                               
                                                                                                    
                                                                                                    
  // 13.5: _C_v := this.top_nextValue  as B;                                                        
                                                                                                    
                                                                                                    
  moverPath4297732 := ReadEval.Stack.top_nextValue(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
  mover4297732 := m#moverPath(moverPath4297732);                                                    
  path4297732 := p#moverPath(moverPath4297732);                                                     
  assume Node._state4297732 == Node._state && Node.value4297732 == Node.value && Node.next4297732 == Node.next && Node._lock4297732 == Node._lock && Stack._state4297732 == Stack._state && Stack.top4297732 == Stack.top && Stack._lock4297732 == Stack._lock && Stack.top_nextThread4297732 == Stack.top_nextThread && Stack.top_nextValue4297732 == Stack.top_nextValue && _C_v4297732 == _C_v && _C_t4297732 == _C_t && next4297732 == next && v4297732 == v && this4297732 == this && tid4297732 == tid && $pc4297732 == $pc;
  assume $recorded.state4297732 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (13.5): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (13.5): Reduction failure
  _C_v := Stack.top_nextValue[this];                                                                
                                                                                                    
  // 13.5: Node _currentValue;                                                                      
                                                                                                    
                                                                                                    
  // 13.5: _currentValue := this.top  as B;                                                         
                                                                                                    
                                                                                                    
  moverPath4297738 := ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
  mover4297738 := m#moverPath(moverPath4297738);                                                    
  path4297738 := p#moverPath(moverPath4297738);                                                     
  assume Node._state4297738 == Node._state && Node.value4297738 == Node.value && Node.next4297738 == Node.next && Node._lock4297738 == Node._lock && Stack._state4297738 == Stack._state && Stack.top4297738 == Stack.top && Stack._lock4297738 == Stack._lock && Stack.top_nextThread4297738 == Stack.top_nextThread && Stack.top_nextValue4297738 == Stack.top_nextValue && _currentValue4297738 == _currentValue && _C_v4297738 == _C_v && _C_t4297738 == _C_t && next4297738 == next && v4297738 == v && this4297738 == this && tid4297738 == tid && $pc4297738 == $pc;
  assume $recorded.state4297738 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (13.5): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (13.5): Reduction failure
  _currentValue := Stack.top[this];                                                                 
                                                                                                    
  // 13.5: Mover _R_t;                                                                              
                                                                                                    
                                                                                                    
  // 13.5: _R_t = readPermission(this.top);                                                         
                                                                                                    
  _R_t := m#moverPath(ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue));
                                                                                                    
  // 13.5: boolean _casable;                                                                        
                                                                                                    
                                                                                                    
  // 13.5: _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                   
                                                                                                    
  _casable := ((((_R_t!=_E)&&false)&&(_C_t==tid))&&(_C_v==_currentValue));                          
  if (_casable) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 13.5: next := this.top  as R;                                                                 
                                                                                                    
                                                                                                    
   moverPath4297776 := ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
   mover4297776 := m#moverPath(moverPath4297776);                                                   
   path4297776 := p#moverPath(moverPath4297776);                                                    
   assume Node._state4297776 == Node._state && Node.value4297776 == Node.value && Node.next4297776 == Node.next && Node._lock4297776 == Node._lock && Stack._state4297776 == Stack._state && Stack.top4297776 == Stack.top && Stack._lock4297776 == Stack._lock && Stack.top_nextThread4297776 == Stack.top_nextThread && Stack.top_nextValue4297776 == Stack.top_nextValue && _casable4297776 == _casable && _R_t4297776 == _R_t && _currentValue4297776 == _currentValue && _C_v4297776 == _C_v && _C_t4297776 == _C_t && next4297776 == next && v4297776 == v && this4297776 == this && tid4297776 == tid && $pc4297776 == $pc;
   assume $recorded.state4297776 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Stack.null;                                                                      
   } else {                                                                                         
    assert this != Stack.null;                                                                             // (13.5): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, _R);                                                                      
   assert $pc != PhaseError;                                                                               // (13.5): Reduction failure
   next := Stack.top[this];                                                                         
  } else {                                                                                          
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 13.5: next := this.top;                                                                       
                                                                                                    
                                                                                                    
   moverPath4297781 := ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
   mover4297781 := m#moverPath(moverPath4297781);                                                   
   path4297781 := p#moverPath(moverPath4297781);                                                    
   assume Node._state4297781 == Node._state && Node.value4297781 == Node.value && Node.next4297781 == Node.next && Node._lock4297781 == Node._lock && Stack._state4297781 == Stack._state && Stack.top4297781 == Stack.top && Stack._lock4297781 == Stack._lock && Stack.top_nextThread4297781 == Stack.top_nextThread && Stack.top_nextValue4297781 == Stack.top_nextValue && _casable4297781 == _casable && _R_t4297781 == _R_t && _currentValue4297781 == _currentValue && _C_v4297781 == _C_v && _C_t4297781 == _C_t && next4297781 == next && v4297781 == v && this4297781 == this && tid4297781 == tid && $pc4297781 == $pc;
   assume $recorded.state4297781 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Stack.null;                                                                      
   } else {                                                                                         
    assert this != Stack.null;                                                                             // (13.5): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4297781);                                                            
   assert $pc != PhaseError;                                                                               // (13.5): Reduction failure
   next := Stack.top[this];                                                                         
  }                                                                                                 
                                                                                                    
  // 14.17: Node nu;                                                                                
                                                                                                    
                                                                                                    
  // 14.17: nu = new Node();                                                                        
                                                                                                    
  havoc nu;                                                                                         
  assume nu != Node.null && isFresh(Node._state[nu]);                                               
  Node._state[nu] := LOCAL(tid);                                                                    
  assume Node.value[nu]  == 0;                                                                      
  assume Node.next[nu]  == Node.null;                                                               
  assume Node._lock[nu]  == Tid.null;                                                               
                                                                                                    
                                                                                                    
  // 15.17: nu.value := v;                                                                          
                                                                                                    
                                                                                                    
  moverPath4297792 := WriteEval.Node.value(tid: Tid,nu: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
  mover4297792 := m#moverPath(moverPath4297792);                                                    
  path4297792 := p#moverPath(moverPath4297792);                                                     
  assume Node._state4297792 == Node._state && Node.value4297792 == Node.value && Node.next4297792 == Node.next && Node._lock4297792 == Node._lock && Stack._state4297792 == Stack._state && Stack.top4297792 == Stack.top && Stack._lock4297792 == Stack._lock && Stack.top_nextThread4297792 == Stack.top_nextThread && Stack.top_nextValue4297792 == Stack.top_nextValue && nu4297792 == nu && next4297792 == next && v4297792 == v && this4297792 == this && tid4297792 == tid && $pc4297792 == $pc;
  assume $recorded.state4297792 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume nu != Node.null;                                                                          
  } else {                                                                                          
   assert nu != Node.null;                                                                                 // (15.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover4297792);                                                             
  assert $pc != PhaseError;                                                                                // (15.17): Reduction failure
  Node.value[nu] := v;                                                                              
                                                                                                    
                                                                                                    
  // 16.5: nu.next := next;                                                                         
                                                                                                    
                                                                                                    
  moverPath4297795 := WriteEval.Node.next(tid: Tid,nu: Node,next: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
  mover4297795 := m#moverPath(moverPath4297795);                                                    
  path4297795 := p#moverPath(moverPath4297795);                                                     
  assume Node._state4297795 == Node._state && Node.value4297795 == Node.value && Node.next4297795 == Node.next && Node._lock4297795 == Node._lock && Stack._state4297795 == Stack._state && Stack.top4297795 == Stack.top && Stack._lock4297795 == Stack._lock && Stack.top_nextThread4297795 == Stack.top_nextThread && Stack.top_nextValue4297795 == Stack.top_nextValue && nu4297795 == nu && next4297795 == next && v4297795 == v && this4297795 == this && tid4297795 == tid && $pc4297795 == $pc;
  assume $recorded.state4297795 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume nu != Node.null;                                                                          
  } else {                                                                                          
   assert nu != Node.null;                                                                                 // (16.5): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover4297795);                                                             
  assert $pc != PhaseError;                                                                                // (16.5): Reduction failure
  Node.next[nu] := next;                                                                            
  if (isLocal(Node._state[next], tid)) {                                                            
   Node._state[next] := SHARED();                                                                   
   assert isSharedAssignable(Node._state[Node.next[next]]);                                                // (16.5): next became shared, but next.next may not be shared.
  }                                                                                                 
                                                                                                    
                                                                                                    
  // 17.5: yield;                                                                                   
                                                                                                    
  assume Node._state4297796 == Node._state && Node.value4297796 == Node.value && Node.next4297796 == Node.next && Node._lock4297796 == Node._lock && Stack._state4297796 == Stack._state && Stack.top4297796 == Stack.top && Stack._lock4297796 == Stack._lock && Stack.top_nextThread4297796 == Stack.top_nextThread && Stack.top_nextValue4297796 == Stack.top_nextValue && nu4297796 == nu && next4297796 == next && v4297796 == v && this4297796 == this && tid4297796 == tid;
  assume $recorded.state4297796 == 1;                                                               
  call Yield(tid);                                                                                  
  $pc := PreCommit;                                                                                 
  assume Node._state4297796_post == Node._state && Node.value4297796_post == Node.value && Node.next4297796_post == Node.next && Node._lock4297796_post == Node._lock && Stack._state4297796_post == Stack._state && Stack.top4297796_post == Stack.top && Stack._lock4297796_post == Stack._lock && Stack.top_nextThread4297796_post == Stack.top_nextThread && Stack.top_nextValue4297796_post == Stack.top_nextValue && nu4297796_post == nu && next4297796_post == next && v4297796_post == v && this4297796_post == this && tid4297796_post == tid;
  assume $recorded.state4297796_post == 1;                                                          
                                                                                                    
  // 18.5: boolean result;                                                                          
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 18.5: boolean ctmp4290129;                                                                     
                                                                                                    
                                                                                                    
  // 18.5: ctmp4290129 = *;                                                                         
                                                                                                    
  havoc ctmp4290129;                                                                                
  if (ctmp4290129) {                                                                                
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 18.5: result = false;                                                                         
                                                                                                    
   result := false;                                                                                 
  } else {                                                                                          
                                                                                                    
   // 18.5: ctmp4290129 = *;                                                                        
                                                                                                    
   havoc ctmp4290129;                                                                               
   if (ctmp4290129) {                                                                               
                                                                                                    
    // 18.5: Tid tmpTid;                                                                            
                                                                                                    
                                                                                                    
    // 18.5: Node tmpValue;                                                                         
                                                                                                    
                                                                                                    
    // 18.5: Mover _m;                                                                              
                                                                                                    
                                                                                                    
    // 18.5: _m = writePermission(this.top, nu);                                                    
                                                                                                    
    _m := m#moverPath(WriteEval.Stack.top(tid: Tid,this: Stack,nu: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue));
                                                                                                    
    // 18.5: assume this.top == next;                                                               
                                                                                                    
    assume (Stack.top[this]==next);                                                                 
                                                                                                    
    // 18.5: assume !goesWrong(_m);                                                                 
                                                                                                    
    assume !(transition($pc, _m) == PhaseError);                                                    
                                                                                                    
    // 18.5: assume this.top_nextThread == tid;                                                     
                                                                                                    
    assume (Stack.top_nextThread[this]==tid);                                                       
                                                                                                    
    // 18.5: assume this.top_nextValue == next;                                                     
                                                                                                    
    assume (Stack.top_nextValue[this]==next);                                                       
                                                                                                    
                                                                                                    
    // 18.5: this.top_nextThread := tmpTid as B;                                                    
                                                                                                    
                                                                                                    
    moverPath4297856 := WriteEval.Stack.top_nextThread(tid: Tid,this: Stack,tmpTid: Tid,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4297856 := m#moverPath(moverPath4297856);                                                  
    path4297856 := p#moverPath(moverPath4297856);                                                   
    assume Node._state4297856 == Node._state && Node.value4297856 == Node.value && Node.next4297856 == Node.next && Node._lock4297856 == Node._lock && Stack._state4297856 == Stack._state && Stack.top4297856 == Stack.top && Stack._lock4297856 == Stack._lock && Stack.top_nextThread4297856 == Stack.top_nextThread && Stack.top_nextValue4297856 == Stack.top_nextValue && _m4297856 == _m && tmpValue4297856 == tmpValue && tmpTid4297856 == tmpTid && ctmp42901294297856 == ctmp4290129 && result4297856 == result && nu4297856 == nu && next4297856 == next && v4297856 == v && this4297856 == this && tid4297856 == tid && $pc4297856 == $pc;
    assume $recorded.state4297856 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (18.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (18.5): Reduction failure
    Stack.top_nextThread[this] := tmpTid;                                                           
                                                                                                    
                                                                                                    
    // 18.5: this.top_nextValue := tmpValue as B;                                                   
                                                                                                    
                                                                                                    
    moverPath4297859 := WriteEval.Stack.top_nextValue(tid: Tid,this: Stack,tmpValue: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4297859 := m#moverPath(moverPath4297859);                                                  
    path4297859 := p#moverPath(moverPath4297859);                                                   
    assume Node._state4297859 == Node._state && Node.value4297859 == Node.value && Node.next4297859 == Node.next && Node._lock4297859 == Node._lock && Stack._state4297859 == Stack._state && Stack.top4297859 == Stack.top && Stack._lock4297859 == Stack._lock && Stack.top_nextThread4297859 == Stack.top_nextThread && Stack.top_nextValue4297859 == Stack.top_nextValue && _m4297859 == _m && tmpValue4297859 == tmpValue && tmpTid4297859 == tmpTid && ctmp42901294297859 == ctmp4290129 && result4297859 == result && nu4297859 == nu && next4297859 == next && v4297859 == v && this4297859 == this && tid4297859 == tid && $pc4297859 == $pc;
    assume $recorded.state4297859 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (18.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (18.5): Reduction failure
    Stack.top_nextValue[this] := tmpValue;                                                          
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 18.5: this.top := nu;                                                                        
                                                                                                    
                                                                                                    
    moverPath4297863 := WriteEval.Stack.top(tid: Tid,this: Stack,nu: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4297863 := m#moverPath(moverPath4297863);                                                  
    path4297863 := p#moverPath(moverPath4297863);                                                   
    assume Node._state4297863 == Node._state && Node.value4297863 == Node.value && Node.next4297863 == Node.next && Node._lock4297863 == Node._lock && Stack._state4297863 == Stack._state && Stack.top4297863 == Stack.top && Stack._lock4297863 == Stack._lock && Stack.top_nextThread4297863 == Stack.top_nextThread && Stack.top_nextValue4297863 == Stack.top_nextValue && _m4297863 == _m && tmpValue4297863 == tmpValue && tmpTid4297863 == tmpTid && ctmp42901294297863 == ctmp4290129 && result4297863 == result && nu4297863 == nu && next4297863 == next && v4297863 == v && this4297863 == this && tid4297863 == tid && $pc4297863 == $pc;
    assume $recorded.state4297863 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (18.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover4297863);                                                           
    assert $pc != PhaseError;                                                                              // (18.5): Reduction failure
    Stack.top[this] := nu;                                                                          
    if (isLocal(Node._state[nu], tid)) {                                                            
     Node._state[nu] := SHARED();                                                                   
     assert isSharedAssignable(Node._state[Node.next[nu]]);                                                // (18.5): nu became shared, but nu.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 18.5: result = true;                                                                         
                                                                                                    
    result := true;                                                                                 
   } else {                                                                                         
                                                                                                    
    // 18.5: assume this.top_nextThread == tid;                                                     
                                                                                                    
    assume (Stack.top_nextThread[this]==tid);                                                       
                                                                                                    
    // 18.5: assume this.top_nextValue == next;                                                     
                                                                                                    
    assume (Stack.top_nextValue[this]==next);                                                       
                                                                                                    
    // 18.5: Node _currentValue;                                                                    
                                                                                                    
                                                                                                    
    // 18.5: _currentValue := this.top  as B;                                                       
                                                                                                    
                                                                                                    
    moverPath4297886 := ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4297886 := m#moverPath(moverPath4297886);                                                  
    path4297886 := p#moverPath(moverPath4297886);                                                   
    assume Node._state4297886 == Node._state && Node.value4297886 == Node.value && Node.next4297886 == Node.next && Node._lock4297886 == Node._lock && Stack._state4297886 == Stack._state && Stack.top4297886 == Stack.top && Stack._lock4297886 == Stack._lock && Stack.top_nextThread4297886 == Stack.top_nextThread && Stack.top_nextValue4297886 == Stack.top_nextValue && _currentValue4297886 == _currentValue && ctmp42901294297886 == ctmp4290129 && result4297886 == result && nu4297886 == nu && next4297886 == next && v4297886 == v && this4297886 == this && tid4297886 == tid && $pc4297886 == $pc;
    assume $recorded.state4297886 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (18.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
                                                                                                    
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (18.5): Reduction failure
    _currentValue := Stack.top[this];                                                               
                                                                                                    
                                                                                                    
    // 18.5: this.top := next as B;                                                                 
                                                                                                    
                                                                                                    
    moverPath4297889 := WriteEval.Stack.top(tid: Tid,this: Stack,next: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4297889 := m#moverPath(moverPath4297889);                                                  
    path4297889 := p#moverPath(moverPath4297889);                                                   
    assume Node._state4297889 == Node._state && Node.value4297889 == Node.value && Node.next4297889 == Node.next && Node._lock4297889 == Node._lock && Stack._state4297889 == Stack._state && Stack.top4297889 == Stack.top && Stack._lock4297889 == Stack._lock && Stack.top_nextThread4297889 == Stack.top_nextThread && Stack.top_nextValue4297889 == Stack.top_nextValue && _currentValue4297889 == _currentValue && ctmp42901294297889 == ctmp4290129 && result4297889 == result && nu4297889 == nu && next4297889 == next && v4297889 == v && this4297889 == this && tid4297889 == tid && $pc4297889 == $pc;
    assume $recorded.state4297889 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (18.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (18.5): Reduction failure
    Stack.top[this] := next;                                                                        
    if (isLocal(Node._state[next], tid)) {                                                          
     Node._state[next] := SHARED();                                                                 
     assert isSharedAssignable(Node._state[Node.next[next]]);                                              // (18.5): next became shared, but next.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 18.5: Mover _m;                                                                              
                                                                                                    
                                                                                                    
    // 18.5: _m = writePermission(this.top, nu);                                                    
                                                                                                    
    _m := m#moverPath(WriteEval.Stack.top(tid: Tid,this: Stack,nu: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue));
                                                                                                    
                                                                                                    
    // 18.5: this.top := _currentValue as B;                                                        
                                                                                                    
                                                                                                    
    moverPath4297901 := WriteEval.Stack.top(tid: Tid,this: Stack,_currentValue: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4297901 := m#moverPath(moverPath4297901);                                                  
    path4297901 := p#moverPath(moverPath4297901);                                                   
    assume Node._state4297901 == Node._state && Node.value4297901 == Node.value && Node.next4297901 == Node.next && Node._lock4297901 == Node._lock && Stack._state4297901 == Stack._state && Stack.top4297901 == Stack.top && Stack._lock4297901 == Stack._lock && Stack.top_nextThread4297901 == Stack.top_nextThread && Stack.top_nextValue4297901 == Stack.top_nextValue && _m4297901 == _m && _currentValue4297901 == _currentValue && ctmp42901294297901 == ctmp4290129 && result4297901 == result && nu4297901 == nu && next4297901 == next && v4297901 == v && this4297901 == this && tid4297901 == tid && $pc4297901 == $pc;
    assume $recorded.state4297901 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (18.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (18.5): Reduction failure
    Stack.top[this] := _currentValue;                                                               
    if (isLocal(Node._state[_currentValue], tid)) {                                                 
     Node._state[_currentValue] := SHARED();                                                        
     assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                     // (18.5): _currentValue became shared, but _currentValue.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 18.5: assume goesWrong(_m);                                                                  
                                                                                                    
    assume transition($pc, _m) == PhaseError;                                                       
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 18.5: this.top := nu;                                                                        
                                                                                                    
                                                                                                    
    moverPath4297908 := WriteEval.Stack.top(tid: Tid,this: Stack,nu: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4297908 := m#moverPath(moverPath4297908);                                                  
    path4297908 := p#moverPath(moverPath4297908);                                                   
    assume Node._state4297908 == Node._state && Node.value4297908 == Node.value && Node.next4297908 == Node.next && Node._lock4297908 == Node._lock && Stack._state4297908 == Stack._state && Stack.top4297908 == Stack.top && Stack._lock4297908 == Stack._lock && Stack.top_nextThread4297908 == Stack.top_nextThread && Stack.top_nextValue4297908 == Stack.top_nextValue && _m4297908 == _m && _currentValue4297908 == _currentValue && ctmp42901294297908 == ctmp4290129 && result4297908 == result && nu4297908 == nu && next4297908 == next && v4297908 == v && this4297908 == this && tid4297908 == tid && $pc4297908 == $pc;
    assume $recorded.state4297908 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (18.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover4297908);                                                           
    assert $pc != PhaseError;                                                                              // (18.5): Reduction failure
    Stack.top[this] := nu;                                                                          
    if (isLocal(Node._state[nu], tid)) {                                                            
     Node._state[nu] := SHARED();                                                                   
     assert isSharedAssignable(Node._state[Node.next[nu]]);                                                // (18.5): nu became shared, but nu.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 18.5: result = false;                                                                        
                                                                                                    
    result := false;                                                                                
   }                                                                                                
  }                                                                                                 
  if (result) {                                                                                     
                                                                                                    
   // 20.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 22.5: yield;                                                                                   
                                                                                                    
  assume Node._state4297923 == Node._state && Node.value4297923 == Node.value && Node.next4297923 == Node.next && Node._lock4297923 == Node._lock && Stack._state4297923 == Stack._state && Stack.top4297923 == Stack.top && Stack._lock4297923 == Stack._lock && Stack.top_nextThread4297923 == Stack.top_nextThread && Stack.top_nextValue4297923 == Stack.top_nextValue && result4297923 == result && nu4297923 == nu && next4297923 == next && v4297923 == v && this4297923 == this && tid4297923 == tid;
  assume $recorded.state4297923 == 1;                                                               
  call Yield(tid);                                                                                  
  $pc := PreCommit;                                                                                 
  assume Node._state4297923_post == Node._state && Node.value4297923_post == Node.value && Node.next4297923_post == Node.next && Node._lock4297923_post == Node._lock && Stack._state4297923_post == Stack._state && Stack.top4297923_post == Stack.top && Stack._lock4297923_post == Stack._lock && Stack.top_nextThread4297923_post == Stack.top_nextThread && Stack.top_nextValue4297923_post == Stack.top_nextValue && result4297923_post == result && nu4297923_post == nu && next4297923_post == next && v4297923_post == v && this4297923_post == this && tid4297923_post == tid;
  assume $recorded.state4297923_post == 1;                                                          
  assume Node._state4297925_bottom == Node._state && Node.value4297925_bottom == Node.value && Node.next4297925_bottom == Node.next && Node._lock4297925_bottom == Node._lock && Stack._state4297925_bottom == Stack._state && Stack.top4297925_bottom == Stack.top && Stack._lock4297925_bottom == Stack._lock && Stack.top_nextThread4297925_bottom == Stack.top_nextThread && Stack.top_nextValue4297925_bottom == Stack.top_nextValue && v4297925_bottom == v && this4297925_bottom == this && tid4297925_bottom == tid;
  assume $recorded.state4297925_bottom == 1;                                                        
  assert phase4297925 == $pc;                                                                              // (12.4): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 24.4:  return;                                                                                  
                                                                                                    
 assume Node._state4297926 == Node._state && Node.value4297926 == Node.value && Node.next4297926 == Node.next && Node._lock4297926 == Node._lock && Stack._state4297926 == Stack._state && Stack.top4297926 == Stack.top && Stack._lock4297926 == Stack._lock && Stack.top_nextThread4297926 == Stack.top_nextThread && Stack.top_nextValue4297926 == Stack.top_nextValue && v4297926 == v && this4297926 == this && tid4297926 == tid;
 assume $recorded.state4297926 == 1;                                                                
 return;                                                                                            
                                                                                                    
 // 11.26: // return;                                                                               
                                                                                                    
 assume Node._state4297928 == Node._state && Node.value4297928 == Node.value && Node.next4297928 == Node.next && Node._lock4297928 == Node._lock && Stack._state4297928 == Stack._state && Stack.top4297928 == Stack.top && Stack._lock4297928 == Stack._lock && Stack.top_nextThread4297928 == Stack.top_nextThread && Stack.top_nextValue4297928 == Stack.top_nextValue && v4297928 == v && this4297928 == this && tid4297928 == tid;
 assume $recorded.state4297928 == 1;                                                                
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  Stack.push2(tid:Tid, this : Stack, v : int)                                              
modifies Node._state;                                                                               
modifies Node.value;                                                                                
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Stack._state;                                                                              
modifies Stack.top;                                                                                 
modifies Stack._lock;                                                                               
modifies Stack.top_nextThread;                                                                      
modifies Stack.top_nextValue;                                                                       
                                                                                                    
requires ValidTid(tid);                                                                                    // (27.2): Bad tid
requires isShared(Stack._state[this]);                                                                     // (27.2): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
                                                                                                    
ensures StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
{                                                                                                   
 var mover4298074: Mover;                                                                           
 var Stack.top4298140_bottom: [Stack]Node;                                                          
 var Stack._lock4297949: [Stack]Tid;                                                                
 var Node.value4298140_bottom: [Node]int;                                                           
 var $pc4298101: Phase;                                                                             
 var _C_t4297955: Tid;                                                                              
 var nu4298123: Node;                                                                               
 var mover4298078: Mover;                                                                           
 var Stack.top4297949: [Stack]Node;                                                                 
 var path4298123: int;                                                                              
 var Node.next4297961: [Node]Node;                                                                  
 var Stack._lock4298116: [Stack]Tid;                                                                
 var tid4298004: Tid;                                                                               
 var Node.next4298011: [Node]Node;                                                                  
 var Node._state4297999: [Node]State;                                                               
 var next4298011_post: Node;                                                                        
 var $pc4298116: Phase;                                                                             
 var Stack.top4298071: [Stack]Node;                                                                 
 var Stack._lock4298140_bottom: [Stack]Tid;                                                         
 var Node._lock4298011: [Node]Tid;                                                                  
 var v4298141: int;                                                                                 
 var tid4298078: Tid;                                                                               
 var Stack.top_nextValue4298074: [Stack]Node;                                                       
 var $pc4298011_post: Phase;                                                                        
 var Stack.top4297955: [Stack]Node;                                                                 
 var Stack._state4298071: [Stack]State;                                                             
 var Stack.top4298138_post: [Stack]Node;                                                            
 var Stack._state4298141: [Stack]State;                                                             
 var _C_v4297961: Node;                                                                             
 var Node._lock4298140: [Node]Tid;                                                                  
 var tid4298143: Tid;                                                                               
 var nu4298078: Node;                                                                               
 var Node.value4298123: [Node]int;                                                                  
 var Stack.top_nextThread4297999: [Stack]Tid;                                                       
 var nu4298071: Node;                                                                               
 var Stack.top4298123: [Stack]Node;                                                                 
 var $recorded.state4298104: int;                                                                   
 var next: Node;                                                                                    
 var _C_t: Tid;                                                                                     
 var $pc4298143: Phase;                                                                             
 var Node._state4298011: [Node]State;                                                               
 var v4298123: int;                                                                                 
 var $recorded.state4298011: int;                                                                   
 var mover4297949: Mover;                                                                           
 var tid4298140: Tid;                                                                               
 var Stack._state4297955: [Stack]State;                                                             
 var tid4297955: Tid;                                                                               
 var nu4298011_post: Node;                                                                          
 var Stack._state4298078: [Stack]State;                                                             
 var ctmp42901764298071: bool;                                                                      
 var $recorded.state4297939: int;                                                                   
 var Node._lock4297999: [Node]Tid;                                                                  
 var moverPath4298004: MoverPath;                                                                   
 var Stack._lock4298011_post: [Stack]Tid;                                                           
 var Stack.top_nextThread4298104: [Stack]Tid;                                                       
 var tmpValue4298071: Node;                                                                         
 var $pc4298104: Phase;                                                                             
 var _m4298078: Mover;                                                                              
 var Node.next4298141: [Node]Node;                                                                  
 var $recorded.state4298101: int;                                                                   
 var path4298116: int;                                                                              
 var Node.value4298011: [Node]int;                                                                  
 var Node.next4298138: [Node]Node;                                                                  
 var nu4298143: Node;                                                                               
 var this4298071: Stack;                                                                            
 var Stack._state4298104: [Stack]State;                                                             
 var ctmp42901764298104: bool;                                                                      
 var Node.value4298104: [Node]int;                                                                  
 var tmpValue: Node;                                                                                
 var Node.next4298104: [Node]Node;                                                                  
 var Node.value4297949: [Node]int;                                                                  
 var tmpValue4298074: Node;                                                                         
 var _casable: bool;                                                                                
 var Stack._lock4297939: [Stack]Tid;                                                                
 var Stack._state4297949: [Stack]State;                                                             
 var Node._state4297961: [Node]State;                                                               
 var this4298143: Stack;                                                                            
 var v4298011: int;                                                                                 
 var Node._state4297955: [Node]State;                                                               
 var Node.value4298074: [Node]int;                                                                  
 var Stack.top_nextValue4298011: [Stack]Node;                                                       
 var Node._state4298140: [Node]State;                                                               
 var Stack.top_nextThread4297961: [Stack]Tid;                                                       
 var Node.next4297949: [Node]Node;                                                                  
 var moverPath4298104: MoverPath;                                                                   
 var path4298078: int;                                                                              
 var nu4298101: Node;                                                                               
 var nu4297961: Node;                                                                               
 var nu4298138: Node;                                                                               
 var Stack.top_nextValue4298104: [Stack]Node;                                                       
 var result4298123: bool;                                                                           
 var Node._state4298140_bottom: [Node]State;                                                        
 var next4298074: Node;                                                                             
 var $pc4298071: Phase;                                                                             
 var Node._state4298123: [Node]State;                                                               
 var Node.value4298116: [Node]int;                                                                  
 var Stack.top_nextThread4298138_post: [Stack]Tid;                                                  
 var this4297949: Stack;                                                                            
 var _C_t4297999: Tid;                                                                              
 var nu4297955: Node;                                                                               
 var tid4298123: Tid;                                                                               
 var $recorded.state4298116: int;                                                                   
 var $pc4297961: Phase;                                                                             
 var ctmp42901764298116: bool;                                                                      
 var next4298071: Node;                                                                             
 var Node._lock4298141: [Node]Tid;                                                                  
 var this4297955: Stack;                                                                            
 var Node._lock4298116: [Node]Tid;                                                                  
 var _currentValue4298004: Node;                                                                    
 var Node.value4298138_post: [Node]int;                                                             
 var Stack.top4297961: [Stack]Node;                                                                 
 var tid4298140_bottom: Tid;                                                                        
 var _R_t4298004: Mover;                                                                            
 var Node._lock4298011_post: [Node]Tid;                                                             
 var Stack.top4298101: [Stack]Node;                                                                 
 var moverPath4298101: MoverPath;                                                                   
 var path4297961: int;                                                                              
 var this4298074: Stack;                                                                            
 var Stack.top4297999: [Stack]Node;                                                                 
 var $pc4298140: Phase;                                                                             
 var nu4298011: Node;                                                                               
 var Node._lock4298101: [Node]Tid;                                                                  
 var _currentValue4298116: Node;                                                                    
 var $recorded.state4297949: int;                                                                   
 var mover4298123: Mover;                                                                           
 var $pc4298141: Phase;                                                                             
 var Stack.top_nextValue4298101: [Stack]Node;                                                       
 var tid4298138: Tid;                                                                               
 var v4298140: int;                                                                                 
 var Stack.top4298138: [Stack]Node;                                                                 
 var next4297999: Node;                                                                             
 var this4298004: Stack;                                                                            
 var Stack._state4298074: [Stack]State;                                                             
 var Node._state4298104: [Node]State;                                                               
 var tid4297961: Tid;                                                                               
 var path4298071: int;                                                                              
 var Stack.top4298074: [Stack]Node;                                                                 
 var this4298116: Stack;                                                                            
 var Stack.top4298010: [Stack]Node;                                                                 
 var Node.value4297999: [Node]int;                                                                  
 var moverPath4298010: MoverPath;                                                                   
 var Node._lock4297939: [Node]Tid;                                                                  
 var $pc4298123: Phase;                                                                             
 var tid4297999: Tid;                                                                               
 var result4298071: bool;                                                                           
 var moverPath4298078: MoverPath;                                                                   
 var result4298101: bool;                                                                           
 var next4297949: Node;                                                                             
 var Node.value4298140: [Node]int;                                                                  
 var $pc4298078: Phase;                                                                             
 var nu4298140_bottom: Node;                                                                        
 var Node._lock4297949: [Node]Tid;                                                                  
 var next4297955: Node;                                                                             
 var this4297961: Stack;                                                                            
 var Node._lock4298143: [Node]Tid;                                                                  
 var Node._lock4298004: [Node]Tid;                                                                  
 var Stack._state4298011_post: [Stack]State;                                                        
 var v4298140_bottom: int;                                                                          
 var Node.value4298004: [Node]int;                                                                  
 var next4298138_post: Node;                                                                        
 var v4297955: int;                                                                                 
 var Node.next4298011_post: [Node]Node;                                                             
 var Stack._state4298101: [Stack]State;                                                             
 var Stack._lock4298123: [Stack]Tid;                                                                
 var Node._lock4298138_post: [Node]Tid;                                                             
 var $recorded.state4297961: int;                                                                   
 var Stack.top_nextValue4298004: [Stack]Node;                                                       
 var _currentValue4298104: Node;                                                                    
 var Stack.top_nextValue4297999: [Stack]Node;                                                       
 var _m4298123: Mover;                                                                              
 var this4298123: Stack;                                                                            
 var nu4297949: Node;                                                                               
 var Stack.top_nextThread4298141: [Stack]Tid;                                                       
 var mover4298101: Mover;                                                                           
 var Stack.top_nextValue4298138_post: [Stack]Node;                                                  
 var v4298078: int;                                                                                 
 var Node.value4297961: [Node]int;                                                                  
 var Stack._lock4298074: [Stack]Tid;                                                                
 var _C_t4297961: Tid;                                                                              
 var Stack.top_nextThread4298138: [Stack]Tid;                                                       
 var result4298116: bool;                                                                           
 var Node._state4298011_post: [Node]State;                                                          
 var v4298074: int;                                                                                 
 var next4297961: Node;                                                                             
 var v4298071: int;                                                                                 
 var Stack._lock4297955: [Stack]Tid;                                                                
 var _currentValue4297961: Node;                                                                    
 var Node.next4298140: [Node]Node;                                                                  
 var this4297999: Stack;                                                                            
 var this4298138_post: Stack;                                                                       
 var Stack.top_nextValue4298138: [Stack]Node;                                                       
 var Node.value4298143: [Node]int;                                                                  
 var v4298010: int;                                                                                 
 var _C_v: Node;                                                                                    
 var Stack.top_nextThread4298071: [Stack]Tid;                                                       
 var tid4297949: Tid;                                                                               
 var $pc4298004: Phase;                                                                             
 var Node._state4298143: [Node]State;                                                               
 var moverPath4297999: MoverPath;                                                                   
 var $recorded.state4298010: int;                                                                   
 var next4298101: Node;                                                                             
 var Node.next4298071: [Node]Node;                                                                  
 var _currentValue4297999: Node;                                                                    
 var Stack.top4298011_post: [Stack]Node;                                                            
 var $recorded.state4297999: int;                                                                   
 var result4298138_post: bool;                                                                      
 var tmpTid4298078: Tid;                                                                            
 var moverPath4297961: MoverPath;                                                                   
 var nu4298004: Node;                                                                               
 var Node._state4298074: [Node]State;                                                               
 var Stack._state4298010: [Stack]State;                                                             
 var v4298004: int;                                                                                 
 var Node._state4297939: [Node]State;                                                               
 var Stack.top_nextThread4298010: [Stack]Tid;                                                       
 var next4298011: Node;                                                                             
 var Node.next4298074: [Node]Node;                                                                  
 var $recorded.state4297955: int;                                                                   
 var this4298140_bottom: Stack;                                                                     
 var path4298010: int;                                                                              
 var mover4297939: Mover;                                                                           
 var result4298104: bool;                                                                           
 var Node._lock4298140_bottom: [Node]Tid;                                                           
 var Node.value4298141: [Node]int;                                                                  
 var Node._lock4298071: [Node]Tid;                                                                  
 var result: bool;                                                                                  
 var moverPath4298123: MoverPath;                                                                   
 var next4298116: Node;                                                                             
 var $recorded.state4298141: int;                                                                   
 var path4298074: int;                                                                              
 var _C_t4298004: Tid;                                                                              
 var tid4298104: Tid;                                                                               
 var next4298010: Node;                                                                             
 var $recorded.state4298004: int;                                                                   
 var Node._lock4297955: [Node]Tid;                                                                  
 var _m4298116: Mover;                                                                              
 var Stack.top_nextThread4298074: [Stack]Tid;                                                       
 var $recorded.state4298138: int;                                                                   
 var Node._state4298101: [Node]State;                                                               
 var Stack._state4297961: [Stack]State;                                                             
 var Stack.top_nextValue4297961: [Stack]Node;                                                       
 var $pc4297999: Phase;                                                                             
 var Node.next4298004: [Node]Node;                                                                  
 var Stack._state4298140: [Stack]State;                                                             
 var Stack.top_nextThread4298101: [Stack]Tid;                                                       
 var tmpValue4298078: Node;                                                                         
 var Node._lock4298074: [Node]Tid;                                                                  
 var path4297999: int;                                                                              
 var path4297949: int;                                                                              
 var this4298078: Stack;                                                                            
 var Node._lock4297961: [Node]Tid;                                                                  
 var Node._state4298141: [Node]State;                                                               
 var moverPath4297939: MoverPath;                                                                   
 var v4297949: int;                                                                                 
 var nu4298141: Node;                                                                               
 var Stack._state4298138: [Stack]State;                                                             
 var Stack._state4298116: [Stack]State;                                                             
 var path4297939: int;                                                                              
 var this4298140: Stack;                                                                            
 var ctmp42901764298078: bool;                                                                      
 var $recorded.state4298078: int;                                                                   
 var result4298138: bool;                                                                           
 var mover4298116: Mover;                                                                           
 var Stack.top_nextValue4298141: [Stack]Node;                                                       
 var $recorded.state4298011_post: int;                                                              
 var next4298078: Node;                                                                             
 var $pc4298074: Phase;                                                                             
 var _C_v4297999: Node;                                                                             
 var Node.value4298078: [Node]int;                                                                  
 var Node._lock4298010: [Node]Tid;                                                                  
 var Node.value4298071: [Node]int;                                                                  
 var Stack.top4298140: [Stack]Node;                                                                 
 var result4298078: bool;                                                                           
 var Node.value4298101: [Node]int;                                                                  
 var _C_v4297955: Node;                                                                             
 var v4298116: int;                                                                                 
 var Stack.top4298143: [Stack]Node;                                                                 
 var Node.next4298123: [Node]Node;                                                                  
 var Stack.top_nextThread4298116: [Stack]Tid;                                                       
 var Node._lock4298104: [Node]Tid;                                                                  
 var _currentValue: Node;                                                                           
 var Node.next4298078: [Node]Node;                                                                  
 var Stack.top_nextThread4297949: [Stack]Tid;                                                       
 var Stack.top4298004: [Stack]Node;                                                                 
 var mover4298071: Mover;                                                                           
 var path4298104: int;                                                                              
 var v4298138_post: int;                                                                            
 var _m4298071: Mover;                                                                              
 var Node.next4298010: [Node]Node;                                                                  
 var Stack.top_nextValue4298123: [Stack]Node;                                                       
 var Stack.top_nextValue4298116: [Stack]Node;                                                       
 var moverPath4298074: MoverPath;                                                                   
 var _R_t: Mover;                                                                                   
 var v4298104: int;                                                                                 
 var Node.next4297999: [Node]Node;                                                                  
 var next4298104: Node;                                                                             
 var Node.next4298116: [Node]Node;                                                                  
 var _C_t4297949: Tid;                                                                              
 var moverPath4297955: MoverPath;                                                                   
 var Node.next4297955: [Node]Node;                                                                  
 var Stack._lock4298010: [Stack]Tid;                                                                
 var _m: Mover;                                                                                     
 var $recorded.state4298074: int;                                                                   
 var Stack._state4298143: [Stack]State;                                                             
 var Stack._lock4298140: [Stack]Tid;                                                                
 var $pc4298140_bottom: Phase;                                                                      
 var Stack._lock4298004: [Stack]Tid;                                                                
 var Stack.top_nextThread4298011_post: [Stack]Tid;                                                  
 var this4297939: Stack;                                                                            
 var nu4298116: Node;                                                                               
 var nu4298010: Node;                                                                               
 var Stack.top_nextThread4298143: [Stack]Tid;                                                       
 var this4298101: Stack;                                                                            
 var Stack.top_nextThread4298004: [Stack]Tid;                                                       
 var Stack.top_nextValue4298078: [Stack]Node;                                                       
 var Stack.top_nextThread4297955: [Stack]Tid;                                                       
 var v4297961: int;                                                                                 
 var ctmp42901764298074: bool;                                                                      
 var Stack.top_nextValue4298140: [Stack]Node;                                                       
 var Node.next4298143: [Node]Node;                                                                  
 var ctmp4290176: bool;                                                                             
 var tid4298011_post: Tid;                                                                          
 var Stack.top_nextThread4298140_bottom: [Stack]Tid;                                                
 var v4297999: int;                                                                                 
 var Stack._lock4298071: [Stack]Tid;                                                                
 var Node.next4298101: [Node]Node;                                                                  
 var next4298004: Node;                                                                             
 var Stack.top4298104: [Stack]Node;                                                                 
 var Stack._state4297999: [Stack]State;                                                             
 var v4298101: int;                                                                                 
 var Stack.top_nextValue4298011_post: [Stack]Node;                                                  
 var this4298138: Stack;                                                                            
 var tid4298074: Tid;                                                                               
 var Node._lock4298123: [Node]Tid;                                                                  
 var Stack.top_nextValue4298010: [Stack]Node;                                                       
 var Stack._state4298140_bottom: [Stack]State;                                                      
 var Node.next4297939: [Node]Node;                                                                  
 var mover4298010: Mover;                                                                           
 var $recorded.state4298140: int;                                                                   
 var _currentValue4298101: Node;                                                                    
 var Stack._state4298011: [Stack]State;                                                             
 var path4298101: int;                                                                              
 var Stack._lock4298078: [Stack]Tid;                                                                
 var Stack._lock4298138: [Stack]Tid;                                                                
 var Stack._lock4298104: [Stack]Tid;                                                                
 var Stack.top_nextValue4298143: [Stack]Node;                                                       
 var Node.value4297939: [Node]int;                                                                  
 var Stack.top_nextThread4297939: [Stack]Tid;                                                       
 var this4298104: Stack;                                                                            
 var Node._state4297949: [Node]State;                                                               
 var Node._state4298004: [Node]State;                                                               
 var nu4297939: Node;                                                                               
 var Stack.top4298011: [Stack]Node;                                                                 
 var path4297955: int;                                                                              
 var $pc4298011: Phase;                                                                             
 var v4298011_post: int;                                                                            
 var $recorded.state4298143: int;                                                                   
 var path4298004: int;                                                                              
 var tid4298071: Tid;                                                                               
 var _C_v4298004: Node;                                                                             
 var Stack.top_nextThread4298078: [Stack]Tid;                                                       
 var _R_t4297999: Mover;                                                                            
 var Node.next4298138_post: [Node]Node;                                                             
 var tmpTid: Tid;                                                                                   
 var tid4297939: Tid;                                                                               
 var $recorded.state4298140_bottom: int;                                                            
 var $recorded.state4298138_post: int;                                                              
 var Node.next4298140_bottom: [Node]Node;                                                           
 var Node._state4298071: [Node]State;                                                               
 var Stack.top4298078: [Stack]Node;                                                                 
 var ctmp42901764298101: bool;                                                                      
 var Stack._state4298004: [Stack]State;                                                             
 var Stack._lock4298138_post: [Stack]Tid;                                                           
 var this4298011_post: Stack;                                                                       
 var Node.value4298011_post: [Node]int;                                                             
 var Node._state4298138_post: [Node]State;                                                          
 var next4298138: Node;                                                                             
 var nu4297999: Node;                                                                               
 var $pc4297939: Phase;                                                                             
 var tid4298116: Tid;                                                                               
 var Stack._lock4298011: [Stack]Tid;                                                                
 var $pc4297955: Phase;                                                                             
 var Node._state4298010: [Node]State;                                                               
 var mover4297955: Mover;                                                                           
 var tid4298011: Tid;                                                                               
 var Stack._state4298123: [Stack]State;                                                             
 var nu4298074: Node;                                                                               
 var Stack.top_nextValue4298071: [Stack]Node;                                                       
 var moverPath4298071: MoverPath;                                                                   
 var mover4298104: Mover;                                                                           
 var Stack.top4298141: [Stack]Node;                                                                 
 var Stack.top_nextValue4297939: [Stack]Node;                                                       
 var nu4298140: Node;                                                                               
 var Stack._lock4297961: [Stack]Tid;                                                                
 var tid4298141: Tid;                                                                               
 var Node.value4298010: [Node]int;                                                                  
 var Stack._lock4298141: [Stack]Tid;                                                                
 var $pc4298138_post: Phase;                                                                        
 var mover4297999: Mover;                                                                           
 var next4298123: Node;                                                                             
 var tmpTid4298074: Tid;                                                                            
 var Stack._state4297939: [Stack]State;                                                             
 var Stack.top_nextThread4298011: [Stack]Tid;                                                       
 var Node._state4298116: [Node]State;                                                               
 var moverPath4297949: MoverPath;                                                                   
 var mover4297961: Mover;                                                                           
 var moverPath4298116: MoverPath;                                                                   
 var _casable4298004: bool;                                                                         
 var v4297939: int;                                                                                 
 var _m4298074: Mover;                                                                              
 var _currentValue4298123: Node;                                                                    
 var Node._lock4298138: [Node]Tid;                                                                  
 var Stack.top_nextThread4298123: [Stack]Tid;                                                       
 var Node._state4298078: [Node]State;                                                               
 var v4298138: int;                                                                                 
 var Stack._lock4297999: [Stack]Tid;                                                                
 var $pc4298010: Phase;                                                                             
 var Stack._lock4298143: [Stack]Tid;                                                                
 var $recorded.state4298123: int;                                                                   
 var this4298010: Stack;                                                                            
 var v4298143: int;                                                                                 
 var phase4298140: Phase;                                                                           
 var Node.value4298138: [Node]int;                                                                  
 var $recorded.state4298071: int;                                                                   
 var $pc4298138: Phase;                                                                             
 var Node.value4297955: [Node]int;                                                                  
 var Node._state4298138: [Node]State;                                                               
 var tid4298010: Tid;                                                                               
 var ctmp42901764298123: bool;                                                                      
 var this4298141: Stack;                                                                            
 var mover4298004: Mover;                                                                           
 var tid4298138_post: Tid;                                                                          
 var Stack.top_nextValue4297955: [Stack]Node;                                                       
 var Stack.top_nextValue4297949: [Stack]Node;                                                       
 var _casable4297999: bool;                                                                         
 var nu4298104: Node;                                                                               
 var tid4298101: Tid;                                                                               
 var nu4298138_post: Node;                                                                          
 var this4298011: Stack;                                                                            
 var result4298074: bool;                                                                           
 var tmpTid4298071: Tid;                                                                            
 var Stack.top4298116: [Stack]Node;                                                                 
 var nu: Node;                                                                                      
 var Stack.top_nextValue4298140_bottom: [Stack]Node;                                                
 var $pc4297949: Phase;                                                                             
 var Node._lock4298078: [Node]Tid;                                                                  
 var Stack.top4297939: [Stack]Node;                                                                 
 var Stack._lock4298101: [Stack]Tid;                                                                
 var Stack._state4298138_post: [Stack]State;                                                        
 var Stack.top_nextThread4298140: [Stack]Tid;                                                       
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 // 28.13: Node nu;                                                                                 
                                                                                                    
                                                                                                    
 // 28.13: nu = new Node();                                                                         
                                                                                                    
 havoc nu;                                                                                          
 assume nu != Node.null && isFresh(Node._state[nu]);                                                
 Node._state[nu] := LOCAL(tid);                                                                     
 assume Node.value[nu]  == 0;                                                                       
 assume Node.next[nu]  == Node.null;                                                                
 assume Node._lock[nu]  == Tid.null;                                                                
                                                                                                    
                                                                                                    
 // 29.13: nu.value := v;                                                                           
                                                                                                    
                                                                                                    
 moverPath4297939 := WriteEval.Node.value(tid: Tid,nu: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 mover4297939 := m#moverPath(moverPath4297939);                                                     
 path4297939 := p#moverPath(moverPath4297939);                                                      
 assume Node._state4297939 == Node._state && Node.value4297939 == Node.value && Node.next4297939 == Node.next && Node._lock4297939 == Node._lock && Stack._state4297939 == Stack._state && Stack.top4297939 == Stack.top && Stack._lock4297939 == Stack._lock && Stack.top_nextThread4297939 == Stack.top_nextThread && Stack.top_nextValue4297939 == Stack.top_nextValue && nu4297939 == nu && v4297939 == v && this4297939 == this && tid4297939 == tid && $pc4297939 == $pc;
 assume $recorded.state4297939 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume nu != Node.null;                                                                           
 } else {                                                                                           
  assert nu != Node.null;                                                                                  // (29.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover4297939);                                                              
 assert $pc != PhaseError;                                                                                 // (29.13): Reduction failure
 Node.value[nu] := v;                                                                               
 assume Node._state4298140 == Node._state && Node.value4298140 == Node.value && Node.next4298140 == Node.next && Node._lock4298140 == Node._lock && Stack._state4298140 == Stack._state && Stack.top4298140 == Stack.top && Stack._lock4298140 == Stack._lock && Stack.top_nextThread4298140 == Stack.top_nextThread && Stack.top_nextValue4298140 == Stack.top_nextValue && nu4298140 == nu && v4298140 == v && this4298140 == this && tid4298140 == tid;
 assume $recorded.state4298140 == 1;                                                                
                                                                                                    
 // 30.4: while (true)                                                                              
                                                                                                    
 phase4298140 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (27.2): Bad tid
  invariant isShared(Stack._state[this]);                                                                  // (27.2): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
  invariant isLocal(Node._state[nu], tid);                                                          
  invariant (forall _this : Node :: Invariant.Y_Node.value(tid : Tid, _this, Node.value[_this] ,Node._state4298140,Node.value4298140,Node.next4298140,Node._lock4298140,Stack._state4298140,Stack.top4298140,Stack._lock4298140,Stack.top_nextThread4298140,Stack.top_nextValue4298140));       // (30.4): Loop does not preserve yields_as annotation for field value
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state4298140,Node.value4298140,Node.next4298140,Node._lock4298140,Stack._state4298140,Stack.top4298140,Stack._lock4298140,Stack.top_nextThread4298140,Stack.top_nextValue4298140));       // (30.4): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Stack :: Invariant.Y_Stack.top(tid : Tid, _this, Stack.top[_this] ,Node._state4298140,Node.value4298140,Node.next4298140,Node._lock4298140,Stack._state4298140,Stack.top4298140,Stack._lock4298140,Stack.top_nextThread4298140,Stack.top_nextValue4298140));       // (30.4): Loop does not preserve yields_as annotation for field top
  invariant phase4298140 == $pc;                                                                           // (30.4): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (30.4): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 33.5: Node next;                                                                               
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 33.5: Tid _C_t;                                                                                
                                                                                                    
                                                                                                    
  // 33.5: _C_t := this.top_nextThread  as B;                                                       
                                                                                                    
                                                                                                    
  moverPath4297949 := ReadEval.Stack.top_nextThread(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
  mover4297949 := m#moverPath(moverPath4297949);                                                    
  path4297949 := p#moverPath(moverPath4297949);                                                     
  assume Node._state4297949 == Node._state && Node.value4297949 == Node.value && Node.next4297949 == Node.next && Node._lock4297949 == Node._lock && Stack._state4297949 == Stack._state && Stack.top4297949 == Stack.top && Stack._lock4297949 == Stack._lock && Stack.top_nextThread4297949 == Stack.top_nextThread && Stack.top_nextValue4297949 == Stack.top_nextValue && _C_t4297949 == _C_t && next4297949 == next && nu4297949 == nu && v4297949 == v && this4297949 == this && tid4297949 == tid && $pc4297949 == $pc;
  assume $recorded.state4297949 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (33.5): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (33.5): Reduction failure
  _C_t := Stack.top_nextThread[this];                                                               
                                                                                                    
  // 33.5: Node _C_v;                                                                               
                                                                                                    
                                                                                                    
  // 33.5: _C_v := this.top_nextValue  as B;                                                        
                                                                                                    
                                                                                                    
  moverPath4297955 := ReadEval.Stack.top_nextValue(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
  mover4297955 := m#moverPath(moverPath4297955);                                                    
  path4297955 := p#moverPath(moverPath4297955);                                                     
  assume Node._state4297955 == Node._state && Node.value4297955 == Node.value && Node.next4297955 == Node.next && Node._lock4297955 == Node._lock && Stack._state4297955 == Stack._state && Stack.top4297955 == Stack.top && Stack._lock4297955 == Stack._lock && Stack.top_nextThread4297955 == Stack.top_nextThread && Stack.top_nextValue4297955 == Stack.top_nextValue && _C_v4297955 == _C_v && _C_t4297955 == _C_t && next4297955 == next && nu4297955 == nu && v4297955 == v && this4297955 == this && tid4297955 == tid && $pc4297955 == $pc;
  assume $recorded.state4297955 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (33.5): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (33.5): Reduction failure
  _C_v := Stack.top_nextValue[this];                                                                
                                                                                                    
  // 33.5: Node _currentValue;                                                                      
                                                                                                    
                                                                                                    
  // 33.5: _currentValue := this.top  as B;                                                         
                                                                                                    
                                                                                                    
  moverPath4297961 := ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
  mover4297961 := m#moverPath(moverPath4297961);                                                    
  path4297961 := p#moverPath(moverPath4297961);                                                     
  assume Node._state4297961 == Node._state && Node.value4297961 == Node.value && Node.next4297961 == Node.next && Node._lock4297961 == Node._lock && Stack._state4297961 == Stack._state && Stack.top4297961 == Stack.top && Stack._lock4297961 == Stack._lock && Stack.top_nextThread4297961 == Stack.top_nextThread && Stack.top_nextValue4297961 == Stack.top_nextValue && _currentValue4297961 == _currentValue && _C_v4297961 == _C_v && _C_t4297961 == _C_t && next4297961 == next && nu4297961 == nu && v4297961 == v && this4297961 == this && tid4297961 == tid && $pc4297961 == $pc;
  assume $recorded.state4297961 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (33.5): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (33.5): Reduction failure
  _currentValue := Stack.top[this];                                                                 
                                                                                                    
  // 33.5: Mover _R_t;                                                                              
                                                                                                    
                                                                                                    
  // 33.5: _R_t = readPermission(this.top);                                                         
                                                                                                    
  _R_t := m#moverPath(ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue));
                                                                                                    
  // 33.5: boolean _casable;                                                                        
                                                                                                    
                                                                                                    
  // 33.5: _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                   
                                                                                                    
  _casable := ((((_R_t!=_E)&&false)&&(_C_t==tid))&&(_C_v==_currentValue));                          
  if (_casable) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 33.5: next := this.top  as R;                                                                 
                                                                                                    
                                                                                                    
   moverPath4297999 := ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
   mover4297999 := m#moverPath(moverPath4297999);                                                   
   path4297999 := p#moverPath(moverPath4297999);                                                    
   assume Node._state4297999 == Node._state && Node.value4297999 == Node.value && Node.next4297999 == Node.next && Node._lock4297999 == Node._lock && Stack._state4297999 == Stack._state && Stack.top4297999 == Stack.top && Stack._lock4297999 == Stack._lock && Stack.top_nextThread4297999 == Stack.top_nextThread && Stack.top_nextValue4297999 == Stack.top_nextValue && _casable4297999 == _casable && _R_t4297999 == _R_t && _currentValue4297999 == _currentValue && _C_v4297999 == _C_v && _C_t4297999 == _C_t && next4297999 == next && nu4297999 == nu && v4297999 == v && this4297999 == this && tid4297999 == tid && $pc4297999 == $pc;
   assume $recorded.state4297999 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Stack.null;                                                                      
   } else {                                                                                         
    assert this != Stack.null;                                                                             // (33.5): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, _R);                                                                      
   assert $pc != PhaseError;                                                                               // (33.5): Reduction failure
   next := Stack.top[this];                                                                         
  } else {                                                                                          
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 33.5: next := this.top;                                                                       
                                                                                                    
                                                                                                    
   moverPath4298004 := ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
   mover4298004 := m#moverPath(moverPath4298004);                                                   
   path4298004 := p#moverPath(moverPath4298004);                                                    
   assume Node._state4298004 == Node._state && Node.value4298004 == Node.value && Node.next4298004 == Node.next && Node._lock4298004 == Node._lock && Stack._state4298004 == Stack._state && Stack.top4298004 == Stack.top && Stack._lock4298004 == Stack._lock && Stack.top_nextThread4298004 == Stack.top_nextThread && Stack.top_nextValue4298004 == Stack.top_nextValue && _casable4298004 == _casable && _R_t4298004 == _R_t && _currentValue4298004 == _currentValue && _C_v4298004 == _C_v && _C_t4298004 == _C_t && next4298004 == next && nu4298004 == nu && v4298004 == v && this4298004 == this && tid4298004 == tid && $pc4298004 == $pc;
   assume $recorded.state4298004 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Stack.null;                                                                      
   } else {                                                                                         
    assert this != Stack.null;                                                                             // (33.5): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4298004);                                                            
   assert $pc != PhaseError;                                                                               // (33.5): Reduction failure
   next := Stack.top[this];                                                                         
  }                                                                                                 
                                                                                                    
                                                                                                    
  // 34.5: nu.next := next;                                                                         
                                                                                                    
                                                                                                    
  moverPath4298010 := WriteEval.Node.next(tid: Tid,nu: Node,next: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
  mover4298010 := m#moverPath(moverPath4298010);                                                    
  path4298010 := p#moverPath(moverPath4298010);                                                     
  assume Node._state4298010 == Node._state && Node.value4298010 == Node.value && Node.next4298010 == Node.next && Node._lock4298010 == Node._lock && Stack._state4298010 == Stack._state && Stack.top4298010 == Stack.top && Stack._lock4298010 == Stack._lock && Stack.top_nextThread4298010 == Stack.top_nextThread && Stack.top_nextValue4298010 == Stack.top_nextValue && next4298010 == next && nu4298010 == nu && v4298010 == v && this4298010 == this && tid4298010 == tid && $pc4298010 == $pc;
  assume $recorded.state4298010 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume nu != Node.null;                                                                          
  } else {                                                                                          
   assert nu != Node.null;                                                                                 // (34.5): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover4298010);                                                             
  assert $pc != PhaseError;                                                                                // (34.5): Reduction failure
  Node.next[nu] := next;                                                                            
  if (isLocal(Node._state[next], tid)) {                                                            
   Node._state[next] := SHARED();                                                                   
   assert isSharedAssignable(Node._state[Node.next[next]]);                                                // (34.5): next became shared, but next.next may not be shared.
  }                                                                                                 
                                                                                                    
                                                                                                    
  // 35.5: yield;                                                                                   
                                                                                                    
  assume Node._state4298011 == Node._state && Node.value4298011 == Node.value && Node.next4298011 == Node.next && Node._lock4298011 == Node._lock && Stack._state4298011 == Stack._state && Stack.top4298011 == Stack.top && Stack._lock4298011 == Stack._lock && Stack.top_nextThread4298011 == Stack.top_nextThread && Stack.top_nextValue4298011 == Stack.top_nextValue && next4298011 == next && nu4298011 == nu && v4298011 == v && this4298011 == this && tid4298011 == tid;
  assume $recorded.state4298011 == 1;                                                               
  call Yield(tid);                                                                                  
  $pc := PreCommit;                                                                                 
  assume Node._state4298011_post == Node._state && Node.value4298011_post == Node.value && Node.next4298011_post == Node.next && Node._lock4298011_post == Node._lock && Stack._state4298011_post == Stack._state && Stack.top4298011_post == Stack.top && Stack._lock4298011_post == Stack._lock && Stack.top_nextThread4298011_post == Stack.top_nextThread && Stack.top_nextValue4298011_post == Stack.top_nextValue && next4298011_post == next && nu4298011_post == nu && v4298011_post == v && this4298011_post == this && tid4298011_post == tid;
  assume $recorded.state4298011_post == 1;                                                          
                                                                                                    
  // 36.5: boolean result;                                                                          
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 36.5: boolean ctmp4290176;                                                                     
                                                                                                    
                                                                                                    
  // 36.5: ctmp4290176 = *;                                                                         
                                                                                                    
  havoc ctmp4290176;                                                                                
  if (ctmp4290176) {                                                                                
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 36.5: result = false;                                                                         
                                                                                                    
   result := false;                                                                                 
  } else {                                                                                          
                                                                                                    
   // 36.5: ctmp4290176 = *;                                                                        
                                                                                                    
   havoc ctmp4290176;                                                                               
   if (ctmp4290176) {                                                                               
                                                                                                    
    // 36.5: Tid tmpTid;                                                                            
                                                                                                    
                                                                                                    
    // 36.5: Node tmpValue;                                                                         
                                                                                                    
                                                                                                    
    // 36.5: Mover _m;                                                                              
                                                                                                    
                                                                                                    
    // 36.5: _m = writePermission(this.top, nu);                                                    
                                                                                                    
    _m := m#moverPath(WriteEval.Stack.top(tid: Tid,this: Stack,nu: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue));
                                                                                                    
    // 36.5: assume this.top == next;                                                               
                                                                                                    
    assume (Stack.top[this]==next);                                                                 
                                                                                                    
    // 36.5: assume !goesWrong(_m);                                                                 
                                                                                                    
    assume !(transition($pc, _m) == PhaseError);                                                    
                                                                                                    
    // 36.5: assume this.top_nextThread == tid;                                                     
                                                                                                    
    assume (Stack.top_nextThread[this]==tid);                                                       
                                                                                                    
    // 36.5: assume this.top_nextValue == next;                                                     
                                                                                                    
    assume (Stack.top_nextValue[this]==next);                                                       
                                                                                                    
                                                                                                    
    // 36.5: this.top_nextThread := tmpTid as B;                                                    
                                                                                                    
                                                                                                    
    moverPath4298071 := WriteEval.Stack.top_nextThread(tid: Tid,this: Stack,tmpTid: Tid,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298071 := m#moverPath(moverPath4298071);                                                  
    path4298071 := p#moverPath(moverPath4298071);                                                   
    assume Node._state4298071 == Node._state && Node.value4298071 == Node.value && Node.next4298071 == Node.next && Node._lock4298071 == Node._lock && Stack._state4298071 == Stack._state && Stack.top4298071 == Stack.top && Stack._lock4298071 == Stack._lock && Stack.top_nextThread4298071 == Stack.top_nextThread && Stack.top_nextValue4298071 == Stack.top_nextValue && _m4298071 == _m && tmpValue4298071 == tmpValue && tmpTid4298071 == tmpTid && ctmp42901764298071 == ctmp4290176 && result4298071 == result && next4298071 == next && nu4298071 == nu && v4298071 == v && this4298071 == this && tid4298071 == tid && $pc4298071 == $pc;
    assume $recorded.state4298071 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (36.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (36.5): Reduction failure
    Stack.top_nextThread[this] := tmpTid;                                                           
                                                                                                    
                                                                                                    
    // 36.5: this.top_nextValue := tmpValue as B;                                                   
                                                                                                    
                                                                                                    
    moverPath4298074 := WriteEval.Stack.top_nextValue(tid: Tid,this: Stack,tmpValue: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298074 := m#moverPath(moverPath4298074);                                                  
    path4298074 := p#moverPath(moverPath4298074);                                                   
    assume Node._state4298074 == Node._state && Node.value4298074 == Node.value && Node.next4298074 == Node.next && Node._lock4298074 == Node._lock && Stack._state4298074 == Stack._state && Stack.top4298074 == Stack.top && Stack._lock4298074 == Stack._lock && Stack.top_nextThread4298074 == Stack.top_nextThread && Stack.top_nextValue4298074 == Stack.top_nextValue && _m4298074 == _m && tmpValue4298074 == tmpValue && tmpTid4298074 == tmpTid && ctmp42901764298074 == ctmp4290176 && result4298074 == result && next4298074 == next && nu4298074 == nu && v4298074 == v && this4298074 == this && tid4298074 == tid && $pc4298074 == $pc;
    assume $recorded.state4298074 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (36.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (36.5): Reduction failure
    Stack.top_nextValue[this] := tmpValue;                                                          
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 36.5: this.top := nu;                                                                        
                                                                                                    
                                                                                                    
    moverPath4298078 := WriteEval.Stack.top(tid: Tid,this: Stack,nu: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298078 := m#moverPath(moverPath4298078);                                                  
    path4298078 := p#moverPath(moverPath4298078);                                                   
    assume Node._state4298078 == Node._state && Node.value4298078 == Node.value && Node.next4298078 == Node.next && Node._lock4298078 == Node._lock && Stack._state4298078 == Stack._state && Stack.top4298078 == Stack.top && Stack._lock4298078 == Stack._lock && Stack.top_nextThread4298078 == Stack.top_nextThread && Stack.top_nextValue4298078 == Stack.top_nextValue && _m4298078 == _m && tmpValue4298078 == tmpValue && tmpTid4298078 == tmpTid && ctmp42901764298078 == ctmp4290176 && result4298078 == result && next4298078 == next && nu4298078 == nu && v4298078 == v && this4298078 == this && tid4298078 == tid && $pc4298078 == $pc;
    assume $recorded.state4298078 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (36.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover4298078);                                                           
    assert $pc != PhaseError;                                                                              // (36.5): Reduction failure
    Stack.top[this] := nu;                                                                          
    if (isLocal(Node._state[nu], tid)) {                                                            
     Node._state[nu] := SHARED();                                                                   
     assert isSharedAssignable(Node._state[Node.next[nu]]);                                                // (36.5): nu became shared, but nu.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 36.5: result = true;                                                                         
                                                                                                    
    result := true;                                                                                 
   } else {                                                                                         
                                                                                                    
    // 36.5: assume this.top_nextThread == tid;                                                     
                                                                                                    
    assume (Stack.top_nextThread[this]==tid);                                                       
                                                                                                    
    // 36.5: assume this.top_nextValue == next;                                                     
                                                                                                    
    assume (Stack.top_nextValue[this]==next);                                                       
                                                                                                    
    // 36.5: Node _currentValue;                                                                    
                                                                                                    
                                                                                                    
    // 36.5: _currentValue := this.top  as B;                                                       
                                                                                                    
                                                                                                    
    moverPath4298101 := ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298101 := m#moverPath(moverPath4298101);                                                  
    path4298101 := p#moverPath(moverPath4298101);                                                   
    assume Node._state4298101 == Node._state && Node.value4298101 == Node.value && Node.next4298101 == Node.next && Node._lock4298101 == Node._lock && Stack._state4298101 == Stack._state && Stack.top4298101 == Stack.top && Stack._lock4298101 == Stack._lock && Stack.top_nextThread4298101 == Stack.top_nextThread && Stack.top_nextValue4298101 == Stack.top_nextValue && _currentValue4298101 == _currentValue && ctmp42901764298101 == ctmp4290176 && result4298101 == result && next4298101 == next && nu4298101 == nu && v4298101 == v && this4298101 == this && tid4298101 == tid && $pc4298101 == $pc;
    assume $recorded.state4298101 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (36.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
                                                                                                    
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (36.5): Reduction failure
    _currentValue := Stack.top[this];                                                               
                                                                                                    
                                                                                                    
    // 36.5: this.top := next as B;                                                                 
                                                                                                    
                                                                                                    
    moverPath4298104 := WriteEval.Stack.top(tid: Tid,this: Stack,next: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298104 := m#moverPath(moverPath4298104);                                                  
    path4298104 := p#moverPath(moverPath4298104);                                                   
    assume Node._state4298104 == Node._state && Node.value4298104 == Node.value && Node.next4298104 == Node.next && Node._lock4298104 == Node._lock && Stack._state4298104 == Stack._state && Stack.top4298104 == Stack.top && Stack._lock4298104 == Stack._lock && Stack.top_nextThread4298104 == Stack.top_nextThread && Stack.top_nextValue4298104 == Stack.top_nextValue && _currentValue4298104 == _currentValue && ctmp42901764298104 == ctmp4290176 && result4298104 == result && next4298104 == next && nu4298104 == nu && v4298104 == v && this4298104 == this && tid4298104 == tid && $pc4298104 == $pc;
    assume $recorded.state4298104 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (36.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (36.5): Reduction failure
    Stack.top[this] := next;                                                                        
    if (isLocal(Node._state[next], tid)) {                                                          
     Node._state[next] := SHARED();                                                                 
     assert isSharedAssignable(Node._state[Node.next[next]]);                                              // (36.5): next became shared, but next.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 36.5: Mover _m;                                                                              
                                                                                                    
                                                                                                    
    // 36.5: _m = writePermission(this.top, nu);                                                    
                                                                                                    
    _m := m#moverPath(WriteEval.Stack.top(tid: Tid,this: Stack,nu: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue));
                                                                                                    
                                                                                                    
    // 36.5: this.top := _currentValue as B;                                                        
                                                                                                    
                                                                                                    
    moverPath4298116 := WriteEval.Stack.top(tid: Tid,this: Stack,_currentValue: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298116 := m#moverPath(moverPath4298116);                                                  
    path4298116 := p#moverPath(moverPath4298116);                                                   
    assume Node._state4298116 == Node._state && Node.value4298116 == Node.value && Node.next4298116 == Node.next && Node._lock4298116 == Node._lock && Stack._state4298116 == Stack._state && Stack.top4298116 == Stack.top && Stack._lock4298116 == Stack._lock && Stack.top_nextThread4298116 == Stack.top_nextThread && Stack.top_nextValue4298116 == Stack.top_nextValue && _m4298116 == _m && _currentValue4298116 == _currentValue && ctmp42901764298116 == ctmp4290176 && result4298116 == result && next4298116 == next && nu4298116 == nu && v4298116 == v && this4298116 == this && tid4298116 == tid && $pc4298116 == $pc;
    assume $recorded.state4298116 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (36.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (36.5): Reduction failure
    Stack.top[this] := _currentValue;                                                               
    if (isLocal(Node._state[_currentValue], tid)) {                                                 
     Node._state[_currentValue] := SHARED();                                                        
     assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                     // (36.5): _currentValue became shared, but _currentValue.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 36.5: assume goesWrong(_m);                                                                  
                                                                                                    
    assume transition($pc, _m) == PhaseError;                                                       
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 36.5: this.top := nu;                                                                        
                                                                                                    
                                                                                                    
    moverPath4298123 := WriteEval.Stack.top(tid: Tid,this: Stack,nu: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298123 := m#moverPath(moverPath4298123);                                                  
    path4298123 := p#moverPath(moverPath4298123);                                                   
    assume Node._state4298123 == Node._state && Node.value4298123 == Node.value && Node.next4298123 == Node.next && Node._lock4298123 == Node._lock && Stack._state4298123 == Stack._state && Stack.top4298123 == Stack.top && Stack._lock4298123 == Stack._lock && Stack.top_nextThread4298123 == Stack.top_nextThread && Stack.top_nextValue4298123 == Stack.top_nextValue && _m4298123 == _m && _currentValue4298123 == _currentValue && ctmp42901764298123 == ctmp4290176 && result4298123 == result && next4298123 == next && nu4298123 == nu && v4298123 == v && this4298123 == this && tid4298123 == tid && $pc4298123 == $pc;
    assume $recorded.state4298123 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (36.5): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover4298123);                                                           
    assert $pc != PhaseError;                                                                              // (36.5): Reduction failure
    Stack.top[this] := nu;                                                                          
    if (isLocal(Node._state[nu], tid)) {                                                            
     Node._state[nu] := SHARED();                                                                   
     assert isSharedAssignable(Node._state[Node.next[nu]]);                                                // (36.5): nu became shared, but nu.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 36.5: result = false;                                                                        
                                                                                                    
    result := false;                                                                                
   }                                                                                                
  }                                                                                                 
  if (result) {                                                                                     
                                                                                                    
   // 38.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 40.5: yield;                                                                                   
                                                                                                    
  assume Node._state4298138 == Node._state && Node.value4298138 == Node.value && Node.next4298138 == Node.next && Node._lock4298138 == Node._lock && Stack._state4298138 == Stack._state && Stack.top4298138 == Stack.top && Stack._lock4298138 == Stack._lock && Stack.top_nextThread4298138 == Stack.top_nextThread && Stack.top_nextValue4298138 == Stack.top_nextValue && result4298138 == result && next4298138 == next && nu4298138 == nu && v4298138 == v && this4298138 == this && tid4298138 == tid;
  assume $recorded.state4298138 == 1;                                                               
  call Yield(tid);                                                                                  
  $pc := PreCommit;                                                                                 
  assume Node._state4298138_post == Node._state && Node.value4298138_post == Node.value && Node.next4298138_post == Node.next && Node._lock4298138_post == Node._lock && Stack._state4298138_post == Stack._state && Stack.top4298138_post == Stack.top && Stack._lock4298138_post == Stack._lock && Stack.top_nextThread4298138_post == Stack.top_nextThread && Stack.top_nextValue4298138_post == Stack.top_nextValue && result4298138_post == result && next4298138_post == next && nu4298138_post == nu && v4298138_post == v && this4298138_post == this && tid4298138_post == tid;
  assume $recorded.state4298138_post == 1;                                                          
  assume Node._state4298140_bottom == Node._state && Node.value4298140_bottom == Node.value && Node.next4298140_bottom == Node.next && Node._lock4298140_bottom == Node._lock && Stack._state4298140_bottom == Stack._state && Stack.top4298140_bottom == Stack.top && Stack._lock4298140_bottom == Stack._lock && Stack.top_nextThread4298140_bottom == Stack.top_nextThread && Stack.top_nextValue4298140_bottom == Stack.top_nextValue && nu4298140_bottom == nu && v4298140_bottom == v && this4298140_bottom == this && tid4298140_bottom == tid;
  assume $recorded.state4298140_bottom == 1;                                                        
  assert phase4298140 == $pc;                                                                              // (30.4): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 42.4:  return;                                                                                  
                                                                                                    
 assume Node._state4298141 == Node._state && Node.value4298141 == Node.value && Node.next4298141 == Node.next && Node._lock4298141 == Node._lock && Stack._state4298141 == Stack._state && Stack.top4298141 == Stack.top && Stack._lock4298141 == Stack._lock && Stack.top_nextThread4298141 == Stack.top_nextThread && Stack.top_nextValue4298141 == Stack.top_nextValue && nu4298141 == nu && v4298141 == v && this4298141 == this && tid4298141 == tid;
 assume $recorded.state4298141 == 1;                                                                
 return;                                                                                            
                                                                                                    
 // 27.27: // return;                                                                               
                                                                                                    
 assume Node._state4298143 == Node._state && Node.value4298143 == Node.value && Node.next4298143 == Node.next && Node._lock4298143 == Node._lock && Stack._state4298143 == Stack._state && Stack.top4298143 == Stack.top && Stack._lock4298143 == Stack._lock && Stack.top_nextThread4298143 == Stack.top_nextThread && Stack.top_nextValue4298143 == Stack.top_nextValue && nu4298143 == nu && v4298143 == v && this4298143 == this && tid4298143 == tid;
 assume $recorded.state4298143 == 1;                                                                
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  Stack.pop(tid:Tid, this : Stack)                                                         
returns ($result : int)                                                                             
modifies Node._state;                                                                               
modifies Node.value;                                                                                
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Stack._state;                                                                              
modifies Stack.top;                                                                                 
modifies Stack._lock;                                                                               
modifies Stack.top_nextThread;                                                                      
modifies Stack.top_nextValue;                                                                       
                                                                                                    
requires ValidTid(tid);                                                                                    // (45.2): Bad tid
requires isShared(Stack._state[this]);                                                                     // (45.2): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
                                                                                                    
ensures StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
{                                                                                                   
 var Node._state4298321: [Node]State;                                                               
 var result4298295: bool;                                                                           
 var moverPath4298340: MoverPath;                                                                   
 var result4298362: bool;                                                                           
 var top4298357: Node;                                                                              
 var Node._lock4298211: [Node]Tid;                                                                  
 var $pc4298217: Phase;                                                                             
 var _C_t4298156: Tid;                                                                              
 var Node.value4298156: [Node]int;                                                                  
 var result4298362_post: bool;                                                                      
 var Node.value4298364_bottom: [Node]int;                                                           
 var $pc4298364_bottom: Phase;                                                                      
 var Stack._lock4298291: [Stack]Tid;                                                                
 var Node._lock4298371: [Node]Tid;                                                                  
 var moverPath4298291: MoverPath;                                                                   
 var $result4298333: int;                                                                           
 var Node.next4298362_post: [Node]Node;                                                             
 var tid4298211: Tid;                                                                               
 var top4298318: Node;                                                                              
 var this4298222: Stack;                                                                            
 var Stack.top_nextValue4298228: [Stack]Node;                                                       
 var Stack.top_nextThread4298288: [Stack]Tid;                                                       
 var Stack.top4298362: [Stack]Node;                                                                 
 var _currentValue4298321: Node;                                                                    
 var Stack._state4298206: [Stack]State;                                                             
 var Node.value4298367: [Node]int;                                                                  
 var next: Node;                                                                                    
 var $result4298228: int;                                                                           
 var _C_t: Tid;                                                                                     
 var Stack.top_nextValue4298333: [Stack]Node;                                                       
 var $pc4298367: Phase;                                                                             
 var this4298357: Stack;                                                                            
 var Node.value4298321: [Node]int;                                                                  
 var Stack._lock4298288: [Stack]Tid;                                                                
 var Node._lock4298340: [Node]Tid;                                                                  
 var Node.next4298357: [Node]Node;                                                                  
 var Stack.top_nextValue4298162: [Stack]Node;                                                       
 var _casable4298211: bool;                                                                         
 var Stack._state4298362: [Stack]State;                                                             
 var $recorded.state4298228: int;                                                                   
 var _R_t4298211: Mover;                                                                            
 var mover4298206: Mover;                                                                           
 var Node.value4298371: [Node]int;                                                                  
 var $result4298340: int;                                                                           
 var _R_t4298206: Mover;                                                                            
 var Stack._lock4298362_post: [Stack]Tid;                                                           
 var Stack._lock4298162: [Stack]Tid;                                                                
 var Node.next4298206: [Node]Node;                                                                  
 var $pc4298333: Phase;                                                                             
 var tid4298371: Tid;                                                                               
 var $recorded.state4298340: int;                                                                   
 var Stack.top_nextValue4298362_post: [Stack]Node;                                                  
 var next4298291: Node;                                                                             
 var this4298367: Stack;                                                                            
 var result4298333: bool;                                                                           
 var tmpValue: Node;                                                                                
 var _casable: bool;                                                                                
 var tid4298364_bottom: Tid;                                                                        
 var Stack.top_nextValue4298318: [Stack]Node;                                                       
 var Node._lock4298295: [Node]Tid;                                                                  
 var next4298321: Node;                                                                             
 var this4298217: Stack;                                                                            
 var Stack._lock4298211: [Stack]Tid;                                                                
 var mover4298291: Mover;                                                                           
 var Stack.top_nextThread4298162: [Stack]Tid;                                                       
 var Node._state4298355: [Node]State;                                                               
 var ctmp4290233: bool;                                                                             
 var ctmp42902334298321: bool;                                                                      
 var this4298364_bottom: Stack;                                                                     
 var Node.value4298364: [Node]int;                                                                  
 var value4298357: int;                                                                             
 var Node._lock4298288: [Node]Tid;                                                                  
 var Stack.top4298333: [Stack]Node;                                                                 
 var result4298355: bool;                                                                           
 var $recorded.state4298371: int;                                                                   
 var moverPath4298206: MoverPath;                                                                   
 var Stack.top_nextThread4298318: [Stack]Tid;                                                       
 var Stack._state4298364: [Stack]State;                                                             
 var Node._state4298291: [Node]State;                                                               
 var path4298321: int;                                                                              
 var Node._state4298371: [Node]State;                                                               
 var moverPath4298162: MoverPath;                                                                   
 var Stack._lock4298367: [Stack]Tid;                                                                
 var $pc4298228: Phase;                                                                             
 var Node._state4298367: [Node]State;                                                               
 var Stack.top4298222: [Stack]Node;                                                                 
 var Node.value4298211: [Node]int;                                                                  
 var Node.next4298162: [Node]Node;                                                                  
 var Stack._state4298228: [Stack]State;                                                             
 var $pc4298162: Phase;                                                                             
 var Stack.top_nextValue4298217: [Stack]Node;                                                       
 var Node._state4298288: [Node]State;                                                               
 var Node.next4298222_post: [Node]Node;                                                             
 var $pc4298340: Phase;                                                                             
 var $recorded.state4298156: int;                                                                   
 var $result4298291: int;                                                                           
 var path4298340: int;                                                                              
 var Stack.top4298156: [Stack]Node;                                                                 
 var top4298333: Node;                                                                              
 var tid4298162: Tid;                                                                               
 var Stack.top4298211: [Stack]Node;                                                                 
 var Stack._state4298222: [Stack]State;                                                             
 var $recorded.state4298211: int;                                                                   
 var result4298318: bool;                                                                           
 var Node._state4298156: [Node]State;                                                               
 var Stack._state4298355: [Stack]State;                                                             
 var $recorded.state4298168: int;                                                                   
 var moverPath4298318: MoverPath;                                                                   
 var tid4298222_post: Tid;                                                                          
 var this4298206: Stack;                                                                            
 var $pc4298357: Phase;                                                                             
 var Node._lock4298357: [Node]Tid;                                                                  
 var Node._state4298364_bottom: [Node]State;                                                        
 var mover4298295: Mover;                                                                           
 var Stack._lock4298295: [Stack]Tid;                                                                
 var Stack.top4298321: [Stack]Node;                                                                 
 var Stack._lock4298364_bottom: [Stack]Tid;                                                         
 var Node._state4298318: [Node]State;                                                               
 var tid4298364: Tid;                                                                               
 var $result4298211: int;                                                                           
 var top4298355: Node;                                                                              
 var mover4298168: Mover;                                                                           
 var Stack.top4298355: [Stack]Node;                                                                 
 var Stack.top4298318: [Stack]Node;                                                                 
 var _C_v4298162: Node;                                                                             
 var tid4298288: Tid;                                                                               
 var $pc4298371: Phase;                                                                             
 var Node._state4298168: [Node]State;                                                               
 var top4298156: Node;                                                                              
 var path4298288: int;                                                                              
 var $pc4298321: Phase;                                                                             
 var top4298228: Node;                                                                              
 var $pc4298222: Phase;                                                                             
 var top4298362_post: Node;                                                                         
 var this4298295: Stack;                                                                            
 var Stack._state4298357: [Stack]State;                                                             
 var Stack.top_nextThread4298211: [Stack]Tid;                                                       
 var this4298291: Stack;                                                                            
 var Node.value4298168: [Node]int;                                                                  
 var next4298295: Node;                                                                             
 var Stack.top_nextThread4298168: [Stack]Tid;                                                       
 var _currentValue4298211: Node;                                                                    
 var Stack._state4298162: [Stack]State;                                                             
 var $recorded.state4298362_post: int;                                                              
 var Stack._state4298156: [Stack]State;                                                             
 var value: int;                                                                                    
 var $recorded.state4298288: int;                                                                   
 var Stack.top_nextThread4298333: [Stack]Tid;                                                       
 var Stack.top_nextThread4298228: [Stack]Tid;                                                       
 var $pc4298295: Phase;                                                                             
 var $recorded.state4298291: int;                                                                   
 var path4298162: int;                                                                              
 var this4298321: Stack;                                                                            
 var _m4298288: Mover;                                                                              
 var this4298364: Stack;                                                                            
 var moverPath4298321: MoverPath;                                                                   
 var $result4298318: int;                                                                           
 var Node._lock4298362_post: [Node]Tid;                                                             
 var $result4298295: int;                                                                           
 var Node._lock4298355: [Node]Tid;                                                                  
 var Node._lock4298168: [Node]Tid;                                                                  
 var Node._state4298357: [Node]State;                                                               
 var $result4298168: int;                                                                           
 var this4298228: Stack;                                                                            
 var Node._state4298295: [Node]State;                                                               
 var Stack.top4298364: [Stack]Node;                                                                 
 var moverPath4298355: MoverPath;                                                                   
 var tid4298291: Tid;                                                                               
 var tid4298357: Tid;                                                                               
 var next4298355: Node;                                                                             
 var moverPath4298228: MoverPath;                                                                   
 var Stack.top_nextValue4298364: [Stack]Node;                                                       
 var Stack.top_nextThread4298357: [Stack]Tid;                                                       
 var $result4298288: int;                                                                           
 var _C_v: Node;                                                                                    
 var $pc4298288: Phase;                                                                             
 var $recorded.state4298321: int;                                                                   
 var tid4298318: Tid;                                                                               
 var next4298362: Node;                                                                             
 var tid4298333: Tid;                                                                               
 var tid4298206: Tid;                                                                               
 var top4298288: Node;                                                                              
 var next4298228: Node;                                                                             
 var top4298222: Node;                                                                              
 var Stack.top4298228: [Stack]Node;                                                                 
 var mover4298156: Mover;                                                                           
 var Stack._lock4298222_post: [Stack]Tid;                                                           
 var _m4298295: Mover;                                                                              
 var result4298291: bool;                                                                           
 var Stack._lock4298357: [Stack]Tid;                                                                
 var Stack.top_nextValue4298355: [Stack]Node;                                                       
 var tid4298362: Tid;                                                                               
 var Node.value4298222_post: [Node]int;                                                             
 var Node._state4298340: [Node]State;                                                               
 var this4298340: Stack;                                                                            
 var ctmp42902334298295: bool;                                                                      
 var _casable4298206: bool;                                                                         
 var Node.next4298291: [Node]Node;                                                                  
 var $pc4298222_post: Phase;                                                                        
 var phase4298364: Phase;                                                                           
 var Stack.top4298371: [Stack]Node;                                                                 
 var Stack.top_nextValue4298362: [Stack]Node;                                                       
 var top4298211: Node;                                                                              
 var this4298333: Stack;                                                                            
 var ctmp42902334298318: bool;                                                                      
 var next4298288: Node;                                                                             
 var Node.value4298291: [Node]int;                                                                  
 var Node.value4298362_post: [Node]int;                                                             
 var mover4298228: Mover;                                                                           
 var Node.value4298318: [Node]int;                                                                  
 var path4298355: int;                                                                              
 var Node.next4298340: [Node]Node;                                                                  
 var Stack.top_nextValue4298371: [Stack]Node;                                                       
 var $recorded.state4298217: int;                                                                   
 var _currentValue4298340: Node;                                                                    
 var result: bool;                                                                                  
 var ctmp42902334298288: bool;                                                                      
 var _currentValue4298318: Node;                                                                    
 var Stack._lock4298222: [Stack]Tid;                                                                
 var $recorded.state4298367: int;                                                                   
 var Stack._lock4298364: [Stack]Tid;                                                                
 var _C_t4298211: Tid;                                                                              
 var Node._state4298211: [Node]State;                                                               
 var tid4298295: Tid;                                                                               
 var Node._lock4298228: [Node]Tid;                                                                  
 var $recorded.state4298295: int;                                                                   
 var Node.value4298217: [Node]int;                                                                  
 var $result4298362: int;                                                                           
 var Stack._lock4298362: [Stack]Tid;                                                                
 var _C_t4298206: Tid;                                                                              
 var Node._lock4298367: [Node]Tid;                                                                  
 var _currentValue4298206: Node;                                                                    
 var tmpTid4298288: Tid;                                                                            
 var Stack.top4298340: [Stack]Node;                                                                 
 var $pc4298362_post: Phase;                                                                        
 var $result4298362_post: int;                                                                      
 var mover4298318: Mover;                                                                           
 var $pc4298362: Phase;                                                                             
 var this4298222_post: Stack;                                                                       
 var $result4298357: int;                                                                           
 var $recorded.state4298318: int;                                                                   
 var Stack.top_nextValue4298295: [Stack]Node;                                                       
 var Node.next4298364_bottom: [Node]Node;                                                           
 var _C_v4298206: Node;                                                                             
 var mover4298288: Mover;                                                                           
 var Stack.top_nextThread4298222: [Stack]Tid;                                                       
 var top4298340: Node;                                                                              
 var ctmp42902334298291: bool;                                                                      
 var this4298371: Stack;                                                                            
 var $result4298162: int;                                                                           
 var Stack.top_nextValue4298367: [Stack]Node;                                                       
 var Node._lock4298318: [Node]Tid;                                                                  
 var $pc4298355: Phase;                                                                             
 var Stack.top_nextThread4298367: [Stack]Tid;                                                       
 var Node._state4298217: [Node]State;                                                               
 var Node._state4298162: [Node]State;                                                               
 var Stack.top_nextThread4298362_post: [Stack]Tid;                                                  
 var moverPath4298156: MoverPath;                                                                   
 var Stack.top4298357: [Stack]Node;                                                                 
 var Stack._state4298211: [Stack]State;                                                             
 var top4298362: Node;                                                                              
 var tmpValue4298295: Node;                                                                         
 var this4298162: Stack;                                                                            
 var path4298211: int;                                                                              
 var _m4298291: Mover;                                                                              
 var result4298288: bool;                                                                           
 var Stack._lock4298228: [Stack]Tid;                                                                
 var Stack._lock4298217: [Stack]Tid;                                                                
 var Node.value4298357: [Node]int;                                                                  
 var Node.value4298295: [Node]int;                                                                  
 var Node.next4298295: [Node]Node;                                                                  
 var this4298211: Stack;                                                                            
 var Node._lock4298217: [Node]Tid;                                                                  
 var _currentValue: Node;                                                                           
 var _C_t4298162: Tid;                                                                              
 var Node._lock4298364_bottom: [Node]Tid;                                                           
 var $pc4298168: Phase;                                                                             
 var Stack.top4298162: [Stack]Node;                                                                 
 var Stack.top_nextValue4298340: [Stack]Node;                                                       
 var Stack.top_nextThread4298222_post: [Stack]Tid;                                                  
 var _R_t: Mover;                                                                                   
 var tmpValue4298291: Node;                                                                         
 var Stack.top_nextValue4298291: [Stack]Node;                                                       
 var Stack.top_nextValue4298288: [Stack]Node;                                                       
 var moverPath4298211: MoverPath;                                                                   
 var path4298168: int;                                                                              
 var tid4298222: Tid;                                                                               
 var Node._state4298333: [Node]State;                                                               
 var Stack.top_nextThread4298206: [Stack]Tid;                                                       
 var Node.next4298222: [Node]Node;                                                                  
 var mover4298211: Mover;                                                                           
 var Stack.top_nextThread4298340: [Stack]Tid;                                                       
 var Stack._lock4298371: [Stack]Tid;                                                                
 var Stack.top_nextValue4298357: [Stack]Node;                                                       
 var Node._lock4298206: [Node]Tid;                                                                  
 var Stack._state4298291: [Stack]State;                                                             
 var $result4298367: int;                                                                           
 var Stack.top4298295: [Stack]Node;                                                                 
 var Node._lock4298364: [Node]Tid;                                                                  
 var Node.value4298333: [Node]int;                                                                  
 var path4298228: int;                                                                              
 var _m: Mover;                                                                                     
 var Stack.top_nextValue4298364_bottom: [Stack]Node;                                                
 var $result4298355: int;                                                                           
 var Stack.top_nextThread4298217: [Stack]Tid;                                                       
 var next4298333: Node;                                                                             
 var moverPath4298295: MoverPath;                                                                   
 var Stack.top4298206: [Stack]Node;                                                                 
 var Node.next4298217: [Node]Node;                                                                  
 var Node.next4298156: [Node]Node;                                                                  
 var Node.value4298340: [Node]int;                                                                  
 var Stack._state4298217: [Stack]State;                                                             
 var Node.next4298318: [Node]Node;                                                                  
 var top4298206: Node;                                                                              
 var Stack._state4298318: [Stack]State;                                                             
 var result4298340: bool;                                                                           
 var Node._lock4298321: [Node]Tid;                                                                  
 var Stack._state4298321: [Stack]State;                                                             
 var $pc4298318: Phase;                                                                             
 var $recorded.state4298355: int;                                                                   
 var Node.value4298355: [Node]int;                                                                  
 var $result4298321: int;                                                                           
 var $result4298156: int;                                                                           
 var Stack._lock4298333: [Stack]Tid;                                                                
 var $pc4298291: Phase;                                                                             
 var Stack.top_nextThread4298371: [Stack]Tid;                                                       
 var Stack._lock4298355: [Stack]Tid;                                                                
 var Stack._lock4298206: [Stack]Tid;                                                                
 var Stack.top_nextValue4298156: [Stack]Node;                                                       
 var $recorded.state4298364_bottom: int;                                                            
 var next4298362_post: Node;                                                                        
 var Node.next4298367: [Node]Node;                                                                  
 var Stack.top_nextValue4298168: [Stack]Node;                                                       
 var Stack._state4298168: [Stack]State;                                                             
 var _C_v4298168: Node;                                                                             
 var ctmp42902334298333: bool;                                                                      
 var Stack._state4298340: [Stack]State;                                                             
 var path4298291: int;                                                                              
 var Stack.top4298367: [Stack]Node;                                                                 
 var tid4298355: Tid;                                                                               
 var Stack.top_nextThread4298295: [Stack]Tid;                                                       
 var Node._lock4298362: [Node]Tid;                                                                  
 var $pc4298211: Phase;                                                                             
 var _currentValue4298168: Node;                                                                    
 var tid4298156: Tid;                                                                               
 var Stack.top_nextThread4298321: [Stack]Tid;                                                       
 var Node.value4298206: [Node]int;                                                                  
 var $result4298364_bottom: int;                                                                    
 var Stack._state4298333: [Stack]State;                                                             
 var mover4298162: Mover;                                                                           
 var Stack._lock4298168: [Stack]Tid;                                                                
 var Node._state4298222_post: [Node]State;                                                          
 var $recorded.state4298333: int;                                                                   
 var top4298162: Node;                                                                              
 var Node.value4298288: [Node]int;                                                                  
 var Node._lock4298222_post: [Node]Tid;                                                             
 var result4298321: bool;                                                                           
 var Node._lock4298162: [Node]Tid;                                                                  
 var moverPath4298333: MoverPath;                                                                   
 var next4298357: Node;                                                                             
 var top4298168: Node;                                                                              
 var mover4298340: Mover;                                                                           
 var top4298295: Node;                                                                              
 var Stack._lock4298156: [Stack]Tid;                                                                
 var Stack.top_nextThread4298355: [Stack]Tid;                                                       
 var this4298355: Stack;                                                                            
 var Stack.top4298291: [Stack]Node;                                                                 
 var tmpTid: Tid;                                                                                   
 var Stack.top_nextThread4298291: [Stack]Tid;                                                       
 var Node._lock4298222: [Node]Tid;                                                                  
 var Stack._state4298295: [Stack]State;                                                             
 var Node._state4298364: [Node]State;                                                               
 var value4298355: int;                                                                             
 var Stack.top4298362_post: [Stack]Node;                                                            
 var tid4298321: Tid;                                                                               
 var path4298333: int;                                                                              
 var $pc4298364: Phase;                                                                             
 var Stack._state4298222_post: [Stack]State;                                                        
 var $recorded.state4298222_post: int;                                                              
 var tmpValue4298288: Node;                                                                         
 var $result4298206: int;                                                                           
 var Node.next4298211: [Node]Node;                                                                  
 var Node.value4298162: [Node]int;                                                                  
 var Stack._state4298367: [Stack]State;                                                             
 var Stack.top_nextThread4298364: [Stack]Tid;                                                       
 var Node._state4298362_post: [Node]State;                                                          
 var tid4298228: Tid;                                                                               
 var $recorded.state4298362: int;                                                                   
 var top4298291: Node;                                                                              
 var Stack._lock4298340: [Stack]Tid;                                                                
 var Node.next4298355: [Node]Node;                                                                  
 var Stack.top4298217: [Stack]Node;                                                                 
 var Stack.top_nextValue4298206: [Stack]Node;                                                       
 var path4298318: int;                                                                              
 var Stack._lock4298318: [Stack]Tid;                                                                
 var ctmp42902334298340: bool;                                                                      
 var Node.value4298362: [Node]int;                                                                  
 var $result4298222_post: int;                                                                      
 var tid4298362_post: Tid;                                                                          
 var $pc4298206: Phase;                                                                             
 var Stack._state4298364_bottom: [Stack]State;                                                      
 var next4298318: Node;                                                                             
 var tmpTid4298291: Tid;                                                                            
 var top4298217: Node;                                                                              
 var next4298340: Node;                                                                             
 var path4298156: int;                                                                              
 var mover4298355: Mover;                                                                           
 var _m4298340: Mover;                                                                              
 var $recorded.state4298222: int;                                                                   
 var Node.next4298362: [Node]Node;                                                                  
 var $result4298217: int;                                                                           
 var _C_v4298211: Node;                                                                             
 var Stack.top_nextThread4298156: [Stack]Tid;                                                       
 var $pc4298156: Phase;                                                                             
 var _currentValue4298333: Node;                                                                    
 var _m4298333: Mover;                                                                              
 var Stack.top4298288: [Stack]Node;                                                                 
 var $recorded.state4298162: int;                                                                   
 var path4298295: int;                                                                              
 var Stack.top4298168: [Stack]Node;                                                                 
 var Node.next4298168: [Node]Node;                                                                  
 var $recorded.state4298357: int;                                                                   
 var Stack._state4298288: [Stack]State;                                                             
 var Stack._state4298362_post: [Stack]State;                                                        
 var Stack.top_nextValue4298222: [Stack]Node;                                                       
 var top4298222_post: Node;                                                                         
 var Node._lock4298291: [Node]Tid;                                                                  
 var $result4298222: int;                                                                           
 var $recorded.state4298364: int;                                                                   
 var tmpTid4298295: Tid;                                                                            
 var Node._lock4298333: [Node]Tid;                                                                  
 var _C_t4298168: Tid;                                                                              
 var this4298318: Stack;                                                                            
 var Stack._state4298371: [Stack]State;                                                             
 var this4298362: Stack;                                                                            
 var tid4298168: Tid;                                                                               
 var Node._state4298222: [Node]State;                                                               
 var result4298357: bool;                                                                           
 var Stack.top_nextValue4298211: [Stack]Node;                                                       
 var Node._lock4298156: [Node]Tid;                                                                  
 var tid4298367: Tid;                                                                               
 var Node.next4298364: [Node]Node;                                                                  
 var this4298362_post: Stack;                                                                       
 var tid4298340: Tid;                                                                               
 var Node.next4298228: [Node]Node;                                                                  
 var Stack._lock4298321: [Stack]Tid;                                                                
 var top4298321: Node;                                                                              
 var tid4298217: Tid;                                                                               
 var Stack.top4298222_post: [Stack]Node;                                                            
 var moverPath4298168: MoverPath;                                                                   
 var $recorded.state4298206: int;                                                                   
 var path4298206: int;                                                                              
 var Stack.top_nextThread4298364_bottom: [Stack]Tid;                                                
 var Stack.top_nextValue4298321: [Stack]Node;                                                       
 var Node.value4298228: [Node]int;                                                                  
 var Node._state4298228: [Node]State;                                                               
 var Node.next4298321: [Node]Node;                                                                  
 var $result4298371: int;                                                                           
 var mover4298333: Mover;                                                                           
 var moverPath4298288: MoverPath;                                                                   
 var Node._state4298362: [Node]State;                                                               
 var this4298168: Stack;                                                                            
 var mover4298321: Mover;                                                                           
 var Node.next4298288: [Node]Node;                                                                  
 var Node._state4298206: [Node]State;                                                               
 var Node.next4298371: [Node]Node;                                                                  
 var $result4298364: int;                                                                           
 var top: Node;                                                                                     
 var this4298156: Stack;                                                                            
 var Node.next4298333: [Node]Node;                                                                  
 var this4298288: Stack;                                                                            
 var Stack.top_nextValue4298222_post: [Stack]Node;                                                  
 var Stack.top_nextThread4298362: [Stack]Tid;                                                       
 var Node.value4298222: [Node]int;                                                                  
 var Stack.top4298364_bottom: [Stack]Node;                                                          
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state4298364 == Node._state && Node.value4298364 == Node.value && Node.next4298364 == Node.next && Node._lock4298364 == Node._lock && Stack._state4298364 == Stack._state && Stack.top4298364 == Stack.top && Stack._lock4298364 == Stack._lock && Stack.top_nextThread4298364 == Stack.top_nextThread && Stack.top_nextValue4298364 == Stack.top_nextValue && $result4298364 == $result && this4298364 == this && tid4298364 == tid;
 assume $recorded.state4298364 == 1;                                                                
                                                                                                    
 // 46.6: while (true)   {                                                                          
                                                                                                    
 phase4298364 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (45.2): Bad tid
  invariant isShared(Stack._state[this]);                                                                  // (45.2): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
  invariant (forall _this : Node :: Invariant.Y_Node.value(tid : Tid, _this, Node.value[_this] ,Node._state4298364,Node.value4298364,Node.next4298364,Node._lock4298364,Stack._state4298364,Stack.top4298364,Stack._lock4298364,Stack.top_nextThread4298364,Stack.top_nextValue4298364));       // (46.6): Loop does not preserve yields_as annotation for field value
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state4298364,Node.value4298364,Node.next4298364,Node._lock4298364,Stack._state4298364,Stack.top4298364,Stack._lock4298364,Stack.top_nextThread4298364,Stack.top_nextValue4298364));       // (46.6): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Stack :: Invariant.Y_Stack.top(tid : Tid, _this, Stack.top[_this] ,Node._state4298364,Node.value4298364,Node.next4298364,Node._lock4298364,Stack._state4298364,Stack.top4298364,Stack._lock4298364,Stack.top_nextThread4298364,Stack.top_nextValue4298364));       // (46.6): Loop does not preserve yields_as annotation for field top
  invariant phase4298364 == $pc;                                                                           // (46.6): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (46.6): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 48.10: Node top;                                                                               
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 48.10: Tid _C_t;                                                                               
                                                                                                    
                                                                                                    
  // 48.10: _C_t := this.top_nextThread  as B;                                                      
                                                                                                    
                                                                                                    
  moverPath4298156 := ReadEval.Stack.top_nextThread(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
  mover4298156 := m#moverPath(moverPath4298156);                                                    
  path4298156 := p#moverPath(moverPath4298156);                                                     
  assume Node._state4298156 == Node._state && Node.value4298156 == Node.value && Node.next4298156 == Node.next && Node._lock4298156 == Node._lock && Stack._state4298156 == Stack._state && Stack.top4298156 == Stack.top && Stack._lock4298156 == Stack._lock && Stack.top_nextThread4298156 == Stack.top_nextThread && Stack.top_nextValue4298156 == Stack.top_nextValue && _C_t4298156 == _C_t && top4298156 == top && $result4298156 == $result && this4298156 == this && tid4298156 == tid && $pc4298156 == $pc;
  assume $recorded.state4298156 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (48.10): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (48.10): Reduction failure
  _C_t := Stack.top_nextThread[this];                                                               
                                                                                                    
  // 48.10: Node _C_v;                                                                              
                                                                                                    
                                                                                                    
  // 48.10: _C_v := this.top_nextValue  as B;                                                       
                                                                                                    
                                                                                                    
  moverPath4298162 := ReadEval.Stack.top_nextValue(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
  mover4298162 := m#moverPath(moverPath4298162);                                                    
  path4298162 := p#moverPath(moverPath4298162);                                                     
  assume Node._state4298162 == Node._state && Node.value4298162 == Node.value && Node.next4298162 == Node.next && Node._lock4298162 == Node._lock && Stack._state4298162 == Stack._state && Stack.top4298162 == Stack.top && Stack._lock4298162 == Stack._lock && Stack.top_nextThread4298162 == Stack.top_nextThread && Stack.top_nextValue4298162 == Stack.top_nextValue && _C_v4298162 == _C_v && _C_t4298162 == _C_t && top4298162 == top && $result4298162 == $result && this4298162 == this && tid4298162 == tid && $pc4298162 == $pc;
  assume $recorded.state4298162 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (48.10): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (48.10): Reduction failure
  _C_v := Stack.top_nextValue[this];                                                                
                                                                                                    
  // 48.10: Node _currentValue;                                                                     
                                                                                                    
                                                                                                    
  // 48.10: _currentValue := this.top  as B;                                                        
                                                                                                    
                                                                                                    
  moverPath4298168 := ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
  mover4298168 := m#moverPath(moverPath4298168);                                                    
  path4298168 := p#moverPath(moverPath4298168);                                                     
  assume Node._state4298168 == Node._state && Node.value4298168 == Node.value && Node.next4298168 == Node.next && Node._lock4298168 == Node._lock && Stack._state4298168 == Stack._state && Stack.top4298168 == Stack.top && Stack._lock4298168 == Stack._lock && Stack.top_nextThread4298168 == Stack.top_nextThread && Stack.top_nextValue4298168 == Stack.top_nextValue && _currentValue4298168 == _currentValue && _C_v4298168 == _C_v && _C_t4298168 == _C_t && top4298168 == top && $result4298168 == $result && this4298168 == this && tid4298168 == tid && $pc4298168 == $pc;
  assume $recorded.state4298168 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Stack.null;                                                                       
  } else {                                                                                          
   assert this != Stack.null;                                                                              // (48.10): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (48.10): Reduction failure
  _currentValue := Stack.top[this];                                                                 
                                                                                                    
  // 48.10: Mover _R_t;                                                                             
                                                                                                    
                                                                                                    
  // 48.10: _R_t = readPermission(this.top);                                                        
                                                                                                    
  _R_t := m#moverPath(ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue));
                                                                                                    
  // 48.10: boolean _casable;                                                                       
                                                                                                    
                                                                                                    
  // 48.10: _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
                                                                                                    
  _casable := ((((_R_t!=_E)&&false)&&(_C_t==tid))&&(_C_v==_currentValue));                          
  if (_casable) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 48.10: top := this.top  as R;                                                                 
                                                                                                    
                                                                                                    
   moverPath4298206 := ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
   mover4298206 := m#moverPath(moverPath4298206);                                                   
   path4298206 := p#moverPath(moverPath4298206);                                                    
   assume Node._state4298206 == Node._state && Node.value4298206 == Node.value && Node.next4298206 == Node.next && Node._lock4298206 == Node._lock && Stack._state4298206 == Stack._state && Stack.top4298206 == Stack.top && Stack._lock4298206 == Stack._lock && Stack.top_nextThread4298206 == Stack.top_nextThread && Stack.top_nextValue4298206 == Stack.top_nextValue && _casable4298206 == _casable && _R_t4298206 == _R_t && _currentValue4298206 == _currentValue && _C_v4298206 == _C_v && _C_t4298206 == _C_t && top4298206 == top && $result4298206 == $result && this4298206 == this && tid4298206 == tid && $pc4298206 == $pc;
   assume $recorded.state4298206 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Stack.null;                                                                      
   } else {                                                                                         
    assert this != Stack.null;                                                                             // (48.10): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, _R);                                                                      
   assert $pc != PhaseError;                                                                               // (48.10): Reduction failure
   top := Stack.top[this];                                                                          
  } else {                                                                                          
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 48.10: top := this.top;                                                                       
                                                                                                    
                                                                                                    
   moverPath4298211 := ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
   mover4298211 := m#moverPath(moverPath4298211);                                                   
   path4298211 := p#moverPath(moverPath4298211);                                                    
   assume Node._state4298211 == Node._state && Node.value4298211 == Node.value && Node.next4298211 == Node.next && Node._lock4298211 == Node._lock && Stack._state4298211 == Stack._state && Stack.top4298211 == Stack.top && Stack._lock4298211 == Stack._lock && Stack.top_nextThread4298211 == Stack.top_nextThread && Stack.top_nextValue4298211 == Stack.top_nextValue && _casable4298211 == _casable && _R_t4298211 == _R_t && _currentValue4298211 == _currentValue && _C_v4298211 == _C_v && _C_t4298211 == _C_t && top4298211 == top && $result4298211 == $result && this4298211 == this && tid4298211 == tid && $pc4298211 == $pc;
   assume $recorded.state4298211 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Stack.null;                                                                      
   } else {                                                                                         
    assert this != Stack.null;                                                                             // (48.10): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4298211);                                                            
   assert $pc != PhaseError;                                                                               // (48.10): Reduction failure
   top := Stack.top[this];                                                                          
  }                                                                                                 
  if ((top==Node.null)) {                                                                           
                                                                                                    
   // 50.14:  return -1;                                                                            
                                                                                                    
   assume Node._state4298217 == Node._state && Node.value4298217 == Node.value && Node.next4298217 == Node.next && Node._lock4298217 == Node._lock && Stack._state4298217 == Stack._state && Stack.top4298217 == Stack.top && Stack._lock4298217 == Stack._lock && Stack.top_nextThread4298217 == Stack.top_nextThread && Stack.top_nextValue4298217 == Stack.top_nextValue && top4298217 == top && $result4298217 == $result && this4298217 == this && tid4298217 == tid;
   assume $recorded.state4298217 == 1;                                                              
   $result := -1;                                                                                   
   return;                                                                                          
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 52.10: yield;                                                                                  
                                                                                                    
  assume Node._state4298222 == Node._state && Node.value4298222 == Node.value && Node.next4298222 == Node.next && Node._lock4298222 == Node._lock && Stack._state4298222 == Stack._state && Stack.top4298222 == Stack.top && Stack._lock4298222 == Stack._lock && Stack.top_nextThread4298222 == Stack.top_nextThread && Stack.top_nextValue4298222 == Stack.top_nextValue && top4298222 == top && $result4298222 == $result && this4298222 == this && tid4298222 == tid;
  assume $recorded.state4298222 == 1;                                                               
  call Yield(tid);                                                                                  
  $pc := PreCommit;                                                                                 
  assume Node._state4298222_post == Node._state && Node.value4298222_post == Node.value && Node.next4298222_post == Node.next && Node._lock4298222_post == Node._lock && Stack._state4298222_post == Stack._state && Stack.top4298222_post == Stack.top && Stack._lock4298222_post == Stack._lock && Stack.top_nextThread4298222_post == Stack.top_nextThread && Stack.top_nextValue4298222_post == Stack.top_nextValue && top4298222_post == top && $result4298222_post == $result && this4298222_post == this && tid4298222_post == tid;
  assume $recorded.state4298222_post == 1;                                                          
                                                                                                    
  // 53.10: Node next;                                                                              
                                                                                                    
                                                                                                    
  // 53.10: next := top.next;                                                                       
                                                                                                    
                                                                                                    
  moverPath4298228 := ReadEval.Node.next(tid: Tid,top: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
  mover4298228 := m#moverPath(moverPath4298228);                                                    
  path4298228 := p#moverPath(moverPath4298228);                                                     
  assume Node._state4298228 == Node._state && Node.value4298228 == Node.value && Node.next4298228 == Node.next && Node._lock4298228 == Node._lock && Stack._state4298228 == Stack._state && Stack.top4298228 == Stack.top && Stack._lock4298228 == Stack._lock && Stack.top_nextThread4298228 == Stack.top_nextThread && Stack.top_nextValue4298228 == Stack.top_nextValue && next4298228 == next && top4298228 == top && $result4298228 == $result && this4298228 == this && tid4298228 == tid && $pc4298228 == $pc;
  assume $recorded.state4298228 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume top != Node.null;                                                                         
  } else {                                                                                          
   assert top != Node.null;                                                                                // (53.10): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4298228);                                                             
  assert $pc != PhaseError;                                                                                // (53.10): Reduction failure
  next := Node.next[top];                                                                           
                                                                                                    
  // 54.10: boolean result;                                                                         
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 54.10: boolean ctmp4290233;                                                                    
                                                                                                    
                                                                                                    
  // 54.10: ctmp4290233 = *;                                                                        
                                                                                                    
  havoc ctmp4290233;                                                                                
  if (ctmp4290233) {                                                                                
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 54.10: result = false;                                                                        
                                                                                                    
   result := false;                                                                                 
  } else {                                                                                          
                                                                                                    
   // 54.10: ctmp4290233 = *;                                                                       
                                                                                                    
   havoc ctmp4290233;                                                                               
   if (ctmp4290233) {                                                                               
                                                                                                    
    // 54.10: Tid tmpTid;                                                                           
                                                                                                    
                                                                                                    
    // 54.10: Node tmpValue;                                                                        
                                                                                                    
                                                                                                    
    // 54.10: Mover _m;                                                                             
                                                                                                    
                                                                                                    
    // 54.10: _m = writePermission(this.top, next);                                                 
                                                                                                    
    _m := m#moverPath(WriteEval.Stack.top(tid: Tid,this: Stack,next: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue));
                                                                                                    
    // 54.10: assume this.top == top;                                                               
                                                                                                    
    assume (Stack.top[this]==top);                                                                  
                                                                                                    
    // 54.10: assume !goesWrong(_m);                                                                
                                                                                                    
    assume !(transition($pc, _m) == PhaseError);                                                    
                                                                                                    
    // 54.10: assume this.top_nextThread == tid;                                                    
                                                                                                    
    assume (Stack.top_nextThread[this]==tid);                                                       
                                                                                                    
    // 54.10: assume this.top_nextValue == top;                                                     
                                                                                                    
    assume (Stack.top_nextValue[this]==top);                                                        
                                                                                                    
                                                                                                    
    // 54.10: this.top_nextThread := tmpTid as B;                                                   
                                                                                                    
                                                                                                    
    moverPath4298288 := WriteEval.Stack.top_nextThread(tid: Tid,this: Stack,tmpTid: Tid,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298288 := m#moverPath(moverPath4298288);                                                  
    path4298288 := p#moverPath(moverPath4298288);                                                   
    assume Node._state4298288 == Node._state && Node.value4298288 == Node.value && Node.next4298288 == Node.next && Node._lock4298288 == Node._lock && Stack._state4298288 == Stack._state && Stack.top4298288 == Stack.top && Stack._lock4298288 == Stack._lock && Stack.top_nextThread4298288 == Stack.top_nextThread && Stack.top_nextValue4298288 == Stack.top_nextValue && _m4298288 == _m && tmpValue4298288 == tmpValue && tmpTid4298288 == tmpTid && ctmp42902334298288 == ctmp4290233 && result4298288 == result && next4298288 == next && top4298288 == top && $result4298288 == $result && this4298288 == this && tid4298288 == tid && $pc4298288 == $pc;
    assume $recorded.state4298288 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (54.10): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (54.10): Reduction failure
    Stack.top_nextThread[this] := tmpTid;                                                           
                                                                                                    
                                                                                                    
    // 54.10: this.top_nextValue := tmpValue as B;                                                  
                                                                                                    
                                                                                                    
    moverPath4298291 := WriteEval.Stack.top_nextValue(tid: Tid,this: Stack,tmpValue: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298291 := m#moverPath(moverPath4298291);                                                  
    path4298291 := p#moverPath(moverPath4298291);                                                   
    assume Node._state4298291 == Node._state && Node.value4298291 == Node.value && Node.next4298291 == Node.next && Node._lock4298291 == Node._lock && Stack._state4298291 == Stack._state && Stack.top4298291 == Stack.top && Stack._lock4298291 == Stack._lock && Stack.top_nextThread4298291 == Stack.top_nextThread && Stack.top_nextValue4298291 == Stack.top_nextValue && _m4298291 == _m && tmpValue4298291 == tmpValue && tmpTid4298291 == tmpTid && ctmp42902334298291 == ctmp4290233 && result4298291 == result && next4298291 == next && top4298291 == top && $result4298291 == $result && this4298291 == this && tid4298291 == tid && $pc4298291 == $pc;
    assume $recorded.state4298291 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (54.10): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (54.10): Reduction failure
    Stack.top_nextValue[this] := tmpValue;                                                          
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 54.10: this.top := next;                                                                     
                                                                                                    
                                                                                                    
    moverPath4298295 := WriteEval.Stack.top(tid: Tid,this: Stack,next: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298295 := m#moverPath(moverPath4298295);                                                  
    path4298295 := p#moverPath(moverPath4298295);                                                   
    assume Node._state4298295 == Node._state && Node.value4298295 == Node.value && Node.next4298295 == Node.next && Node._lock4298295 == Node._lock && Stack._state4298295 == Stack._state && Stack.top4298295 == Stack.top && Stack._lock4298295 == Stack._lock && Stack.top_nextThread4298295 == Stack.top_nextThread && Stack.top_nextValue4298295 == Stack.top_nextValue && _m4298295 == _m && tmpValue4298295 == tmpValue && tmpTid4298295 == tmpTid && ctmp42902334298295 == ctmp4290233 && result4298295 == result && next4298295 == next && top4298295 == top && $result4298295 == $result && this4298295 == this && tid4298295 == tid && $pc4298295 == $pc;
    assume $recorded.state4298295 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (54.10): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover4298295);                                                           
    assert $pc != PhaseError;                                                                              // (54.10): Reduction failure
    Stack.top[this] := next;                                                                        
    if (isLocal(Node._state[next], tid)) {                                                          
     Node._state[next] := SHARED();                                                                 
     assert isSharedAssignable(Node._state[Node.next[next]]);                                              // (54.10): next became shared, but next.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 54.10: result = true;                                                                        
                                                                                                    
    result := true;                                                                                 
   } else {                                                                                         
                                                                                                    
    // 54.10: assume this.top_nextThread == tid;                                                    
                                                                                                    
    assume (Stack.top_nextThread[this]==tid);                                                       
                                                                                                    
    // 54.10: assume this.top_nextValue == top;                                                     
                                                                                                    
    assume (Stack.top_nextValue[this]==top);                                                        
                                                                                                    
    // 54.10: Node _currentValue;                                                                   
                                                                                                    
                                                                                                    
    // 54.10: _currentValue := this.top  as B;                                                      
                                                                                                    
                                                                                                    
    moverPath4298318 := ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298318 := m#moverPath(moverPath4298318);                                                  
    path4298318 := p#moverPath(moverPath4298318);                                                   
    assume Node._state4298318 == Node._state && Node.value4298318 == Node.value && Node.next4298318 == Node.next && Node._lock4298318 == Node._lock && Stack._state4298318 == Stack._state && Stack.top4298318 == Stack.top && Stack._lock4298318 == Stack._lock && Stack.top_nextThread4298318 == Stack.top_nextThread && Stack.top_nextValue4298318 == Stack.top_nextValue && _currentValue4298318 == _currentValue && ctmp42902334298318 == ctmp4290233 && result4298318 == result && next4298318 == next && top4298318 == top && $result4298318 == $result && this4298318 == this && tid4298318 == tid && $pc4298318 == $pc;
    assume $recorded.state4298318 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (54.10): Cannot have potential null deference in left-mover part.
    }                                                                                               
                                                                                                    
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (54.10): Reduction failure
    _currentValue := Stack.top[this];                                                               
                                                                                                    
                                                                                                    
    // 54.10: this.top := top as B;                                                                 
                                                                                                    
                                                                                                    
    moverPath4298321 := WriteEval.Stack.top(tid: Tid,this: Stack,top: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298321 := m#moverPath(moverPath4298321);                                                  
    path4298321 := p#moverPath(moverPath4298321);                                                   
    assume Node._state4298321 == Node._state && Node.value4298321 == Node.value && Node.next4298321 == Node.next && Node._lock4298321 == Node._lock && Stack._state4298321 == Stack._state && Stack.top4298321 == Stack.top && Stack._lock4298321 == Stack._lock && Stack.top_nextThread4298321 == Stack.top_nextThread && Stack.top_nextValue4298321 == Stack.top_nextValue && _currentValue4298321 == _currentValue && ctmp42902334298321 == ctmp4290233 && result4298321 == result && next4298321 == next && top4298321 == top && $result4298321 == $result && this4298321 == this && tid4298321 == tid && $pc4298321 == $pc;
    assume $recorded.state4298321 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (54.10): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (54.10): Reduction failure
    Stack.top[this] := top;                                                                         
    if (isLocal(Node._state[top], tid)) {                                                           
     Node._state[top] := SHARED();                                                                  
     assert isSharedAssignable(Node._state[Node.next[top]]);                                               // (54.10): top became shared, but top.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 54.10: Mover _m;                                                                             
                                                                                                    
                                                                                                    
    // 54.10: _m = writePermission(this.top, next);                                                 
                                                                                                    
    _m := m#moverPath(WriteEval.Stack.top(tid: Tid,this: Stack,next: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue));
                                                                                                    
                                                                                                    
    // 54.10: this.top := _currentValue as B;                                                       
                                                                                                    
                                                                                                    
    moverPath4298333 := WriteEval.Stack.top(tid: Tid,this: Stack,_currentValue: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298333 := m#moverPath(moverPath4298333);                                                  
    path4298333 := p#moverPath(moverPath4298333);                                                   
    assume Node._state4298333 == Node._state && Node.value4298333 == Node.value && Node.next4298333 == Node.next && Node._lock4298333 == Node._lock && Stack._state4298333 == Stack._state && Stack.top4298333 == Stack.top && Stack._lock4298333 == Stack._lock && Stack.top_nextThread4298333 == Stack.top_nextThread && Stack.top_nextValue4298333 == Stack.top_nextValue && _m4298333 == _m && _currentValue4298333 == _currentValue && ctmp42902334298333 == ctmp4290233 && result4298333 == result && next4298333 == next && top4298333 == top && $result4298333 == $result && this4298333 == this && tid4298333 == tid && $pc4298333 == $pc;
    assume $recorded.state4298333 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (54.10): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (54.10): Reduction failure
    Stack.top[this] := _currentValue;                                                               
    if (isLocal(Node._state[_currentValue], tid)) {                                                 
     Node._state[_currentValue] := SHARED();                                                        
     assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                     // (54.10): _currentValue became shared, but _currentValue.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 54.10: assume goesWrong(_m);                                                                 
                                                                                                    
    assume transition($pc, _m) == PhaseError;                                                       
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 54.10: this.top := next;                                                                     
                                                                                                    
                                                                                                    
    moverPath4298340 := WriteEval.Stack.top(tid: Tid,this: Stack,next: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
    mover4298340 := m#moverPath(moverPath4298340);                                                  
    path4298340 := p#moverPath(moverPath4298340);                                                   
    assume Node._state4298340 == Node._state && Node.value4298340 == Node.value && Node.next4298340 == Node.next && Node._lock4298340 == Node._lock && Stack._state4298340 == Stack._state && Stack.top4298340 == Stack.top && Stack._lock4298340 == Stack._lock && Stack.top_nextThread4298340 == Stack.top_nextThread && Stack.top_nextValue4298340 == Stack.top_nextValue && _m4298340 == _m && _currentValue4298340 == _currentValue && ctmp42902334298340 == ctmp4290233 && result4298340 == result && next4298340 == next && top4298340 == top && $result4298340 == $result && this4298340 == this && tid4298340 == tid && $pc4298340 == $pc;
    assume $recorded.state4298340 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this != Stack.null;                                                                     
    } else {                                                                                        
     assert this != Stack.null;                                                                            // (54.10): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover4298340);                                                           
    assert $pc != PhaseError;                                                                              // (54.10): Reduction failure
    Stack.top[this] := next;                                                                        
    if (isLocal(Node._state[next], tid)) {                                                          
     Node._state[next] := SHARED();                                                                 
     assert isSharedAssignable(Node._state[Node.next[next]]);                                              // (54.10): next became shared, but next.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 54.10: result = false;                                                                       
                                                                                                    
    result := false;                                                                                
   }                                                                                                
  }                                                                                                 
  if (result) {                                                                                     
                                                                                                    
   // 56.14: int value;                                                                             
                                                                                                    
                                                                                                    
   // 56.14: value := top.value;                                                                    
                                                                                                    
                                                                                                    
   moverPath4298355 := ReadEval.Node.value(tid: Tid,top: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
   mover4298355 := m#moverPath(moverPath4298355);                                                   
   path4298355 := p#moverPath(moverPath4298355);                                                    
   assume Node._state4298355 == Node._state && Node.value4298355 == Node.value && Node.next4298355 == Node.next && Node._lock4298355 == Node._lock && Stack._state4298355 == Stack._state && Stack.top4298355 == Stack.top && Stack._lock4298355 == Stack._lock && Stack.top_nextThread4298355 == Stack.top_nextThread && Stack.top_nextValue4298355 == Stack.top_nextValue && value4298355 == value && result4298355 == result && next4298355 == next && top4298355 == top && $result4298355 == $result && this4298355 == this && tid4298355 == tid && $pc4298355 == $pc;
   assume $recorded.state4298355 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume top != Node.null;                                                                        
   } else {                                                                                         
    assert top != Node.null;                                                                               // (56.14): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4298355);                                                            
   assert $pc != PhaseError;                                                                               // (56.14): Reduction failure
   value := Node.value[top];                                                                        
                                                                                                    
   // 57.14:  return value;                                                                         
                                                                                                    
   assume Node._state4298357 == Node._state && Node.value4298357 == Node.value && Node.next4298357 == Node.next && Node._lock4298357 == Node._lock && Stack._state4298357 == Stack._state && Stack.top4298357 == Stack.top && Stack._lock4298357 == Stack._lock && Stack.top_nextThread4298357 == Stack.top_nextThread && Stack.top_nextValue4298357 == Stack.top_nextValue && value4298357 == value && result4298357 == result && next4298357 == next && top4298357 == top && $result4298357 == $result && this4298357 == this && tid4298357 == tid;
   assume $recorded.state4298357 == 1;                                                              
   $result := value;                                                                                
   return;                                                                                          
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 59.10: yield;                                                                                  
                                                                                                    
  assume Node._state4298362 == Node._state && Node.value4298362 == Node.value && Node.next4298362 == Node.next && Node._lock4298362 == Node._lock && Stack._state4298362 == Stack._state && Stack.top4298362 == Stack.top && Stack._lock4298362 == Stack._lock && Stack.top_nextThread4298362 == Stack.top_nextThread && Stack.top_nextValue4298362 == Stack.top_nextValue && result4298362 == result && next4298362 == next && top4298362 == top && $result4298362 == $result && this4298362 == this && tid4298362 == tid;
  assume $recorded.state4298362 == 1;                                                               
  call Yield(tid);                                                                                  
  $pc := PreCommit;                                                                                 
  assume Node._state4298362_post == Node._state && Node.value4298362_post == Node.value && Node.next4298362_post == Node.next && Node._lock4298362_post == Node._lock && Stack._state4298362_post == Stack._state && Stack.top4298362_post == Stack.top && Stack._lock4298362_post == Stack._lock && Stack.top_nextThread4298362_post == Stack.top_nextThread && Stack.top_nextValue4298362_post == Stack.top_nextValue && result4298362_post == result && next4298362_post == next && top4298362_post == top && $result4298362_post == $result && this4298362_post == this && tid4298362_post == tid;
  assume $recorded.state4298362_post == 1;                                                          
  assume Node._state4298364_bottom == Node._state && Node.value4298364_bottom == Node.value && Node.next4298364_bottom == Node.next && Node._lock4298364_bottom == Node._lock && Stack._state4298364_bottom == Stack._state && Stack.top4298364_bottom == Stack.top && Stack._lock4298364_bottom == Stack._lock && Stack.top_nextThread4298364_bottom == Stack.top_nextThread && Stack.top_nextValue4298364_bottom == Stack.top_nextValue && $result4298364_bottom == $result && this4298364_bottom == this && tid4298364_bottom == tid;
  assume $recorded.state4298364_bottom == 1;                                                        
  assert phase4298364 == $pc;                                                                              // (46.6): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 61.6:  return -1;                                                                               
                                                                                                    
 assume Node._state4298367 == Node._state && Node.value4298367 == Node.value && Node.next4298367 == Node.next && Node._lock4298367 == Node._lock && Stack._state4298367 == Stack._state && Stack.top4298367 == Stack.top && Stack._lock4298367 == Stack._lock && Stack.top_nextThread4298367 == Stack.top_nextThread && Stack.top_nextValue4298367 == Stack.top_nextValue && $result4298367 == $result && this4298367 == this && tid4298367 == tid;
 assume $recorded.state4298367 == 1;                                                                
 $result := -1;                                                                                     
 return;                                                                                            
                                                                                                    
 // 45.19: // return -1;                                                                            
                                                                                                    
 assume Node._state4298371 == Node._state && Node.value4298371 == Node.value && Node.next4298371 == Node.next && Node._lock4298371 == Node._lock && Stack._state4298371 == Stack._state && Stack.top4298371 == Stack.top && Stack._lock4298371 == Stack._lock && Stack.top_nextThread4298371 == Stack.top_nextThread && Stack.top_nextValue4298371 == Stack.top_nextValue && $result4298371 == $result && this4298371 == this && tid4298371 == tid;
 assume $recorded.state4298371 == 1;                                                                
 $result := -1;                                                                                     
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Stack._state: [Stack]State,Stack.top: [Stack]Node,Stack._lock: [Stack]Tid,Stack.top_nextThread: [Stack]Tid,Stack.top_nextValue: [Stack]Node) returns (bool) {
  true &&                                                                                           
  (forall _i: Node  :: _i == Node.null <==> isNull(Node._state[_i])) &&                             
  (forall _i: Stack  :: _i == Stack.null <==> isNull(Stack._state[_i])) &&                          
  (forall _i: Node ::  (isShared(Node._state[_i]) ==> isSharedAssignable(Node._state[Node.next[_i]]))) &&
  (forall _i: Node ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Node._state[_i],_t) ==> isLocalAssignable(Node._state[Node.next[_i]], _t)))) &&
  (forall _i: Stack ::  (isShared(Stack._state[_i]) ==> isSharedAssignable(Node._state[Stack.top[_i]]))) &&
  (forall _i: Stack ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Stack._state[_i],_t) ==> isLocalAssignable(Node._state[Stack.top[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)          
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.value(u: Tid,x: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (3.2): Node.value failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)           
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.value(u: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (3.2): Node.value failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)           
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.value[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.value[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.value(u: Tid,x: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (3.2): Node.value failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.value[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.value(u: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (3.2): Node.value failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)                
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.value(u: Tid,x: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (3.2): Node.value failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)                 
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
 assume w == Node.value[x];                                                                         
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.value[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.value(u: Tid,x: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (3.2): Node.value failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)         
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (4.2): Node.next failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (4.2): Node.next failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (4.2): Node.next failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)           
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (4.2): Node.next failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)               
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (4.2): Node.next failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)                
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Node.next[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (4.2): Node.next failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Stack.top(t: Tid, u: Tid, v: Node, w: Node, x: Stack)        
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[x], u);                                                         
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Stack.top[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Stack.top(u: Tid,x: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (9.2): Stack.top failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Stack.top(t: Tid, u: Tid, v: Node, w: Node, x: Stack)         
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[x], u);                                                         
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Stack.top[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Stack.top(u: Tid,x: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (9.2): Stack.top failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Stack.top(t: Tid, u: Tid, v: Node, w: Node, x: Stack)         
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[x], u);                                                         
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Stack.top[x];                                                                          
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Stack.top[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Stack.top(u: Tid,x: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (9.2): Stack.top failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Stack.top(t: Tid, u: Tid, v: Node, w: Node, x: Stack)          
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[x], u);                                                         
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Stack.top[x];                                                                          
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Stack.top(u: Tid,x: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (9.2): Stack.top failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Stack.top(t: Tid, u: Tid, v: Node, w: Node, x: Stack)              
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[x], u);                                                         
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Stack.top(t: Tid,x: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Stack.top(u: Tid,x: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (9.2): Stack.top failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Stack.top(t: Tid, u: Tid, v: Node, w: Node, x: Stack)               
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[x], u);                                                         
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Stack.top[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Stack.top(t: Tid,x: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Stack.top[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Stack.top(u: Tid,x: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (9.2): Stack.top failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Node.value (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.2): Node.value is not Write-Write Stable with respect to Node.value (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Node.value (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var w_mid: int;                                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Node.value (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var w_mid: int;                                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Node.value (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Node.value (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.2): Node.value is not Read-Write Stable with respect to Node.value (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.2): Node.value is not Read-Write Stable with respect to Node.value (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.2): Node.value is not Read-Write Stable with respect to Node.value (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.2): Node.value is not Write-Read Stable with respect to Node.value (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.2): Node.value is not Write-Read Stable with respect to Node.value (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.2): Node.value is not Write-Read Stable with respect to Node.value (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Node.value (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.2): Node.next is not Write-Write Stable with respect to Node.value (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Node.value (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var w0_mid: Node;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var w0_mid: Node;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.2): Node.value is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.2): Node.value is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.2): Node.value is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Node.next is not Write-Read Stable with respect to Node.value (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Node.next is not Write-Read Stable with respect to Node.value (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.2): Node.next is not Write-Read Stable with respect to Node.value (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.value.Stack.top(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Node.value (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.2): Stack.top is not Write-Write Stable with respect to Node.value (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Node.value (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.value.Stack.top(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var w0_mid: Node;                                                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Stack.top[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.value.Stack.top(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var w0_mid: Node;                                                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Stack.top[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.value.Stack.top(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.top[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.2): Node.value is not Read-Write Stable with respect to Stack.top (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.2): Node.value is not Read-Write Stable with respect to Stack.top (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.2): Node.value is not Read-Write Stable with respect to Stack.top (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.value.Stack.top(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Stack.top(u: Tid,y: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Stack.top(u: Tid,y: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Stack.top is not Write-Read Stable with respect to Node.value (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Stack.top is not Write-Read Stable with respect to Node.value (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.2): Stack.top is not Write-Read Stable with respect to Node.value (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.2): Node.value is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var w_mid: int;                                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Node.value (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var w_mid: int;                                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Node.value (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Node.value (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Node.next is not Read-Write Stable with respect to Node.value (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Node.next is not Read-Write Stable with respect to Node.value (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Node.next is not Read-Write Stable with respect to Node.value (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.2): Node.value is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.2): Node.value is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.2): Node.value is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.2): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var w0_mid: Node;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var w0_mid: Node;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Node.next is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Node.next is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Node.next is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Node.next is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Node.next is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.2): Node.next is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Stack.top(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.2): Stack.top is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Stack.top(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var w0_mid: Node;                                                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Stack.top[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Stack.top(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var w0_mid: Node;                                                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Stack.top[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Stack.top(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.top[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Node.next is not Read-Write Stable with respect to Stack.top (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Node.next is not Read-Write Stable with respect to Stack.top (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Node.next is not Read-Write Stable with respect to Stack.top (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Stack.top(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Stack.top(u: Tid,y: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Stack.top(u: Tid,y: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Stack.top is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Stack.top is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.2): Stack.top is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Stack.top.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.top[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Stack.top.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var w_mid: int;                                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var x_mid: Stack;                                                                                  
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Stack.top[x];                                                                              
 Stack.top[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Stack.top[x] := tmpV;                                                                              
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Node.value (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Stack.top.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var w_mid: int;                                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var x_mid: Stack;                                                                                  
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Stack.top[x];                                                                              
 Stack.top[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Stack.top[x] := tmpV;                                                                              
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Node.value (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Node.value (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Stack.top.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Stack.top(t: Tid,x: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Stack.top(t: Tid,x: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Stack.top is not Read-Write Stable with respect to Node.value (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Stack.top is not Read-Write Stable with respect to Node.value (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Stack.top is not Read-Write Stable with respect to Node.value (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Stack.top.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.top[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.2): Node.value is not Write-Read Stable with respect to Stack.top (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.2): Node.value is not Write-Read Stable with respect to Stack.top (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.2): Node.value is not Write-Read Stable with respect to Stack.top (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Stack.top.Node.value(t: Tid, u: Tid, v: Node, w1: int, w2: int, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: int;                                                                                     
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var w2_pre: int;                                                                                   
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w1_pre: int;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var w2_mid: int;                                                                                   
 var x_mid: Stack;                                                                                  
 var Node._state_mid: [Node]State;                                                                  
 var w1_mid: int;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var w2_post: int;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var w1_post: int;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w1: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.value[y];                                                                             
 Node.value[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.value(u: Tid,y: Node,w2: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.value[y] := tmpW;                                                                             
                                                                                                    
 Stack.top[x] := v;                                                                                 
 Node.value[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.value(u: Tid,y: Node,w2: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Stack.top.Node.value(t: Tid, u: Tid, v1: Node, v2: Node, w: int, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var v2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var v1_pre: Node;                                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var w_mid: int;                                                                                    
 var v1_mid: Node;                                                                                  
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var x_mid: Stack;                                                                                  
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v2_post: Node;                                                                                 
 var x_post: Stack;                                                                                 
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Stack.top[x];                                                                              
 Stack.top[x] := v1;                                                                                
 _writeByTAfterT := WriteEval.Stack.top(t: Tid,x: Stack,v2: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Stack.top[x] := tmpV;                                                                              
                                                                                                    
 Node.value[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v1: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Stack.top[x] := v1;                                                                                
 _writeByTAfterUAndT := WriteEval.Stack.top(t: Tid,x: Stack,v2: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Stack.top.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.top[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Stack.top.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var w0_mid: Node;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var x_mid: Stack;                                                                                  
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Stack.top[x];                                                                              
 Stack.top[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Stack.top[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Stack.top.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var w0_mid: Node;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var x_mid: Stack;                                                                                  
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Stack.top[x];                                                                              
 Stack.top[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Stack.top[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Stack.top.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Stack.top(t: Tid,x: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Stack.top(t: Tid,x: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Stack.top is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Stack.top is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Stack.top is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Stack.top.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.top[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Node.next is not Write-Read Stable with respect to Stack.top (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Node.next is not Write-Read Stable with respect to Stack.top (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.2): Node.next is not Write-Read Stable with respect to Stack.top (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Stack.top.Node.next(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var w2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var w2_mid: Node;                                                                                  
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var x_mid: Stack;                                                                                  
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w1: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.next[y];                                                                              
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.next[y] := tmpW;                                                                              
                                                                                                    
 Stack.top[x] := v;                                                                                 
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Stack.top.Node.next(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Stack, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Stack.top;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var v2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var v1_pre: Node;                                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var v1_mid: Node;                                                                                  
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var x_mid: Stack;                                                                                  
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v2_post: Node;                                                                                 
 var x_post: Stack;                                                                                 
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Stack.top[x];                                                                              
 Stack.top[x] := v1;                                                                                
 _writeByTAfterT := WriteEval.Stack.top(t: Tid,x: Stack,v2: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Stack.top[x] := tmpV;                                                                              
                                                                                                    
 Node.next[y] := w;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v1: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Stack.top[x] := v1;                                                                                
 _writeByTAfterUAndT := WriteEval.Stack.top(t: Tid,x: Stack,v2: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Stack.top.Stack.top(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Stack.top;                                                                                
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.top[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Stack.top.Stack.top(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Stack.top;                                                                                
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var w0_mid: Node;                                                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var x_mid: Stack;                                                                                  
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Stack.top[x];                                                                              
 Stack.top[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Stack.top[x] := tmpV;                                                                              
 Stack.top[y] := w;                                                                                 
 _writeByTPost := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Stack.top.Stack.top(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Stack.top;                                                                                
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var w0_mid: Node;                                                                                  
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var x_mid: Stack;                                                                                  
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Stack.top[x];                                                                              
 Stack.top[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Stack.top[x] := tmpV;                                                                              
 Stack.top[y] := w;                                                                                 
 _writeByTPost := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Stack.top.Stack.top(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Stack.top;                                                                                
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Stack.top(t: Tid,x: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.top[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Stack.top(t: Tid,x: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Stack.top is not Read-Write Stable with respect to Stack.top (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Stack.top is not Read-Write Stable with respect to Stack.top (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Stack.top is not Read-Write Stable with respect to Stack.top (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Stack.top.Stack.top(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Stack, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Stack.top;                                                                                
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var w0_post: Node;                                                                                 
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Stack.top(u: Tid,y: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Stack.top[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Stack.top(u: Tid,y: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Stack.top is not Write-Read Stable with respect to Stack.top (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Stack.top is not Write-Read Stable with respect to Stack.top (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.2): Stack.top is not Write-Read Stable with respect to Stack.top (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Stack.top.Stack.top(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Stack, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Stack.top;                                                                                
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var w2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var w2_mid: Node;                                                                                  
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var x_mid: Stack;                                                                                  
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var x_post: Stack;                                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
 var Stack.top_post: [Stack]Node;                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w1: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Stack.top[y];                                                                              
 Stack.top[y] := w1;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Stack.top(u: Tid,y: Stack,w2: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Stack.top[y] := tmpW;                                                                              
                                                                                                    
 Stack.top[x] := v;                                                                                 
 Stack.top[y] := w1;                                                                                
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Stack.top(u: Tid,y: Stack,w2: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Stack.top.Stack.top(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Stack, y: Stack)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Stack._state[x], t);                                                         
 requires isAccessible(Stack._state[y], u);                                                         
 modifies Stack.top;                                                                                
 modifies Stack.top;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Stack.top_pre: [Stack]Node;                                                                    
 var v2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Stack.top_nextValue_pre: [Stack]Node;                                                          
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: Stack;                                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Stack._lock_pre: [Stack]Tid;                                                                   
 var v1_pre: Node;                                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Stack.top_nextThread_pre: [Stack]Tid;                                                          
 var Stack._state_pre: [Stack]State;                                                                
 var t_pre: Tid;                                                                                    
 var y_pre: Stack;                                                                                  
                                                                                                    
 var Stack._state_mid: [Stack]State;                                                                
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Stack.top_nextValue_mid: [Stack]Node;                                                          
 var Stack.top_mid: [Stack]Node;                                                                    
 var v1_mid: Node;                                                                                  
 var Stack.top_nextThread_mid: [Stack]Tid;                                                          
 var y_mid: Stack;                                                                                  
 var Stack._lock_mid: [Stack]Tid;                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var x_mid: Stack;                                                                                  
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Stack;                                                                                 
 var Stack._state_post: [Stack]State;                                                               
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Stack.top_nextThread_post: [Stack]Tid;                                                         
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Stack.top_nextValue_post: [Stack]Node;                                                         
 var Stack._lock_post: [Stack]Tid;                                                                  
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v2_post: Node;                                                                                 
 var x_post: Stack;                                                                                 
 var u_post: Tid;                                                                                   
 var Stack.top_post: [Stack]Node;                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Stack.top(u: Tid,y: Stack,w: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Stack.top[x];                                                                              
 Stack.top[x] := v1;                                                                                
 _writeByTAfterT := WriteEval.Stack.top(t: Tid,x: Stack,v2: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Stack.top[x] := tmpV;                                                                              
                                                                                                    
 Stack.top[y] := w;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Stack._state_mid == Stack._state && Stack.top_mid == Stack.top && Stack._lock_mid == Stack._lock && Stack.top_nextThread_mid == Stack.top_nextThread && Stack.top_nextValue_mid == Stack.top_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Stack.top(t: Tid,x: Stack,v1: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Stack.top[x] := v1;                                                                                
 _writeByTAfterUAndT := WriteEval.Stack.top(t: Tid,x: Stack,v2: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Stack._state_post == Stack._state && Stack.top_post == Stack.top && Stack._lock_post == Stack._lock && Stack.top_nextThread_post == Stack.top_nextThread && Stack.top_nextValue_post == Stack.top_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
requires ValidTid(tid);                                                                             
modifies Node._state;                                                                               
modifies Node.value;                                                                                
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Stack._state;                                                                              
modifies Stack.top;                                                                                 
modifies Stack._lock;                                                                               
modifies Stack.top_nextThread;                                                                      
modifies Stack.top_nextValue;                                                                       
ensures StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
ensures Y(tid , old(Node._state), old(Node.value), old(Node.next), old(Node._lock), old(Stack._state), old(Stack.top), old(Stack._lock), old(Stack.top_nextThread), old(Stack.top_nextValue) , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
                                                                                                    
// Node.value:                                                                                      
                                                                                                    
function {:inline} Y_Node.value(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.value(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)), _R)) ==> (Node.value[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.value(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.value.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Stack.top_nextThread_yield: [Stack]Tid;                                                         
var Stack.top_yield: [Stack]Node;                                                                   
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var newValue_yield: int;                                                                            
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Stack._state_yield: [Stack]State;                                                               
var Stack.top_nextValue_yield: [Stack]Node;                                                         
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.value(u: Tid,this: Node,newValue: int,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.top_yield == Stack.top && Stack._lock_yield == Stack._lock && Stack.top_nextThread_yield == Stack.top_nextThread && Stack.top_nextValue_yield == Stack.top_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.value(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.value.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Stack.top_nextThread_yield: [Stack]Tid;                                                         
var Stack.top_yield: [Stack]Node;                                                                   
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var Stack._state_yield: [Stack]State;                                                               
var Stack.top_nextValue_yield: [Stack]Node;                                                         
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.top_yield == Stack.top && Stack._lock_yield == Stack._lock && Stack.top_nextThread_yield == Stack.top_nextThread && Stack.top_nextValue_yield == Stack.top_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.value(tid, this, Node.value[this] , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.value.Transitive(tid : Tid, this: Node, newValue : int , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.top_p: [Stack]Node, Stack._lock_p: [Stack]Tid, Stack.top_nextThread_p: [Stack]Tid, Stack.top_nextValue_p: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Stack.top_pre: [Stack]Node;                                                                     
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var Stack.top_nextValue_pre: [Stack]Node;                                                           
var newValue_pre: int;                                                                              
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Stack._lock_pre: [Stack]Tid;                                                                    
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var Stack.top_nextThread_pre: [Stack]Tid;                                                           
var Stack._state_pre: [Stack]State;                                                                 
                                                                                                    
var Stack._state_post: [Stack]State;                                                                
var $recorded.state_post: int;                                                                      
var Stack.top_nextThread_post: [Stack]Tid;                                                          
var Node.value_post: [Node]int;                                                                     
var newValue_post: int;                                                                             
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Stack.top_nextValue_post: [Stack]Node;                                                          
var tid_post: Tid;                                                                                  
var Stack._lock_post: [Stack]Tid;                                                                   
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var this_post: Node;                                                                                
var Stack.top_post: [Stack]Node;                                                                    
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
 assume Y_Node.value(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Stack._state_post == Stack._state_p && Stack.top_post == Stack.top_p && Stack._lock_post == Stack._lock_p && Stack.top_nextThread_post == Stack.top_nextThread_p && Stack.top_nextValue_post == Stack.top_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.value(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
// Node.next:                                                                                       
                                                                                                    
function {:inline} Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.next(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)), _R)) ==> (Node.next[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Stack.top_nextThread_yield: [Stack]Tid;                                                         
var Stack.top_yield: [Stack]Node;                                                                   
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Node;                                                                           
var Stack._state_yield: [Stack]State;                                                               
var Stack.top_nextValue_yield: [Stack]Node;                                                         
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.next(u: Tid,this: Node,newValue: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.top_yield == Stack.top && Stack._lock_yield == Stack._lock && Stack.top_nextThread_yield == Stack.top_nextThread && Stack.top_nextValue_yield == Stack.top_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Stack.top_nextThread_yield: [Stack]Tid;                                                         
var Stack.top_yield: [Stack]Node;                                                                   
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var Stack._state_yield: [Stack]State;                                                               
var Stack.top_nextValue_yield: [Stack]Node;                                                         
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.top_yield == Stack.top && Stack._lock_yield == Stack._lock && Stack.top_nextThread_yield == Stack.top_nextThread && Stack.top_nextValue_yield == Stack.top_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, Node.next[this] , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Transitive(tid : Tid, this: Node, newValue : Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.top_p: [Stack]Node, Stack._lock_p: [Stack]Tid, Stack.top_nextThread_p: [Stack]Tid, Stack.top_nextValue_p: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Stack.top_pre: [Stack]Node;                                                                     
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var Stack.top_nextValue_pre: [Stack]Node;                                                           
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Stack._lock_pre: [Stack]Tid;                                                                    
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var Stack.top_nextThread_pre: [Stack]Tid;                                                           
var Stack._state_pre: [Stack]State;                                                                 
                                                                                                    
var Stack._state_post: [Stack]State;                                                                
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Stack.top_nextThread_post: [Stack]Tid;                                                          
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Stack.top_nextValue_post: [Stack]Node;                                                          
var tid_post: Tid;                                                                                  
var Stack._lock_post: [Stack]Tid;                                                                   
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var this_post: Node;                                                                                
var Stack.top_post: [Stack]Node;                                                                    
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
 assume Y_Node.next(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Stack._state_post == Stack._state_p && Stack.top_post == Stack.top_p && Stack._lock_post == Stack._lock_p && Stack.top_nextThread_post == Stack.top_nextThread_p && Stack.top_nextValue_post == Stack.top_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.next(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
// Node._lock:                                                                                      
                                                                                                    
function {:inline} Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)), _R)) ==> (Node._lock[this] == newValue))
 &&(((Node._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Stack.top_nextThread_yield: [Stack]Tid;                                                         
var newValue_yield: Tid;                                                                            
var Stack.top_yield: [Stack]Node;                                                                   
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Stack._state_yield: [Stack]State;                                                               
var Stack.top_nextValue_yield: [Stack]Node;                                                         
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node._lock(u: Tid,this: Node,newValue: Tid,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)));
 assume leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)), _N);
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.top_yield == Stack.top && Stack._lock_yield == Stack._lock && Stack.top_nextThread_yield == Stack.top_nextThread && Stack.top_nextValue_yield == Stack.top_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Stack.top_nextThread_yield: [Stack]Tid;                                                         
var Stack.top_yield: [Stack]Node;                                                                   
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var Stack._state_yield: [Stack]State;                                                               
var Stack.top_nextValue_yield: [Stack]Node;                                                         
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.top_yield == Stack.top && Stack._lock_yield == Stack._lock && Stack.top_nextThread_yield == Stack.top_nextThread && Stack.top_nextValue_yield == Stack.top_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, Node._lock[this] , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Transitive(tid : Tid, this: Node, newValue : Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.top_p: [Stack]Node, Stack._lock_p: [Stack]Tid, Stack.top_nextThread_p: [Stack]Tid, Stack.top_nextValue_p: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Stack.top_pre: [Stack]Node;                                                                     
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var Stack.top_nextValue_pre: [Stack]Node;                                                           
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Stack._lock_pre: [Stack]Tid;                                                                    
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var Stack.top_nextThread_pre: [Stack]Tid;                                                           
var Stack._state_pre: [Stack]State;                                                                 
var newValue_pre: Tid;                                                                              
                                                                                                    
var Stack._state_post: [Stack]State;                                                                
var $recorded.state_post: int;                                                                      
var Stack.top_nextThread_post: [Stack]Tid;                                                          
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Stack.top_nextValue_post: [Stack]Node;                                                          
var tid_post: Tid;                                                                                  
var Stack._lock_post: [Stack]Tid;                                                                   
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var this_post: Node;                                                                                
var newValue_post: Tid;                                                                             
var Stack.top_post: [Stack]Node;                                                                    
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
 assume Y_Node._lock(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Stack._state_post == Stack._state_p && Stack.top_post == Stack.top_p && Stack._lock_post == Stack._lock_p && Stack.top_nextThread_post == Stack.top_nextThread_p && Stack.top_nextValue_post == Stack.top_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
// Stack.top:                                                                                       
                                                                                                    
function {:inline} Y_Stack.top(tid : Tid, this: Stack, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 ((isAccessible(Stack._state[this], tid) && leq(m#moverPath(ReadEval.Stack.top(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)), _R)) ==> (Stack.top[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Stack.top(tid : Tid, this: Stack, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Stack.top.Subsumes.W(tid : Tid, u : Tid, this: Stack, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var Node.value_yield: [Node]int;                                                                    
var Stack.top_nextThread_yield: [Stack]Tid;                                                         
var Stack.top_yield: [Stack]Node;                                                                   
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var this_yield: Stack;                                                                              
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Node;                                                                           
var Stack._state_yield: [Stack]State;                                                               
var Stack.top_nextValue_yield: [Stack]Node;                                                         
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Stack._state[this], tid);                                                      
 assume isAccessible(Stack._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Stack.top(u: Tid,this: Stack,newValue: Node,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.top_yield == Stack.top && Stack._lock_yield == Stack._lock && Stack.top_nextThread_yield == Stack.top_nextThread && Stack.top_nextValue_yield == Stack.top_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Stack.top(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Stack.top.Reflexive(tid : Tid, this: Stack , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var Node.value_yield: [Node]int;                                                                    
var Stack.top_nextThread_yield: [Stack]Tid;                                                         
var Stack.top_yield: [Stack]Node;                                                                   
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var this_yield: Stack;                                                                              
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var Stack._state_yield: [Stack]State;                                                               
var Stack.top_nextValue_yield: [Stack]Node;                                                         
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Stack._state[this], tid);                                                      
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.top_yield == Stack.top && Stack._lock_yield == Stack._lock && Stack.top_nextThread_yield == Stack.top_nextThread && Stack.top_nextValue_yield == Stack.top_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Stack.top(tid, this, Stack.top[this] , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Stack.top.Transitive(tid : Tid, this: Stack, newValue : Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.top_p: [Stack]Node, Stack._lock_p: [Stack]Tid, Stack.top_nextThread_p: [Stack]Tid, Stack.top_nextValue_p: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Stack.top_pre: [Stack]Node;                                                                     
var $recorded.state_pre: int;                                                                       
var Stack.top_nextValue_pre: [Stack]Node;                                                           
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var this_pre: Stack;                                                                                
var tid_pre: Tid;                                                                                   
var Stack._lock_pre: [Stack]Tid;                                                                    
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var Stack.top_nextThread_pre: [Stack]Tid;                                                           
var Stack._state_pre: [Stack]State;                                                                 
                                                                                                    
var Stack._state_post: [Stack]State;                                                                
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var this_post: Stack;                                                                               
var Stack.top_nextThread_post: [Stack]Tid;                                                          
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Stack.top_nextValue_post: [Stack]Node;                                                          
var tid_post: Tid;                                                                                  
var Stack._lock_post: [Stack]Tid;                                                                   
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Stack.top_post: [Stack]Node;                                                                    
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Stack._state[this], tid);                                                      
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
 assume Y_Stack.top(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Stack._state_post == Stack._state_p && Stack.top_post == Stack.top_p && Stack._lock_post == Stack._lock_p && Stack.top_nextThread_post == Stack.top_nextThread_p && Stack.top_nextValue_post == Stack.top_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Stack.top(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
// Stack._lock:                                                                                     
                                                                                                    
function {:inline} Y_Stack._lock(tid : Tid, this: Stack, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 ((isAccessible(Stack._state[this], tid) && leq(m#moverPath(ReadEval.Stack._lock(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)), _R)) ==> (Stack._lock[this] == newValue))
 &&(((Stack._lock[this]==tid)==(newValue==tid)))                                                    
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Stack._lock(tid : Tid, this: Stack, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Stack._lock.Subsumes.W(tid : Tid, u : Tid, this: Stack, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var Node.value_yield: [Node]int;                                                                    
var Stack.top_nextThread_yield: [Stack]Tid;                                                         
var newValue_yield: Tid;                                                                            
var Stack.top_yield: [Stack]Node;                                                                   
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var this_yield: Stack;                                                                              
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Stack._state_yield: [Stack]State;                                                               
var Stack.top_nextValue_yield: [Stack]Node;                                                         
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Stack._state[this], tid);                                                      
 assume isAccessible(Stack._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Stack._lock(u: Tid,this: Stack,newValue: Tid,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)));
 assume leq(m#moverPath(ReadEval.Stack._lock(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)), _N);
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.top_yield == Stack.top && Stack._lock_yield == Stack._lock && Stack.top_nextThread_yield == Stack.top_nextThread && Stack.top_nextValue_yield == Stack.top_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Stack._lock(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Stack._lock.Reflexive(tid : Tid, this: Stack , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Stack._lock_yield: [Stack]Tid;                                                                  
var Node.value_yield: [Node]int;                                                                    
var Stack.top_nextThread_yield: [Stack]Tid;                                                         
var Stack.top_yield: [Stack]Node;                                                                   
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var this_yield: Stack;                                                                              
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var Stack._state_yield: [Stack]State;                                                               
var Stack.top_nextValue_yield: [Stack]Node;                                                         
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Stack._state[this], tid);                                                      
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Stack._state_yield == Stack._state && Stack.top_yield == Stack.top && Stack._lock_yield == Stack._lock && Stack.top_nextThread_yield == Stack.top_nextThread && Stack.top_nextValue_yield == Stack.top_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Stack._lock(tid, this, Stack._lock[this] , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Stack._lock.Transitive(tid : Tid, this: Stack, newValue : Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.top_p: [Stack]Node, Stack._lock_p: [Stack]Tid, Stack.top_nextThread_p: [Stack]Tid, Stack.top_nextValue_p: [Stack]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Stack.top_pre: [Stack]Node;                                                                     
var $recorded.state_pre: int;                                                                       
var Stack.top_nextValue_pre: [Stack]Node;                                                           
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var this_pre: Stack;                                                                                
var tid_pre: Tid;                                                                                   
var Stack._lock_pre: [Stack]Tid;                                                                    
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var Stack.top_nextThread_pre: [Stack]Tid;                                                           
var Stack._state_pre: [Stack]State;                                                                 
var newValue_pre: Tid;                                                                              
                                                                                                    
var Stack._state_post: [Stack]State;                                                                
var $recorded.state_post: int;                                                                      
var this_post: Stack;                                                                               
var Stack.top_nextThread_post: [Stack]Tid;                                                          
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Stack.top_nextValue_post: [Stack]Node;                                                          
var tid_post: Tid;                                                                                  
var Stack._lock_post: [Stack]Tid;                                                                   
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var newValue_post: Tid;                                                                             
var Stack.top_post: [Stack]Node;                                                                    
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Stack._state_pre == Stack._state && Stack.top_pre == Stack.top && Stack._lock_pre == Stack._lock && Stack.top_nextThread_pre == Stack.top_nextThread && Stack.top_nextValue_pre == Stack.top_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Stack._state[this], tid);                                                      
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
 assume Y_Stack._lock(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Stack._state_p, Stack.top_p, Stack._lock_p, Stack.top_nextThread_p, Stack.top_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Stack._state_post == Stack._state_p && Stack.top_post == Stack.top_p && Stack._lock_post == Stack._lock_p && Stack.top_nextThread_post == Stack.top_nextThread_p && Stack.top_nextValue_post == Stack.top_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Stack._lock(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue);
}                                                                                                   
// Stack.top_nextThread:                                                                            
                                                                                                    
function {:inline} Y_Stack.top_nextThread(tid : Tid, this: Stack, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 ((isAccessible(Stack._state[this], tid) && leq(m#moverPath(ReadEval.Stack.top_nextThread(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)), _R)) ==> (Stack.top_nextThread[this] == newValue))
 &&(((Stack.top_nextThread[this]==tid)==>(newValue==tid)))                                          
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Stack.top_nextThread(tid : Tid, this: Stack, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// Stack.top_nextValue:                                                                             
                                                                                                    
function {:inline} Y_Stack.top_nextValue(tid : Tid, this: Stack, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 ((isAccessible(Stack._state[this], tid) && leq(m#moverPath(ReadEval.Stack.top_nextValue(tid: Tid,this: Stack,Node._state,Node.value,Node.next,Node._lock,Stack._state,Stack.top,Stack._lock,Stack.top_nextThread,Stack.top_nextValue)), _R)) ==> (Stack.top_nextValue[this] == newValue))
 &&(((Stack.top_nextThread[this]==tid)==>(newValue==Stack.top_nextValue[this])))                    
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Stack.top_nextValue(tid : Tid, this: Stack, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Stack._state: [Stack]State, Stack.top: [Stack]Node, Stack._lock: [Stack]Tid, Stack.top_nextThread: [Stack]Tid, Stack.top_nextValue: [Stack]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Stack._state_p: [Stack]State, Stack.top_p: [Stack]Node, Stack._lock_p: [Stack]Tid, Stack.top_nextThread_p: [Stack]Tid, Stack.top_nextValue_p: [Stack]Node): bool
{                                                                                                   
 (forall this: Node :: Y_Node.value(tid : Tid, this, Node.value_p[this] , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue))
 && (forall this: Node :: Y_Node.next(tid : Tid, this, Node.next_p[this] , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue))
 && (forall this: Node :: Y_Node._lock(tid : Tid, this, Node._lock_p[this] , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue))
 && (forall this: Stack :: Y_Stack.top(tid : Tid, this, Stack.top_p[this] , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue))
 && (forall this: Stack :: Y_Stack._lock(tid : Tid, this, Stack._lock_p[this] , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue))
 && (forall this: Stack :: Y_Stack.top_nextThread(tid : Tid, this, Stack.top_nextThread_p[this] , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue))
 && (forall this: Stack :: Y_Stack.top_nextValue(tid : Tid, this, Stack.top_nextValue_p[this] , Node._state, Node.value, Node.next, Node._lock, Stack._state, Stack.top, Stack._lock, Stack.top_nextThread, Stack.top_nextValue))
 && (forall _i : Node :: isShared(Node._state[_i]) ==> isShared(Node._state_p[_i]))                 
 && (forall _i : Node :: isLocal(Node._state[_i], tid) <==> isLocal(Node._state_p[_i], tid))        
 && (forall _i : Stack :: isShared(Stack._state[_i]) ==> isShared(Stack._state_p[_i]))              
 && (forall _i : Stack :: isLocal(Stack._state[_i], tid) <==> isLocal(Stack._state_p[_i], tid))     
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 1594.1-2527.2: (Method:11.2)
// 1607.1-1607.24: (11.2): Bad tid
// 1608.1-1608.39: (11.2): this is not global
// 2062.2-2066.14: (class anchor.sink.While:12.4)
// 2068.1-2068.27: (11.2): Bad tid
// 2069.1-2069.42: (11.2): this is not global
// 2072.1-2072.282: (12.4): Loop does not preserve yields_as annotation for field value
// 2073.1-2073.280: (12.4): Loop does not preserve yields_as annotation for field next
// 2074.1-2074.281: (12.4): Loop does not preserve yields_as annotation for field top
// 2075.1-2075.33: (12.4): Phase must be invariant at loop head
// 2076.1-2076.30: (12.4): Potentially infinite loop cannot be in post-commit phase.
// 2078.3-2080.3: (class anchor.sink.VarDeclStmt:13.5)
// 2082.3-2084.3: (class anchor.sink.VarDeclStmt:13.5)
// 2085.3-2102.38: (class anchor.sink.Read:13.5)
// 2097.1-2097.30: (13.5): Cannot have potential null deference in left-mover part.
// 2101.1-2101.28: (13.5): Reduction failure
// 2103.3-2105.3: (class anchor.sink.VarDeclStmt:13.5)
// 2106.3-2123.37: (class anchor.sink.Read:13.5)
// 2118.1-2118.30: (13.5): Cannot have potential null deference in left-mover part.
// 2122.1-2122.28: (13.5): Reduction failure
// 2124.3-2126.3: (class anchor.sink.VarDeclStmt:13.5)
// 2127.3-2144.36: (class anchor.sink.Read:13.5)
// 2139.1-2139.30: (13.5): Cannot have potential null deference in left-mover part.
// 2143.1-2143.28: (13.5): Reduction failure
// 2145.3-2147.3: (class anchor.sink.VarDeclStmt:13.5)
// 2148.3-2151.185: (class anchor.sink.Assign:13.5)
// 2152.3-2154.3: (class anchor.sink.VarDeclStmt:13.5)
// 2155.3-2158.75: (class anchor.sink.Assign:13.5)
// 2161.4-2178.28: (class anchor.sink.Read:13.5)
// 2173.1-2173.31: (13.5): Cannot have potential null deference in left-mover part.
// 2177.1-2177.29: (13.5): Reduction failure
// 2181.4-2198.28: (class anchor.sink.Read:13.5)
// 2193.1-2193.31: (13.5): Cannot have potential null deference in left-mover part.
// 2197.1-2197.29: (13.5): Reduction failure
// 2200.3-2202.3: (class anchor.sink.VarDeclStmt:14.17)
// 2203.3-2211.38: (class anchor.sink.Alloc:14.17)
// 2213.3-2229.23: (class anchor.sink.Write:15.17)
// 2225.1-2225.27: (15.17): Cannot have potential null deference in left-mover part.
// 2228.1-2228.28: (15.17): Reduction failure
// 2231.3-2252.3: (class anchor.sink.Write:16.5)
// 2243.1-2243.27: (16.5): Cannot have potential null deference in left-mover part.
// 2246.1-2246.28: (16.5): Reduction failure
// 2250.1-2250.60: (16.5): next became shared, but next.next may not be shared.
// 2253.3-2261.43: (class anchor.sink.Yield:17.5)
// 2262.3-2264.3: (class anchor.sink.VarDeclStmt:18.5)
// 2266.3-2268.3: (class anchor.sink.VarDeclStmt:18.5)
// 2269.3-2272.21: (class anchor.sink.Assign:18.5)
// 2275.4-2278.20: (class anchor.sink.Assign:18.5)
// 2280.4-2283.22: (class anchor.sink.Assign:18.5)
// 2285.5-2287.5: (class anchor.sink.VarDeclStmt:18.5)
// 2288.5-2290.5: (class anchor.sink.VarDeclStmt:18.5)
// 2291.5-2293.5: (class anchor.sink.VarDeclStmt:18.5)
// 2294.5-2297.195: (class anchor.sink.Assign:18.5)
// 2298.5-2301.36: (class anchor.sink.Assume:18.5)
// 2302.5-2305.49: (class anchor.sink.Assume:18.5)
// 2306.5-2309.46: (class anchor.sink.Assume:18.5)
// 2310.5-2313.46: (class anchor.sink.Assume:18.5)
// 2315.5-2331.42: (class anchor.sink.Write:18.5)
// 2327.1-2327.32: (18.5): Cannot have potential null deference in left-mover part.
// 2330.1-2330.30: (18.5): Reduction failure
// 2333.5-2349.43: (class anchor.sink.Write:18.5)
// 2345.1-2345.32: (18.5): Cannot have potential null deference in left-mover part.
// 2348.1-2348.30: (18.5): Reduction failure
// 2352.5-2373.5: (class anchor.sink.Write:18.5)
// 2364.1-2364.32: (18.5): Cannot have potential null deference in left-mover part.
// 2367.1-2367.30: (18.5): Reduction failure
// 2371.1-2371.60: (18.5): nu became shared, but nu.next may not be shared.
// 2374.5-2377.20: (class anchor.sink.Assign:18.5)
// 2379.5-2382.46: (class anchor.sink.Assume:18.5)
// 2383.5-2386.46: (class anchor.sink.Assume:18.5)
// 2387.5-2389.5: (class anchor.sink.VarDeclStmt:18.5)
// 2390.5-2407.38: (class anchor.sink.Read:18.5)
// 2402.1-2402.32: (18.5): Cannot have potential null deference in left-mover part.
// 2406.1-2406.30: (18.5): Reduction failure
// 2409.5-2430.5: (class anchor.sink.Write:18.5)
// 2421.1-2421.32: (18.5): Cannot have potential null deference in left-mover part.
// 2424.1-2424.30: (18.5): Reduction failure
// 2428.1-2428.62: (18.5): next became shared, but next.next may not be shared.
// 2431.5-2433.5: (class anchor.sink.VarDeclStmt:18.5)
// 2434.5-2437.195: (class anchor.sink.Assign:18.5)
// 2439.5-2460.5: (class anchor.sink.Write:18.5)
// 2451.1-2451.32: (18.5): Cannot have potential null deference in left-mover part.
// 2454.1-2454.30: (18.5): Reduction failure
// 2458.1-2458.71: (18.5): _currentValue became shared, but _currentValue.next may not be shared.
// 2461.5-2464.46: (class anchor.sink.Assume:18.5)
// 2467.5-2488.5: (class anchor.sink.Write:18.5)
// 2479.1-2479.32: (18.5): Cannot have potential null deference in left-mover part.
// 2482.1-2482.30: (18.5): Reduction failure
// 2486.1-2486.60: (18.5): nu became shared, but nu.next may not be shared.
// 2489.5-2492.21: (class anchor.sink.Assign:18.5)
// 2496.4-2499.10: (class anchor.sink.Break:20.9)
// 2502.3-2510.43: (class anchor.sink.Yield:22.5)
// 2513.1-2513.30: (12.4): Phase must be invariant at loop head
// 2515.2-2520.9: (class anchor.sink.Return:24.4)
// 2521.2-2526.9: (class anchor.sink.Return:11.26)
// 2528.1-3470.2: (Method:27.2)
// 2541.1-2541.24: (27.2): Bad tid
// 2542.1-2542.39: (27.2): this is not global
// 3002.2-3004.2: (class anchor.sink.VarDeclStmt:28.13)
// 3005.2-3013.37: (class anchor.sink.Alloc:28.13)
// 3015.2-3031.22: (class anchor.sink.Write:29.13)
// 3027.1-3027.26: (29.13): Cannot have potential null deference in left-mover part.
// 3030.1-3030.27: (29.13): Reduction failure
// 3034.2-3038.14: (class anchor.sink.While:30.4)
// 3040.1-3040.27: (27.2): Bad tid
// 3041.1-3041.42: (27.2): this is not global
// 3043.157-3044.43: (30.4): invariant isLocal(nu, tid) may not hold
// 3045.1-3045.282: (30.4): Loop does not preserve yields_as annotation for field value
// 3046.1-3046.280: (30.4): Loop does not preserve yields_as annotation for field next
// 3047.1-3047.281: (30.4): Loop does not preserve yields_as annotation for field top
// 3048.1-3048.33: (30.4): Phase must be invariant at loop head
// 3049.1-3049.30: (30.4): Potentially infinite loop cannot be in post-commit phase.
// 3051.3-3053.3: (class anchor.sink.VarDeclStmt:33.5)
// 3055.3-3057.3: (class anchor.sink.VarDeclStmt:33.5)
// 3058.3-3075.38: (class anchor.sink.Read:33.5)
// 3070.1-3070.30: (33.5): Cannot have potential null deference in left-mover part.
// 3074.1-3074.28: (33.5): Reduction failure
// 3076.3-3078.3: (class anchor.sink.VarDeclStmt:33.5)
// 3079.3-3096.37: (class anchor.sink.Read:33.5)
// 3091.1-3091.30: (33.5): Cannot have potential null deference in left-mover part.
// 3095.1-3095.28: (33.5): Reduction failure
// 3097.3-3099.3: (class anchor.sink.VarDeclStmt:33.5)
// 3100.3-3117.36: (class anchor.sink.Read:33.5)
// 3112.1-3112.30: (33.5): Cannot have potential null deference in left-mover part.
// 3116.1-3116.28: (33.5): Reduction failure
// 3118.3-3120.3: (class anchor.sink.VarDeclStmt:33.5)
// 3121.3-3124.185: (class anchor.sink.Assign:33.5)
// 3125.3-3127.3: (class anchor.sink.VarDeclStmt:33.5)
// 3128.3-3131.75: (class anchor.sink.Assign:33.5)
// 3134.4-3151.28: (class anchor.sink.Read:33.5)
// 3146.1-3146.31: (33.5): Cannot have potential null deference in left-mover part.
// 3150.1-3150.29: (33.5): Reduction failure
// 3154.4-3171.28: (class anchor.sink.Read:33.5)
// 3166.1-3166.31: (33.5): Cannot have potential null deference in left-mover part.
// 3170.1-3170.29: (33.5): Reduction failure
// 3174.3-3195.3: (class anchor.sink.Write:34.5)
// 3186.1-3186.27: (34.5): Cannot have potential null deference in left-mover part.
// 3189.1-3189.28: (34.5): Reduction failure
// 3193.1-3193.60: (34.5): next became shared, but next.next may not be shared.
// 3196.3-3204.43: (class anchor.sink.Yield:35.5)
// 3205.3-3207.3: (class anchor.sink.VarDeclStmt:36.5)
// 3209.3-3211.3: (class anchor.sink.VarDeclStmt:36.5)
// 3212.3-3215.21: (class anchor.sink.Assign:36.5)
// 3218.4-3221.20: (class anchor.sink.Assign:36.5)
// 3223.4-3226.22: (class anchor.sink.Assign:36.5)
// 3228.5-3230.5: (class anchor.sink.VarDeclStmt:36.5)
// 3231.5-3233.5: (class anchor.sink.VarDeclStmt:36.5)
// 3234.5-3236.5: (class anchor.sink.VarDeclStmt:36.5)
// 3237.5-3240.195: (class anchor.sink.Assign:36.5)
// 3241.5-3244.36: (class anchor.sink.Assume:36.5)
// 3245.5-3248.49: (class anchor.sink.Assume:36.5)
// 3249.5-3252.46: (class anchor.sink.Assume:36.5)
// 3253.5-3256.46: (class anchor.sink.Assume:36.5)
// 3258.5-3274.42: (class anchor.sink.Write:36.5)
// 3270.1-3270.32: (36.5): Cannot have potential null deference in left-mover part.
// 3273.1-3273.30: (36.5): Reduction failure
// 3276.5-3292.43: (class anchor.sink.Write:36.5)
// 3288.1-3288.32: (36.5): Cannot have potential null deference in left-mover part.
// 3291.1-3291.30: (36.5): Reduction failure
// 3295.5-3316.5: (class anchor.sink.Write:36.5)
// 3307.1-3307.32: (36.5): Cannot have potential null deference in left-mover part.
// 3310.1-3310.30: (36.5): Reduction failure
// 3314.1-3314.60: (36.5): nu became shared, but nu.next may not be shared.
// 3317.5-3320.20: (class anchor.sink.Assign:36.5)
// 3322.5-3325.46: (class anchor.sink.Assume:36.5)
// 3326.5-3329.46: (class anchor.sink.Assume:36.5)
// 3330.5-3332.5: (class anchor.sink.VarDeclStmt:36.5)
// 3333.5-3350.38: (class anchor.sink.Read:36.5)
// 3345.1-3345.32: (36.5): Cannot have potential null deference in left-mover part.
// 3349.1-3349.30: (36.5): Reduction failure
// 3352.5-3373.5: (class anchor.sink.Write:36.5)
// 3364.1-3364.32: (36.5): Cannot have potential null deference in left-mover part.
// 3367.1-3367.30: (36.5): Reduction failure
// 3371.1-3371.62: (36.5): next became shared, but next.next may not be shared.
// 3374.5-3376.5: (class anchor.sink.VarDeclStmt:36.5)
// 3377.5-3380.195: (class anchor.sink.Assign:36.5)
// 3382.5-3403.5: (class anchor.sink.Write:36.5)
// 3394.1-3394.32: (36.5): Cannot have potential null deference in left-mover part.
// 3397.1-3397.30: (36.5): Reduction failure
// 3401.1-3401.71: (36.5): _currentValue became shared, but _currentValue.next may not be shared.
// 3404.5-3407.46: (class anchor.sink.Assume:36.5)
// 3410.5-3431.5: (class anchor.sink.Write:36.5)
// 3422.1-3422.32: (36.5): Cannot have potential null deference in left-mover part.
// 3425.1-3425.30: (36.5): Reduction failure
// 3429.1-3429.60: (36.5): nu became shared, but nu.next may not be shared.
// 3432.5-3435.21: (class anchor.sink.Assign:36.5)
// 3439.4-3442.10: (class anchor.sink.Break:38.9)
// 3445.3-3453.43: (class anchor.sink.Yield:40.5)
// 3456.1-3456.30: (30.4): Phase must be invariant at loop head
// 3458.2-3463.9: (class anchor.sink.Return:42.4)
// 3464.2-3469.9: (class anchor.sink.Return:27.27)
// 3471.1-4443.2: (Method:45.2)
// 3485.1-3485.24: (45.2): Bad tid
// 3486.1-3486.39: (45.2): this is not global
// 3974.2-3978.14: (class anchor.sink.While:46.6)
// 3980.1-3980.27: (45.2): Bad tid
// 3981.1-3981.42: (45.2): this is not global
// 3984.1-3984.282: (46.6): Loop does not preserve yields_as annotation for field value
// 3985.1-3985.280: (46.6): Loop does not preserve yields_as annotation for field next
// 3986.1-3986.281: (46.6): Loop does not preserve yields_as annotation for field top
// 3987.1-3987.33: (46.6): Phase must be invariant at loop head
// 3988.1-3988.30: (46.6): Potentially infinite loop cannot be in post-commit phase.
// 3990.3-3992.3: (class anchor.sink.VarDeclStmt:48.10)
// 3994.3-3996.3: (class anchor.sink.VarDeclStmt:48.10)
// 3997.3-4014.38: (class anchor.sink.Read:48.10)
// 4009.1-4009.30: (48.10): Cannot have potential null deference in left-mover part.
// 4013.1-4013.28: (48.10): Reduction failure
// 4015.3-4017.3: (class anchor.sink.VarDeclStmt:48.10)
// 4018.3-4035.37: (class anchor.sink.Read:48.10)
// 4030.1-4030.30: (48.10): Cannot have potential null deference in left-mover part.
// 4034.1-4034.28: (48.10): Reduction failure
// 4036.3-4038.3: (class anchor.sink.VarDeclStmt:48.10)
// 4039.3-4056.36: (class anchor.sink.Read:48.10)
// 4051.1-4051.30: (48.10): Cannot have potential null deference in left-mover part.
// 4055.1-4055.28: (48.10): Reduction failure
// 4057.3-4059.3: (class anchor.sink.VarDeclStmt:48.10)
// 4060.3-4063.185: (class anchor.sink.Assign:48.10)
// 4064.3-4066.3: (class anchor.sink.VarDeclStmt:48.10)
// 4067.3-4070.75: (class anchor.sink.Assign:48.10)
// 4073.4-4090.27: (class anchor.sink.Read:48.10)
// 4085.1-4085.31: (48.10): Cannot have potential null deference in left-mover part.
// 4089.1-4089.29: (48.10): Reduction failure
// 4093.4-4110.27: (class anchor.sink.Read:48.10)
// 4105.1-4105.31: (48.10): Cannot have potential null deference in left-mover part.
// 4109.1-4109.29: (48.10): Reduction failure
// 4113.4-4119.11: (class anchor.sink.Return:50.14)
// 4122.3-4130.43: (class anchor.sink.Yield:52.10)
// 4131.3-4133.3: (class anchor.sink.VarDeclStmt:53.10)
// 4134.3-4151.26: (class anchor.sink.Read:53.10)
// 4146.1-4146.28: (53.10): Cannot have potential null deference in left-mover part.
// 4150.1-4150.28: (53.10): Reduction failure
// 4152.3-4154.3: (class anchor.sink.VarDeclStmt:54.10)
// 4156.3-4158.3: (class anchor.sink.VarDeclStmt:54.10)
// 4159.3-4162.21: (class anchor.sink.Assign:54.10)
// 4165.4-4168.20: (class anchor.sink.Assign:54.10)
// 4170.4-4173.22: (class anchor.sink.Assign:54.10)
// 4175.5-4177.5: (class anchor.sink.VarDeclStmt:54.10)
// 4178.5-4180.5: (class anchor.sink.VarDeclStmt:54.10)
// 4181.5-4183.5: (class anchor.sink.VarDeclStmt:54.10)
// 4184.5-4187.197: (class anchor.sink.Assign:54.10)
// 4188.5-4191.35: (class anchor.sink.Assume:54.10)
// 4192.5-4195.49: (class anchor.sink.Assume:54.10)
// 4196.5-4199.46: (class anchor.sink.Assume:54.10)
// 4200.5-4203.45: (class anchor.sink.Assume:54.10)
// 4205.5-4221.42: (class anchor.sink.Write:54.10)
// 4217.1-4217.32: (54.10): Cannot have potential null deference in left-mover part.
// 4220.1-4220.30: (54.10): Reduction failure
// 4223.5-4239.43: (class anchor.sink.Write:54.10)
// 4235.1-4235.32: (54.10): Cannot have potential null deference in left-mover part.
// 4238.1-4238.30: (54.10): Reduction failure
// 4242.5-4263.5: (class anchor.sink.Write:54.10)
// 4254.1-4254.32: (54.10): Cannot have potential null deference in left-mover part.
// 4257.1-4257.30: (54.10): Reduction failure
// 4261.1-4261.62: (54.10): next became shared, but next.next may not be shared.
// 4264.5-4267.20: (class anchor.sink.Assign:54.10)
// 4269.5-4272.46: (class anchor.sink.Assume:54.10)
// 4273.5-4276.45: (class anchor.sink.Assume:54.10)
// 4277.5-4279.5: (class anchor.sink.VarDeclStmt:54.10)
// 4280.5-4297.38: (class anchor.sink.Read:54.10)
// 4292.1-4292.32: (54.10): Cannot have potential null deference in left-mover part.
// 4296.1-4296.30: (54.10): Reduction failure
// 4299.5-4320.5: (class anchor.sink.Write:54.10)
// 4311.1-4311.32: (54.10): Cannot have potential null deference in left-mover part.
// 4314.1-4314.30: (54.10): Reduction failure
// 4318.1-4318.61: (54.10): top became shared, but top.next may not be shared.
// 4321.5-4323.5: (class anchor.sink.VarDeclStmt:54.10)
// 4324.5-4327.197: (class anchor.sink.Assign:54.10)
// 4329.5-4350.5: (class anchor.sink.Write:54.10)
// 4341.1-4341.32: (54.10): Cannot have potential null deference in left-mover part.
// 4344.1-4344.30: (54.10): Reduction failure
// 4348.1-4348.71: (54.10): _currentValue became shared, but _currentValue.next may not be shared.
// 4351.5-4354.46: (class anchor.sink.Assume:54.10)
// 4357.5-4378.5: (class anchor.sink.Write:54.10)
// 4369.1-4369.32: (54.10): Cannot have potential null deference in left-mover part.
// 4372.1-4372.30: (54.10): Reduction failure
// 4376.1-4376.62: (54.10): next became shared, but next.next may not be shared.
// 4379.5-4382.21: (class anchor.sink.Assign:54.10)
// 4386.4-4388.4: (class anchor.sink.VarDeclStmt:56.14)
// 4389.4-4406.29: (class anchor.sink.Read:56.14)
// 4401.1-4401.29: (56.14): Cannot have potential null deference in left-mover part.
// 4405.1-4405.29: (56.14): Reduction failure
// 4407.4-4413.11: (class anchor.sink.Return:57.14)
// 4416.3-4424.43: (class anchor.sink.Yield:59.10)
// 4427.1-4427.30: (46.6): Phase must be invariant at loop head
// 4429.2-4435.9: (class anchor.sink.Return:61.6)
// 4436.2-4442.9: (class anchor.sink.Return:45.19)
// 4534.1-4534.34: (3.2): Node.value failed Write-Write Right-Mover Check
// 4603.1-4603.30: (3.2): Node.value failed Write-Read Right-Mover Check
// 4676.1-4676.34: (3.2): Node.value failed Write-Write Left-Mover Check
// 4746.1-4746.30: (3.2): Node.value failed Write-Read Left-Mover Check
// 4813.1-4813.34: (3.2): Node.value failed Read-Write Right-Mover Check
// 4883.1-4883.34: (3.2): Node.value failed Read-Write Left-Mover Check
// 4952.1-4952.34: (4.2): Node.next failed Write-Write Right-Mover Check
// 5021.1-5021.30: (4.2): Node.next failed Write-Read Right-Mover Check
// 5094.1-5094.34: (4.2): Node.next failed Write-Write Left-Mover Check
// 5164.1-5164.30: (4.2): Node.next failed Write-Read Left-Mover Check
// 5231.1-5231.34: (4.2): Node.next failed Read-Write Right-Mover Check
// 5301.1-5301.34: (4.2): Node.next failed Read-Write Left-Mover Check
// 5370.1-5370.34: (9.2): Stack.top failed Write-Write Right-Mover Check
// 5439.1-5439.30: (9.2): Stack.top failed Write-Read Right-Mover Check
// 5512.1-5512.34: (9.2): Stack.top failed Write-Write Left-Mover Check
// 5582.1-5582.30: (9.2): Stack.top failed Write-Read Left-Mover Check
// 5649.1-5649.34: (9.2): Stack.top failed Read-Write Right-Mover Check
// 5719.1-5719.34: (9.2): Stack.top failed Read-Write Left-Mover Check
// 5800.1-5800.140: (3.2): Node.value is not Write-Write Stable with respect to Node.value (case A.1)
// 5801.1-5801.101: (3.2): Node.value is not Write-Write Stable with respect to Node.value (case A.2)
// 5802.1-5802.158: (3.2): Node.value is not Write-Write Stable with respect to Node.value (case A.3)
// 5913.1-5913.140: (3.2): Node.value is not Write-Write Stable with respect to Node.value (case C)
// 6029.1-6029.144: (3.2): Node.value is not Write-Write Stable with respect to Node.value (case D)
// 6030.1-6030.144: (3.2): Node.value is not Write-Write Stable with respect to Node.value (case R)
// 6111.1-6111.136: (3.2): Node.value is not Read-Write Stable with respect to Node.value (case F)
// 6112.1-6112.136: (3.2): Node.value is not Read-Write Stable with respect to Node.value (case H)
// 6113.1-6113.146: (3.2): Node.value is not Read-Write Stable with respect to Node.value (case I)
// 6193.1-6193.136: (3.2): Node.value is not Write-Read Stable with respect to Node.value (case J)
// 6194.1-6194.136: (3.2): Node.value is not Write-Read Stable with respect to Node.value (case K)
// 6195.1-6195.99: (3.2): Node.value is not Write-Read Stable with respect to Node.value (case L)
// 6277.1-6277.140: (4.2): Node.next is not Write-Write Stable with respect to Node.value (case A.1)
// 6278.1-6278.101: (4.2): Node.next is not Write-Write Stable with respect to Node.value (case A.2)
// 6279.1-6279.158: (4.2): Node.next is not Write-Write Stable with respect to Node.value (case A.3)
// 6390.1-6390.140: (3.2): Node.value is not Write-Write Stable with respect to Node.next (case C)
// 6506.1-6506.144: (3.2): Node.value is not Write-Write Stable with respect to Node.next (case D)
// 6507.1-6507.144: (3.2): Node.value is not Write-Write Stable with respect to Node.next (case R)
// 6588.1-6588.136: (3.2): Node.value is not Read-Write Stable with respect to Node.next (case F)
// 6589.1-6589.136: (3.2): Node.value is not Read-Write Stable with respect to Node.next (case H)
// 6590.1-6590.146: (3.2): Node.value is not Read-Write Stable with respect to Node.next (case I)
// 6670.1-6670.136: (4.2): Node.next is not Write-Read Stable with respect to Node.value (case J)
// 6671.1-6671.136: (4.2): Node.next is not Write-Read Stable with respect to Node.value (case K)
// 6672.1-6672.99: (4.2): Node.next is not Write-Read Stable with respect to Node.value (case L)
// 6754.1-6754.140: (9.2): Stack.top is not Write-Write Stable with respect to Node.value (case A.1)
// 6755.1-6755.101: (9.2): Stack.top is not Write-Write Stable with respect to Node.value (case A.2)
// 6756.1-6756.156: (9.2): Stack.top is not Write-Write Stable with respect to Node.value (case A.3)
// 6867.1-6867.140: (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case C)
// 6983.1-6983.144: (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case D)
// 6984.1-6984.144: (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case R)
// 7065.1-7065.136: (3.2): Node.value is not Read-Write Stable with respect to Stack.top (case F)
// 7066.1-7066.136: (3.2): Node.value is not Read-Write Stable with respect to Stack.top (case H)
// 7067.1-7067.144: (3.2): Node.value is not Read-Write Stable with respect to Stack.top (case I)
// 7147.1-7147.136: (9.2): Stack.top is not Write-Read Stable with respect to Node.value (case J)
// 7148.1-7148.136: (9.2): Stack.top is not Write-Read Stable with respect to Node.value (case K)
// 7149.1-7149.99: (9.2): Stack.top is not Write-Read Stable with respect to Node.value (case L)
// 7231.1-7231.140: (3.2): Node.value is not Write-Write Stable with respect to Node.next (case A.1)
// 7232.1-7232.101: (3.2): Node.value is not Write-Write Stable with respect to Node.next (case A.2)
// 7233.1-7233.158: (3.2): Node.value is not Write-Write Stable with respect to Node.next (case A.3)
// 7344.1-7344.140: (4.2): Node.next is not Write-Write Stable with respect to Node.value (case C)
// 7460.1-7460.144: (4.2): Node.next is not Write-Write Stable with respect to Node.value (case D)
// 7461.1-7461.144: (4.2): Node.next is not Write-Write Stable with respect to Node.value (case R)
// 7542.1-7542.136: (4.2): Node.next is not Read-Write Stable with respect to Node.value (case F)
// 7543.1-7543.136: (4.2): Node.next is not Read-Write Stable with respect to Node.value (case H)
// 7544.1-7544.146: (4.2): Node.next is not Read-Write Stable with respect to Node.value (case I)
// 7624.1-7624.136: (3.2): Node.value is not Write-Read Stable with respect to Node.next (case J)
// 7625.1-7625.136: (3.2): Node.value is not Write-Read Stable with respect to Node.next (case K)
// 7626.1-7626.99: (3.2): Node.value is not Write-Read Stable with respect to Node.next (case L)
// 7708.1-7708.140: (4.2): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
// 7709.1-7709.101: (4.2): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
// 7710.1-7710.158: (4.2): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
// 7821.1-7821.140: (4.2): Node.next is not Write-Write Stable with respect to Node.next (case C)
// 7937.1-7937.144: (4.2): Node.next is not Write-Write Stable with respect to Node.next (case D)
// 7938.1-7938.144: (4.2): Node.next is not Write-Write Stable with respect to Node.next (case R)
// 8019.1-8019.136: (4.2): Node.next is not Read-Write Stable with respect to Node.next (case F)
// 8020.1-8020.136: (4.2): Node.next is not Read-Write Stable with respect to Node.next (case H)
// 8021.1-8021.146: (4.2): Node.next is not Read-Write Stable with respect to Node.next (case I)
// 8101.1-8101.136: (4.2): Node.next is not Write-Read Stable with respect to Node.next (case J)
// 8102.1-8102.136: (4.2): Node.next is not Write-Read Stable with respect to Node.next (case K)
// 8103.1-8103.99: (4.2): Node.next is not Write-Read Stable with respect to Node.next (case L)
// 8185.1-8185.140: (9.2): Stack.top is not Write-Write Stable with respect to Node.next (case A.1)
// 8186.1-8186.101: (9.2): Stack.top is not Write-Write Stable with respect to Node.next (case A.2)
// 8187.1-8187.156: (9.2): Stack.top is not Write-Write Stable with respect to Node.next (case A.3)
// 8298.1-8298.140: (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case C)
// 8414.1-8414.144: (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case D)
// 8415.1-8415.144: (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case R)
// 8496.1-8496.136: (4.2): Node.next is not Read-Write Stable with respect to Stack.top (case F)
// 8497.1-8497.136: (4.2): Node.next is not Read-Write Stable with respect to Stack.top (case H)
// 8498.1-8498.144: (4.2): Node.next is not Read-Write Stable with respect to Stack.top (case I)
// 8578.1-8578.136: (9.2): Stack.top is not Write-Read Stable with respect to Node.next (case J)
// 8579.1-8579.136: (9.2): Stack.top is not Write-Read Stable with respect to Node.next (case K)
// 8580.1-8580.99: (9.2): Stack.top is not Write-Read Stable with respect to Node.next (case L)
// 8662.1-8662.140: (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case A.1)
// 8663.1-8663.101: (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case A.2)
// 8664.1-8664.156: (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case A.3)
// 8775.1-8775.140: (9.2): Stack.top is not Write-Write Stable with respect to Node.value (case C)
// 8891.1-8891.144: (9.2): Stack.top is not Write-Write Stable with respect to Node.value (case D)
// 8892.1-8892.144: (9.2): Stack.top is not Write-Write Stable with respect to Node.value (case R)
// 8973.1-8973.136: (9.2): Stack.top is not Read-Write Stable with respect to Node.value (case F)
// 8974.1-8974.136: (9.2): Stack.top is not Read-Write Stable with respect to Node.value (case H)
// 8975.1-8975.144: (9.2): Stack.top is not Read-Write Stable with respect to Node.value (case I)
// 9055.1-9055.136: (3.2): Node.value is not Write-Read Stable with respect to Stack.top (case J)
// 9056.1-9056.136: (3.2): Node.value is not Write-Read Stable with respect to Stack.top (case K)
// 9057.1-9057.99: (3.2): Node.value is not Write-Read Stable with respect to Stack.top (case L)
// 9178.1-9178.142: (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case M)
// 9297.1-9297.130: (3.2): Node.value is not Write-Write Stable with respect to Stack.top (case N)
// 9380.1-9380.140: (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case A.1)
// 9381.1-9381.101: (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case A.2)
// 9382.1-9382.156: (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case A.3)
// 9493.1-9493.140: (9.2): Stack.top is not Write-Write Stable with respect to Node.next (case C)
// 9609.1-9609.144: (9.2): Stack.top is not Write-Write Stable with respect to Node.next (case D)
// 9610.1-9610.144: (9.2): Stack.top is not Write-Write Stable with respect to Node.next (case R)
// 9691.1-9691.136: (9.2): Stack.top is not Read-Write Stable with respect to Node.next (case F)
// 9692.1-9692.136: (9.2): Stack.top is not Read-Write Stable with respect to Node.next (case H)
// 9693.1-9693.144: (9.2): Stack.top is not Read-Write Stable with respect to Node.next (case I)
// 9773.1-9773.136: (4.2): Node.next is not Write-Read Stable with respect to Stack.top (case J)
// 9774.1-9774.136: (4.2): Node.next is not Write-Read Stable with respect to Stack.top (case K)
// 9775.1-9775.99: (4.2): Node.next is not Write-Read Stable with respect to Stack.top (case L)
// 9896.1-9896.142: (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case M)
// 10015.1-10015.130: (4.2): Node.next is not Write-Write Stable with respect to Stack.top (case N)
// 10098.1-10098.140: (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case A.1)
// 10099.1-10099.101: (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case A.2)
// 10100.1-10100.158: (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case A.3)
// 10211.1-10211.140: (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case C)
// 10327.1-10327.144: (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case D)
// 10328.1-10328.144: (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case R)
// 10409.1-10409.136: (9.2): Stack.top is not Read-Write Stable with respect to Stack.top (case F)
// 10410.1-10410.136: (9.2): Stack.top is not Read-Write Stable with respect to Stack.top (case H)
// 10411.1-10411.146: (9.2): Stack.top is not Read-Write Stable with respect to Stack.top (case I)
// 10491.1-10491.136: (9.2): Stack.top is not Write-Read Stable with respect to Stack.top (case J)
// 10492.1-10492.136: (9.2): Stack.top is not Write-Read Stable with respect to Stack.top (case K)
// 10493.1-10493.99: (9.2): Stack.top is not Write-Read Stable with respect to Stack.top (case L)
// 10614.1-10614.142: (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case M)
// 10733.1-10733.130: (9.2): Stack.top is not Write-Write Stable with respect to Stack.top (case N)
// 10771.1-10796.2: (3.2): yields_as clause for Node.value is not valid
// 10801.1-10821.2: (3.2): yields_as clause for Node.value is not reflexive
// 10827.1-10867.2: (3.2): yields_as clause for Node.value is not transitive
// 10886.1-10911.2: (4.2): yields_as clause for Node.next is not valid
// 10916.1-10936.2: (4.2): yields_as clause for Node.next is not reflexive
// 10942.1-10982.2: (4.2): yields_as clause for Node.next is not transitive
// 11002.1-11027.2: (7.32): yields_as clause for Node._lock is not valid
// 11032.1-11052.2: (7.32): yields_as clause for Node._lock is not reflexive
// 11058.1-11098.2: (7.32): yields_as clause for Node._lock is not transitive
// 11117.1-11142.2: (9.2): yields_as clause for Stack.top is not valid
// 11147.1-11167.2: (9.2): yields_as clause for Stack.top is not reflexive
// 11173.1-11213.2: (9.2): yields_as clause for Stack.top is not transitive
// 11233.1-11258.2: (7.32): yields_as clause for Stack._lock is not valid
// 11263.1-11283.2: (7.32): yields_as clause for Stack._lock is not reflexive
// 11289.1-11329.2: (7.32): yields_as clause for Stack._lock is not transitive
